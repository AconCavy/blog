<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title>acon.log</title>
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2023 AconCavy</rights>
	<updated>2023-11-25T02:53:58Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231118abc329</id>
		<title>ABC329</title>
		<link href="https://blog.aconcavy.dev/posts/20231118abc329" />
		<updated>2023-11-19T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 329の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329"&gt;https://atcoder.jp/contests/abc329&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47673253"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C#&lt;/code&gt;では、&lt;code&gt;string.Join&lt;/code&gt;メソッドを使うと、指定した区切り文字で与えられたシーケンスを文字列として結合することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, S.ToArray()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47677331"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;から重複をなくしたものをソートし、2番目に大きいものが答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = A.Distinct().ToArray();
    Array.Sort(B);
    Array.Reverse(B);
    var answer = B[1];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47683874"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1種類の文字からなる長さが&lt;code&gt;L&lt;/code&gt;の連続部分列が存在するとき、長さが&lt;code&gt;L-1&lt;/code&gt;の連続部分列も存在します。&lt;br /&gt;
よって、ある文字のみからなる連続部分列の最大長が、その文字のからなる連続部分列の種類の個数になります。&lt;br /&gt;
このことから、全ての文字ごとのその文字のみからなる連続部分列の最大長の和が答えとなります。&lt;br /&gt;
連続部分列の長さは、尺取り法を行うことで時間計算量&lt;code&gt;O(N)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - 'a').ToArray();
    var maxLengths = new int[26];
    var l = 0;
    var r = 0;
    while (l &amp;lt; N)
    {
        while (r &amp;lt; N &amp;amp;&amp;amp; S[r] == S[l]) r++;
        maxLengths[S[l]] = Math.Max(maxLengths[S[l]], r - l);
        l = r;
    }

    var answer = maxLengths.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47694536"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;count[x]&lt;/code&gt;を候補者&lt;code&gt;x&lt;/code&gt;の得票数、&lt;code&gt;i-1&lt;/code&gt;票目に当選した候補者を&lt;code&gt;y&lt;/code&gt;とします。
&lt;code&gt;i&lt;/code&gt;票目の投票により、候補者&lt;code&gt;A[i]&lt;/code&gt;の票が&lt;code&gt;+1&lt;/code&gt;されます。&lt;br /&gt;
このとき、&lt;code&gt;count[A[i]]&amp;gt;count[y]&lt;/code&gt;の場合、&lt;code&gt;A[i]&lt;/code&gt;の得票数が最多となるので、&lt;code&gt;A[i]&lt;/code&gt;が答えになります。
&lt;code&gt;count[A[i]]==count[y]&lt;/code&gt;の場合、&lt;code&gt;A[i]&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;は得票数が最多の候補者が複数いることになるので、&lt;code&gt;Min(A[i],y)&lt;/code&gt;が答えとなります。
&lt;code&gt;count[A[i]]&amp;lt;count[y]&lt;/code&gt;の場合、変わらず&lt;code&gt;y&lt;/code&gt;の得票数が最多なので、&lt;code&gt;y&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var count = new int[N + 1];
    var answer = 0;
    foreach (var a in A)
    {
        count[a]++;
        if (count[answer] &amp;lt; count[a])
        {
            answer = a;
        }
        else if (count[answer] == count[a])
        {
            answer = Math.Min(answer, a);
        }

        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47736738"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;元の操作に対して、逆の操作を考えます。&lt;br /&gt;
これは、&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;文字目から長さ&lt;code&gt;M&lt;/code&gt;の連続する部分文字列に対して、全ての&lt;code&gt;j&lt;/code&gt;において&lt;code&gt;S[i+j]=='#'&lt;/code&gt;または&lt;code&gt;S[i+j]==T[j]&lt;/code&gt;であるとき、その部分文字列を全て&lt;code&gt;#&lt;/code&gt;にするという操作になります。&lt;br /&gt;
この操作を繰り返し、全ての文字が&lt;code&gt;#&lt;/code&gt;になっている場合、答えは&lt;code&gt;Yes&lt;/code&gt;になります。&lt;/p&gt;
&lt;p&gt;この操作を&lt;code&gt;i&lt;/code&gt;番目に対しての操作としたとき、&lt;code&gt;i&lt;/code&gt;番目に対して複数回操作を行う必要はないので、&lt;code&gt;i&lt;/code&gt;番目に対して既に操作を行ったことがあるかを管理しながら、&lt;code&gt;i&lt;/code&gt;番目の前後&lt;code&gt;M-1&lt;/code&gt;箇所に対して判定を行っていくことで、時間計算量&lt;code&gt;O(NM^2)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();

    var X = S.ToCharArray();
    var used = new bool[N - (M - 1)];
    var queue = new Queue&amp;lt;int&amp;gt;();

    void F(int idx)
    {
        if (used[idx]) return;

        var ok = true;
        for (var i = 0; i &amp;lt; M &amp;amp;&amp;amp; ok; i++)
        {
            ok &amp;amp;= (X[idx + i] == '#' || X[idx + i] == T[i]);
        }

        if (ok)
        {
            used[idx] = true;
            queue.Enqueue(idx);
        }
    }

    for (var i = 0; i &amp;lt; N - (M - 1); i++)
    {
        F(i);
    }

    while (queue.Count &amp;gt; 0)
    {
        var idx = queue.Dequeue();
        X.AsSpan(idx, M).Fill('#');

        for (var i = Math.Max(0, idx - (M - 1)); i &amp;lt;= Math.Min(N - M, idx + (M - 1)); i++)
        {
            F(i);
        }
    }

    var answer = new string(X) == new string('#', N);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47702938"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;番目の箱に入っているボールの色の集合とします。&lt;br /&gt;
各クエリにおいて、&lt;code&gt;S[a]&lt;/code&gt;から&lt;code&gt;S[b]&lt;/code&gt;にボールを移動し、&lt;code&gt;S[a]&lt;/code&gt;を空にするという操作を行います。&lt;br /&gt;
このとき、&lt;code&gt;|S[a]|&amp;gt;|S[b]|&lt;/code&gt;の場合、&lt;code&gt;S[a]&lt;/code&gt;から&lt;code&gt;S[b]&lt;/code&gt;にボールを移動する代わりに、&lt;code&gt;S[a]&lt;/code&gt;と&lt;code&gt;S[b]&lt;/code&gt;を入れ替えてから&lt;code&gt;S[a]&lt;/code&gt;から&lt;code&gt;S[b]&lt;/code&gt;にボールを移動させることで、ボールの移動回数を減らすことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var set = C.Select(c =&amp;gt; new HashSet&amp;lt;int&amp;gt; { c }).ToArray();
    while (Q-- &amp;gt; 0)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        if (set[b].Count &amp;lt; set[a].Count) (set[a], set[b]) = (set[b], set[a]);
        set[b].UnionWith(set[a]);
        set[a].Clear();
        Console.WriteLine(set[b].Count);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 329の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231111abc328</id>
		<title>ABC328</title>
		<link href="https://blog.aconcavy.dev/posts/20231111abc328" />
		<updated>2023-11-25T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 328の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc328"&gt;https://atcoder.jp/contests/abc328&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47452227"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;のうち、&lt;code&gt;X&lt;/code&gt;以下の値の総和を求めます。&lt;br /&gt;
C#では、配列などの&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;に対して&lt;code&gt;LINQ&lt;/code&gt;を使って例のように書くことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = S.Where(x =&amp;gt; x &amp;lt;= X).Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47464933"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ぞろ目であるには、月と日の数字がすべて同じである必要があるため、各数字が&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;のいずれかである必要があります。&lt;br /&gt;
そのため、ぞろ目にする数字&lt;code&gt;x&lt;/code&gt;を全探索し、&lt;code&gt;N&lt;/code&gt;以下の&lt;code&gt;x&lt;/code&gt;を並べてできた値の月&lt;code&gt;m&lt;/code&gt;のうち、&lt;code&gt;D[m]&lt;/code&gt;以下の&lt;code&gt;x&lt;/code&gt;を並べてできた値の日&lt;code&gt;d&lt;/code&gt;の数を数え上げます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = 0;
    for (var b = 1; b &amp;lt; 10; b++)
    {
        var m = b;
        while (m &amp;lt;= N)
        {
            var d = b;
            while (d &amp;lt;= D[m - 1])
            {
                answer++;
                d *= 10;
                d += b;
            }

            m *= 10;
            m += b;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47472269"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[l..r]&lt;/code&gt;を全探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になってしまいます。&lt;br /&gt;
そこで、あらかじめ&lt;code&gt;x&lt;/code&gt;文字までに文字が隣り合う回数を累積和&lt;code&gt;cum[x]&lt;/code&gt;として時間計算量&lt;code&gt;O(N)&lt;/code&gt;で計算しておき、クエリごとに&lt;code&gt;cum[r]-cum[l-1]&lt;/code&gt;を計算することで、&lt;code&gt;S[l..r]&lt;/code&gt;の文字が隣り合う回数を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求められるようになります。&lt;br /&gt;
ただし、&lt;code&gt;S[l]==S[l-1]&lt;/code&gt;である場合、&lt;code&gt;S[l-1]&lt;/code&gt;は範囲外であるため、答えを&lt;code&gt;-1&lt;/code&gt;する必要がある点に注意が必要です。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var cum = new int[N + 1];
    for (var i = 1; i &amp;lt; N; i++)
    {
        cum[i + 1] += cum[i];
        if (S[i] == S[i - 1]) cum[i + 1]++;
    }

    while (Q-- &amp;gt; 0)
    {
        var (l, r) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        l--;
        var answer = cum[r] - cum[l];
        if (l &amp;gt; 0 &amp;amp;&amp;amp; S[l - 1] == S[l]) answer--;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47476394"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;T&lt;/code&gt;の&lt;code&gt;m&lt;/code&gt;文字目までの文字が決まっているとしたとき、3文字を削除することは&lt;code&gt;m&lt;/code&gt;を&lt;code&gt;-3&lt;/code&gt;することと同じ意味になります。&lt;br /&gt;
よって、はじめに&lt;code&gt;T&lt;/code&gt;を空文字、&lt;code&gt;m=0&lt;/code&gt;として、&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目の文字を順に追加していき、&lt;code&gt;T&lt;/code&gt;の長さが3文字以上かつ末尾が&lt;code&gt;ABC&lt;/code&gt;となる場合は&lt;code&gt;ABC&lt;/code&gt;を削除しながら&lt;code&gt;m&lt;/code&gt;を更新していくことで、最終的にできた文字列が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var T = new char[N];
    var m = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        T[m] = S[i];
        while (m &amp;gt;= 2 &amp;amp;&amp;amp; T[m - 2] == 'A' &amp;amp;&amp;amp; T[m - 1] == 'B' &amp;amp;&amp;amp; T[m] == 'C')
        {
            m -= 3;
        }

        m++;
    }

    var answer = new string(T[..m]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47497743"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;頂点のグラフの全域木には、&lt;code&gt;N-1&lt;/code&gt;本の辺が必要となります。&lt;br /&gt;
よって、&lt;code&gt;M&lt;/code&gt;本の辺から&lt;code&gt;N-1&lt;/code&gt;本を選ぶ組み合わせを全探索し、その&lt;code&gt;N-1&lt;/code&gt;本の辺の組み合わせが全域木になる場合のコストの最小値が答えとなります
&lt;code&gt;N-1&lt;/code&gt;本の辺の組み合わせが全域木になるかは、&lt;code&gt;DSU&lt;/code&gt;などのデータ構造を使ってグラフの連結成分が1つであることを示すことで判定することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var E = new (int U, int V, long W)[M];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v, w) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        u--; v--;
        E[i] = (u, v, w);
    }

    var answer = K;
    foreach (var order in Combine(Enumerable.Range(0, M), N - 1))
    {
        long cost = 0;
        var dsu = new DisjointSetUnion(N);
        foreach (var (u, v, w) in order.Select(x =&amp;gt; E[x]))
        {
            dsu.Merge(u, v);
            cost += w;
            cost %= K;
        }

        if (dsu.SizeOf(0) == N)
        {
            answer = Math.Min(answer, cost);
        }
    }

    Console.WriteLine(answer);
}

public static IEnumerable&amp;lt;TSource[]&amp;gt; Combine&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;? source, int count)
{
    if (source is null) throw new ArgumentNullException(nameof(source));

    IEnumerable&amp;lt;TSource[]&amp;gt; Inner()
    {
        var items = source.ToArray();
        if (count &amp;lt;= 0 || items.Length &amp;lt; count) throw new ArgumentOutOfRangeException(nameof(count));
        var n = items.Length;
        var indices = new int[n];
        for (var i = 0; i &amp;lt; indices.Length; i++)
        {
            indices[i] = i;
        }

        TSource[] Result()
        {
            var result = new TSource[count];
            for (var i = 0; i &amp;lt; count; i++)
            {
                result[i] = items[indices[i]];
            }

            return result;
        }

        yield return Result();
        while (true)
        {
            var done = true;
            var idx = 0;
            for (var i = count - 1; i &amp;gt;= 0; i--)
            {
                if (indices[i] == i + n - count) continue;
                idx = i;
                done = false;
                break;
            }

            if (done) yield break;
            indices[idx]++;
            for (var i = idx; i + 1 &amp;lt; count; i++)
            {
                indices[i + 1] = indices[i] + 1;
            }

            yield return Result();
        }
    }

    return Inner();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47506380"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の頂点があり、各頂点の値が&lt;code&gt;X[i]&lt;/code&gt;であるものを考えます。
部分集合&lt;code&gt;S&lt;/code&gt;が良い集合であるということは、部分集合&lt;code&gt;S&lt;/code&gt;に含まれる全てのクエリ&lt;code&gt;(a,b,d)&lt;/code&gt;において、&lt;code&gt;X[a]-X[b]==d&lt;/code&gt;であり、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;間は同じ連結成分であると考えることができます。&lt;br /&gt;
よって、各クエリ&lt;code&gt;(a,b,d)&lt;/code&gt;を順に見ていったとき、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;が同じ連結成分である場合は、&lt;code&gt;X[a]-X[b]==d&lt;/code&gt;が成り立つ場合にのみクエリを&lt;code&gt;S&lt;/code&gt;に追加できます。&lt;br /&gt;
一方、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;が異なる連結成分である場合は、&lt;code&gt;X[a]-X[b]==d&lt;/code&gt;となるように片方の連結集合の全ての&lt;code&gt;X&lt;/code&gt;の値を変更することで、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;を同じ連結成分にできるため、クエリを&lt;code&gt;S&lt;/code&gt;に追加することができます。&lt;br /&gt;
この操作をマージとしたとき、連結成分の小さい方から大きい方へマージすることで、高速にマージすることができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new List&amp;lt;int&amp;gt;();
    var X = new long[N];
    var dsu = new DisjointSetUnion(N);
    var nodes = new List&amp;lt;int&amp;gt;[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        nodes[i] = new List&amp;lt;int&amp;gt; { i };
    }

    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (a, b, d) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        if (dsu.IsSame(a, b))
        {
            if (X[a] - X[b] == d)
            {
                S.Add(i);
            }
        }
        else
        {
            var (u, v) = (dsu.LeaderOf(a), dsu.LeaderOf(b));
            d -= X[a] - X[b];
            if (nodes[u].Count &amp;lt; nodes[v].Count)
            {
                (u, v) = (v, u);
                d *= -1;
            }

            for (var j = 0; j &amp;lt; nodes[v].Count; j++)
            {
                nodes[u].Add(nodes[v][j]);
                X[nodes[v][j]] -= d;
            }

            dsu.Merge(a, b);
            S.Add(i);
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, S.Select(x =&amp;gt; x + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 328の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231104abc327</id>
		<title>ABC327</title>
		<link href="https://blog.aconcavy.dev/posts/20231104abc327" />
		<updated>2023-11-04T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 327の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc327"&gt;https://atcoder.jp/contests/abc327&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47207464"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;が隣接するということは、&lt;code&gt;S[i]&lt;/code&gt;が&lt;code&gt;a&lt;/code&gt;かつ&lt;code&gt;S[i+1]&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;となる箇所がある、または、&lt;code&gt;S[i]&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;かつ&lt;code&gt;S[i+1]&lt;/code&gt;が&lt;code&gt;a&lt;/code&gt;となる箇所がある必要があるため、そのような&lt;code&gt;i&lt;/code&gt;を全探索します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = false;
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        answer |= S[i] == 'a' &amp;amp;&amp;amp; S[i + 1] == 'b';
        answer |= S[i] == 'b' &amp;amp;&amp;amp; S[i + 1] == 'a';
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47215008"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;を全探索します。&lt;br /&gt;
符号なし64bit整数型で表現できる最大の数は、&lt;code&gt;2^64==2^(4*16)==2^4*2^16==16^16&lt;/code&gt;であり、これは&lt;code&gt;B&lt;/code&gt;の上限となる&lt;code&gt;10^18&lt;/code&gt;未満となります。&lt;br /&gt;
よって&lt;code&gt;A&lt;/code&gt;の上限を&lt;code&gt;15&lt;/code&gt;として探索することで、オーバーフローを考えずに答えを求めることができます。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;x^x&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;に&lt;code&gt;x&lt;/code&gt;を&lt;code&gt;x&lt;/code&gt;回掛けることで求めることができ、&lt;code&gt;x&lt;/code&gt;を&lt;code&gt;x&lt;/code&gt;回掛けるまでに&lt;code&gt;B&lt;/code&gt;を超える場合は、その&lt;code&gt;x&lt;/code&gt;以上の数値は&lt;code&gt;B&lt;/code&gt;を超えるため答えが存在しません。&lt;br /&gt;
つまり、&lt;code&gt;x^y&amp;lt;=B (0&amp;lt;=y&amp;lt;x)&lt;/code&gt;のとき、&lt;code&gt;x^(y+1)&amp;lt;=B&lt;/code&gt;であるためには、&lt;code&gt;x^y&amp;lt;=B/x&lt;/code&gt;である必要があります。&lt;br /&gt;
よって、&lt;code&gt;x^y&amp;gt;B/x&lt;/code&gt;の場合は、&lt;code&gt;x&lt;/code&gt;以上の値には&lt;code&gt;x^x==B&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;は存在しないことが分かります。&lt;br /&gt;
このことから、探索の上限が思いつかなくても、計算途中で&lt;code&gt;B&lt;/code&gt;を超える場合に探索を打ち切ることで、符号付き64bit整数型を使った探索を行ったとしてもオーバーフローを起こさずに答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var B = Scanner.Scan&amp;lt;long&amp;gt;();
    for (long i = 1; i &amp;lt;= 20; i++)
    {
        long v = 1;
        for (var j = 0; j &amp;lt; i; j++)
        {
            if (v &amp;lt;= B / i)
            {
                v *= i;
            }
            else
            {
                Console.WriteLine(-1);
                return;
            }
        }

        if (v == B)
        {
            Console.WriteLine(i);
            return;
        }
    }

    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47225443"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に3つの条件を判定します。&lt;br /&gt;
&lt;code&gt;3*3&lt;/code&gt;のマス目の判定は、&lt;code&gt;a*3+i&lt;/code&gt;行&lt;code&gt;b*3+j&lt;/code&gt;列(&lt;code&gt;0&amp;lt;=a,b&amp;lt;3&lt;/code&gt;、&lt;code&gt;0&amp;lt;=i,j&amp;lt;3&lt;/code&gt;)とすることで、&lt;code&gt;3*3&lt;/code&gt;のマス目を1つの大きなマス目としたとき、&lt;code&gt;a&lt;/code&gt;行&lt;code&gt;b&lt;/code&gt;列の大きなマス目とし、大きなマス目の中の&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列の小さなマス目として見ることができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int N = 9;
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    }

    var answer = true;
    var mask = (1 &amp;lt;&amp;lt; 9) - 1; // マス目の数字の存在判定をbit maskで管理

    for (var i = 0; i &amp;lt; N; i++)
    {
        var v = 0;
        for (var j = 0; j &amp;lt; N; j++)
        {
            v |= 1 &amp;lt;&amp;lt; A[i][j];
        }

        answer &amp;amp;= v == mask;
    }

    for (var j = 0; j &amp;lt; N; j++)
    {
        var v = 0;
        for (var i = 0; i &amp;lt; N; i++)
        {
            v |= 1 &amp;lt;&amp;lt; A[i][j];
        }

        answer &amp;amp;= v == mask;
    }

    for (var a = 0; a &amp;lt; 3; a++)
    {
        for (var b = 0; b &amp;lt; 3; b++)
        {
            var v = 0;
            for (var i = 0; i &amp;lt; 3; i++)
            {
                for (var j = 0; j &amp;lt; 3; j++)
                {
                    v |= 1 &amp;lt;&amp;lt; A[a * 3 + i][b * 3 + j];
                }
            }

            answer &amp;amp;= v == mask;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47236945"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長さ&lt;code&gt;N&lt;/code&gt;の数列&lt;code&gt;X&lt;/code&gt;を、頂点&lt;code&gt;A[i]&lt;/code&gt;と頂点&lt;code&gt;B[i]&lt;/code&gt;間に辺がある&lt;code&gt;N&lt;/code&gt;頂点&lt;code&gt;M&lt;/code&gt;辺のグラフとして考えます。&lt;br /&gt;
このとき、数列&lt;code&gt;X&lt;/code&gt;が良い数列の組であるためには、全ての&lt;code&gt;i&lt;/code&gt;について&lt;code&gt;X[A[i]]!=X[B[i]]&lt;/code&gt;が成立する必要があります。&lt;br /&gt;
よって、隣り合う頂点には異なる数字を割り当てる必要があることから、このグラフが二部グラフであることが良い数列である条件であることがわかります。&lt;br /&gt;
したがって、全ての連結成分において二部グラフが成り立つかを判定することで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var G = new HashSet&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new HashSet&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        G[A[i]].Add(B[i]);
        G[B[i]].Add(A[i]);
    }

    var colors = new int[N];
    Array.Fill(colors, -1);
    var queue = new Queue&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (colors[i] != -1) continue;
        colors[i] = 0;
        queue.Enqueue(i);
        while (queue.TryDequeue(out var u))
        {
            foreach (var v in G[u])
            {
                if (colors[u] == colors[v])
                {
                    Console.WriteLine(&amp;quot;No&amp;quot;);
                    return;
                }

                if (colors[v] != -1) continue;
                colors[v] = colors[u] ^ 1;
                queue.Enqueue(v);
            }
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47256767"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;選んだコンテストによる変動する、&lt;code&gt;Sum((0.9)^(k-i)*Q[i])&lt;/code&gt;の部分について、次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][j] := i個目のコンテストまで見たとき、参加したコンテストがj個のときの最大値。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;あるコンテストが&lt;code&gt;x&lt;/code&gt;個目の選んだコンテストであった場合のパフォーマンスの重みを&lt;code&gt;w[x]&lt;/code&gt;とします。
また、&lt;code&gt;P&lt;/code&gt;を逆順にすることで、逆順にした&lt;code&gt;P&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目のコンテストのパフォーマンス重みを&lt;code&gt;w[j] (j&amp;lt;=i)&lt;/code&gt;とすることができます。
このとき、遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;// i番目のコンテストを選ばないとき、
dp[i+1][j] = Max(dp[i+1][j], dp[i][j])

// i番目のコンテストを選ぶとき、
dp[i+1][j+1] = Max(dp[i+1][j+1], dp[i][j]+w[j+1]*P[i])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cumW[x]&lt;/code&gt;を選んだコンテストの数が&lt;code&gt;x&lt;/code&gt;個の時の重みの累積和とします。
&lt;code&gt;N&lt;/code&gt;番目のコンテストまで見たとき、&lt;code&gt;dp[N][j]/cumW[j] - 1200/sqrt[j]&lt;/code&gt;の最大値が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var sqrt = new double[N + 1];
    var w = new double[N + 1];
    var cumW = new double[N + 1];
    sqrt[1] = w[1] = cumW[1] = 1;
    for (var i = 2; i &amp;lt;= N; i++)
    {
        sqrt[i] = Math.Sqrt(i);
        w[i] = w[i - 1] * 0.9;
        cumW[i] = cumW[i - 1] + w[i];
    }

    Array.Reverse(P);
    var dp = new double[N + 1, N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            // i番目のコンテストを選ばないとき
            dp[i + 1, j] = Math.Max(dp[i + 1, j], dp[i, j]);
            // i番目のコンテストを選ぶとき
            dp[i + 1, j + 1] = Math.Max(dp[i + 1, j + 1], dp[i, j] + w[j + 1] * P[i]);
        }
    }

    const double Inf = 1e18;
    var answer = -Inf;
    for (var j = 1; j &amp;lt;= N; j++)
    {
        var r = dp[N, j] / cumW[j] - 1200 / sqrt[j];
        answer = Math.Max(answer, r);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 327の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231028abc326</id>
		<title>ABC326</title>
		<link href="https://blog.aconcavy.dev/posts/20231028abc326" />
		<updated>2023-10-28T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 326の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc326"&gt;https://atcoder.jp/contests/abc326&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/46992128"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;階層の差が&lt;code&gt;d&lt;/code&gt;階のとき、下に3階分は&lt;code&gt;-3&amp;lt;=d&lt;/code&gt;、上に2階分は&lt;code&gt;d&amp;lt;=2&lt;/code&gt;となるので、&lt;code&gt;-3&amp;lt;=d&amp;lt;=2&lt;/code&gt;の場合に答えは&lt;code&gt;Yes&lt;/code&gt;になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var d = Y - X;
    var answer = -3 &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= 2;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/46996643"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;以上の整数&lt;code&gt;x&lt;/code&gt;を全探索し、&lt;code&gt;x&lt;/code&gt;の百の位を&lt;code&gt;a&lt;/code&gt;、十の位を&lt;code&gt;b&lt;/code&gt;、一の位を&lt;code&gt;c&lt;/code&gt;としたとき、&lt;code&gt;a*b==c&lt;/code&gt;になるかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var x = N; x &amp;lt;= 999; x++)
    {
        var a = x / 100;
        var b = x / 10 % 10;
        var c = x % 10;
        if (a * b == c)
        {
            Console.WriteLine(x);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/47002900"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;をソートし、&lt;code&gt;l&lt;/code&gt;を固定したとき、&lt;code&gt;A[r]&amp;gt;=A[l]+M&lt;/code&gt;となる&lt;code&gt;r&lt;/code&gt;を求めることで、座標&lt;code&gt;A[l]&lt;/code&gt;を半開区間の左端としたときに&lt;code&gt;r-l&lt;/code&gt;個のプレゼントを選ぶことができるようになります。
&lt;code&gt;A&lt;/code&gt;のソートに時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;、&lt;code&gt;r&lt;/code&gt;を尺取り法で求めることで時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    Array.Sort(A);
    var answer = 0;
    var r = 0;
    for (var l = 0; l &amp;lt; N; l++)
    {
        while (r &amp;lt; N &amp;amp;&amp;amp; A[r] &amp;lt; A[l] + M) r++;
        answer = Math.Max(answer, r - l);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/47046457"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;条件1から、&lt;code&gt;A&lt;/code&gt;が各行/各列にちょうど1つのみ含まれるパターンは&lt;code&gt;5!&lt;/code&gt;通りであり、同様に&lt;code&gt;B&lt;/code&gt;と&lt;code&gt;C&lt;/code&gt;も&lt;code&gt;5!&lt;/code&gt;通りになります。
&lt;code&gt;5!^3&lt;/code&gt;通りパターンを全探索し、条件の2と3を満たすかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var R = Scanner.Scan&amp;lt;string&amp;gt;();
    var C = Scanner.Scan&amp;lt;string&amp;gt;();

    var G = new char[N, N];

    bool CheckR()
    {
        var result = true;
        for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; result; i++)
        {
            for (var j = 0; j &amp;lt; N &amp;amp;&amp;amp; result; j++)
            {
                if (G[i, j] != '.')
                {
                    result &amp;amp;= G[i, j] == R[i];
                    break;
                }
            }
        }

        return result;
    }

    bool CheckC()
    {
        var result = true;
        for (var j = 0; j &amp;lt; N &amp;amp;&amp;amp; result; j++)
        {
            for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; result; i++)
            {
                if (G[i, j] != '.')
                {
                    result &amp;amp;= G[i, j] == C[j];
                    break;
                }
            }
        }

        return result;
    }

    foreach (var AI in Permutation.GeneratePermutation(N))
    {
        foreach (var BI in Permutation.GeneratePermutation(N))
        {
            foreach (var CI in Permutation.GeneratePermutation(N))
            {
                var ok = true;
                for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; ok; i++)
                {
                    ok &amp;amp;= AI[i] != BI[i];
                    ok &amp;amp;= AI[i] != CI[i];
                    ok &amp;amp;= BI[i] != CI[i];
                }

                if (!ok) continue;

                for (var i = 0; i &amp;lt; N; i++)
                {
                    for (var j = 0; j &amp;lt; N; j++)
                    {
                        G[i, j] = '.';
                    }
                }

                for (var i = 0; i &amp;lt; N; i++)
                {
                    G[AI[i], i] = 'A';
                    G[BI[i], i] = 'B';
                    G[CI[i], i] = 'C';
                }

                if (CheckR() &amp;amp;&amp;amp; CheckC())
                {
                    Console.WriteLine(&amp;quot;Yes&amp;quot;);
                    Printer.Print2D(G);
                    return;
                }
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/47043979"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;が支給される確率を&lt;code&gt;P[i]&lt;/code&gt;、期待値を&lt;code&gt;E[i]&lt;/code&gt;としたとき、&lt;code&gt;E[i]=A[i]*P[i]&lt;/code&gt;となります。&lt;br /&gt;
ある&lt;code&gt;y&lt;/code&gt;について&lt;code&gt;P[y]&lt;/code&gt;の確率は、&lt;code&gt;x&amp;lt;y&lt;/code&gt;となる&lt;code&gt;P[x]&lt;/code&gt;から&lt;code&gt;1/N&lt;/code&gt;の確率で推移することから、&lt;code&gt;cumP[y-1]=P[0]+P[1]+...+P[y-1]&lt;/code&gt;としたとき、&lt;code&gt;P[y]=cumP[y-1]/N&lt;/code&gt;として求めることができます。&lt;br /&gt;
よって、各&lt;code&gt;i&lt;/code&gt;について累積の確率を管理しながら期待値を求めることで、時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var iN = mint.Inverse(N);
    var E = new mint[N + 1];
    var P = new mint[N + 1];
    var cumP = new mint[N + 1];
    P[0] = cumP[0] = 1;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        P[i] = cumP[i - 1] * iN;
        E[i] = A[i - 1] * P[i];
        cumP[i] = cumP[i - 1] + P[i];
    }

    mint answer = 0;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer += E[i];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 326の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231021abc325</id>
		<title>ABC325</title>
		<link href="https://blog.aconcavy.dev/posts/20231021abc325" />
		<updated>2023-10-21T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 325の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc325"&gt;https://atcoder.jp/contests/abc325&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc325/tasks/abc325_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC325/submissions/46790409"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の入力をとり、&lt;code&gt;S san&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (S, _) = Scanner.Scan&amp;lt;string, string&amp;gt;();
    Console.WriteLine($&amp;quot;{S} san&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc325/tasks/abc325_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC325/submissions/46808063"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cum[x]&lt;/code&gt;を世界標準時の&lt;code&gt;x&lt;/code&gt;時に会議に参加できる人の数とします。&lt;br /&gt;
拠点の時刻が&lt;code&gt;t&lt;/code&gt;時で時差が&lt;code&gt;d&lt;/code&gt;時間の場合、世界標準時では&lt;code&gt;t-d&lt;/code&gt;時になります。&lt;br /&gt;
このことから各拠点の&lt;code&gt;9&lt;/code&gt;時から&lt;code&gt;18&lt;/code&gt;時までを世界標準時に変換した時間帯に&lt;code&gt;w&lt;/code&gt;人を追加する累積和を求め、世界標準時で何時に一番参加できる人が多いかを判定します。&lt;br /&gt;
このとき、2日分の累積和を求めることに注意が必要です。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var cum = new long[100];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (w, x) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        cum[24 + 9 - x] += w;
        cum[24 + 18 - x] -= w;
        cum[48 + 9 - x] += w;
        cum[48 + 18 - x] -= w;
    }

    for (var i = 0; i + 1 &amp;lt; cum.Length; i++)
    {
        cum[i + 1] += cum[i];
    }

    long answer = 0;
    for (var i = 24; i &amp;lt;= 48; i++)
    {
        answer = Math.Max(answer, cum[i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc325/tasks/abc325_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC325/submissions/46803063"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連動するセンサの個数は、各センサを頂点としたグラフの連結成分の個数と一致します。&lt;br /&gt;
これは、各センサに番号を与え、8方向に別のセンサが存在する場合、そのセンサどうしの連結する操作を&lt;code&gt;DFS&lt;/code&gt;を行ったり、&lt;code&gt;DSU&lt;/code&gt;などのデータ構造を使うことで求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;summary&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var M = 0;
    var S = new char[H][];
    var dict = new Dictionary&amp;lt;(int H, int W), int&amp;gt;();
    for (var i = 0; i &amp;lt; H; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (S[i][j] == '#')
            {
                dict[(i, j)] = M++;
            }
        }
    }

    var dsu = new DisjointSetUnion(M);
    var D8 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1) };
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (S[i][j] != '#') continue;
            foreach (var (dh, dw) in D8)
            {
                var (nh, nw) = (i + dh, j + dw);
                if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
                if (S[nh][nw] == '#')
                {
                    dsu.Merge(dict[(i, j)], dict[(nh, nw)]);
                }
            }
        }
    }

    var answer = dsu.GetGroups().Count();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc325/tasks/abc325_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC325/submissions/46834674"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある時間&lt;code&gt;t&lt;/code&gt;に印字機の範囲内にある商品のうち、範囲から出る時間が早いものから順に印字することで答えを求めることができます。&lt;br /&gt;
印字機の範囲から出る時間が早い順に管理するデータ構造を使い、時刻&lt;code&gt;t&lt;/code&gt;における印字機の範囲内にある商品を管理しながら、時刻&lt;code&gt;t&lt;/code&gt;を更新していきます。&lt;br /&gt;
時刻&lt;code&gt;t&lt;/code&gt;を全探索してしまうと、&lt;code&gt;t&lt;/code&gt;が最大で&lt;code&gt;10^18&lt;/code&gt;になり実行時間制限に間に合わなくなるため、印字機に商品がない場合はまだ印字機に入っていない商品が印字機に入る時刻&lt;code&gt;t&lt;/code&gt;までスキップすることで、全体時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var T = new Timeline[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (t, d) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        T[i] = new Timeline(t, t + d);
    }

    Array.Sort(T, (x, y) =&amp;gt; x.In.CompareTo(y.In));
    var idx = 0;
    var queue = new PriorityQueue&amp;lt;Timeline&amp;gt;((x, y) =&amp;gt; x.Out.CompareTo(y.Out));
    long curr = 0;
    var answer = 0;

    while (true)
    {
        if (queue.Count == 0)
        {
            if (idx == N) break;
            curr = T[idx].In;
        }

        while (idx &amp;lt; N &amp;amp;&amp;amp; T[idx].In &amp;lt;= curr)
        {
            queue.Enqueue(T[idx++]);
        }

        while (queue.TryPeek(out var t) &amp;amp;&amp;amp; t.Out &amp;lt; curr)
        {
            queue.Dequeue();
        }

        if (queue.TryDequeue(out _))
        {
            answer++;
        }

        curr++;
    }

    Console.WriteLine(answer);
}

public record struct Timeline(long In, long Out);
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc325/tasks/abc325_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC325/submissions/46822538"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各都市について、電車を使わないときの最短の時間と、電車を一度以上使うときの最短の時間を管理することで、&lt;code&gt;電車から社用車に乗り換えることはできない&lt;/code&gt;という制約に対応することができます。&lt;br /&gt;
これは、各都市につき電車を使わない|使うとした頂点を用意し、電車を使わない頂点からは電車を使わない頂点と電車を使う頂点への辺を張り、電車を使う頂点からは電車を使う頂点への辺のみを張ったグラフを作成することで、Djikstra法を使って最短時間を求めることができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B, C) = Scanner.Scan&amp;lt;int, long, long, long&amp;gt;();
    var D = new long[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        D[i] = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    }

    var G = new List&amp;lt;(int, long)&amp;gt;[N * 2].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            G[i].Add((j, D[i][j] * A));
            G[j].Add((i, D[j][i] * A));

            G[i].Add((N + j, D[i][j] * B + C));
            G[j].Add((N + i, D[j][i] * B + C));

            G[N + i].Add((N + j, D[i][j] * B + C));
            G[N + j].Add((N + i, D[j][i] * B + C));
        }
    }

    var costs = new long[N * 2];
    Array.Fill(costs, 1L &amp;lt;&amp;lt; 60);
    costs[0] = 0;
    costs[N] = 0;
    var queue = new PriorityQueue&amp;lt;(int U, long C), long&amp;gt;();
    queue.Enqueue((0, 0), 0);
    queue.Enqueue((N, 0), 0);
    while (queue.TryDequeue(out var top, out _))
    {
        var (u, uc) = top;
        if (costs[u] &amp;lt; uc) continue;
        foreach (var (v, vc) in G[u])
        {
            var nc = costs[u] + vc;
            if (costs[v] &amp;lt;= nc) continue;
            costs[v] = nc;
            queue.Enqueue((v, nc), nc);
        }
    }

    var answer = Math.Min(costs[N - 1], costs[N + N - 1]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 325の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231014abc324</id>
		<title>ABC324</title>
		<link href="https://blog.aconcavy.dev/posts/20231014abc324" />
		<updated>2023-10-14T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 324の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc324"&gt;https://atcoder.jp/contests/abc324&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc324/tasks/abc324_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC324/submissions/46520270"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;から重複をなくしたものの要素の個数が&lt;code&gt;1&lt;/code&gt;であるかどうかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = A.Distinct().Count() == 1;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc324/tasks/abc324_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC324/submissions/46525383"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N==(2^x)*(3^x)&lt;/code&gt;であることは、&lt;code&gt;N/((2^x)*(3^x))==1&lt;/code&gt;であることと同値であるため、&lt;code&gt;N&lt;/code&gt;を&lt;code&gt;2&lt;/code&gt;と&lt;code&gt;3&lt;/code&gt;で割れるだけ割ったものが&lt;code&gt;1&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    while (N &amp;gt; 1 &amp;amp;&amp;amp; N % 2 == 0) N /= 2;
    while (N &amp;gt; 1 &amp;amp;&amp;amp; N % 3 == 0) N /= 3;
    var answer = N == 1;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc324/tasks/abc324_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC324/submissions/46539612"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある&lt;code&gt;S&lt;/code&gt;は&lt;code&gt;T'&lt;/code&gt;と等しいか、(挿入|削除|変更)により1文字違いである必要があります。&lt;br /&gt;
これにより、&lt;code&gt;||S| - |T|| &amp;lt;= 1&lt;/code&gt;である必要があります。
そして、&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T'&lt;/code&gt;の差分が&lt;code&gt;1&lt;/code&gt;または&lt;code&gt;0&lt;/code&gt;である、つまり差分が&lt;code&gt;1&lt;/code&gt;以下であれば、&lt;code&gt;S&lt;/code&gt;は条件を満たすことがわかります。
これは次のようなアルゴリズムで判定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;siをSのsi文字目、tiをTのti文字目、diffを現在見ている文字までの差分とする。

- S[si] == T[ti] の場合、
    siを1増やす。
    tiを1増やす。

- S[si] != T[ti] の場合、
    - diffが0の場合、
        diffを1増やす。
        - |S| &amp;gt; |T|の場合、(SはTに1文字追加したものの可能性)
            siを1増やす。
        - |S| &amp;lt; |T|の場合、(SはTから1文字削除したものの可能性)
            tiを1増やす。
        - |S| == |T|の場合、(SはTから1文字変更したものの可能性)
            siを1増やす。
            tiを1増やす。

    - diffが1以上の場合
        Sは条件を満たさない

全てのsiとtiを見たとき、diffが1以下であればSは条件を満たす。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T) = Scanner.Scan&amp;lt;int, string&amp;gt;();
    var answers = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        if (Math.Abs(S.Length - T.Length) &amp;gt; 1) continue;

        var si = 0;
        var ti = 0;
        var diff = 0;
        var ok = true;
        while (si &amp;lt; S.Length &amp;amp;&amp;amp; ti &amp;lt; T.Length &amp;amp;&amp;amp; ok)
        {
            if (S[si] == T[ti]) { si++; ti++; }
            else
            {
                diff++;
                if (S.Length &amp;lt; T.Length) { ti++; }
                else if (S.Length &amp;gt; T.Length) { si++; }
                else { si++; ti++; }
            }

            ok = diff &amp;lt;= 1;
        }

        if (ok) answers.Add(i + 1);
    }

    Console.WriteLine(answers.Count);
    if (answers.Count == 0) Console.WriteLine();
    else Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc324/tasks/abc324_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC324/submissions/46552389"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;桁以下の平方数を列挙し、各平方数の桁の数字の個数が&lt;code&gt;S&lt;/code&gt;の桁の数字の個数と一致するかを判定します。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;桁以下の平方数は、&lt;code&gt;Sqrt(10^13)&lt;/code&gt;程度なので、十分高速に求めることができます。
また、&lt;code&gt;0&lt;/code&gt;の個数に関しては、平方数に対して&lt;code&gt;0&lt;/code&gt;埋めすることが可能なので、&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;0&lt;/code&gt;の個数以下であれば条件を満たします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var CS = new int[10];

    foreach (var c in S.Select(x =&amp;gt; x - '0')) CS[c]++;

    var MAX = (long)1e13;

    var sqrs = new List&amp;lt;long&amp;gt;();
    long v = 0;
    while (v * v &amp;lt;= MAX)
    {
        sqrs.Add(v * v);
        v++;
    }

    long answer = 0;
    foreach (var x in sqrs)
    {
        var CT = new int[10];
        var y = x;
        while (y &amp;gt; 0)
        {
            CT[(int)(y % 10)]++;
            y /= 10;
        }

        var ok = true;
        for (var i = 0; i &amp;lt; 10 &amp;amp;&amp;amp; ok; i++)
        {
            if (i == 0)
            {
                ok &amp;amp;= CS[i] &amp;gt;= CT[i];
            }
            else
            {
                ok &amp;amp;= CS[i] == CT[i];
            }
        }

        if (ok) answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc324/tasks/abc324_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC324/submissions/46561251"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;番目の文字列を先頭から見たときの&lt;code&gt;T&lt;/code&gt;の部分列として一致している長さ、&lt;code&gt;B[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;番目の文字列を末尾から見たときの&lt;code&gt;T&lt;/code&gt;の部分列として一致している長さとしたとき、&lt;code&gt;A[i]+B[j]&amp;gt;=|T|&lt;/code&gt;が成り立つ&lt;code&gt;i,j&lt;/code&gt;が条件を満たします。&lt;br /&gt;
これは、あらかじめ&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;を計算しておき、各&lt;code&gt;A&lt;/code&gt;に対してソートした&lt;code&gt;B&lt;/code&gt;を二部探索することで、時間計算量&lt;code&gt;O(|S| + NlogN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T) = Scanner.Scan&amp;lt;int, string&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    var A = new int[N];
    var B = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var a = 0;
        var b = 0;
        for (var j = 0; j &amp;lt; S[i].Length; j++)
        {
            if (a &amp;lt; T.Length &amp;amp;&amp;amp; S[i][j] == T[a]) a++;
            if (b &amp;lt; T.Length &amp;amp;&amp;amp; S[i][^(j + 1)] == T[^(b + 1)]) b++;
        }

        A[i] = a;
        B[i] = b;
    }

    Array.Sort(B);

    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var lb = LowerBound(B, T.Length - A[i]);
        answer += N - lb;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 324の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231007abc323</id>
		<title>ABC323</title>
		<link href="https://blog.aconcavy.dev/posts/20231007abc323" />
		<updated>2023-10-07T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 323の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc323"&gt;https://atcoder.jp/contests/abc323&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46279658"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;偶数番目は&lt;code&gt;0-indexed&lt;/code&gt;で奇数番目となり、それらが&lt;code&gt;0&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = true;
    for (var i = 1; i &amp;lt; 16; i += 2)
    {
        answer &amp;amp;= S[i] == '0';
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46279658"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の人の番号と勝利数をペアとしたとき、勝利数を降順、番号を昇順に並べ替えたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new char[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var answer = new (int ID, int C)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer[i] = (i, G[i].Count(x =&amp;gt; x == 'o'));
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.OrderByDescending(x =&amp;gt; x.C).ThenBy(x =&amp;gt; x.ID).Select(x =&amp;gt; x.ID + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46308075"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の人がまだ解いていない問題のうち、スコアが高い問題から順に、現在の総合得点の最大より高くなるまで解くことで条件を達成できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var scores = new long[N];
    var queues = new PriorityQueue&amp;lt;long, long&amp;gt;[N];
    long max = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        queues[i] = new PriorityQueue&amp;lt;long, long&amp;gt;();
        long score = i + 1;
        for (var j = 0; j &amp;lt; M; j++)
        {
            if (S[j] == 'o') score += A[j];
            else queues[i].Enqueue(A[j], -A[j]);
        }

        scores[i] = score;
        max = Math.Max(max, score);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var answer = 0;
        while (queues[i].Count &amp;gt; 0 &amp;amp;&amp;amp; scores[i] &amp;lt; max)
        {
            answer++;
            scores[i] += queues[i].Dequeue();
        }

        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46314486"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スライムの大きさが小さくなることはないので、大きさが小さいものから順にスライムを合成させていくことで、スライムの引数を最小にすることができます。&lt;br /&gt;
この操作は、辞書と優先度付きキューなどを使うことで達成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;long, long&amp;gt;();
    var queue = new PriorityQueue&amp;lt;long, long&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, c) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        if (!dict.ContainsKey(s)) dict[s] = 0;
        dict[s] += c;
        queue.Enqueue(s, s);
    }

    while (queue.Count &amp;gt; 0)
    {
        var s = queue.Dequeue();
        var c = dict[s];
        var ns = s * 2;
        var nc = c / 2;
        if (nc &amp;gt; 0)
        {
            if (!dict.ContainsKey(ns)) dict[ns] = 0;
            dict[ns] += nc;
            dict[s] -= nc * 2;
            queue.Enqueue(ns, ns);
        }
    }

    var answer = dict.Values.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46314486"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P[t]&lt;/code&gt;を&lt;code&gt;t&lt;/code&gt;秒に曲が切り替わる確率とします。&lt;br /&gt;
&lt;code&gt;(X+0.5)&lt;/code&gt;秒後に曲1が再生されている確率は、&lt;code&gt;X&lt;/code&gt;秒以前に曲1に切り替わり&lt;code&gt;X+1&lt;/code&gt;秒以降に曲1が再生されている確率であり、これは&lt;code&gt;t&amp;lt;=X&amp;lt;t+T[1]&lt;/code&gt;となる&lt;code&gt;P[t]&lt;/code&gt;に曲1が再生される確率&lt;code&gt;1/N&lt;/code&gt;を掛けたものの総和になります。&lt;br /&gt;
よって、&lt;code&gt;Sum(P[t], X-T[1]+1&amp;lt;=t&amp;lt;=X) / N&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;P[t]&lt;/code&gt;は次のように求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;P[0] = 1
P[t+T[i]] = P[t]/N (0&amp;lt;=t&amp;lt;=X, 1&amp;lt;=i&amp;lt;=N)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var T = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var P = new mint[X + 1];
    P[0] = 1;
    var pN = (mint)1 / N;

    for (var i = 0; i &amp;lt;= X; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (i + T[j] &amp;lt;= X) P[i + T[j]] += P[i] * pN;
        }
    }

    mint answer = 0;
    for (var i = Math.Max(0, X - T[0] + 1); i &amp;lt;= X; i++)
    {
        answer += P[i] * pN;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 323の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230930abc322</id>
		<title>ABC322</title>
		<link href="https://blog.aconcavy.dev/posts/20230930abc322" />
		<updated>2023-09-30T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 322の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc322"&gt;https://atcoder.jp/contests/abc322&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46057457"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;code&gt;String.IndexOf&lt;/code&gt;メソッドを使うことで、文字列のうち指定した文字列が最初に出現する位置を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.IndexOf(&amp;quot;ABC&amp;quot;);
    if (answer != -1) answer += 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46068042"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の先頭&lt;code&gt;N&lt;/code&gt;文字が一致しているかを&lt;code&gt;isPrefix&lt;/code&gt;、&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の末尾&lt;code&gt;N&lt;/code&gt;文字が一致しているかを&lt;code&gt;isSuffix&lt;/code&gt;として求めておき、それぞれの条件に対応した答えを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var isPrefix = true;
    var isSuffix = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        isPrefix &amp;amp;= T[i] == S[i];
        isSuffix &amp;amp;= T[M - 1 - i] == S[N - 1 - i];
    }

    if (isPrefix &amp;amp;&amp;amp; isSuffix)
    {
        Console.WriteLine(0);
    }
    else if (isPrefix)
    {
        Console.WriteLine(1);
    }
    else if (isSuffix)
    {
        Console.WriteLine(2);
    }
    else
    {
        Console.WriteLine(3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46070765"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;i&lt;/code&gt;につき愚直に&lt;code&gt;A&lt;/code&gt;を探索すると全体時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になってしまうので、各&lt;code&gt;i&lt;/code&gt;につき&lt;code&gt;A&lt;/code&gt;を二部探索することで全体時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 1; i &amp;lt;= N; i++)
    {
        var lb = LowerBound(A, i);
        Console.WriteLine(A[lb] - i);
    }
}

public static int LowerBound&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; source, T key, IComparer&amp;lt;T&amp;gt;? comparer = null)
    =&amp;gt; LowerBound(System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source), key, comparer);

public static int LowerBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key, IComparer&amp;lt;T&amp;gt;? comparer = null)
{
    comparer ??= Comparer&amp;lt;T&amp;gt;.Default;
    var (lo, hi) = (-1, source.Length);
    while (hi - lo &amp;gt; 1)
    {
        var mi = lo + ((hi - lo) &amp;gt;&amp;gt; 1);
        if (comparer.Compare(source[mi], key) &amp;gt;= 0) hi = mi;
        else lo = mi;
    }

    return hi;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46114358"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全てのポリオミノの回転の組み合わせと全てのポリオミノの平行移動の組み合わせを全探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int N = 4;
    var P = new char[3][,];
    for (var k = 0; k &amp;lt; 3; k++)
    {
        P[k] = new char[N, N];
        for (var i = 0; i &amp;lt; N; i++)
        {
            var p = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
            for (var j = 0; j &amp;lt; N; j++)
            {
                P[k][i, j] = p[j];
            }
        }
    }

    var G = new char[N, N];
    const int Inf = 1 &amp;lt;&amp;lt; 30;

    // グリッドの初期化
    void Init(char[,] g)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                g[i, j] = '.';
            }
        }
    }

    // ポリオミノを回転させ、左上に寄せる
    char[,] Rotate(char[,] p)
    {
        // ポリオミノを回転させる
        var tmp = new char[N, N];
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                tmp[i, j] = p[j, N - 1 - i];
            }
        }

        // 左上に寄せるために#が出現する最小のhとwを求める
        var h = Inf;
        var w = Inf;
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                if (tmp[i, j] == '#')
                {
                    h = Math.Min(h, i);
                    w = Math.Min(w, j);
                }
            }
        }

        // ポリオミノを左上に寄せる
        var result = new char[N, N];
        if (h == Inf) return result;
        for (var i = 0; h + i &amp;lt; N; i++)
        {
            for (var j = 0; w + j &amp;lt; N; j++)
            {
                result[i, j] = tmp[h + i, w + j];
            }
        }

        return result;
    }

    // グリッドに平行移動させたポリオミノを配置できるかを判定する
    bool Fill(char[,] p, int dh, int dw)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                if (p[i, j] == '#')
                {
                    if (dh + i &amp;lt; N &amp;amp;&amp;amp; dw + j &amp;lt; N &amp;amp;&amp;amp; G[dh + i, dw + j] != '#')
                    {
                        G[dh + i, dw + j] = '#';
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    // 平行移動
    IEnumerable&amp;lt;(int dh, int dw)&amp;gt; Delta()
    {
        for (var h = 0; h &amp;lt; N; h++)
        {
            for (var w = 0; w &amp;lt; N; w++)
            {
                yield return (h, w);
            }
        }
    }

    for (var a = 0; a &amp;lt; 4; a++)
    {
        P[0] = Rotate(P[0]);
        for (var b = 0; b &amp;lt; 4; b++)
        {
            P[1] = Rotate(P[1]);
            for (var c = 0; c &amp;lt; 4; c++)
            {
                P[2] = Rotate(P[2]);
                foreach (var (dha, dwa) in Delta())
                {
                    foreach (var (dhb, dwb) in Delta())
                    {
                        foreach (var (dhc, dwc) in Delta())
                        {
                            var ok = true;
                            Init(G);
                            ok &amp;amp;= Fill(P[0], dha, dwa);
                            ok &amp;amp;= Fill(P[1], dhb, dwb);
                            ok &amp;amp;= Fill(P[2], dhc, dwc);

                            for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; ok; i++)
                            {
                                for (var j = 0; j &amp;lt; N &amp;amp;&amp;amp; ok; j++)
                                {
                                    ok &amp;amp;= G[i, j] == '#';
                                }
                            }

                            if (ok)
                            {
                                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                                return;
                            }
                        }
                    }
                }
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46118122"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][s] := i番目までの開発案を見たとき、開発案のパラメータ状態がsのときの最小コスト
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;パラメータ状態は&lt;code&gt;K&lt;/code&gt;個のパラメータの値を連結した文字列とすることで管理することができ、パラメータ状態の数は&lt;code&gt;(P+1)^K&lt;/code&gt;であり、&lt;code&gt;1&amp;lt;=K,P&amp;lt;=5&lt;/code&gt;であることから最大でも&lt;code&gt;6^5=7776&lt;/code&gt;通りになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K, P) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var Plans = new (long C, int[] A)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var array = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        Plans[i] = (array[0], array[1..]);
    }

    var dp = new Dictionary&amp;lt;string, long&amp;gt;();
    const long Inf = 1L &amp;lt;&amp;lt; 60;
    dp[new string('0', K)] = 0;
    var B = new int[K];

    for (var i = 0; i &amp;lt; N; i++)
    {
        var (C, A) = Plans[i];
        var ndp = new Dictionary&amp;lt;string, long&amp;gt;();
        foreach (var (s, c) in dp)
        {
            for (var j = 0; j &amp;lt; K; j++)
            {
                B[j] = A[j];
            }

            for (var j = 0; j &amp;lt; K; j++)
            {
                B[j] += s[j] - '0';
                B[j] = Math.Min(P, B[j]);
            }

            var ns = string.Join(&amp;quot;&amp;quot;, B);
            if (!ndp.ContainsKey(s)) ndp[s] = Inf;
            ndp[s] = Math.Min(ndp[s], c);
            if (!ndp.ContainsKey(ns)) ndp[ns] = Inf;
            ndp[ns] = Math.Min(ndp[ns], C + c);
        }
        dp = ndp;
    }

    var g = new string((char)(P + '0'), K);
    var answer = dp.ContainsKey(g) ? dp[g] : -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 322の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230923abc321</id>
		<title>ABC321</title>
		<link href="https://blog.aconcavy.dev/posts/20230923abc321" />
		<updated>2023-09-23T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 321の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc321"&gt;https://atcoder.jp/contests/abc321&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45817144"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;を文字列としてみたとき、全ての&lt;code&gt;1&amp;lt;=i&amp;lt;=N-1&lt;/code&gt;において&lt;code&gt;N[i]&amp;gt;N[i+1]&lt;/code&gt;が成り立つものが&lt;code&gt;321-like Number&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = true;
    for (var i = 0; i + 1 &amp;lt; N.Length; i++)
    {
        answer &amp;amp;= N[i] &amp;gt; N[i + 1];
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45824801"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後に&lt;code&gt;k&lt;/code&gt;点取ると固定したときの最終結果が&lt;code&gt;X&lt;/code&gt;以上になる&lt;code&gt;k&lt;/code&gt;を全探索します。&lt;br /&gt;
あらかじめ、&lt;code&gt;N-1&lt;/code&gt;試合の合計スコア(&lt;code&gt;sum&lt;/code&gt;)、最低スコア(&lt;code&gt;min&lt;/code&gt;)、最高スコア(&lt;code&gt;max&lt;/code&gt;)を計算しておくと、最終試験で&lt;code&gt;k&lt;/code&gt;点とった場合、最終結果は&lt;code&gt;sum + k - Min(min,k) - Max(max,k)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var min = A.Min();
    var max = A.Max();
    var sum = A.Sum();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var answer = Inf;
    for (var k = 0; k &amp;lt;= 100; k++)
    {
        var mmin = Math.Min(min, k);
        var mmax = Math.Max(max, k);
        var x = sum + k - mmin - mmax;
        if (x &amp;gt;= X)
        {
            answer = Math.Min(answer, k);
        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45887284"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;321-like Number&lt;/code&gt;の各桁に同じ数字が現れることはないため、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の数字をそれぞれ使う/使わないとしたときに、使う数字のみを降順に並べたものが&lt;code&gt;321-like Number&lt;/code&gt;になり得ます。&lt;br /&gt;
このことから、それぞれの数字を使う/使わないとする組み合わせ&lt;code&gt;2^10-1&lt;/code&gt;通りをbit全探索し、全ての&lt;code&gt;321-like Number&lt;/code&gt;を列挙してソートすることで、&lt;code&gt;K&lt;/code&gt;番目の値を得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new List&amp;lt;long&amp;gt;();
    for (var s = 1; s &amp;lt; 1 &amp;lt;&amp;lt; 10; s++)
    {
        var list = new List&amp;lt;int&amp;gt;();
        for (var i = 0; i &amp;lt; 10; i++)
        {
            if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1) list.Add(i);
        }

        list.Sort();
        list.Reverse();
        S.Add(long.Parse(string.Join(&amp;quot;&amp;quot;, list)));
    }

    S.Sort();
    var answer = S[K];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45853839"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある主菜&lt;code&gt;A[i]&lt;/code&gt;を固定したとき、副菜&lt;code&gt;B&lt;/code&gt;のうち価格が&lt;code&gt;P-A[i]&lt;/code&gt;以上のものは価格が&lt;code&gt;P&lt;/code&gt;となることから、&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;P-A[i]&lt;/code&gt;以上のものと&lt;code&gt;P-A[i]&lt;/code&gt;より小さいもので分けて考えることができます。&lt;br /&gt;
&lt;code&gt;P-A[i]&lt;/code&gt;以上のものの個数を&lt;code&gt;X&lt;/code&gt;としたとき、&lt;code&gt;P-A[i]&lt;/code&gt;以上のものの価格の総和は&lt;code&gt;M*P&lt;/code&gt;になります。&lt;br /&gt;
&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの個数は&lt;code&gt;M-X&lt;/code&gt;となり、&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格和を&lt;code&gt;S&lt;/code&gt;とすると、&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格の総和は&lt;code&gt;A[i]*(M-X)+S&lt;/code&gt;となります。
&lt;code&gt;B&lt;/code&gt;をあらかじめソートしておき、累積和を求めておくことで、各&lt;code&gt;A[i]&lt;/code&gt;ごとに&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;P-A[i]&lt;/code&gt;以上の個数を時間計算量&lt;code&gt;O(logM)&lt;/code&gt;で求めることができ、累積和から&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格和を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。&lt;br /&gt;
よって、全体時間計算量&lt;code&gt;O(MlogM + NlogM)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, P) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(B);
    var cumB = new long[M + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        cumB[i + 1] = cumB[i] + B[i];
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var lb = LowerBound(B, Math.Max(0, P - A[i]));
        var x = A[i] * lb + cumB[lb];
        var y = (M - lb) * P;
        answer += x + y;
    }

    Console.WriteLine(answer);
}

public static int LowerBound&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
    =&amp;gt; LowerBound(System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source), key);

public static int LowerBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m].CompareTo(key) &amp;gt;= 0) r = m;
        else l = m;
    }

    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けていません。&lt;/p&gt;
&lt;!-- 
```csharp
``` --&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45887679"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 現在のクエリまでみたとき、総和がsとなる組み合わせの個数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;if op == '+'
dp[j] += dp[i][j-x] (j=K,K-1,..,x+1,x)

if op == '-'
dp[j] -= dp[i][j-x] (j=x,x+1,..,K-1,K)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (Q, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new mint[K + 1];
    dp[0] = 1;
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (op, x) = Scanner.Scan&amp;lt;char, int&amp;gt;();
        if (op == '+')
        {
            for (var j = K; j &amp;gt;= x; j--)
            {
                dp[j] += dp[j - x];
            }
        }
        else
        {
            for (var j = x; j &amp;lt;= K; j++)
            {
                dp[j] -= dp[j - x];
            }
        }

        var answer = dp[K];
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 321の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230916abc320</id>
		<title>ABC320</title>
		<link href="https://blog.aconcavy.dev/posts/20230916abc320" />
		<updated>2023-09-16T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 320の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320"&gt;https://atcoder.jp/contests/abc320&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45588498"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Math.Pow&lt;/code&gt;関数や、&lt;code&gt;for&lt;/code&gt;文で&lt;code&gt;A&lt;/code&gt;を&lt;code&gt;B&lt;/code&gt;回掛けたもの、&lt;code&gt;B&lt;/code&gt;を&lt;code&gt;A&lt;/code&gt;回掛けたものを求め、それぞれを足したものを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answer = Math.Pow(A, B) + Math.Pow(B, A);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45589841"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連続する部分文字列の両端の組み合わせ&lt;code&gt;i,j (i&amp;lt;=j)&lt;/code&gt;を全探索し、その部分文字列が回文であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i; j &amp;lt; N; j++)
        {
            var ok = true;
            for (var k = 0; k &amp;lt;= j - i &amp;amp;&amp;amp; ok; k++)
            {
                var a = i + k;
                var b = j - k;
                ok &amp;amp;= S[a] == S[b];
            }

            if (ok)
            {
                answer = Math.Max(answer, j - i + 1);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45601337"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スロットのリールのうち、どの数字を止めるかを固定して考えます。&lt;br /&gt;
止める数字を固定したとき、各リールでその数字が出現する順番を全探索します。&lt;br /&gt;
出現する順番が一致しているリールが2つのとき、それぞれ1周目と2周目で止めることで、その数字をそろえることができます。&lt;br /&gt;
出現する順番が一致しているリールが3つのとき、それぞれ1周目、2週目、3週目で止めることで、その数字をそろえることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var M = Scanner.Scan&amp;lt;int&amp;gt;();
    var list = new List&amp;lt;int&amp;gt;[3][];
    for (var i = 0; i &amp;lt; 3; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
        list[i] = new List&amp;lt;int&amp;gt;[10].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
        for (var j = 0; j &amp;lt; M; j++)
        {
            list[i][S[j]].Add(j);
        }
    }

    const int Inf = (int)1e9;
    var answer = Inf;
    for (var k = 0; k &amp;lt; 10; k++)
    {
        foreach (var a in list[0][k])
        {
            foreach (var b in list[1][k])
            {
                foreach (var c in list[2][k])
                {
                    var x = a;
                    var y = b;
                    var z = c;
                    if (x == y &amp;amp;&amp;amp; y == z)
                    {
                        x += M;
                        y += M * 2;
                    }
                    else if (x == y)
                    {
                        y += M;
                    }
                    else if (x == z)
                    {
                        z += M;
                    }
                    else if (y == z)
                    {
                        z += M;
                    }

                    answer = Math.Min(answer, Math.Max(Math.Max(x, y), z));
                }
            }

        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45608907"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の頂点に対して、&lt;code&gt;M&lt;/code&gt;個の情報を&lt;code&gt;A[i]&lt;/code&gt;から&lt;code&gt;B[i]&lt;/code&gt;への&lt;code&gt;D(X[i],Y[i])&lt;/code&gt;となる有向辺と&lt;code&gt;B[i]&lt;/code&gt;から&lt;code&gt;A[i]&lt;/code&gt;への&lt;code&gt;D(-X[i],-Y[i])&lt;/code&gt;となる有向辺とした、&lt;code&gt;2M&lt;/code&gt;個の辺からなる有向グラフを構築し、人&lt;code&gt;1&lt;/code&gt;を始点とした幅優先探索を行い、それぞれの人の座標の集合を求めます。&lt;br /&gt;
各人のあり得る座標の集合において、一意に定まる場合はその座標を、それ以外の場合は&lt;code&gt;undecidable&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    const string Undecidable = &amp;quot;undecidable&amp;quot;;
    var G = new HashSet&amp;lt;(int, Point)&amp;gt;[N].Select(x =&amp;gt; new HashSet&amp;lt;(int, Point)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, x, y) = Scanner.Scan&amp;lt;int, int, long, long&amp;gt;();
        a--; b--;
        G[a].Add((b, new(x, y)));
        G[b].Add((a, new(-x, -y)));
    }

    var P = new HashSet&amp;lt;Point&amp;gt;[N].Select(_ =&amp;gt; new HashSet&amp;lt;Point&amp;gt;()).ToArray();
    P[0].Add(new(0, 0));
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(0);
    while (queue.TryDequeue(out var u))
    {
        var cp = P[u].First();
        foreach (var (v, diff) in G[u])
        {
            var (dx, dy) = diff;
            var np = new Point(cp.X + dx, cp.Y + dy);
            if (P[v].Contains(np)) continue;
            P[v].Add(np);
            queue.Enqueue(v);
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (P[i].Count == 1)
        {
            var p = P[i].First();
            Console.WriteLine($&amp;quot;{p.X} {p.Y}&amp;quot;);
        }
        else
        {
            Console.WriteLine(Undecidable);
        }
    }
}

public readonly record struct Point(long X, long Y);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45623544"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待機列の人を番号順に管理できる優先度付きキューと、列から離れた人の番号と帰ってくる時間を時間順に管理できる優先度付きキューを用意し、そうめんが流れてくるごとに、その時間以前の列から離れた人を待機列に追加し、待機列の先頭の人にそうめんを獲得させ、その人を列から離れさせるというシミュレーションを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();

    var leavingID = new PriorityQueue&amp;lt;R&amp;gt;((x, y) =&amp;gt;
    {
        var result = x.Time.CompareTo(y.Time);
        if (result == 0) result = x.ID.CompareTo(y.ID);
        return result;
    });

    for (var i = 0; i &amp;lt; N; i++)
    {
        leavingID.Enqueue(new R(i, 0));
    }

    var waitingID = new PriorityQueue&amp;lt;int&amp;gt;((x, y) =&amp;gt; x.CompareTo(y));
    var answers = new long[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (t, w, s) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        while (leavingID.Count &amp;gt; 0 &amp;amp;&amp;amp; leavingID.Peek().Time &amp;lt;= t)
        {
            var (id, _) = leavingID.Dequeue();
            waitingID.Enqueue(id);
        }

        if (waitingID.Count == 0) continue;
        var waited = waitingID.Dequeue();
        answers[waited] += w;
        var nt = t + s;
        leavingID.Enqueue(new R(waited, nt));
    }

    Console.WriteLine(string.Join(Environment.NewLine, answers));
}

public readonly record struct R(int ID, long Time);

public class PriorityQueue&amp;lt;T&amp;gt; : IReadOnlyCollection&amp;lt;T&amp;gt;
{
    private readonly Comparison&amp;lt;T&amp;gt; _comparison;
    private readonly List&amp;lt;T&amp;gt; _heap;

    public PriorityQueue(IEnumerable&amp;lt;T&amp;gt; items, IComparer&amp;lt;T&amp;gt; comparer = null) : this(comparer)
    {
        foreach (var item in items) Enqueue(item);
    }

    public PriorityQueue(IEnumerable&amp;lt;T&amp;gt; items, Comparison&amp;lt;T&amp;gt; comparison) : this(comparison)
    {
        foreach (var item in items) Enqueue(item);
    }

    public PriorityQueue(IComparer&amp;lt;T&amp;gt; comparer = null) : this((comparer ?? Comparer&amp;lt;T&amp;gt;.Default).Compare) { }

    public PriorityQueue(Comparison&amp;lt;T&amp;gt; comparison)
    {
        _heap = new List&amp;lt;T&amp;gt;();
        _comparison = comparison;
    }

    public int Count =&amp;gt; _heap.Count;
    public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; _heap.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();

    public void Enqueue(T item)
    {
        var child = Count;
        _heap.Add(item);
        while (child &amp;gt; 0)
        {
            var parent = (child - 1) / 2;
            if (_comparison(_heap[parent], _heap[child]) &amp;lt;= 0) break;
            (_heap[parent], _heap[child]) = (_heap[child], _heap[parent]);
            child = parent;
        }
    }

    public T Dequeue()
    {
        if (Count == 0) throw new InvalidOperationException();
        var result = _heap[0];
        _heap[0] = _heap[Count - 1];
        _heap.RemoveAt(Count - 1);
        var parent = 0;
        while (parent * 2 + 1 &amp;lt; Count)
        {
            var left = parent * 2 + 1;
            var right = parent * 2 + 2;
            if (right &amp;lt; Count &amp;amp;&amp;amp; _comparison(_heap[left], _heap[right]) &amp;gt; 0)
                left = right;
            if (_comparison(_heap[parent], _heap[left]) &amp;lt;= 0) break;
            (_heap[parent], _heap[left]) = (_heap[left], _heap[parent]);
            parent = left;
        }

        return result;
    }

    public T Peek()
    {
        if (Count == 0) throw new InvalidOperationException();
        return _heap[0];
    }

    public bool TryDequeue(out T result)
    {
        if (Count &amp;gt; 0)
        {
            result = Dequeue();
            return true;
        }

        result = default;
        return false;
    }

    public bool TryPeek(out T result)
    {
        if (Count &amp;gt; 0)
        {
            result = Peek();
            return true;
        }

        result = default;
        return false;
    }

    public void Clear() =&amp;gt; _heap.Clear();
    public bool Contains(T item) =&amp;gt; _heap.Contains(item);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 320の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>