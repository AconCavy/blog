<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title />
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2023 AconCavy</rights>
	<updated>2023-06-03T15:18:35Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230603abc304</id>
		<title>ABC304</title>
		<link href="https://blog.aconcavy.dev/posts/20230603abc304" />
		<updated>2023-06-03T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 304の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc304"&gt;https://atcoder.jp/contests/abc304&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41937503"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;が最も小さい番号の人の順番を&lt;code&gt;k (0-indexed)&lt;/code&gt;としたとき、&lt;code&gt;i&lt;/code&gt;番目に出力すべき人は&lt;code&gt;(k+i-1)%N&lt;/code&gt;番の人となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new string[N];
    var A = new int[N];
    var first = -1;
    const int Inf = (int)1e9;
    var min = Inf;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, a) = Scanner.Scan&amp;lt;string, int&amp;gt;();
        S[i] = s;
        A[i] = a;
        if (a &amp;lt; min)
        {
            min = a;
            first = i;
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        Console.WriteLine(S[(first + i) % N]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41937568"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;が&lt;code&gt;M&lt;/code&gt;桁の数値であるとき、下位&lt;code&gt;Max(0,M-3)&lt;/code&gt;桁を切り捨てたものが答えとなります。
そのため、&lt;code&gt;K=Max(0,M-3)&lt;/code&gt;としたとき、&lt;code&gt;Floor(N/K)*K&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var M = N.ToString().Length - 3;
    var k = 1;
    for (var i = 0; i &amp;lt; M; i++)
    {
        k *= 10;
    }

    Console.WriteLine(N / k * k);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41941546"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各番号の人を頂点としたBFSを行います。
遷移できるかの判定において、距離の2乗で判定を行うことで、浮動小数点による誤差を無視して判定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = new (int X, int Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        P[i] = (x, y);
    }

    var used = new bool[N];
    used[0] = true;
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(0);
    var D2 = D * D;
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        for (var v = 0; v &amp;lt; N; v++)
        {
            if (used[v]) continue;
            var (dx, dy) = (P[u].X - P[v].X, P[u].Y - P[v].Y);
            var d = dx * dx + dy * dy;
            if (d &amp;lt;= D2)
            {
                used[v] = true;
                queue.Enqueue(v);
            }
        }
    }

    Console.WriteLine(string.Join(Environment.NewLine, used.Select(x =&amp;gt; x ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41963721"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分割されたケーキのピースをそれぞれ、横&lt;code&gt;i (1&amp;lt;=i&amp;lt;=A+1)&lt;/code&gt;番目、縦&lt;code&gt;j (1&amp;lt;=j&amp;lt;=B+1)&lt;/code&gt;番目のピースとし、それぞれのピースにイチゴが何個乗っているかを数え上げます。&lt;/p&gt;
&lt;p&gt;このとき、イチゴがどのピースに乗っているかを二次元配列で管理してしまうと、計算量が&lt;code&gt;O((A+1)(B+1))&lt;/code&gt;になってしまいますが、イチゴの数は高々&lt;code&gt;N&lt;/code&gt;個なので、ピース&lt;code&gt;(i,j)&lt;/code&gt;をキーとする辞書などのデータ構造を使うことで、計算量を&lt;code&gt;O(log(N))&lt;/code&gt;に抑えて管理することができます。&lt;/p&gt;
&lt;p&gt;また、イチゴがどの位置のピースに乗っているかについて、愚直に探索してしまうと、イチゴごとに時間計算量&lt;code&gt;O(A+B)&lt;/code&gt;かかりますが、二部探索をおこなうことで時間計算量&lt;code&gt;O(logA+logB)&lt;/code&gt;に抑えることができます。&lt;br /&gt;
これにより、イチゴがあるピースにおける最小値と最大値を求めることができます。
しかし、この最小値はイチゴがないピースは対象としていないため、イチゴがないピースが存在した場合は最小は&lt;code&gt;0&lt;/code&gt;となります。&lt;br /&gt;
これは、&lt;code&gt;(i,j)&lt;/code&gt;の組み合わせのピースを全て走査することで判定することができますが、イチゴの数は&lt;code&gt;N&lt;/code&gt;個なので、&lt;code&gt;Min(N+1,(A+1)(B+1))&lt;/code&gt;個の組み合わせを調べるだけで、イチゴがないピースが存在するかを判定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (W, H) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Berries = new (int X, int Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        Berries[i] = (x, y);
    }
    var AN = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToList();
    var BN = Scanner.Scan&amp;lt;int&amp;gt;();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToList();
    A.Insert(0, 0);
    B.Insert(0, 0);

    var dict = new Dictionary&amp;lt;(int, int), int&amp;gt;();
    foreach (var (x, y) in Berries)
    {
        var i = LowerBound(A, x);
        var j = LowerBound(B, y);
        if (!dict.ContainsKey((i, j))) dict[(i, j)] = 0;
        dict[(i, j)]++;
    }

    const int Inf = (int)1e9;
    var min = Inf;
    var max = 0;
    foreach (var v in dict.Values)
    {
        min = Math.Min(min, v);
        max = Math.Max(max, v);
    }

    var ok = false;
    for (var i = 1; i &amp;lt;= AN + 1 &amp;amp;&amp;amp; !ok; i++)
    {
        for (var j = 1; j &amp;lt;= BN + 1 &amp;amp;&amp;amp; !ok; j++)
        {
            if (!dict.ContainsKey((i, j)))
            {
                min = 0;
                ok = true;
            }
        }
    }

    Console.WriteLine($&amp;quot;{min} {max}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41972347"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G&lt;/code&gt;上で頂点&lt;code&gt;x&lt;/code&gt;と頂点&lt;code&gt;y&lt;/code&gt;を結ぶパスが存在しないということは、&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;y&lt;/code&gt;が属する連結成分を&lt;code&gt;gx&lt;/code&gt;、&lt;code&gt;gy&lt;/code&gt;としたとき、&lt;code&gt;gx&lt;/code&gt;と&lt;code&gt;gy&lt;/code&gt;が別の連結成分であることが良いグラフである条件になります。&lt;br /&gt;
このことから、&lt;code&gt;gx&lt;/code&gt;と&lt;code&gt;gy&lt;/code&gt;を接続する辺を追加したときは、&lt;code&gt;G&lt;/code&gt;は良いグラフではなくなります。&lt;br /&gt;
そのため、連結成分ごとに互いに接続してはいけない連結成分を管理し、クエリごとに&lt;code&gt;p&lt;/code&gt;、&lt;code&gt;q&lt;/code&gt;が互いに接続してはいけない連結成分に属していないかを判定することで答えを求めることができます。&lt;br /&gt;
各頂点がどの連結成分に属しているかは、&lt;code&gt;DisjointSetUnion&lt;/code&gt;を使って各連結成分の代表となる頂点をインデックスにするなどの方法で管理することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dsu = new DisjointSetUnion(N);
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        dsu.Merge(u, v);
    }

    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; K; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--; y--;
        var xl = dsu.LeaderOf(x);
        var yl = dsu.LeaderOf(y);
        if (!dict.ContainsKey(xl)) dict[xl] = new HashSet&amp;lt;int&amp;gt;();
        if (!dict.ContainsKey(yl)) dict[yl] = new HashSet&amp;lt;int&amp;gt;();
        dict[xl].Add(yl);
        dict[yl].Add(xl);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (p, q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        p--; q--;
        var pl = dsu.LeaderOf(p);
        var ql = dsu.LeaderOf(q);
        var answer = true;
        if (dict.ContainsKey(pl)) answer &amp;amp;= !dict[pl].Contains(ql);
        if (dict.ContainsKey(ql)) answer &amp;amp;= !dict[ql].Contains(pl);

        Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 304の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230527abc303</id>
		<title>ABC303</title>
		<link href="https://blog.aconcavy.dev/posts/20230527abc303" />
		<updated>2023-05-27T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 303の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc303"&gt;https://atcoder.jp/contests/abc303&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41726568"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;両方の文字列の&lt;code&gt;1&lt;/code&gt;を&lt;code&gt;l&lt;/code&gt;に、&lt;code&gt;0&lt;/code&gt;を&lt;code&gt;o&lt;/code&gt;に変換した文字列が一致する場合、似た文字列となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    string F(string str) =&amp;gt; str.Replace('1', 'l').Replace('0', 'o');
    var answer = F(S) == F(T);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41733840"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G[x][y]&lt;/code&gt;を番号&lt;code&gt;x&lt;/code&gt;と番号&lt;code&gt;y&lt;/code&gt;の人が隣り合ったことがあるかを判定する&lt;code&gt;bool&lt;/code&gt;行列、&lt;code&gt;A[i][j]&lt;/code&gt;を&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;A[i][j+1]&lt;/code&gt;を&lt;code&gt;v&lt;/code&gt;すると、&lt;code&gt;G[u][v]&lt;/code&gt;と&lt;code&gt;G[v][u]&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;にすることができます。&lt;br /&gt;
そして、&lt;code&gt;u&amp;lt;v&lt;/code&gt;となる組み合わせのうち&lt;code&gt;G[u][v]&lt;/code&gt;が&lt;code&gt;false&lt;/code&gt;である組み合わせの数が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[M][].Select(_ =&amp;gt; Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray()).ToArray();
    var G = new bool[N, N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        for (var j = 0; j + 1 &amp;lt; N; j++)
        {
            var u = A[i][j] - 1;
            var v = A[i][j + 1] - 1;
            G[u, v] = true;
            G[v, u] = true;
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            if (!G[i, j]) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41740054"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文の通りにシミュレーションを行います。
ただし、&lt;code&gt;|x|,|y|&amp;lt;=2e5&lt;/code&gt;であるため、アイテムの位置を二次元座標を配列として管理してしまうと、計算量が&lt;code&gt;O(Max(|x|,|y|)^2)&lt;/code&gt;となり実行時間制限に間に合いません。
そのため、アイテムの位置を&lt;code&gt;Set&lt;/code&gt;や&lt;code&gt;HashSet&lt;/code&gt;などで管理することで、時間計算量&lt;code&gt;O(Nlog(M))&lt;/code&gt;や&lt;code&gt;O(N)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, H, K) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    var items = new HashSet&amp;lt;(int X, int Y)&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        items.Add((x, y));
    }

    (int Nx, int Ny) F(int x, int y, char c)
    {
        return c switch
        {
            'R' =&amp;gt; (x + 1, y),
            'L' =&amp;gt; (x - 1, y),
            'U' =&amp;gt; (x, y + 1),
            'D' =&amp;gt; (x, y - 1),
            _ =&amp;gt; (x, y),
        };
    }

    var (cx, cy) = (0, 0);
    foreach (var c in S)
    {
        (cx, cy) = F(cx, cy, c);
        H--;
        if (H &amp;lt; 0)
        {
            Console.WriteLine(&amp;quot;No&amp;quot;);
            return;
        }

        if (items.Contains((cx, cy)) &amp;amp;&amp;amp; H &amp;lt; K)
        {
            items.Remove((cx, cy));
            H = K;
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41746026"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,f] := i番目の文字を入力するときにCapsLockキーのランプがf(OFF|ON)のときの最短の時間
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4種類の操作があり得ます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Xミリ秒でaキーを押す&lt;/li&gt;
&lt;li&gt;Yミリ秒でShiftキーとaキーを押す&lt;/li&gt;
&lt;li&gt;Zミリ秒でCapsLockキーを押した後にaキーを押す&lt;/li&gt;
&lt;li&gt;Zミリ秒でCapsLockキーを押した後にShiftキーとaキーを押す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;初期値
dp[0,OFF]   = 0
dp[1,ON]    = INF

S[i]がaのとき
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,OFF]+X)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,ON] +Y)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,OFF]+Z+Y)
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,ON] +Z+X)

S[i]がAのとき
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,OFF]+Y)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,ON] +Y)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,OFF]+Z+X)
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,ON] +Z+Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;まとめると次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;S[i]がaのときf=0,Aのときf=1とする
dp[i+1,f]   = Min(dp[i+1,f],   dp[i,f]  +X)
dp[i+1,f^1] = Min(dp[i+1,f^1], dp[i,f^1]+Y)
dp[i+1,f]   = Min(dp[i+1,f],   dp[i,f^1]+Z+X)
dp[i+1,f^1] = Min(dp[i+1,f^1], dp[i,f]  +Z+Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;文字目まで入力後の&lt;code&gt;Min(dp[N,OFF],dp[N,ON])&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, Z) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var dp = new long[N + 1, 2];
    const long Inf = (long)1e18;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        dp[i, 0] = dp[i, 1] = Inf;
    }

    dp[0, 0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var f = S[i] == 'a' ? 0 : 1;
        var g = f ^ 1;
        dp[i + 1, f] = Math.Min(dp[i + 1, f], dp[i, f] + X);
        dp[i + 1, g] = Math.Min(dp[i + 1, g], dp[i, g] + Y);
        dp[i + 1, f] = Math.Min(dp[i + 1, f], dp[i, g] + Z + X);
        dp[i + 1, g] = Math.Min(dp[i + 1, g], dp[i, f] + Z + Y);
    }

    var answer = Math.Min(dp[N, 0], dp[N, 1]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41770653"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;星の中心となる頂点は、葉となる頂点と辺で結ばれている頂点になります。&lt;br /&gt;
また、星の中心となる頂点と辺で結ばれている頂点はすべて葉である必要があります。&lt;br /&gt;
そのため、葉となる頂点&lt;code&gt;u&lt;/code&gt;を順番に見ていき、その葉を含む星の中心となる頂点&lt;code&gt;v&lt;/code&gt;と辺で結ばれている頂点&lt;code&gt;w&lt;/code&gt;に結ばれている辺のうち、&lt;code&gt;v&lt;/code&gt;以外の辺を全て取り除くことで、&lt;code&gt;v&lt;/code&gt;の辺の数がレベルとなる星にすることができます。&lt;br /&gt;
また、グラフは木であるため、&lt;code&gt;w&lt;/code&gt;と結ばれている辺を削除した頂点&lt;code&gt;x&lt;/code&gt;は新しく葉となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;  u -- v -- w
            |
  z -- y -- x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var deg = new int[N];
    var G = new HashSet&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new HashSet&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--;
        v--;
        G[u].Add(v);
        G[v].Add(u);
        deg[u]++;
        deg[v]++;
    }

    var queue = new Queue&amp;lt;int&amp;gt;();

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (deg[i] == 1) queue.Enqueue(i);
    }

    var answer = new List&amp;lt;int&amp;gt;();
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        if (G[u].Count &amp;lt; 1) continue;
        var v = G[u].First();
        var vd = G[v].Count;
        answer.Add(vd);

        var removed = new List&amp;lt;(int, int)&amp;gt;();
        foreach (var w in G[v])
        {
            foreach (var x in G[w])
            {
                removed.Add((w, x));
                deg[w]--;
                deg[x]--;
                queue.Enqueue(x);
            }
        }

        foreach (var (x, y) in removed)
        {
            G[x].Remove(y);
            G[y].Remove(x);
        }
    }

    answer.Sort();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 303の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230520abc302</id>
		<title>ABC302</title>
		<link href="https://blog.aconcavy.dev/posts/20230520abc302" />
		<updated>2023-05-21T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 302の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc302"&gt;https://atcoder.jp/contests/abc302&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41536854"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ceil(A/B)&lt;/code&gt;が答えになるので、&lt;code&gt;(A+B-1)/B&lt;/code&gt;で切り上げた値を得ることができます。&lt;br /&gt;
また、double型などの浮動小数点型だと、精度の問題で正しい値を求めることができないことがあります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answer = (A + B - 1) / B;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41548153"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;snuke&lt;/code&gt;文字列の始点のマスの位置を&lt;code&gt;(ch,cw)&lt;/code&gt;、&lt;code&gt;snuke&lt;/code&gt;文字列が続く方向を&lt;code&gt;(dh,dw)&lt;/code&gt;とすると、&lt;code&gt;snuke&lt;/code&gt;文字列の&lt;code&gt;k&lt;/code&gt;文字目は&lt;code&gt;(ch+dh*k,cw+dw*k)&lt;/code&gt;の位置のマスになります。この位置のマスがグリッド上にあり、5文字全て一致している場合、始点から順に出力することで答えを得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new char[H][];
    const string Snuke = &amp;quot;snuke&amp;quot;;

    for (var i = 0; i &amp;lt; H; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    for (var ch = 0; ch &amp;lt; H; ch++)
    {
        for (var cw = 0; cw &amp;lt; W; cw++)
        {
            for (var dh = -1; dh &amp;lt;= 1; dh++)
            {
                for (var dw = -1; dw &amp;lt;= 1; dw++)
                {
                    var ok = true;
                    for (var k = 0; k &amp;lt; 5 &amp;amp;&amp;amp; ok; k++)
                    {
                        var nh = ch + dh * k;
                        var nw = cw + dw * k;
                        if (nh &amp;lt; 0 || nh &amp;gt;= H || nw &amp;lt; 0 || nw &amp;gt;= W)
                        {
                            ok = false;
                            break;
                        }

                        ok &amp;amp;= S[nh][nw] == Snuke[k];
                    }

                    if (ok)
                    {
                        for (var k = 0; k &amp;lt; 5; k++)
                        {
                            Console.WriteLine($&amp;quot;{ch + 1 + dh * k} {cw + 1 + dw * k}&amp;quot;);
                        }
                        return;
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41550544"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の文字列の順列を全探索し、いずれかの場合において条件を満たすことができるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    foreach (var perm in Permute(Enumerable.Range(0, N)))
    {
        var answer = true;
        for (var k = 0; k + 1 &amp;lt; N; k++)
        {
            var curr = perm[k];
            var next = perm[k + 1];
            var diff = 0;
            for (var i = 0; i &amp;lt; M; i++)
            {
                if (S[curr][i] != S[next][i]) diff++;
            }

            answer &amp;amp;= diff == 1;
        }

        if (answer)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}

public static IEnumerable&amp;lt;T[]&amp;gt; Permute&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    if (source is null) throw new ArgumentNullException(nameof(source));
    IEnumerable&amp;lt;T[]&amp;gt; Inner()
    {
        var items = source.ToArray();
        var n = items.Length;
        var indices = new int[n];
        for (var i = 0; i &amp;lt; indices.Length; i++)
        {
            indices[i] = i;
        }
        T[] Result()
        {
            var result = new T[n];
            for (var i = 0; i &amp;lt; n; i++)
            {
                result[i] = items[indices[i]];
            }
            return result;
        }
        yield return Result();
        while (true)
        {
            var (i, j) = (n - 2, n - 1);
            while (i &amp;gt;= 0)
            {
                if (indices[i] &amp;lt; indices[i + 1]) break;
                i--;
            }
            if (i == -1) yield break;
            while (true)
            {
                if (indices[j] &amp;gt; indices[i]) break;
                j--;
            }
            (indices[i], indices[j]) = (indices[j], indices[i]);
            Array.Reverse(indices, i + 1, n - 1 - i);
            yield return Result();
        }
    }
    return Inner();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41557498"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての組み合わせを考えてしまうと、時間計算量が&lt;code&gt;O(NM)&lt;/code&gt;になり、実行時間制限に間に合いません。
&lt;code&gt;A&lt;/code&gt;を固定して考えたとき、&lt;code&gt;A[i]&lt;/code&gt;に対して選ぶことができる&lt;code&gt;B&lt;/code&gt;の最大の贈り物は&lt;code&gt;A[i]+D&lt;/code&gt;以下のものになります。&lt;br /&gt;
ここで、&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;A[i]+D&lt;/code&gt;以下になる最大のものを&lt;code&gt;B&lt;/code&gt;をソートして二部探索で求めることで、各&lt;code&gt;A[i]&lt;/code&gt;に対して時間計算量&lt;code&gt;O(logM)&lt;/code&gt;で求めることができ、まとめると時間計算量&lt;code&gt;O(NlogM)&lt;/code&gt;で求めることができます。
同様に、&lt;code&gt;B&lt;/code&gt;を固定して考えたとき、時間計算量&lt;code&gt;O(MlogN)&lt;/code&gt;で求めることができるため、全体時間計算量は&lt;code&gt;O(NlogM+MlogN)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, D) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    Array.Sort(A);
    Array.Sort(B);
    long answer = -1;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var a = A[i];
        var j = Math.Max(0, UpperBound(B, a + D) - 1);
        var b = B[j];
        if (Math.Abs(a - b) &amp;lt;= D)
        {
            answer = Math.Max(answer, a + b);
        }
    }

    for (var i = 0; i &amp;lt; M; i++)
    {
        var b = B[i];
        var j = Math.Max(0, UpperBound(A, b + D) - 1);
        var a = A[j];
        if (Math.Abs(b - a) &amp;lt;= D)
        {
            answer = Math.Max(answer, b + a);
        }
    }

    Console.WriteLine(answer);
}

public static int UpperBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m].CompareTo(key) &amp;gt; 0) r = m;
        else l = m;
    }

    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41563876"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点ごとに辺で結ばれている頂点の集合を管理しながら、クエリごとにシミュレートを行います。&lt;br /&gt;
「他のどの頂点とも辺で結ばれていない頂点」の数を&lt;code&gt;answer&lt;/code&gt;とします。
初期状態として、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;N&lt;/code&gt;になります。&lt;/p&gt;
&lt;p&gt;1番のクエリについて、頂点&lt;code&gt;u&lt;/code&gt;がその時点でほかのどの頂点とも辺で結ばれていない場合、頂点&lt;code&gt;v&lt;/code&gt;と辺で結ばれるため、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;-1&lt;/code&gt;されます。
同様に、頂点&lt;code&gt;v&lt;/code&gt;の場合も、その時点でほかのどの頂点とも辺で結ばれていない場合、頂点&lt;code&gt;u&lt;/code&gt;と辺で結ばれるため、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;-1&lt;/code&gt;されます。&lt;/p&gt;
&lt;p&gt;2番のクエリについて、頂点&lt;code&gt;v&lt;/code&gt;がその時点でいずれかの頂点と辺で結ばれている場合、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;+1&lt;/code&gt;されます。
また、頂点&lt;code&gt;v&lt;/code&gt;と辺で結ばれている各頂点について、その頂点の辺で結ばれている頂点集合から頂点&lt;code&gt;v&lt;/code&gt;を削除した後、その頂点の辺で結ばれている頂点が存在しない場合、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;+1&lt;/code&gt;されます。
その後、頂点&lt;code&gt;v&lt;/code&gt;の辺で結ばれている頂点の集合をすべて削除します。&lt;/p&gt;
&lt;p&gt;辺で結ばれている頂点の集合を&lt;code&gt;HashSet&lt;/code&gt;などのデータ構造を用いることで、追加と削除を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で行うことができ、全体時間計算量&lt;code&gt;O(Q)&lt;/code&gt;でシミュレートすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var connected = new HashSet&amp;lt;int&amp;gt;[N].Select(_ =&amp;gt; new HashSet&amp;lt;int&amp;gt;()).ToArray();
    var answer = N;

    for (var i = 0; i &amp;lt; Q; i++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var queryType = query[0];
        var queryArgs = query.AsSpan(1);

        void QF1(ReadOnlySpan&amp;lt;int&amp;gt; queryArgs)
        {
            var (u, v) = (queryArgs[0] - 1, queryArgs[1] - 1);
            if (connected[u].Count == 0) answer--;
            if (connected[v].Count == 0) answer--;
            connected[u].Add(v);
            connected[v].Add(u);
            Console.WriteLine(answer);
        }

        void QF2(ReadOnlySpan&amp;lt;int&amp;gt; queryArgs)
        {
            var u = queryArgs[0] - 1;
            if (connected[u].Count != 0) answer++;
            foreach (var v in connected[u])
            {
                connected[v].Remove(u);
                if (connected[v].Count == 0) answer++;
            }
            connected[u].Clear();

            Console.WriteLine(answer);
        }

        switch (queryType)
        {
            case 1:
                QF1(queryArgs);
                break;
            case 2:
                QF2(queryArgs);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41573888"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;各集合を頂点とした幅優先探索を行います。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;整数&lt;code&gt;x&lt;/code&gt;が属する集合群を&lt;code&gt;Has[x]&lt;/code&gt;としたとき、始点は&lt;code&gt;Has[1]&lt;/code&gt;に属する集合群になります。&lt;/del&gt;
&lt;del&gt;また、&lt;code&gt;Has[1]&lt;/code&gt;に属する集合を&lt;code&gt;u&lt;/code&gt;としたとき、&lt;code&gt;S[u]&lt;/code&gt;の整数集合の最小操作回数は&lt;code&gt;0&lt;/code&gt;になります。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;幅優先探索において、遷移元の集合を&lt;code&gt;u&lt;/code&gt;としたとき、&lt;code&gt;u&lt;/code&gt;から遷移することができる集合群は、整数&lt;code&gt;S[u][i] (1&amp;lt;=i&amp;lt;=A[u])&lt;/code&gt;を含む集合、つまり&lt;code&gt;Has[S[u][i]]&lt;/code&gt;の集合群になります。&lt;/del&gt;
&lt;del&gt;整数&lt;code&gt;S[u][i]&lt;/code&gt;を&lt;code&gt;s1&lt;/code&gt;、&lt;code&gt;s1&lt;/code&gt;を含む集合を&lt;code&gt;v&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;に含まれる整数&lt;code&gt;S[u][j] (1&amp;lt;=j&amp;lt;=A[v])&lt;/code&gt;を&lt;code&gt;s2&lt;/code&gt;、整数&lt;code&gt;x&lt;/code&gt;への最小操作回数を&lt;code&gt;costs[x]&lt;/code&gt;としたとき、&lt;code&gt;s2&lt;/code&gt;への遷移回数は&lt;code&gt;Min(costs[s2],costs[s1]+1)&lt;/code&gt;になります。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;よって、時間計算量&lt;code&gt;O(N+M+Sum(A))&lt;/code&gt;で答えを求めることができます。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023/05/22更新&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;を集合の番号、頂点&lt;code&gt;N+1&lt;/code&gt;から&lt;code&gt;N+M&lt;/code&gt;を&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;M&lt;/code&gt;の整数に対応させ、集合から整数、整数から集合に対してそれぞれコスト1の辺を張ったグラフを作成し、幅優先探索を行います。&lt;/p&gt;
&lt;p&gt;集合から整数、整数から集合に対しての移動で2回の移動をしているため、答えが2倍になることに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new int[N][];
    var G = new List&amp;lt;int&amp;gt;[N + M + 1].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        _ = Scanner.Scan&amp;lt;int&amp;gt;();
        S[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        foreach (var s in S[i])
        {
            G[i + 1].Add(N + s);
            G[N + s].Add(i + 1);
        }
    }

    var queue = new Queue&amp;lt;int&amp;gt;();
    var costs = new int[N + M + 1];
    Array.Fill(costs, -1);
    costs[N + 1] = 0;
    queue.Enqueue(N + 1);

    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        foreach (var v in G[u])
        {
            if (costs[v] != -1) continue;
            costs[v] = costs[u] + 1;
            queue.Enqueue(v);
        }
    }

    var answer = costs[N + M];
    if (answer != -1) answer = (answer - 1) / 2;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 302の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230513abc301</id>
		<title>ABC301</title>
		<link href="https://blog.aconcavy.dev/posts/20230513abc301" />
		<updated>2023-05-13T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 301の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301"&gt;https://atcoder.jp/contests/abc301&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41344570"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;勝った試合の数が多い方が総合勝者ということは、総合勝者は半分以上の試合で勝っていることになります。
また、勝ち数が同じ場合は先にその勝ち数に達したものが総合勝者となるので、順に勝ち数を数え上げ、先に過半数を取得した方が総合勝者になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var t = 0;
    var a = 0;
    foreach (var c in S)
    {
        if (c == 'T') t++;
        else a++;
        if (t * 2 &amp;gt;= N)
        {
            Console.WriteLine(&amp;quot;T&amp;quot;);
            return;
        }
        else if (a * 2 &amp;gt;= N)
        {
            Console.WriteLine(&amp;quot;A&amp;quot;);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41350380"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数列の1項目は&lt;code&gt;A&lt;/code&gt;の1項目になります。&lt;br /&gt;
&lt;code&gt;A&lt;/code&gt;の2項目以降を考えます。
数列に最後に追加した値を&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;A&lt;/code&gt;の次の項を&lt;code&gt;a&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&amp;lt;a&lt;/code&gt;の間は、次に&lt;code&gt;x+1&lt;/code&gt;を追加する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&amp;gt;a&lt;/code&gt;の間は、次に&lt;code&gt;x-1&lt;/code&gt;を追加する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x==a&lt;/code&gt;の場合は、&lt;code&gt;a&lt;/code&gt;を&lt;code&gt;A&lt;/code&gt;の次の項に更新する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という操作を繰り返すことで、答えとなる数列を生成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    IEnumerable&amp;lt;int&amp;gt; F()
    {
        var x = A[0];
        yield return x;
        foreach (var a in A.Skip(1))
        {
            while (x &amp;lt; a) yield return ++x;
            while (x &amp;gt; a) yield return --x;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, F()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41358374"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二つの文字列を構成する文字の個数が全て一致する必要があります。
&lt;code&gt;atcoder&lt;/code&gt;の各文字の個数が一致しない場合、少ない方の個数をその文字列にある&lt;code&gt;&amp;#64;&lt;/code&gt;の個数以内で補うことができます。
補う操作を行ったうえで&lt;code&gt;atcoder&lt;/code&gt;の文字の個数が一致し、ほかの文字の個数もすべて一致した場合のみ答えは&lt;code&gt;Yes&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;

    int[] F(string str)
    {
        var used = new int[27];
        foreach (var c in str)
        {
            if (c == '&amp;#64;') used[26]++;
            else used[c - 'a']++;
        }

        return used;
    }

    var usedS = F(S);
    var usedT = F(T);
    var answer = true;

    bool G(int i)
    {
        foreach (var c in &amp;quot;atcoder&amp;quot;)
        {
            if (c - 'a' == i) return true;
        }

        return false;
    }

    for (var i = 0; i &amp;lt; 26; i++)
    {
        var s = usedS[i];
        var t = usedT[i];
        if (s == t) continue;
        if (G(i))
        {
            if (s &amp;gt; t)
            {
                var d = s - t;
                answer &amp;amp;= usedT[26] &amp;gt;= d;
                usedT[26] -= d;
            }
            else
            {
                var d = t - s;
                answer &amp;amp;= usedS[26] &amp;gt;= d;
                usedS[26] -= d;
            }
        }
        else
        {
            answer = false;
            break;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41372439"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt;の部分を全て&lt;code&gt;0&lt;/code&gt;にした値が&lt;code&gt;N&lt;/code&gt;より大きい場合、答えは&lt;code&gt;-1&lt;/code&gt;となります。
それ以外の場合、桁の大きいところから順にみていき、その&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;1&lt;/code&gt;にした値が&lt;code&gt;N&lt;/code&gt;以下であるかを判定していくことで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    var N = Scanner.Scan&amp;lt;long&amp;gt;();

    long answer = 0;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        if (S[i] != '?') answer |= (long)(S[i] - '0') &amp;lt;&amp;lt; (S.Length - 1 - i);
    }

    if (answer &amp;gt; N)
    {
        Console.WriteLine(-1);
        return;
    }

    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        if (S[i] != '?') continue;
        var v = answer | (1L &amp;lt;&amp;lt; (S.Length - 1 - i));
        if (v &amp;lt;= N) answer = v;
    }

    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41395116"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スタートマスからゴールマスの最小移動回数が&lt;code&gt;T&lt;/code&gt;より大きいとき、答えは&lt;code&gt;-1&lt;/code&gt;になります。
それ以外のとき、次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s][u] := 訪れたお菓子のマスの集合がs、現在値がお菓子のマスがuのときの最小移動回数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;初期値:
dp[1&amp;lt;&amp;lt;u][u] = スタートマスからお菓子のマスuへの最小移動回数

遷移:
訪れたお菓子のマスの集合がs、お菓子のマスuからお菓子のマスvにD(u,v)の移動回数がかかるとき、
dp[s|(1&amp;lt;&amp;lt;v)][v] = Min(dp[s|(1&amp;lt;&amp;lt;v)][v], dp[s][u]+D(u,v))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、各状態からゴールマスへの移動回数を足したものが&lt;code&gt;T&lt;/code&gt;回以下であるときの訪れたお菓子のマスの個数の最大値が答えとなります。&lt;br /&gt;
お菓子のマスの個数を&lt;code&gt;M&lt;/code&gt;とすると、各お菓子のマスを始点とした幅優先探索を行うことで、&lt;code&gt;D(u,v)&lt;/code&gt;は時間計算量&lt;code&gt;O(MHW)&lt;/code&gt;で求めることができます。
よって、時間計算量&lt;code&gt;O(MHW+(2^M)*M^2)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, T) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = new char[H][];
    var G = new bool[H][];
    var (sh, sw) = (0, 0);
    var (gh, gw) = (0, 0);
    var map = new Dictionary&amp;lt;(int, int), int&amp;gt;();
    var M = 0;
    var snacks = new List&amp;lt;(int H, int W)&amp;gt;();

    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        G[i] = new bool[W];
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (A[i][j] == 'S') (sh, sw) = (i, j);
            if (A[i][j] == 'G') (gh, gw) = (i, j);
            if (A[i][j] == 'o')
            {
                map[(i, j)] = M++;
                snacks.Add((i, j));
            }

            G[i][j] = A[i][j] != '#';
        }
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };
    const int Inf = (int)1e9;

    int[][] GetDistance(int h, int w)
    {
        var result = new int[H][];
        for (var i = 0; i &amp;lt; H; i++)
        {
            result[i] = new int[W];
            for (var j = 0; j &amp;lt; W; j++)
            {
                result[i][j] = Inf;
            }
        }

        result[h][w] = 0;
        var queue = new Queue&amp;lt;(int, int)&amp;gt;();
        queue.Enqueue((h, w));
        while (queue.Count &amp;gt; 0)
        {
            var (ch, cw) = queue.Dequeue();
            foreach (var (dh, dw) in D4)
            {
                var (nh, nw) = (ch + dh, cw + dw);
                if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
                if (!G[nh][nw] || result[nh][nw] != Inf) continue;
                result[nh][nw] = result[ch][cw] + 1;
                queue.Enqueue((nh, nw));
            }
        }

        return result;
    }

    var startToGoal = GetDistance(sh, sw)[gh][gw];
    if (startToGoal &amp;gt; T)
    {
        Console.WriteLine(-1);
        return;
    }

    var snackDistances = new int[M][][];
    for (var k = 0; k &amp;lt; M; k++)
    {
        var (h, w) = snacks[k];
        snackDistances[k] = GetDistance(h, w);
    }

    var dp = new int[1 &amp;lt;&amp;lt; M, M];
    for (var i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; M; i++)
    {
        for (var j = 0; j &amp;lt; M; j++)
        {
            dp[i, j] = Inf;
        }
    }

    for (var u = 0; u &amp;lt; M; u++)
    {
        dp[1 &amp;lt;&amp;lt; u, u] = snackDistances[u][sh][sw];
    }

    for (var cs = 0; cs &amp;lt; 1 &amp;lt;&amp;lt; M; cs++)
    {
        for (var u = 0; u &amp;lt; M; u++)
        {
            if ((cs &amp;gt;&amp;gt; u &amp;amp; 1) == 0) continue;
            for (var v = 0; v &amp;lt; M; v++)
            {
                if ((cs &amp;gt;&amp;gt; v &amp;amp; 1) == 1) continue;
                var (nh, nw) = snacks[v];
                var nd = dp[cs, u] + snackDistances[u][nh][nw];
                var ns = cs | (1 &amp;lt;&amp;lt; v);
                dp[ns, v] = Math.Min(dp[ns, v], nd);
            }
        }
    }

    var answer = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; M; s++)
    {
        for (var u = 0; u &amp;lt; M; u++)
        {
            var gd = dp[s, u] + snackDistances[u][gh][gw];
            if (gd &amp;lt;= T)
            {
                var count = 0;
                for (var i = 0; i &amp;lt; M; i++)
                {
                    count += (s &amp;gt;&amp;gt; i) &amp;amp; 1;
                }

                answer = Math.Max(answer, count);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 301の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230429abc300</id>
		<title>ABC300</title>
		<link href="https://blog.aconcavy.dev/posts/20230429abc300" />
		<updated>2023-04-29T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 300の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc300"&gt;https://atcoder.jp/contests/abc300&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc300/tasks/abc300_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC300/submissions/41022598"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A+B&lt;/code&gt;の値を&lt;code&gt;V&lt;/code&gt;としたとき、&lt;code&gt;C&lt;/code&gt;のうち&lt;code&gt;V&lt;/code&gt;の位置を出力します。
&lt;code&gt;for&lt;/code&gt;文で位置を探索する方法のほかに、&lt;code&gt;Array.IndexOf&lt;/code&gt;メソッドを使うことで、指定した値の配列内の位置を取得することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var V = A + B;
    var answer = Array.IndexOf(C, V) + 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc300/tasks/abc300_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC300/submissions/41026844"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;に対して縦方向のシフトを&lt;code&gt;s&lt;/code&gt;回すると、&lt;code&gt;A[i][j]&lt;/code&gt;の値は&lt;code&gt;A[(i+s)%H][j]&lt;/code&gt;に置き換わります。&lt;br /&gt;
同様に、横方向のシフトを&lt;code&gt;t&lt;/code&gt;回すると、&lt;code&gt;A[i][j]&lt;/code&gt;の値は&lt;code&gt;A[i][(j+t)%W]&lt;/code&gt;に置き換わります。&lt;br /&gt;
このことから、&lt;code&gt;(s,t)&lt;/code&gt;を&lt;code&gt;0&amp;lt;=s&amp;lt;H,0&amp;lt;=t&amp;lt;W&lt;/code&gt;の間で全探索して、各要素を判定することで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new char[H][].Select(_ =&amp;gt; Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray()).ToArray();
    var B = new char[H][].Select(_ =&amp;gt; Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray()).ToArray();
    for (var s = 0; s &amp;lt; H; s++)
    {
        for (var t = 0; t &amp;lt; W; t++)
        {
            var ok = true;
            for (var i = 0; i &amp;lt; H &amp;amp;&amp;amp; ok; i++)
            {
                for (var j = 0; j &amp;lt; W &amp;amp;&amp;amp; ok; j++)
                {
                    ok &amp;amp;= A[(i + s) % H][(j + t) % W] == B[i][j];
                }
            }

            if (ok)
            {
                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc300/tasks/abc300_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC300/submissions/41031263"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;サイズ&lt;code&gt;s&lt;/code&gt;のバツ印が成り立つとき、サイズ&lt;code&gt;s-1&lt;/code&gt;のバツ印も成り立つ必要があります。
また、サイズ&lt;code&gt;s-1&lt;/code&gt;のバツ印が成り立つとき、&lt;code&gt;C[a-s][b-s]&lt;/code&gt;、&lt;code&gt;C[a-s][b+s]&lt;/code&gt;、&lt;code&gt;C[a+s][b-s]&lt;/code&gt;、&lt;code&gt;C[a+s][b+s]&lt;/code&gt;がグリッド内に存在し、いずれも&lt;code&gt;#&lt;/code&gt;であると、サイズ&lt;code&gt;s&lt;/code&gt;のバツ印が成り立つことになります。
このことから、中心となる&lt;code&gt;(a,b)&lt;/code&gt;を全探索し、その位置から成り立つ最大サイズを走査することで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var N = Math.Min(H, W);
    var C = new char[H][].Select(_ =&amp;gt; Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray()).ToArray();
    var answer = new int[N + 1];

    int Dfs(int a, int b, int s)
    {
        var ok = true;
        ok &amp;amp;= a - s &amp;gt;= 0 &amp;amp;&amp;amp; b - s &amp;gt;= 0 &amp;amp;&amp;amp; C[a - s][b - s] == '#';
        ok &amp;amp;= a - s &amp;gt;= 0 &amp;amp;&amp;amp; b + s &amp;lt; W &amp;amp;&amp;amp; C[a - s][b + s] == '#';
        ok &amp;amp;= a + s &amp;lt; H &amp;amp;&amp;amp; b - s &amp;gt;= 0 &amp;amp;&amp;amp; C[a + s][b - s] == '#';
        ok &amp;amp;= a + s &amp;lt; H &amp;amp;&amp;amp; b + s &amp;lt; W &amp;amp;&amp;amp; C[a + s][b + s] == '#';
        var result = s;
        if (ok)
        {
            result = Math.Max(result, Dfs(a, b, s + 1));
        }

        return ok ? result : 0;
    }

    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            answer[Dfs(i, j, 0)]++;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Skip(1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc300/tasks/abc300_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC300/submissions/41044943"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC300/submissions/41055466"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c^2&amp;lt;=1e12&lt;/code&gt;より、&lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;はそれぞれ&lt;code&gt;1e6&lt;/code&gt;未満の素数になります。
&lt;code&gt;i&amp;lt;k&amp;lt;j&lt;/code&gt;番目の素数をそれぞれ&lt;code&gt;a=P[i]&lt;/code&gt;、&lt;code&gt;P[k]&lt;/code&gt;、&lt;code&gt;c=P[j]&lt;/code&gt;としたとき、&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;を固定すると、&lt;code&gt;Floor(N/(a^2*c^2))&lt;/code&gt;以下の&lt;code&gt;P[k]&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;になりえます。&lt;br /&gt;
このとき、全ての&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;を探索してしまうと、時間計算量が&lt;code&gt;O(|P|^2)&lt;/code&gt;になってしまいますが、&lt;code&gt;a^2&amp;gt;=N&lt;/code&gt;、&lt;code&gt;c^2&amp;gt;=N&lt;/code&gt;、&lt;code&gt;a^2*c^2&amp;gt;=N&lt;/code&gt;のときを枝刈りすることで、高速で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var P = Prime.Sieve((int)1e6).Select(x =&amp;gt; (long)x).ToArray();
    var answer = 0;
    for (var i = 0; i + 2 &amp;lt; P.Length; i++)
    {
        var a = P[i];
        var aa = a * a;
        if (aa &amp;gt;= N) break;
        for (var j = i + 2; j &amp;lt; P.Length; j++)
        {
            var c = P[j];
            var cc = c * c;
            if (cc &amp;gt;= N || aa * cc &amp;gt;= N) break;
            var v = N / (aa * cc);
            for (var k = i + 1; k &amp;lt; j &amp;amp;&amp;amp; P[k] &amp;lt;= v; k++)
            {
                answer++;
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc300/tasks/abc300_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC300/submissions/41049838"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;を素因数分解したとき、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;5&lt;/code&gt;以外の素数が含まれているとき、どうやっても&lt;code&gt;N&lt;/code&gt;にすることができないので、答えは&lt;code&gt;0&lt;/code&gt;になります。
それ以外のとき、次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][a][b][c] := 素因数をi回使ったとき、2をa回、3をb回、5をc回使っているときの確率
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;出目が1のとき、素因数の組み合わせに変動を起こさないので無視する。
出目が2のとき、dp[i+1][a+1][b][c]   += dp[i][a][b][c] / 5
出目が3のとき、dp[i+1][a][b+1][c]   += dp[i][a][b][c] / 5
出目が4のとき、dp[i+2][a+2][b][c]   += dp[i][a][b][c] / 5
出目が5のとき、dp[i+1][a][b][c+1]   += dp[i][a][b][c] / 5
出目が6のとき、dp[i+2][a+1][b+1][c] += dp[i][a][b][c] / 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;N==2^a+3^b+5^c&lt;/code&gt;となるときの&lt;code&gt;M=a+b+c&lt;/code&gt;としたとき、&lt;code&gt;dp[M][a][b][c]&lt;/code&gt;の値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var C = new Dictionary&amp;lt;int, long&amp;gt;();
    var n = N;
    foreach (var v in new[] { 2, 3, 5 })
    {
        C[v] = 0;
        while (n % v == 0)
        {
            C[v]++;
            n /= v;
        }
    }

    if (n != 1)
    {
        Console.WriteLine(0);
        return;
    }

    var i5 = mint.Inverse(5);

    var (c2, c3, c5) = (C[2], C[3], C[5]);
    var M = c2 + c3 + c5;
    var dp = new mint[M + 1, c2 + 1, c3 + 1, c5 + 1];
    dp[0, 0, 0, 0] = 1;
    for (var i = 0; i &amp;lt; M; i++)
    {
        for (var p2 = 0; p2 &amp;lt;= c2; p2++)
        {
            for (var p3 = 0; p3 &amp;lt;= c3; p3++)
            {
                for (var p5 = 0; p5 &amp;lt;= c5; p5++)
                {
                    if (p2 + 1 &amp;lt;= c2) dp[i + 1, p2 + 1, p3, p5] += dp[i, p2, p3, p5] * i5;
                    if (p3 + 1 &amp;lt;= c3) dp[i + 1, p2, p3 + 1, p5] += dp[i, p2, p3, p5] * i5;
                    if (i + 2 &amp;lt;= M &amp;amp;&amp;amp; p2 + 2 &amp;lt;= c2) dp[i + 2, p2 + 2, p3, p5] += dp[i, p2, p3, p5] * i5;
                    if (p5 + 1 &amp;lt;= c5) dp[i + 1, p2, p3, p5 + 1] += dp[i, p2, p3, p5] * i5;
                    if (i + 2 &amp;lt;= M &amp;amp;&amp;amp; p2 + 1 &amp;lt;= c2 &amp;amp;&amp;amp; p3 + 1 &amp;lt;= c3) dp[i + 2, p2 + 1, p3 + 1, p5] += dp[i, p2, p3, p5] * i5;
                }
            }
        }
    }

    var answer = dp[M, c2, c3, c5];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 300の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230422abc299</id>
		<title>ABC299</title>
		<link href="https://blog.aconcavy.dev/posts/20230422abc299" />
		<updated>2023-04-22T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 299の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc299"&gt;https://atcoder.jp/contests/abc299&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc299/tasks/abc299_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC299/submissions/40833712"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;左側の&lt;code&gt;|&lt;/code&gt;と右側の&lt;code&gt;|&lt;/code&gt;のインデックスを検索した後、その間に&lt;code&gt;*&lt;/code&gt;が存在するかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var l = 0;
    var r = N - 1;
    while (l &amp;lt; N &amp;amp;&amp;amp; S[l] != '|') l++;
    while (r &amp;gt;= 0 &amp;amp;&amp;amp; S[r] != '|') r--;
    for (var i = l; i &amp;lt;= r; i++)
    {
        if (S[i] == '*')
        {
            Console.WriteLine(&amp;quot;in&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;out&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc299/tasks/abc299_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC299/submissions/40833830"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書などのデータ構造を使い、&lt;code&gt;C&lt;/code&gt;をキーとした最大の&lt;code&gt;R&lt;/code&gt;とそのプレイヤー&lt;code&gt;i&lt;/code&gt;を管理します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var R = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;int, (int R, int I)&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = C[i];
        var r = R[i];
        if (!dict.ContainsKey(c)) dict[c] = (r, i);
        else if (r &amp;gt; dict[c].R) dict[c] = (r, i);
    }

    var t = dict.ContainsKey(T) ? T : C[0];
    var answer = dict[t].I + 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc299/tasks/abc299_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC299/submissions/40844162"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;尺取り法で文字列を順にみていき、連続した&lt;code&gt;o&lt;/code&gt;の後に&lt;code&gt;-&lt;/code&gt;が続くダンゴ文字列のレベルの最大値を更新します。&lt;br /&gt;
文字列を反転させたものを再び判定することで、&lt;code&gt;-&lt;/code&gt;の後に&lt;code&gt;o&lt;/code&gt;が連続するダンゴ文字列のレベルを判定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();

    int F(char[] s)
    {
        var l = 0;
        var result = -1;
        while (l &amp;lt; s.Length)
        {
            if (s[l] == '-')
            {
                l++;
                continue;
            }

            var r = l;
            while (r &amp;lt; s.Length &amp;amp;&amp;amp; s[r] == 'o') r++;
            if (r &amp;lt; s.Length &amp;amp;&amp;amp; s[r] == '-')
            {
                result = Math.Max(result, r - l);
            }

            l = r;
        }

        return result;
    }

    var answer = F(S);
    Array.Reverse(S);
    answer = Math.Max(answer, F(S));
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc299/tasks/abc299_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC299/submissions/40840107"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連続した&lt;code&gt;0&lt;/code&gt;と連続した&lt;code&gt;1&lt;/code&gt;が繋がった文字列のうち、&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;の境目の番号を求める問題です。
&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;の境目を二部探索することで&lt;code&gt;Ceil(logN)&lt;/code&gt;回(最大でも18回)の質問で、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();

    bool F(int x)
    {
        Console.WriteLine($&amp;quot;?{x + 1}&amp;quot;);
        var v = Scanner.Scan&amp;lt;int&amp;gt;();
        return v == 1;
    }

    var answer = BinarySearch(0, N, F);
    Console.WriteLine($&amp;quot;!{answer}&amp;quot;);
}

public static int BinarySearch(int ng, int ok, Func&amp;lt;int, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc299/tasks/abc299_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC299/submissions/40870875"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC299/submissions/40882103"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;のとき、黒を1つ以上含むグラフであれば条件を満たします。&lt;br /&gt;
それ以外のときを考えます。&lt;br /&gt;
「黒で塗られた頂点のうち頂点&lt;code&gt;p[i]&lt;/code&gt;からの距離が最小であるもの」の距離がちょうど&lt;code&gt;d&lt;/code&gt;となるものであることから、頂点&lt;code&gt;p[i]&lt;/code&gt;から距離&lt;code&gt;d&lt;/code&gt;未満の頂点に黒で塗られた頂点が存在してはいけません。&lt;br /&gt;
そのため、はじめに全ての頂点を黒で塗り、各&lt;code&gt;p[i]&lt;/code&gt;から&lt;code&gt;1&amp;lt;=u&amp;lt;=N&lt;/code&gt;の頂点について、距離が&lt;code&gt;d&lt;/code&gt;未満の頂点を白で塗ったものが、条件を満たす可能性のある塗る方法になります。&lt;br /&gt;
このうち、1つ以上の頂点が黒で塗られているかつ、全ての&lt;code&gt;p[i]&lt;/code&gt;において、黒で塗られている頂点との距離が&lt;code&gt;d&lt;/code&gt;のものが1つ以上存在する場合、その頂点の塗り方が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();

    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    if (K == 0)
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        Console.WriteLine(new string('1', N));
        return;
    }

    var D = new int[N][];
    var queue = new Queue&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var dist = new int[N];
        Array.Fill(dist, -1);
        queue.Enqueue(i);
        dist[i] = 0;
        while (queue.Count &amp;gt; 0)
        {
            var u = queue.Dequeue();
            foreach (var v in G[u])
            {
                if (dist[v] != -1) continue;
                dist[v] = dist[u] + 1;
                queue.Enqueue(v);
            }
        }

        D[i] = dist;
    }

    var minD = new int[N];
    const int Inf = (int)1e9;
    Array.Fill(minD, Inf);
    var PD = new (int P, int D)[K];
    for (var i = 0; i &amp;lt; K; i++)
    {
        var (p, d) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        p--;
        PD[i] = (p, d);
    }

    var C = new int[N];
    Array.Fill(C, 1);
    foreach (var (p, d) in PD)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (D[p][j] &amp;lt; d) C[j] = 0;
        }
    }

    foreach (var (p, d) in PD)
    {
        var ok = false;
        for (var v = 0; v &amp;lt; N; v++)
        {
            ok |= C[v] == 1 &amp;amp;&amp;amp; D[p][v] == d;
        }

        if (!ok)
        {
            Console.WriteLine(&amp;quot;No&amp;quot;);
            return;
        }
    }

    if (!C.Contains(1))
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
        return;
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
    Console.WriteLine(string.Join(&amp;quot;&amp;quot;, C));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 299の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230415abc298</id>
		<title>ABC298</title>
		<link href="https://blog.aconcavy.dev/posts/20230415abc298" />
		<updated>2023-04-15T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 298の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc298"&gt;https://atcoder.jp/contests/abc298&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc298/tasks/abc298_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC298/submissions/40634135"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;に&lt;code&gt;o&lt;/code&gt;が含まれているかつ、&lt;code&gt;S&lt;/code&gt;に&lt;code&gt;x&lt;/code&gt;が含まれていないという条件を満たすかを判定します。
文字列内にある文字が含まれているかは&lt;code&gt;string.Contains&lt;/code&gt;で調べることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.Contains('o') &amp;amp;&amp;amp; !S.Contains('x');
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc298/tasks/abc298_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC298/submissions/40640081"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行列&lt;code&gt;A&lt;/code&gt;を4回回転させると元に戻ることから、調べる必要がある行列&lt;code&gt;A&lt;/code&gt;の状態は4つであることがわかります。
そのため、&lt;code&gt;A&lt;/code&gt;を回転させながら、&lt;code&gt;A[i][j]==1&lt;/code&gt;のとき&lt;code&gt;B[i][j]==1&lt;/code&gt;であることを4回判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N][].Select(_ =&amp;gt; Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray()).ToArray();
    var B = new int[N][].Select(_ =&amp;gt; Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray()).ToArray();

    bool F(int[][] C)
    {
        var result = true;
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                if (C[i][j] == 1)
                {
                    result &amp;amp;= B[i][j] == 1;
                }
            }
        }

        return result;
    }

    int[][] Rotate(int[][] C)
    {
        var result = new int[N][];
        for (var i = 0; i &amp;lt; N; i++)
        {
            result[i] = new int[N];
            for (var j = 0; j &amp;lt; N; j++)
            {
                result[i][j] = C[j][N - 1 - i];
            }
        }

        return result;
    }

    var answer = false;
    for (var k = 0; k &amp;lt; 4; k++)
    {
        answer |= F(A);
        A = Rotate(A);
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc298/tasks/abc298_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC298/submissions/40643775"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC298/submissions/40678970"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書などのデータ構造と順序集合を使って、&lt;code&gt;C[i]&lt;/code&gt;には&lt;code&gt;i&lt;/code&gt;が書かれたカードが入っている箱の番号を&lt;em&gt;&lt;strong&gt;重複を許さず&lt;/strong&gt;&lt;/em&gt;昇順にならべた集合を管理し、&lt;code&gt;B[j]&lt;/code&gt;には箱&lt;code&gt;j&lt;/code&gt;に入っているカードに書かれた数を&lt;em&gt;&lt;strong&gt;重複を許して&lt;/strong&gt;&lt;/em&gt;昇順にならべた集合を管理することで、次のような操作で答えを求めることができます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1番目の形式のクエリについて、&lt;code&gt;B[j]&lt;/code&gt;に&lt;code&gt;i&lt;/code&gt;を追加し、&lt;code&gt;C[i]&lt;/code&gt;に&lt;code&gt;j&lt;/code&gt;を追加する。&lt;/li&gt;
&lt;li&gt;2番目の形式のクエリについて、&lt;code&gt;B[i]&lt;/code&gt;を表示する。&lt;/li&gt;
&lt;li&gt;3番目の形式のクエリについて、&lt;code&gt;C[i]&lt;/code&gt;を表示する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C#では、&lt;code&gt;SortedSet&lt;/code&gt;を使うことで順序集合を得ることができますが、重複する要素を管理することはできないので、&lt;code&gt;j&lt;/code&gt;番目の箱に&lt;code&gt;i&lt;/code&gt;が書かれたカードが何枚あるかを別に管理し、2番目のクエリの形式でその枚数繰り返したものを出力する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var B = new Dictionary&amp;lt;int, SortedSet&amp;lt;int&amp;gt;&amp;gt;();
    var C = new Dictionary&amp;lt;int, SortedSet&amp;lt;int&amp;gt;&amp;gt;();
    var Bc = new Dictionary&amp;lt;int, Dictionary&amp;lt;int, int&amp;gt;&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var (i, j) = (query[1], query[2]);
            if (!B.ContainsKey(j)) B[j] = new SortedSet&amp;lt;int&amp;gt;();
            if (!C.ContainsKey(i)) C[i] = new SortedSet&amp;lt;int&amp;gt;();
            if (!Bc.ContainsKey(j)) Bc[j] = new Dictionary&amp;lt;int, int&amp;gt;();
            if (!Bc[j].ContainsKey(i)) Bc[j][i] = 0;
            B[j].Add(i);
            Bc[j][i]++;
            C[i].Add(j);
        }
        else if (query[0] == 2)
        {
            var i = query[1];
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B[i].SelectMany(x =&amp;gt; Enumerable.Repeat(x, Bc[i][x]))));
        }
        else
        {
            var i = query[1];
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, C[i]));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc298/tasks/abc298_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC298/submissions/40647216"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;の管理に整数型を使ってしまうと、&lt;code&gt;Q&lt;/code&gt;が最大でも&lt;code&gt;6e5&lt;/code&gt;なので正確に値を管理することができません。
また、3番目の形式のクエリごとに文字列から愚直に値を求めようとすると、クエリごとに時間計算量が&lt;code&gt;O(|S|)&lt;/code&gt;になり、全体時間計算量が&lt;code&gt;O(Q^2)&lt;/code&gt;になってしまいます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;V&lt;/code&gt;を&lt;code&gt;S&lt;/code&gt;の十進数表記の数として&lt;code&gt;998244353&lt;/code&gt;で割った余りとしたときを考えます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1番目の形式のクエリのとき、&lt;code&gt;V=(V*10+x)%998244353&lt;/code&gt;になります。&lt;/li&gt;
&lt;li&gt;2番目の形式のクエリのとき、&lt;code&gt;S&lt;/code&gt;の先頭を&lt;code&gt;x&lt;/code&gt;とすると、&lt;code&gt;V=V-10^(|S-1|)*x&lt;/code&gt;になります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このことから、&lt;code&gt;V&lt;/code&gt;の値を保持しながら&lt;code&gt;Queue&lt;/code&gt;などのデータ構造を使って、その時点の&lt;code&gt;S&lt;/code&gt;の先頭と長さを管理することで、クエリあたりの計算量を高速化することができます。
2番目の形式のクエリのときに、&lt;code&gt;10^|S-1|&lt;/code&gt;を求めるには時間計算量が&lt;code&gt;O(log|S|)&lt;/code&gt;必要になりますが、あらかじめ&lt;code&gt;10&lt;/code&gt;のべき乗を時間計算量&lt;code&gt;O(N)&lt;/code&gt;で計算しておくことで、クエリのごとの時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。
以上のことから、全体時間計算量&lt;code&gt;O(N+Q)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();

    var P = new mint[Q + 10];
    P[0] = 1;
    for (var i = 0; i + 1 &amp;lt; P.Length; i++)
    {
        P[i + 1] = P[i] * 10;
    }

    mint curr = 1;
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(1);
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var x = query[1];
            curr *= 10;
            curr += x;
            queue.Enqueue(x);
        }
        else if (query[0] == 2)
        {
            var len = queue.Count - 1;
            var x = queue.Dequeue();
            curr -= P[len] * x;
        }
        else
        {
            Console.WriteLine(curr);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc298/tasks/abc298_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC298/submissions/40664557"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,j,k] := k(先手|後手)のとき高橋君の位置が地点i、青木君の位置が地点jにいる確率
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、次のような遷移になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;- 初期状態
dp[A,B,1] = 1 // 高橋君から始めるので、青木君が後手で高橋君がA、青木君がBについたところから開始する

dp[Min(i+p,N),j,0] += dp[i,j,1]/P; // 1&amp;lt;=p&amp;lt;=P
dp[i,Min(j+q,N),1] += dp[i,j,0]/Q; // 1&amp;lt;=q&amp;lt;=Q
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dp[N,j,0] (B&amp;lt;=j&amp;lt;N)&lt;/code&gt;の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B, P, Q) = Scanner.Scan&amp;lt;int, int, int, int, int&amp;gt;();

    var dp = new mint[N + 1, N + 1, 2];
    dp[A, B, 1] = 1;

    var iP = mint.Inverse(P);
    var iQ = mint.Inverse(Q);

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            for (var p = 1; p &amp;lt;= P; p++)
            {
                dp[Math.Min(i + p, N), j, 0] += dp[i, j, 1] * iP;
            }

            for (var q = 1; q &amp;lt;= Q; q++)
            {
                dp[i, Math.Min(j + q, N), 1] += dp[i, j, 0] * iQ;
            }
        }
    }

    mint answer = 0;
    for (var j = B; j &amp;lt; N; j++)
    {
        answer += dp[N, j, 0];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 298の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230409abc297</id>
		<title>ABC297</title>
		<link href="https://blog.aconcavy.dev/posts/20230409abc297" />
		<updated>2023-04-09T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 297の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc297"&gt;https://atcoder.jp/contests/abc297&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc297/tasks/abc297_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC297/submissions/40452075"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最初に&lt;code&gt;T[i]-T[i-1]&amp;lt;=D&lt;/code&gt;となる&lt;code&gt;T[i]&lt;/code&gt;を走査します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var T = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 1; i &amp;lt; N; i++)
    {
        var d = T[i] - T[i - 1];
        if (d &amp;lt;= D)
        {
            Console.WriteLine(T[i]);
            return;
        }
    }

    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc297/tasks/abc297_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC297/submissions/40457596"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1つ目の条件を&lt;code&gt;F1&lt;/code&gt;、2つ目の条件を&lt;code&gt;F2&lt;/code&gt;としたとき、&lt;code&gt;F1 &amp;amp;&amp;amp; F2&lt;/code&gt;を判定します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F1&lt;/code&gt;; &lt;code&gt;B&lt;/code&gt;が2文字あることが保証されているので、文字列の先頭から見て初めて出現する&lt;code&gt;B&lt;/code&gt;のインデックスを&lt;code&gt;x&lt;/code&gt;、文字列の末尾から見て初めて出現する&lt;code&gt;B&lt;/code&gt;のインデックスを&lt;code&gt;y&lt;/code&gt;としたとき、&lt;code&gt;x%2 != y%2&lt;/code&gt;を判定します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F2&lt;/code&gt;; &lt;code&gt;R&lt;/code&gt;が2文字あることが保証されているので、文字列の先頭から見て初めて出現する&lt;code&gt;R&lt;/code&gt;のインデックスを&lt;code&gt;x&lt;/code&gt;、文字列の末尾から見て初めて出現する&lt;code&gt;R&lt;/code&gt;のインデックスを&lt;code&gt;y&lt;/code&gt;としたとき、&lt;code&gt;x&amp;lt;z&amp;lt;y &amp;amp;&amp;amp; S[z]=='K'&lt;/code&gt;となるインデックス&lt;code&gt;z&lt;/code&gt;が存在するかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    bool F1(string s)
    {
        var x = 0;
        var y = s.Length - 1;
        while (x &amp;lt; s.Length &amp;amp;&amp;amp; s[x] != 'B') x++;
        while (y &amp;gt;= 0 &amp;amp;&amp;amp; s[y] != 'B') y--;
        return x % 2 != y % 2;
    }

    bool F2(string s)
    {
        var x = 0;
        var y = s.Length - 1;
        while (x &amp;lt; s.Length &amp;amp;&amp;amp; s[x] != 'R') x++;
        while (y &amp;gt;= 0 &amp;amp;&amp;amp; s[y] != 'R') y--;
        for (var i = x + 1; i &amp;lt; y; i++)
        {
            if (s[i] == 'K') return true;
        }

        return false;
    }

    var answer = F1(S) &amp;amp;&amp;amp; F2(S);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc297/tasks/abc297_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC297/submissions/40461587"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列中の全ての&lt;code&gt;TT&lt;/code&gt;を&lt;code&gt;PC&lt;/code&gt;に置き換えたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j + 1 &amp;lt; W; j++)
        {
            if ((S[i][j], S[i][j + 1]) == ('T', 'T'))
            {
                S[i][j] = 'P';
                S[i][j + 1] = 'C';
            }
        }
    }

    Printer.Print2D(S);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc297/tasks/abc297_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC297/submissions/40470609"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作を愚直に実装してしまうと、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の差がを大きいときに実行時間制限に間に合わなくなってしまうため、同じ操作が行われているものをまとめることを考えます。&lt;br /&gt;
&lt;code&gt;A&amp;lt;B&lt;/code&gt;のとき、1回の操作で&lt;code&gt;B&lt;/code&gt;の値は&lt;code&gt;A&lt;/code&gt;減少します。&lt;br /&gt;
この操作は&lt;code&gt;A&amp;lt;B&lt;/code&gt;の間繰り返されることから、&lt;code&gt;D=B-A&lt;/code&gt;としたとき&lt;code&gt;Ceil(D/A)&lt;/code&gt;回の操作が行われます。&lt;br /&gt;
&lt;code&gt;A&amp;gt;B&lt;/code&gt;のとき、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の値を入れ替えることで、&lt;code&gt;A&amp;lt;B&lt;/code&gt;としたときと同様の操作が行われます。&lt;br /&gt;
このことから、&lt;code&gt;A==B&lt;/code&gt;になるまでに行われる操作の合計が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();

    long F(long a, long b)
    {
        long result = 0;
        while (a != b)
        {
            if (a &amp;gt; b) (a, b) = (b, a);
            var d = b - a;
            var t = (d + a - 1) / a;
            result += t;
            b -= t * a;
        }

        return result;
    }

    var answer = F(A, B);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc297/tasks/abc297_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC297/submissions/40474365"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支払う金額としてあり得るものに&lt;code&gt;A[i] (1&amp;lt;=i&amp;lt;=N)&lt;/code&gt;を足したものも、支払う金額としてあり得るものになります。&lt;br /&gt;
そのため、支払う金額としてあり得るものを優先度付きキューを使って小さい順に取り出していき、&lt;code&gt;K&lt;/code&gt;回目に取り出したものが答えとなります。&lt;br /&gt;
支払う金額としてあり得るもののうち、同じ金額は1回だけ数えることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().Distinct().ToArray();
    var queue = new PriorityQueue&amp;lt;long&amp;gt;(A);
    var used = new HashSet&amp;lt;long&amp;gt;(A);
    while (K &amp;gt; 1)
    {
        K--;
        var x = queue.Dequeue();
        foreach (var a in A)
        {
            var y = x + a;
            if (used.Contains(y)) continue;
            queue.Enqueue(y);
            used.Add(y);
        }
    }

    var answer = queue.Dequeue();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 297の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230401abc296</id>
		<title>ABC296</title>
		<link href="https://blog.aconcavy.dev/posts/20230401abc296" />
		<updated>2023-04-01T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 296の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc296"&gt;https://atcoder.jp/contests/abc296&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc296/tasks/abc296_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC296/submissions/40210681"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&amp;lt;=i&amp;lt;N&lt;/code&gt;において、&lt;code&gt;S[i]&lt;/code&gt;と&lt;code&gt;S[i+1]&lt;/code&gt;がすべて異なっている場合、答えは&lt;code&gt;Yes&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    var answer = true;
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        answer &amp;amp;= S[i] != S[i + 1];
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc296/tasks/abc296_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC296/submissions/40214277"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[r][c]&lt;/code&gt;が&lt;code&gt;*&lt;/code&gt;のとなる&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;を求め、&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;を指定されたフォーマット文字列に変換します。&lt;br /&gt;
フォーマット文字列は、&lt;code&gt;{行}{列}&lt;/code&gt;ではなく、&lt;code&gt;{列+'a'}{8-行}&lt;/code&gt;であることに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int H = 8;
    const int W = 8;
    var S = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    string F(int r, int c) =&amp;gt; $&amp;quot;{(char)(c + 'a')}{8 - r}&amp;quot;

    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (S[i][j] == '*')
            {
                Console.WriteLine(F(i, j));
                return;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc296/tasks/abc296_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC296/submissions/40219829"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC296/submissions/40268336"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;をソートし、尺取り法で&lt;code&gt;A[r]-A[l]==X&lt;/code&gt;となる&lt;code&gt;l&lt;/code&gt;と&lt;code&gt;r&lt;/code&gt;を探索することで、時間計算量&lt;code&gt;O(NlogN+N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    var r = 0;
    for (var l = 0; l &amp;lt; N; l++)
    {
        while (r &amp;lt; N &amp;amp;&amp;amp; A[r] - A[l] &amp;lt; X) r++;
        if (r &amp;lt; N &amp;amp;&amp;amp; A[r] - A[l] == X)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;A[i]-A[j]==X&lt;/code&gt;を式変形すると&lt;code&gt;A[i]==A[j]+X&lt;/code&gt;であることから、&lt;code&gt;A&lt;/code&gt;からなる集合&lt;code&gt;S&lt;/code&gt;を用意し、&lt;code&gt;A[i]+X&lt;/code&gt;が&lt;code&gt;S&lt;/code&gt;に含まれているかどうかを判定することでも、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var set = new HashSet&amp;lt;long&amp;gt;(A);
    var answer = set.Any(a =&amp;gt; set.Contains(a + X));
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc296/tasks/abc296_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC296/submissions/40233550"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a&amp;lt;=b&lt;/code&gt;とし&lt;code&gt;a&lt;/code&gt;を固定して考えると、&lt;code&gt;M&amp;lt;=a*b&lt;/code&gt;より&lt;code&gt;b&amp;gt;=M/a&lt;/code&gt;、&lt;code&gt;Floor(M/a)&amp;lt;=M/a&amp;lt;=Ceil(M/a)&lt;/code&gt;より、&lt;code&gt;b=Ceil(M/a)&lt;/code&gt;とすることができ、&lt;code&gt;1&amp;lt;=b&amp;lt;=N&lt;/code&gt;であることから、&lt;code&gt;c=a*Min(b,N)&lt;/code&gt;になり、&lt;code&gt;c&amp;gt;=M&lt;/code&gt;のときの最小値が答えとなります。&lt;br /&gt;
時間計算量は&lt;code&gt;O(Min(N,Sqrt(M)))&lt;/code&gt;程度となり、最大でも&lt;code&gt;1e6&lt;/code&gt;回程度の計算で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    const long Inf = (long)1e18;

    long CalcB(long a) =&amp;gt; Math.Min(N, (M + a - 1) / a);

    var answer = Inf;
    for (long a = 1; a &amp;lt;= CalcB(a); a++)
    {
        var b = CalcB(a);
        var c = a * b;
        if (c &amp;gt;= M) answer = Math.Min(answer, c);
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc296/tasks/abc296_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC296/submissions/40261543"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&amp;lt;=i&amp;lt;=N&lt;/code&gt;を頂点としたグラフとし、&lt;code&gt;黒板にxが書かれているとき、それを消し、A[x]を新しく書く&lt;/code&gt;という操作を&lt;code&gt;x&lt;/code&gt;から&lt;code&gt;A[x]&lt;/code&gt;に対する有向辺とすると、
サイクルを構築する頂点の集合(強連結成分)に含まれる頂点には、正整数&lt;code&gt;K[i]&lt;/code&gt;がどのような値であっても、始点となる頂点を任意に決めることができるので、たどり着くことができます。&lt;br /&gt;
このことから、&lt;code&gt;i&lt;/code&gt;から&lt;code&gt;A[i]&lt;/code&gt;に対する有効辺を構築したグラフに対して強連結成分分解を行い、各強連結成分を構成する頂点の総和が答えとなります。&lt;br /&gt;
このとき、自己辺が存在する場合に注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var isSelf = new bool[N];

    var scc = new StronglyConnectedComponent(N);
    for (var i = 0; i &amp;lt; N; i++)
    {
        scc.AddEdge(i, A[i]);
        if (i == A[i]) isSelf[i] = true;
    }

    var answer = 0;
    foreach (var graph in scc.GetGraph())
    {
        if (graph.Count == 1 &amp;amp;&amp;amp; !isSelf[graph[0]]) continue;
        answer += graph.Count;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;強連結成分に関しては以下のクラスを使いました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class StronglyConnectedComponent
{
    public int Length { get; }
    private readonly List&amp;lt;(int, Edge)&amp;gt; _edges;

    public StronglyConnectedComponent(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _edges = new List&amp;lt;(int, Edge)&amp;gt;();
    }

    public void AddEdge(int from, int to)
    {
        if (from &amp;lt; 0 || Length &amp;lt;= from) throw new ArgumentOutOfRangeException(nameof(from));
        if (to &amp;lt; 0 || Length &amp;lt;= to) throw new ArgumentOutOfRangeException(nameof(to));
        _edges.Add((from, new Edge(to)));
    }

    public (int GroupCount, int[] IDs) GetIDs()
    {
        var g = new CompressedSparseRow&amp;lt;Edge&amp;gt;(Length, _edges);
        var (nowOrd, groupCount) = (0, 0);
        var visited = new Stack&amp;lt;int&amp;gt;(Length);
        var low = new int[Length];
        var ord = new int[Length];
        Array.Fill(ord, -1);
        var ids = new int[Length];

        void Dfs(int v)
        {
            low[v] = ord[v] = nowOrd++;
            visited.Push(v);
            for (var i = g.Start[v]; i &amp;lt; g.Start[v + 1]; i++)
            {
                var to = g.Edges[i].To;
                if (ord[to] == -1)
                {
                    Dfs(to);
                    low[v] = Math.Min(low[v], low[to]);
                }
                else
                {
                    low[v] = Math.Min(low[v], ord[to]);
                }
            }

            if (low[v] != ord[v]) return;
            while (true)
            {
                var u = visited.Pop();
                ord[u] = Length;
                ids[u] = groupCount;
                if (u == v) break;
            }

            groupCount++;
        }

        for (var i = 0; i &amp;lt; Length; i++)
        {
            if (ord[i] == -1)
                Dfs(i);
        }

        for (var i = 0; i &amp;lt; Length; i++)
        {
            ids[i] = groupCount - 1 - ids[i];
        }

        return (groupCount, ids);
    }

    public IReadOnlyList&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; GetGraph()
    {
        var (groupCount, ids) = GetIDs();
        var groups = new List&amp;lt;int&amp;gt;[groupCount];
        for (var i = 0; i &amp;lt; groups.Length; i++)
        {
            groups[i] = new List&amp;lt;int&amp;gt;();
        }

        foreach (var (id, index) in ids.Select((x, i) =&amp;gt; (x, i)))
        {
            groups[id].Add(index);
        }

        return groups;
    }

    private readonly struct Edge
    {
        public readonly int To;
        public Edge(int to) =&amp;gt; To = to;
    }
}

public class CompressedSparseRow&amp;lt;T&amp;gt;
{
    public CompressedSparseRow(int length, IEnumerable&amp;lt;(int ID, T)&amp;gt; edges)
    {
        Start = new int[length + 1];
        var es = edges.ToArray();
        Edges = new T[es.Length];
        foreach (var e in es) Start[e.ID + 1]++;
        for (var i = 0; i &amp;lt; length; i++) Start[i + 1] += Start[i];
        var counter = new int[length + 1];
        Start.AsSpan().CopyTo(counter.AsSpan());
        foreach (var (i, t) in es) Edges[counter[i]++] = t;
    }

    public int[] Start { get; }
    public T[] Edges { get; }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 296の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230325abc295</id>
		<title>ABC295</title>
		<link href="https://blog.aconcavy.dev/posts/20230325abc295" />
		<updated>2023-03-25T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 295の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc295"&gt;https://atcoder.jp/contests/abc295&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40021040"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;W&lt;/code&gt;について、&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;not&lt;/code&gt;、&lt;code&gt;that&lt;/code&gt;、&lt;code&gt;the&lt;/code&gt;、&lt;code&gt;you&lt;/code&gt;のいずれかと一致するかを判定します。
対象となる5つの語を配列にまとめることで、&lt;code&gt;Contains&lt;/code&gt;メソッドで引数に指定した値が配列内に存在するかを判定することでき、この操作を各&lt;code&gt;W&lt;/code&gt;について
行い、いずれかが一致すれば答えは&lt;code&gt;Yes&lt;/code&gt;、しなければ答えは&lt;code&gt;No&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var W = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
    var words = new[] { &amp;quot;and&amp;quot;, &amp;quot;not&amp;quot;, &amp;quot;that&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;you&amp;quot; };
    var answer = W.Any(x =&amp;gt; words.Contains(x));
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40027852"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;爆発後の盤面を&lt;code&gt;G&lt;/code&gt;としたとき、&lt;code&gt;G&lt;/code&gt;の初期状態は&lt;code&gt;B&lt;/code&gt;であり、&lt;code&gt;B[r1][c1]&lt;/code&gt;が爆弾の場合は、マンハッタン距離が&lt;code&gt;B[r1][c1]&lt;/code&gt;以下となる&lt;code&gt;G[r2][c2]&lt;/code&gt;を空きマスにします。&lt;br /&gt;
&lt;code&gt;1&amp;lt;=R,C&amp;lt;=20&lt;/code&gt;と制約が小さいため、&lt;code&gt;r1&lt;/code&gt;、&lt;code&gt;c1&lt;/code&gt;、&lt;code&gt;r2&lt;/code&gt;、&lt;code&gt;c2&lt;/code&gt;を全探索しても、最大でも&lt;code&gt;20^4=160,000&lt;/code&gt;なので十分高速です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (R, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var B = new char[R][];
    for (var i = 0; i &amp;lt; R; i++)
    {
        B[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    bool IsWallOrEmpty(char c) =&amp;gt; c == '#' || c == '.';
    int Distance(int r1, int c1, int r2, int c2) =&amp;gt; Math.Abs(r1 - r2) + Math.Abs(c1 - c2);

    var G = new char[R, C];
    for (var i = 0; i &amp;lt; R; i++)
    {
        for (var j = 0; j &amp;lt; C; j++)
        {
            G[i, j] = B[i][j];
        }
    }

    for (var r1 = 0; r1 &amp;lt; R; r1++)
    {
        for (var c1 = 0; c1 &amp;lt; C; c1++)
        {
            if (IsWallOrEmpty(B[r1][c1])) continue;
            var x = B[r1][c1] - '0';
            for (var r2 = 0; r2 &amp;lt; R; r2++)
            {
                for (var c2 = 0; c2 &amp;lt; C; c2++)
                {
                    if (Distance(r1, c1, r2, c2) &amp;lt;= x)
                    {
                        G[r2, c2] = '.';
                    }
                }
            }
        }
    }

    Printer.Print2D(G);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40029453"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書などのデータ構造を使って各色の靴下の個数をそれぞれ数え上げ、各色の&lt;code&gt;靴下の個数/2&lt;/code&gt;の合計が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    foreach (var a in A)
    {
        if (!dict.ContainsKey(a)) dict[a] = 0;
        dict[a]++;
    }

    var answer = dict.Values.Sum(x =&amp;gt; x / 2);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40047728"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嬉しい文字列である条件は、その文字列に存在する各数字について、全ての個数が偶数であることが条件です。&lt;br /&gt;
ある数字に注目したとき、範囲&lt;code&gt;[l,r)&lt;/code&gt;に存在する数字個数は、&lt;code&gt;cum[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;文字目までの累積和としたとき、&lt;code&gt;cum[r]-cum[l]&lt;/code&gt;で求めることができます。&lt;br /&gt;
また、範囲&lt;code&gt;[l,r)&lt;/code&gt;に存在する数字の個数が偶数であるには、&lt;code&gt;cum[r]-cum[l]&lt;/code&gt;が&lt;code&gt;偶数-偶数&lt;/code&gt;、または&lt;code&gt;奇数-奇数&lt;/code&gt;である必要があります。&lt;br /&gt;
この条件が全ての数字に当てはまることから、&lt;code&gt;l&lt;/code&gt;文字目まで見たときの各数字の個数の偶奇と、&lt;code&gt;r&lt;/code&gt;文字目まで見たときの各数字の個数の偶奇が一致すれば、その&lt;code&gt;[l,r)&lt;/code&gt;は嬉しい文字列であることがわかります。&lt;br /&gt;
このことから、各&lt;code&gt;0&amp;lt;=i&amp;lt;=|S|&lt;/code&gt;について、各数字の個数の偶奇の集合の個数を数え上げ、集合が&lt;code&gt;x&lt;/code&gt;個ある場合、&lt;code&gt;x&lt;/code&gt;個のうちから2個選ぶ組み合わせが、その集合になる&lt;code&gt;[l,r)&lt;/code&gt;の組み合わせの個数になります。&lt;/p&gt;
&lt;p&gt;各数字の個数の偶奇の集合について、数字は&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の10種類のみかつそれぞれ偶奇の2通りのため、整数型の各ビットに偶奇フラグとして保持することができます。&lt;br /&gt;
これは、初期状態&lt;code&gt;0&lt;/code&gt;に対して、&lt;code&gt;1&amp;lt;&amp;lt;S[i]&lt;/code&gt;の排他的論理和を累積していくことで、&lt;code&gt;i&lt;/code&gt;まで見たときの各数字の個数の偶奇の集合として管理することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
    var N = S.Length;
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    var curr = 0;
    dict[curr] = 1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        curr ^= 1 &amp;lt;&amp;lt; S[i];
        if (!dict.ContainsKey(curr)) dict[curr] = 0;
        dict[curr]++;
    }

    var answer = dict.Values.Sum(x =&amp;gt; x * (x - 1) / 2);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 295の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>