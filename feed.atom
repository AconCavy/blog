<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title />
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2022 AconCavy</rights>
	<updated>2022-06-18T14:45:55Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220618abc256</id>
		<title>ABC256</title>
		<link href="https://blog.aconcavy.dev/posts/20220618abc256" />
		<updated>2022-06-18T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 256の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc256"&gt;https://atcoder.jp/contests/abc256&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32536346"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Math.Pow(2, N)&lt;/code&gt;や&lt;code&gt;1&lt;/code&gt;をNビットシフトした値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = 1L &amp;lt;&amp;lt; N;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32541675"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各ターンの初めに位置&lt;code&gt;0&lt;/code&gt;に1を足し、位置&lt;code&gt;3,2,1,0&lt;/code&gt;の順で&lt;code&gt;Min(現在の位置+a,4)&lt;/code&gt;に移動させるシミュレーションを行います。
位置の操作を&lt;code&gt;0,1,2,3&lt;/code&gt;ではなく逆順で処理することで、移動した後の現在の位置を&lt;code&gt;0&lt;/code&gt;にすることができるので、何個移動させたかを記録せずに操作できるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var g = new int[5];
    foreach (var a in A)
    {
        g[0]++;
        for (var i = 3; i &amp;gt;= 0; i--)
        {
            g[Math.Min(i + a, 4)] += g[i];
            g[i] = 0;
        }
    }

    var answer = g[4];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32554919"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全てのマスを全探索してしまうと&lt;code&gt;30^9&lt;/code&gt;通りとなり、実行時間制限に間に合いません。
しかし、左上の&lt;code&gt;2x2&lt;/code&gt;マスさえわかれば、3行目と3列目の数字が固定されるので、&lt;code&gt;30^4&lt;/code&gt;の全探索で済むようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H1, H2, H3, W1, W2, W3) = Scanner.Scan&amp;lt;int, int, int, int, int, int&amp;gt;();
    var answer = 0;
    for (var h1w1 = 1; h1w1 &amp;lt; Math.Min(H1, W1); h1w1++)
    {
        for (var h2w1 = 1; h1w1 + h2w1 &amp;lt; W1; h2w1++)
        {
            for (var h1w2 = 1; h1w1 + h1w2 &amp;lt; H1; h1w2++)
            {
                for (var h2w2 = 1; h1w2 + h2w2 &amp;lt; W2 &amp;amp;&amp;amp; h2w1 + h2w2 &amp;lt; H2; h2w2++)
                {
                    var h3w1 = W1 - h1w1 - h2w1;
                    var h3w2 = W2 - h1w2 - h2w2;
                    var h1w3 = H1 - h1w1 - h1w2;
                    var h2w3 = H2 - h2w1 - h2w2;
                    if (H3 - h3w1 - h3w2 == W3 - h1w3 - h2w3 &amp;amp;&amp;amp; W3 - h1w3 - h2w3 &amp;gt; 0)
                    {
                        answer++;
                    }
                }
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32558635"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;区間の左側を昇順で並べたときに、ある区間の左側よりもその直前区間の右側が大きい場合、その二つの区間をマージすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var range = new (int L, int R)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        range[i] = Scanner.Scan&amp;lt;int, int&amp;gt;();
    }

    Array.Sort(range, (x, y) =&amp;gt; x.L.CompareTo(y.L));
    var answer = new List&amp;lt;(int L, int R)&amp;gt;();
    answer.Add(range[0]);

    foreach (var (l, r) in range.Skip(1))
    {
        if (answer[^1].R &amp;gt;= l)
        {
            answer[^1] = (Math.Min(answer[^1].L, l), Math.Max(answer[^1].R, r));
        }
        else
        {
            answer.Add((l, r));
        }
    }

    answer.Sort((x, y) =&amp;gt; x.L.CompareTo(y.L));
    foreach (var (l, r) in answer)
    {
        Console.WriteLine($&amp;quot;{l} {r}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32565127"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嫌いな人との関係を有効辺として考えることで、グラフとして考えることができるようになります。&lt;br /&gt;
N頂点N辺のグラフであることから、連結成分ごとにサイクルは多くても1個であることがわかります。&lt;br /&gt;
そこで、グラフを強連結成分ごとに分解し、サイクル内の最小の不満を受け入れることで、サイクルごとの不満度を最小にすることができます。&lt;br /&gt;
そして、サイクルごとの不満度の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var C = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var scc = new StronglyConnectedComponent(N);
    for (var i = 0; i &amp;lt; N; i++)
    {
        scc.AddEdge(i, X[i]);
    }

    const long inf = (long)1e18;
    var answer = 0L;
    foreach (var graph in scc.GetGraph())
    {
        if (graph.Count == 1) continue;
        var min = inf;
        foreach (var u in graph)
        {
            min = Math.Min(min, C[u]);
        }

        answer += min;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;強連結成分は&lt;code&gt;ACL&lt;/code&gt;の&lt;code&gt;scc&lt;/code&gt;等で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class StronglyConnectedComponent
{
    public int Length { get; }
    private readonly List&amp;lt;(int, Edge)&amp;gt; _edges;

    public StronglyConnectedComponent(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _edges = new List&amp;lt;(int, Edge)&amp;gt;();
    }

    public void AddEdge(int from, int to)
    {
        if (from &amp;lt; 0 || Length &amp;lt;= from) throw new ArgumentOutOfRangeException(nameof(from));
        if (to &amp;lt; 0 || Length &amp;lt;= to) throw new ArgumentOutOfRangeException(nameof(to));
        _edges.Add((from, new Edge(to)));
    }

    public (int GroupCount, int[] IDs) GetIDs()
    {
        var g = new CompressedSparseRow&amp;lt;Edge&amp;gt;(Length, _edges);
        var (nowOrd, groupCount) = (0, 0);
        var visited = new Stack&amp;lt;int&amp;gt;(Length);
        var low = new int[Length];
        var ord = new int[Length];
        Array.Fill(ord, -1);
        var ids = new int[Length];

        void Dfs(int v)
        {
            low[v] = ord[v] = nowOrd++;
            visited.Push(v);
            for (var i = g.Start[v]; i &amp;lt; g.Start[v + 1]; i++)
            {
                var to = g.Edges[i].To;
                if (ord[to] == -1)
                {
                    Dfs(to);
                    low[v] = Math.Min(low[v], low[to]);
                }
                else
                {
                    low[v] = Math.Min(low[v], ord[to]);
                }
            }

            if (low[v] != ord[v]) return;
            while (true)
            {
                var u = visited.Pop();
                ord[u] = Length;
                ids[u] = groupCount;
                if (u == v) break;
            }

            groupCount++;
        }

        for (var i = 0; i &amp;lt; Length; i++)
        {
            if (ord[i] == -1)
                Dfs(i);
        }

        for (var i = 0; i &amp;lt; Length; i++)
        {
            ids[i] = groupCount - 1 - ids[i];
        }

        return (groupCount, ids);
    }

    public IReadOnlyList&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; GetGraph()
    {
        var (groupCount, ids) = GetIDs();
        var groups = new List&amp;lt;int&amp;gt;[groupCount];
        for (var i = 0; i &amp;lt; groups.Length; i++)
        {
            groups[i] = new List&amp;lt;int&amp;gt;();
        }

        foreach (var (id, index) in ids.Select((x, i) =&amp;gt; (x, i)))
        {
            groups[id].Add(index);
        }

        return groups;
    }

    private readonly struct Edge
    {
        public readonly int To;
        public Edge(int to) =&amp;gt; To = to;
    }
}

public class CompressedSparseRow&amp;lt;T&amp;gt;
{
    public CompressedSparseRow(int length, IEnumerable&amp;lt;(int ID, T)&amp;gt; edges)
    {
        Start = new int[length + 1];
        var es = edges.ToArray();
        Edges = new T[es.Length];
        foreach (var e in es) Start[e.ID + 1]++;
        for (var i = 0; i &amp;lt; length; i++) Start[i + 1] += Start[i];
        var counter = new int[length + 1];
        Start.AsSpan().CopyTo(counter.AsSpan());
        foreach (var (i, t) in es) Edges[counter[i]++] = t;
    }

    public int[] Start { get; }
    public T[] Edges { get; }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 256の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220611abc255</id>
		<title>ABC255</title>
		<link href="https://blog.aconcavy.dev/posts/20220611abc255" />
		<updated>2022-06-11T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 255の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc255"&gt;https://atcoder.jp/contests/abc255&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32372739"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt;と&lt;code&gt;C&lt;/code&gt;の値ごとに場合分けして答えることもできますが(4通り)、&lt;code&gt;2*2&lt;/code&gt;の行列&lt;code&gt;M&lt;/code&gt;として値を保持して&lt;code&gt;M[R][C]&lt;/code&gt;の値を答えることもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (R, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    R--; C--;
    var M = new int[2][];
    for (var i = 0; i &amp;lt; 2; i++)
    {
        M[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var answer = M[R][C];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32381972"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある人を照らすために必要な&lt;code&gt;R&lt;/code&gt;は、何れかの明かりを持つことができる人の位置からの最小距離であり、その&lt;code&gt;R&lt;/code&gt;の最大値を求めることで全ての人をカバーすることができます。&lt;br /&gt;
距離&lt;code&gt;D&lt;/code&gt;は二点の&lt;code&gt;X&lt;/code&gt;の差分&lt;code&gt;dx&lt;/code&gt;と&lt;code&gt;Y&lt;/code&gt;の差分を&lt;code&gt;dy&lt;/code&gt;としたとき、&lt;code&gt;D = Sqrt(dx^2 + dy^2)&lt;/code&gt;で求めることができますが、&lt;code&gt;D &amp;lt; D'&lt;/code&gt;ならば、&lt;code&gt;D^2 &amp;lt; D'^2&lt;/code&gt;なので、距離の二乗の値で走査することで、最後に答えを求めるときを除いて実数による誤差を無視することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var P = new (long X, long Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = (x, y);
    }

    var answer = 0L;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var min = inf;
        for (var i = 0; i &amp;lt; N; i++)
        {
            var dx = P[a].X - P[i].X;
            var dy = P[a].Y - P[i].Y;
            var d = dx * dx + dy * dy;
            min = Math.Min(min, d);
        }

        answer = Math.Max(answer, min);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答え&lt;code&gt;R&lt;/code&gt;の二部探索でも答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var P = new (long X, long Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = (x, y);
    }

    bool F(long x)
    {
        var ok = new bool[N];
        foreach (var a in A)
        {
            for (var i = 0; i &amp;lt; N; i++)
            {
                var dx = P[a].X - P[i].X;
                var dy = P[a].Y - P[i].Y;
                var d = dx * dx + dy * dy;
                ok[i] |= d &amp;lt;= x;
            }
        }

        return ok.All(x =&amp;gt; x);
    }

    const long inf = (long)1e18;
    var answer = Math.Sqrt(BinarySearch(-1, inf, F));
    Console.WriteLine(answer);
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32396621"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32418071"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D=0&lt;/code&gt;のときは明らかに、&lt;code&gt;Abs(X-A)&lt;/code&gt;となります。
以下それ以外のときに&lt;code&gt;d=(X-A)/D&lt;/code&gt;とし、&lt;code&gt;x&lt;/code&gt;を初項を除く項数の数として&lt;code&gt;F(x)=Abs(X-(A+D*x))&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&amp;lt;=d&amp;lt;=N-2&lt;/code&gt;のとき、&lt;code&gt;初項+d項目&lt;/code&gt;と&lt;code&gt;初項+(d+1)項目&lt;/code&gt;の間に&lt;code&gt;X&lt;/code&gt;が存在するため、&lt;code&gt;F(d)&lt;/code&gt;と&lt;code&gt;F(d+1)&lt;/code&gt;の回数が小さいほうが答えとなります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d=N-1&lt;/code&gt;のとき、&lt;code&gt;N&lt;/code&gt;項より大きな項にすることができないため、&lt;code&gt;F(N-1)&lt;/code&gt;となります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&amp;lt;0&lt;/code&gt;のとき、&lt;code&gt;1&lt;/code&gt;項より小さな項にすることができないため、&lt;code&gt;F(0)&lt;/code&gt;となります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このことから、&lt;code&gt;d&lt;/code&gt;を&lt;code&gt;0&amp;lt;=d&amp;lt;=N-1&lt;/code&gt;に制限したときの&lt;code&gt;F(d)&lt;/code&gt;と&lt;code&gt;d+1&amp;lt;=N-1&lt;/code&gt;ならば&lt;code&gt;F(d+1)&lt;/code&gt;の回数が小さいほうが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, A, D, N) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();

    long F(long n)
    {
        return Math.Abs(X - (A + n * D));
    }

    if (D == 0)
    {
        Console.WriteLine(F(0));
        return;
    }

    var n = Math.Max(0, Math.Min(N - 1, (X - A) / D));
    var answer = F(n);
    if (n + 1 &amp;lt;= N - 1) answer = Math.Min(answer, F(n + 1));
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32399982"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32418084"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに&lt;code&gt;A&lt;/code&gt;の値を走査してしまうと、&lt;code&gt;O(QN)&lt;/code&gt;かかってしまい、実行時間制限に間に合いません。
そこで、&lt;code&gt;A&lt;/code&gt;の値をソートし、&lt;code&gt;A&lt;/code&gt;において&lt;code&gt;X&lt;/code&gt;以上が現れる位置&lt;code&gt;i (0-indexed)&lt;/code&gt;において左右に二つに分けた場合、左側の操作に必要な回数は&lt;code&gt;X*左側の個数 - A[0..i)の合計&lt;/code&gt;となり、右側の操作に必要な回数は&lt;code&gt;A[i..N)の合計 - X*右側の個数&lt;/code&gt;となることがわかります。&lt;br /&gt;
そのため、あらかじめ&lt;code&gt;A&lt;/code&gt;の累積和を求めておき、クエリごとに&lt;code&gt;A&lt;/code&gt;において&lt;code&gt;X&lt;/code&gt;以上が現れる位置を二部探索で求めることで、位置を求めることに&lt;code&gt;O(logN)&lt;/code&gt;、左側の合計と右側の合計を求めることに&lt;code&gt;O(1)&lt;/code&gt;で対応することができ、全体で&lt;code&gt;O(QlogN)&lt;/code&gt;で求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    while (Q-- &amp;gt; 0)
    {
        var X = Scanner.Scan&amp;lt;long&amp;gt;();
        var l = LowerBound(A, X);
        var r = N - l;
        var answer = Math.Abs(cum[l] - X * l) + Math.Abs((cum[N] - cum[l]) - X * r);
        Console.WriteLine(answer);
    }
}

public static int LowerBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m].CompareTo(key) &amp;gt;= 0) r = m;
        else l = m;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32416252"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var X = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var B = new long[N];
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        B[i + 1] = S[i] - B[i];
    }

    var dict = new Dictionary&amp;lt;long, long&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; M; j++)
        {
            var c = X[j] - B[i];
            if (i % 2 == 1) c *= -1;
            if (!dict.ContainsKey(c)) dict[c] = 0;
            dict[c]++;
        }
    }

    var answer = dict.Values.Max();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 255の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220604abc254</id>
		<title>ABC254</title>
		<link href="https://blog.aconcavy.dev/posts/20220604abc254" />
		<updated>2022-06-04T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 254の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc254"&gt;https://atcoder.jp/contests/abc254&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32198774"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列として入力を取り、文字列の後ろ2文字を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = N[^2..];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32202968"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文に沿って実装をします。
これはパスカルの三角形、二項係数を表します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var nCk = new long[N, N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            if (j == 0 || j == i) nCk[i, j] = 1;
            else nCk[i, j] = nCk[i - 1, j - 1] + nCk[i - 1, j];
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            Console.Write(nCk[i, j]);
            Console.Write(j == i ? '\n' : ' ');
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32210520"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;が入れ替え可能な位置として、&lt;code&gt;A[i+K]&lt;/code&gt;や&lt;code&gt;A[i+k*2]&lt;/code&gt;のように&lt;code&gt;i+Kの倍数&lt;/code&gt;の何れかの値と入れ替えることができることがわかります。
そのため、&lt;code&gt;i%K番目&lt;/code&gt;のグループごとに値をソートし、数列&lt;code&gt;B&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目に&lt;code&gt;i%K番目&lt;/code&gt;のグループの&lt;code&gt;i/K&lt;/code&gt;番目の値を復元してできたものが、&lt;code&gt;A&lt;/code&gt;をソートしたものと一致かを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;A = [3, 4, 1, 3, 4]
G[0] = [3, 1, 4] -&amp;gt; [1, 3, 4]
G[1] = [4, 3] -&amp;gt; [3, 4]
B = [1, 3, 3, 4, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var G = new int[K][].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i % K].Add(A[i]);
    }

    for (var i = 0; i &amp;lt; K; i++)
    {
        G[i].Sort();
    }

    var B = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        B.Add(G[i % K][i / K]);
    }

    var C = A.OrderBy(x =&amp;gt; x).ToArray();
    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer &amp;amp;= B[i] == C[i];
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32245869"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var sq = new bool[N + 1];
    for (var i = 1; i * i &amp;lt;= N; i++)
    {
        sq[i * i] = true;
    }

    var count = new long[N + 1];
    for (var i = 1; i &amp;lt;= N; i++)
    {
        long j = 0;
        foreach (var d in GetDivisors(i))
        {
            if (sq[d]) j = Math.Max(j, d);
        }

        count[i / j]++;
    }

    var answer = 0L;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer += count[i] * count[i];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32243464"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリに対して、全ての頂点をメモしてDFSやBFSをしてしまうと、時間計算量が&lt;code&gt;O(QM)&lt;/code&gt;となってしまい、実行時間制限に間に合いません。
しかし、制約にグラフの各頂点の時数は&lt;code&gt;3&lt;/code&gt;以下であり、&lt;code&gt;0&amp;lt;=k&amp;lt;=3&lt;/code&gt;とあることから、クエリあたり最大でも距離が&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;3&lt;/code&gt;の頂点の和&lt;code&gt;1+3^1+3^2+3^3=1+3+9+27=40&lt;/code&gt;しかないことがわかります。
そのため、訪れた頂点のみを&lt;code&gt;HashSet&lt;/code&gt;などで管理することで、実行時間制限に間に合わせることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        G[a].Add(b);
        G[b].Add(a);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (x, k) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--;
        var set = new HashSet&amp;lt;long&amp;gt;();
        var queue = new Queue&amp;lt;(int, int)&amp;gt;();
        set.Add(x);
        queue.Enqueue((x, 0));
        while (queue.Count &amp;gt; 0)
        {
            var (u, d) = queue.Dequeue();
            if (d == k) continue;
            foreach (var v in G[u])
            {
                if (set.Contains(v)) continue;
                set.Add(v);
                queue.Enqueue((v, d + 1));
            }
        }

        var answer = set.Sum() + set.Count;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 254の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220528abc253</id>
		<title>ABC253</title>
		<link href="https://blog.aconcavy.dev/posts/20220528abc253" />
		<updated>2022-05-28T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 253の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253"&gt;https://atcoder.jp/contests/abc253&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/31997507"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要素が3つしかないため、3つの値の合計から最大値と最小値を引いた値が中央値として求めることができるので、中央値が&lt;code&gt;B&lt;/code&gt;と一致しているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var mid = A.Sum() - A.Min() - A.Max();
    var answer = A[1] == mid ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32003197"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(h1,w1)&lt;/code&gt;から&lt;code&gt;(h2,w2)&lt;/code&gt;への移動回数は縦横の差分の合計&lt;code&gt;Abs(h2-h1) + Abs(w2-w1)&lt;/code&gt;で求めることができます。&lt;br /&gt;
2つの&lt;code&gt;o&lt;/code&gt;の位置を取得は、1つ目ならば&lt;code&gt;(h1,w1)&lt;/code&gt;を更新し、2つ目ならば&lt;code&gt;(h2,w2)&lt;/code&gt;を更新するようにフラグなどで管理することで判定できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new string[H];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    var (h1, w1) = (0, 0);
    var (h2, w2) = (0, 0);
    var ok = false;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == '-') continue;
            if (!ok)
            {
                (h1, w1) = (i, j);
                ok = true;
            }
            else
            {
                (h2, w2) = (i, j);
            }
        }
    }

    var answer = Math.Abs(h2 - h1) + Math.Abs(w2 - w1);
    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32010454"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;リストを使って集合の管理をしてしまうと、クエリごとの最悪時間計算量が&lt;code&gt;O(NlogN)&lt;/code&gt;になってしまい、全体で&lt;code&gt;O(QNlogN)&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、ソートされている集合(C#では&lt;code&gt;SortedSet&lt;/code&gt;)等を実際に集合に存在する値に対して使うことで、要素の追加を&lt;code&gt;O(logN)&lt;/code&gt;、最大値の最小値の取得を&lt;code&gt;O(1)&lt;/code&gt;で行うことができ、全体で&lt;code&gt;O(QlogN)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var set = new SortedSet&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var x = query[1];
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x]++;
            set.Add(x);
        }
        else if (query[0] == 2)
        {
            var (x, c) = (query[1], query[2]);
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x] -= Math.Min(dict[x], c);
            if (dict[x] == 0)
            {
                set.Remove(x);
            }
        }
        else
        {
            var answer = set.Max - set.Min;
            Console.WriteLine(answer);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32035460"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc253/submissions/32057974"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;以下の値を全て捜査してしまうと、時間計算量が&lt;code&gt;O(N)&lt;/code&gt;になってしまい、&lt;code&gt;N=1e9&lt;/code&gt;の場合に間に合いません。
そこで、&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;までの総和から、&lt;code&gt;A&lt;/code&gt;の倍数の総和と&lt;code&gt;B&lt;/code&gt;の倍数の総和を引き、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の最小公倍数の総和を足すことで&lt;code&gt;O(logMin(a,b))&lt;/code&gt;で求めることができます。&lt;br /&gt;
&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;x&lt;/code&gt;までの総和は、&lt;code&gt;F(x) = x * (x+1) / 2&lt;/code&gt;で求められるので、1から&lt;code&gt;N&lt;/code&gt;までの総和は&lt;code&gt;F(N)&lt;/code&gt;で求めることができます。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;以下の&lt;code&gt;X&lt;/code&gt;の倍数の総和は、&lt;code&gt;N&lt;/code&gt;以下に&lt;code&gt;X&lt;/code&gt;の倍数は&lt;code&gt;N/X&lt;/code&gt;個あるため、&lt;code&gt;M=N/X&lt;/code&gt;としたとき、&lt;code&gt;X*F(M)&lt;/code&gt;で求めることができます。
よって、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;の最小公倍数を&lt;code&gt;LCM(x,y)&lt;/code&gt;としたとき、&lt;code&gt;F(N) - F(N/A)*A - F(N/B)*B + F(N/LCM(A,B))*LCM(A,B)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();

    long F(long x) =&amp;gt; x * (x + 1) / 2;
    long G(long n, long a, long b)
    {
        var result = F(n);
        result -= a * F(n / a);
        result -= b * F(n / b);
        var lcm = Lcm(a, b);
        result += lcm * F(n / lcm);
        return result;
    }

    var answer = G(N, A, B);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32057606"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;累積和を求めながら動的計画法をすることで求めることができます。
初期状態として、&lt;code&gt;[1,M]&lt;/code&gt;は各&lt;code&gt;1&lt;/code&gt;になり、&lt;code&gt;i+1&lt;/code&gt;項目への遷移は&lt;code&gt;dp[i][0..j-k] + dp[i][j+k..M]&lt;/code&gt;の総和となります。
区間和&lt;code&gt;dp[i][0..j-k] + dp[i][j+k..M]&lt;/code&gt;を各&lt;code&gt;j&lt;/code&gt;に対して求めてしまうと、時間計算量が&lt;code&gt;O(M)&lt;/code&gt;かかってしまうので、あらかじめ累積和を取っておくことで、&lt;code&gt;j&lt;/code&gt;ごとに&lt;code&gt;O(1)&lt;/code&gt;で区間和を求めることができます。
&lt;code&gt;K=0&lt;/code&gt;のときには注意が必要で、&lt;code&gt;dp[i][1..M]&lt;/code&gt;の総和が遷移します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var dp = new mint[N + 1, M + 10];
    for (var j = 1; j &amp;lt;= M; j++)
    {
        dp[0, j] = 1;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var cum = new mint[M + 10];
        for (var j = 1; j &amp;lt;= M; j++)
        {
            cum[j + 1] = cum[j] + dp[i, j];
        }

        for (var j = 1; j &amp;lt;= M; j++)
        {
            if (K &amp;gt; 0)
            {
                var l1 = 0;
                var r1 = Math.Max(0, j - K) + 1;
                var l2 = Math.Min(M + 1, j + K);
                var r2 = M + 1;
                dp[i + 1, j] += cum[r1] - cum[l1] + cum[r2] - cum[l2];
            }
            else
            {
                dp[i + 1, j] += cum[M + 1];
            }
        }
    }

    mint answer = 0;
    for (var i = 1; i &amp;lt;= M; i++)
    {
        answer += dp[N - 1, i];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 253の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220521abc252</id>
		<title>ABC252</title>
		<link href="https://blog.aconcavy.dev/posts/20220521abc252" />
		<updated>2022-05-22T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 252の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc252"&gt;https://atcoder.jp/contests/abc252&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc252/tasks/abc252_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc252/submissions/31834327"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では&lt;code&gt;char&lt;/code&gt;の&lt;code&gt;0-255&lt;/code&gt;にはASCII文字コードが割り当てられているため、数値を&lt;code&gt;char&lt;/code&gt;型に明示的に変換することで、与えられた数値に対する文字に変換することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = (char)N;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc252/tasks/abc252_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc252/submissions/31840735"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;おいしさが最大のときの食品の番号の集合をとり、&lt;code&gt;B&lt;/code&gt;の何れかがその集合に存在していれば&lt;code&gt;Yes&lt;/code&gt;、そうでなければ&lt;code&gt;No&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var set = new HashSet&amp;lt;int&amp;gt;();
    var max = -1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (max &amp;lt; A[i])
        {
            max = A[i];
            set.Clear();
            set.Add(i + 1);
        }
        else if (max == A[i])
        {
            set.Add(i + 1);
        }
    }

    var answer = false;
    foreach (var b in B)
    {
        answer |= set.Contains(b);
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc252/tasks/abc252_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc252/submissions/31852070"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表示される数字を全探索して最小となる秒数を求めます。&lt;br /&gt;
各リールにおいて指定した数字が出現する秒数を&lt;code&gt;N&lt;/code&gt;周分保持し、出現する秒数が早い順から採用します。&lt;br /&gt;
採用したリールをメモしておき、全てのリールが採用された時の秒数の最小を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        S[i] = s.Select(x =&amp;gt; x - '0').ToArray();
    }

    const long inf = (long)1e18;
    var answer = inf;
    for (var n = 0; n &amp;lt; 10; n++)
    {
        var list = new List&amp;lt;(int T, int ID)&amp;gt;();
        for (var i = 0; i &amp;lt; N; i++)
        {
            var idx = Array.IndexOf(S[i], n);
            list.AddRange(Enumerable.Range(0, N).Select(x =&amp;gt; (x * 10 + idx, i)));
        }

        list.Sort((x, y) =&amp;gt; x.T.CompareTo(y.T));
        var used = new HashSet&amp;lt;int&amp;gt;();
        var curr = -1;
        foreach (var (t, i) in list)
        {
            if (t &amp;lt;= curr || used.Contains(i)) continue;
            used.Add(i);
            curr = t;
            if (used.Count == N)
            {
                answer = Math.Min(answer, curr);
                break;
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc252/tasks/abc252_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc252/submissions/31867979"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に&lt;code&gt;i,j,k&lt;/code&gt;の全ての組み合わせを全探索してしまうと、数え上げの時間計算量が&lt;code&gt;O(N^3)&lt;/code&gt;となり、実行時間制限に間に合わないません。
そこで、出現する数値をまとめて数え上げます。
以下数値をまとめた個数の配列を&lt;code&gt;C&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;の長さを&lt;code&gt;M&lt;/code&gt;とします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;のうち、&lt;code&gt;0&amp;lt;=i&amp;lt;j&amp;lt;k&amp;lt;M&lt;/code&gt;となる&lt;code&gt;i,j,k&lt;/code&gt;の組み合わせを全探索すると、時間計算量が&lt;code&gt;O(M^3)&lt;/code&gt;であり、時間計算量はまだ改善できていません。
まず、&lt;code&gt;C&lt;/code&gt;のうち&lt;code&gt;0&amp;lt;=j&amp;lt;k&amp;lt;M&lt;/code&gt;となる&lt;code&gt;j,k&lt;/code&gt;組み合わせを愚直に考えると、以下のように数え上げることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var j = 0; j &amp;lt; M; j++)
{
    for(var k = j + 1; k &amp;lt; M; k++)
    {
        sumJK += C[j] * C[k];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この場合、&lt;code&gt;j,k&lt;/code&gt;の組み合わせは時間計算量&lt;code&gt;O(M^2)&lt;/code&gt;で求めることができますが、&lt;code&gt;j&lt;/code&gt;を固定したときの組み合わせの個数は、&lt;code&gt;C[j]*(C[j+1] + C[j+2] + .. + C[M-1])&lt;/code&gt;となり、&lt;code&gt;C[j]&lt;/code&gt;に&lt;code&gt;j&lt;/code&gt;以降の累積和をかけたものであることがわかります。
そのため、&lt;code&gt;C[k]&lt;/code&gt;の累積和をあらかじめ求めておくことで、数え上げの時間計算量を&lt;code&gt;O(M)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for (var k = M - 1; k &amp;gt;= 0; k--)
{
    cumK[k] = C[k] + cumK[k + 1];
}

for(var j = 0; j &amp;lt; M; j++)
{
    sumJK += C[j] * cumK[j + 1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを利用すると、&lt;code&gt;C&lt;/code&gt;のうち&lt;code&gt;0&amp;lt;=i&amp;lt;j&amp;lt;k&amp;lt;M&lt;/code&gt;となる&lt;code&gt;i,j,k&lt;/code&gt;の組み合わせは時間計算量&lt;code&gt;O(M^2)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var i = 0; i &amp;lt; M; i++)
{
    for(var j = i + 1; j &amp;lt; M; j++)
    {
        sumIJK += C[i] * C[j] * cumK[j + 1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、&lt;code&gt;i&lt;/code&gt;を固定したときの組み合わせは、&lt;code&gt;C[i] * (C[i+1]*cumK[i+2] + C[i+2]*cumK[i+3] + .. + C[M-2]*cumK[M-1])&lt;/code&gt;となり、&lt;code&gt;C[i]&lt;/code&gt;に&lt;code&gt;i&lt;/code&gt;以降の&lt;code&gt;C&lt;/code&gt;と&lt;code&gt;C[k]&lt;/code&gt;の累積和をかけたものの累積和であることがわかります。
そのため、&lt;code&gt;C[j]&lt;/code&gt;に&lt;code&gt;C[k]&lt;/code&gt;の累積和をかけたものの累積和をあらかじめ求めておくことで、数え上げの時間計算量を&lt;code&gt;O(M)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for (var j = M - 1; k &amp;gt;= 0; k--)
{
    cumJ[k] = C[j] * cumK[j + 1] + cumJ[j + 1];
}

for(var i = 0; i &amp;lt; M; j++)
{
    sumIJK += C[i] * cumJ[i + 1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上により、時間計算量&lt;code&gt;O(M)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var count = new int[(int)2e5 + 1];
    foreach (var a in A)
    {
        count[a]++;
    }

    var C = count.Where(x =&amp;gt; x &amp;gt; 0).ToArray();
    var M = C.Length;

    var cumK = new long[M + 1];
    var cumJ = new long[M + 1];
    for (var k = M - 1; k &amp;gt;= 0; k--)
    {
        cumK[k] = C[k] + cumK[k + 1];
    }

    for (var j = M - 1; j &amp;gt;= 0; j--)
    {
        cumJ[j] = C[j] * cumK[j + 1] + cumJ[j + 1];
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        answer += C[i] * cumJ[i + 1];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc252/tasks/abc252_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc252/submissions/31874511"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;1&lt;/code&gt;からの最短経路を求め、各頂点への最短経路とその直前の頂点を結ぶ&lt;code&gt;N-1&lt;/code&gt;本の道が答えとなります。&lt;br /&gt;
これは、頂点&lt;code&gt;1&lt;/code&gt;から頂点&lt;code&gt;v&lt;/code&gt;への最短経路があるとき、その経路上の頂点&lt;code&gt;u&lt;/code&gt;への経路は、頂点&lt;code&gt;1&lt;/code&gt;から頂点&lt;code&gt;u&lt;/code&gt;への最短経路であることからわかります。
ダイクストラ法で頂点&lt;code&gt;1&lt;/code&gt;から各頂点への最短経路を求めるときに、各頂点の直前の頂点をメモしておき、頂点&lt;code&gt;v&lt;/code&gt;の直前の頂点&lt;code&gt;u&lt;/code&gt;をつなぐ道が何番目の道であるかを実装することで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dict = new Dictionary&amp;lt;(int U, int V), int&amp;gt;();
    var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, c) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        G[a].Add((b, c));
        G[b].Add((a, c));

        dict[(a, b)] = dict[(b, a)] = i + 1;
    }

    var costs = new long[N];
    Array.Fill(costs, long.MaxValue);
    costs[0] = 0;
    var queue = new PriorityQueue&amp;lt;(int U, long Cost)&amp;gt;((x, y) =&amp;gt; x.Cost.CompareTo(y.Cost));
    queue.Enqueue((0, 0));
    var prev = new int[N];
    while (queue.Count &amp;gt; 0)
    {
        var (u, cu) = queue.Dequeue();
        if (costs[u] &amp;lt; cu) continue;
        foreach (var (v, cv) in G[u])
        {
            var c = costs[u] + cv;
            if (costs[v] &amp;lt;= c) continue;
            costs[v] = c;
            prev[v] = u;
            queue.Enqueue((v, c));
        }
    }

    var answer = new List&amp;lt;int&amp;gt;();
    for (var v = 1; v &amp;lt; N; v++)
    {
        var u = prev[v];
        answer.Add(dict[(u, v)]);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 252の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220514abc251</id>
		<title>ABC251</title>
		<link href="https://blog.aconcavy.dev/posts/20220514abc251" />
		<updated>2022-05-14T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 251の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc251"&gt;https://atcoder.jp/contests/abc251&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc251/tasks/abc251_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc251/submissions/31659858"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を繰り返して長さ6以上の文字列を作成し、長さ6の文字を&lt;code&gt;SubString&lt;/code&gt;や&lt;code&gt;Range&lt;/code&gt;で作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S;
    while (answer.Length &amp;lt; 6)
    {
        answer += S;
    }

    answer = answer[0..6];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc251/tasks/abc251_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc251/submissions/31659934"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&amp;lt;=i,j,k&amp;lt;=N&lt;/code&gt;の組み合わせのうち、&lt;code&gt;A[i]&lt;/code&gt;、&lt;code&gt;A[i]+A[j]&lt;/code&gt;、&lt;code&gt;A[i]+A[j]+A[k]&lt;/code&gt;かつ&lt;code&gt;W&lt;/code&gt;以下になる組み合わせを全探索し、重複をなくしたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var set = new HashSet&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        set.Add(A[i]);
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            set.Add(A[i] + A[j]);
            for (var k = j + 1; k &amp;lt; N; k++)
            {
                set.Add(A[i] + A[j] + A[k]);
            }
        }
    }

    var answer = set.Count(x =&amp;gt; x &amp;lt;= W);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc251/tasks/abc251_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc251/submissions/31664269"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各文字列において2番目以降のスコアを無視したとき、スコアが最大の文字列が何番目にでてくるかを解答します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var sub = new (string S, int T)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, t) = Scanner.Scan&amp;lt;string, int&amp;gt;();
        sub[i] = (s, t);
    }

    var dict = new Dictionary&amp;lt;string, int&amp;gt;();

    for (var i = N - 1; i &amp;gt;= 0; i--)
    {
        var (s, t) = sub[i];
        dict[s] = t;
    }

    var max = -1;
    var result = &amp;quot;&amp;quot;;
    foreach (var (s, t) in dict)
    {
        if (max &amp;lt; t)
        {
            max = t;
            result = s;
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (result == sub[i].S)
        {
            Console.WriteLine(i + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc251/tasks/abc251_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc251/submissions/31695211"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;なにこれ?????????&lt;/li&gt;
&lt;li&gt;フィボナッチ数列とかでどうにかならないか&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W=100,000&lt;/code&gt;が解ければよさそう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;1-100&lt;/code&gt;、&lt;code&gt;100-10000&lt;/code&gt;、&lt;code&gt;10000-1000000&lt;/code&gt;をカバーできれば全ての範囲をカバーできるようです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var W = Scanner.Scan&amp;lt;int&amp;gt;();
    var list = new List&amp;lt;int&amp;gt;();

    for (var i = 1; i &amp;lt;= 100; i++)
    {
        list.Add(i);
        list.Add(i * 100);
        list.Add(i * 10000);
    }

    Console.WriteLine(list.Count);
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, list));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc251/tasks/abc251_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc251/submissions/31695236"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二部探索?&lt;/li&gt;
&lt;li&gt;動的計画法?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i=1&lt;/code&gt;と&lt;code&gt;i=N&lt;/code&gt;の処理をどうするか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;i=1&lt;/code&gt;を採用したときと&lt;code&gt;i=N&lt;/code&gt;を採用したときの2つのパターンで動的計画法を解くことが解法でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    const long inf = (long)1e18;

    var answer = inf;
    for (var k = 0; k &amp;lt; 2; k++)
    {
        var dp = new long[N + 10, 2];
        if (k == 0)
        {
            dp[1, 0] = 0;
            dp[1, 1] = inf;
        }
        else
        {
            dp[1, 0] = inf;
            dp[1, 1] = A[0];
        }

        for (var i = 1; i &amp;lt; N; i++)
        {
            dp[i + 1, 0] = dp[i, 1];
            dp[i + 1, 1] = Math.Min(dp[i, 0], dp[i, 1]) + A[i];
        }

        if (k == 0) answer = Math.Min(answer, dp[N, 1]);
        else answer = Math.Min(answer, Math.Min(dp[N, 0], dp[N, 1]));
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 251の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220508abc250</id>
		<title>ABC250</title>
		<link href="https://blog.aconcavy.dev/posts/20220508abc250" />
		<updated>2022-05-08T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 250の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc250"&gt;https://atcoder.jp/contests/abc250&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc250/tasks/abc250_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc250/submissions/31514088"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;隣接するマスは上下左右なので、&lt;code&gt;(R,C)&lt;/code&gt;に&lt;code&gt;x&lt;/code&gt;軸と&lt;code&gt;y&lt;/code&gt;軸の差分4方向(&lt;code&gt;(+1,0), (-1,0), (0,+1),(0,-1)&lt;/code&gt;)を確認し、&lt;code&gt;1&amp;lt;=R+d&amp;lt;=H &amp;amp;&amp;amp; 1&amp;lt;=R+d&amp;lt;=W&lt;/code&gt;に含まれている個数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var (R, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    R--;
    C--;
    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };
    var answer = 0;
    foreach (var (dh, dw) in D4)
    {
        var (nh, nw) = (R + dh, C + dw);
        if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
        answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc250/tasks/abc250_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc250/submissions/31519381"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N=1, A=1, B=1&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;.#
#.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のようになり、&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;がそれぞれ偶奇をとるとき、つまり&lt;code&gt;(0,0), (0,1), (1,0), (1,1)&lt;/code&gt;の4パターンが存在することがわかります。&lt;br /&gt;
また、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の値を変更したとき、それぞれのタイルは縦&lt;code&gt;A&lt;/code&gt;マス、横&lt;code&gt;B&lt;/code&gt;マスになるので、&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;それぞれ&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;で割ったときの偶奇によってタイルを指定すれば、答えとなるタイルが求められます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G = new char[N * A, N * B];
    for (var i = 0; i &amp;lt; N * A; i++)
    {
        for (var j = 0; j &amp;lt; N * B; j++)
        {
            var x = i / A % 2;
            var y = j / B % 2;
            G[i, j] = (x, y) switch
            {
                (0, 0) =&amp;gt; '.',
                (0, 1) =&amp;gt; '#',
                (1, 0) =&amp;gt; '#',
                (1, 1) =&amp;gt; '.',
                _ =&amp;gt; '.',
            };
        }
    }

    Printer.Print2D(G);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc250/tasks/abc250_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc250/submissions/31522256"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに&lt;code&gt;x&lt;/code&gt;の位置を全探索してしまうと、計算量が&lt;code&gt;O(N)&lt;/code&gt;かかってしまい、全体計算量が&lt;code&gt;O(QN)&lt;/code&gt;となり実行時間制限に間に合いません。
そこで、あらかじめ&lt;code&gt;x&lt;/code&gt;の位置をキーとした辞書や配列などを用意しておきます。&lt;br /&gt;
クエリが与えられたら、&lt;code&gt;x&lt;/code&gt;の位置を&lt;code&gt;i&lt;/code&gt;とし、&lt;code&gt;i&lt;/code&gt;が端(&lt;code&gt;i=N-1&lt;/code&gt;)なら&lt;code&gt;i-1&lt;/code&gt;、それ以外ならば&lt;code&gt;i+1&lt;/code&gt;の位置を&lt;code&gt;j&lt;/code&gt;として、&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;の位置にある要素を入れ替え、位置をキーとした辞書の要素も入れ替えることで、クエリ当たりの計算量を&lt;code&gt;O(1)&lt;/code&gt;にすることができ、全体計算量&lt;code&gt;O(Q+N)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Enumerable.Range(1, N).ToArray();
    var dict = new Dictionary&amp;lt;int, int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        dict[A[i]] = i;
    }

    for (var k = 0; k &amp;lt; Q; k++)
    {
        var x = Scanner.Scan&amp;lt;int&amp;gt;();
        var i = dict[x];
        var j = i + 1 != N ? i + 1 : i - 1;
        var y = A[j];
        (A[i], A[j]) = (A[j], A[i]);
        dict[x] = j;
        dict[y] = i;
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc250/tasks/abc250_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc250/submissions/31525287"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc250/submissions/31554504"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文における最大の素数を考えたとき、&lt;code&gt;k=p*q^3, N&amp;lt;=1e18&lt;/code&gt;から、&lt;code&gt;q^3&amp;lt;=N&lt;/code&gt;までの素数を考えればいいため、&lt;code&gt;q&lt;/code&gt;以下となる素数群を昇順にソートしたものをあらかじめ用意しておきます。&lt;br /&gt;
それらの素数を&lt;code&gt;p&amp;lt;q&lt;/code&gt;の範囲で走査したときの、&lt;code&gt;p*q^3&amp;lt;=N&lt;/code&gt;となる組み合わせの数が答えとなります。&lt;br /&gt;
このとき、全探索してしまうと、素数の数を&lt;code&gt;M&lt;/code&gt;としたとき計算量&lt;code&gt;O(M^2)&lt;/code&gt;となり、&lt;code&gt;N=1e18&lt;/code&gt;のときに&lt;code&gt;M=78498&lt;/code&gt;となって実行時間制限に間に合いませんが、&lt;code&gt;p*q^3&amp;gt;N&lt;/code&gt;のときの&lt;code&gt;q&lt;/code&gt;以降の対象となりえない組み合わせを枝刈りすることで、実行時間制限に間に合わせることができます。&lt;br /&gt;
あるいは、&lt;code&gt;p&amp;lt;q&lt;/code&gt;の範囲で&lt;code&gt;q&lt;/code&gt;を二部探索することで計算量&lt;code&gt;O(MlogM)&lt;/code&gt;、&lt;code&gt;p*q^3&amp;gt;=N&lt;/code&gt;ならば&lt;code&gt;(p+1)*q^3&amp;gt;=N&lt;/code&gt;から&lt;code&gt;q&lt;/code&gt;を大きいほうから尺取り法で求めることで&lt;code&gt;O(M)&lt;/code&gt;で求めることができます。
また、&lt;code&gt;p*q^3&lt;/code&gt;の値が、64bit整数に収まらない場合もあるので、多倍長整数を使ったり、オーバーフローした場合の処理が必要となる場合があります。&lt;br /&gt;
C#の場合、整数のオーバーフローは例外が発生しませんが、&lt;code&gt;checked&lt;/code&gt;ブロックを使うことで例外を明示的に発生させることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var primes = Prime.Sieve((int)1e6).ToArray();
    var M = primes.Length;
    var answer = 0;
    var j = M - 1;
    for (var i = 0; i &amp;lt; j; i++)
    {
        while (i &amp;lt; j)
        {
            var p = (long)primes[i];
            var q = (long)primes[j] * primes[j] * primes[j];
            try
            {
                checked
                {
                    if (p * q &amp;lt;= N)
                    {
                        break;
                    }
                    else
                    {
                        j--;
                    }
                }
            }
            catch
            {
                j--;
            }
        }

        answer += j - i;
    }

    Console.WriteLine(answer);
}

public static IEnumerable&amp;lt;int&amp;gt; Sieve(int value)
{
    if (value &amp;lt; 2) yield break;
    yield return 2;
    var sieve = new bool[(value + 1) / 2];
    for (var i = 1; i &amp;lt; sieve.Length; i++)
    {
        if (sieve[i]) continue;
        yield return i * 2 + 1;
        for (var j = i; j &amp;lt; sieve.Length; j += i * 2 + 1) sieve[j] = true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc250/tasks/abc250_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc250/submissions/31543730"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc250/submissions/31553993"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;x&lt;/code&gt;番目までの要素に対応する&lt;code&gt;B&lt;/code&gt;の最小の出現位置の最大が&lt;code&gt;y&lt;/code&gt;以下であり、&lt;code&gt;B&lt;/code&gt;の&lt;code&gt;y&lt;/code&gt;番目までの要素に対応する&lt;code&gt;A&lt;/code&gt;の最小の出現位置の最大が&lt;code&gt;x&lt;/code&gt;以下であれば答えは&lt;code&gt;Yes&lt;/code&gt;となります。&lt;/p&gt;
&lt;p&gt;あらかじめ、&lt;code&gt;A&lt;/code&gt;の各要素の&lt;code&gt;B&lt;/code&gt;における最小の出現位置(&lt;code&gt;AtoB&lt;/code&gt;)と、&lt;code&gt;B&lt;/code&gt;の各要素の&lt;code&gt;A&lt;/code&gt;における最小の出現位置(&lt;code&gt;BtoA&lt;/code&gt;)を求めておき、クエリごとに&lt;code&gt;AtoB&lt;/code&gt;の&lt;code&gt;x&lt;/code&gt;までの最大値と&lt;code&gt;BtoA&lt;/code&gt;の&lt;code&gt;y&lt;/code&gt;までの最大値を求められるようにします。&lt;br /&gt;
このとき愚直に&lt;code&gt;x&lt;/code&gt;番目と&lt;code&gt;y&lt;/code&gt;番目までを走査してしまうとクエリ当たりの計算量が&lt;code&gt;O(N)&lt;/code&gt;となってしまうため、累積最大値をもとめておくことでクエリ当たりの計算量を&lt;code&gt;O(1)&lt;/code&gt;に抑えることができ、全体で&lt;code&gt;O(Q+NlogN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dictAB = new Dictionary&amp;lt;int, int&amp;gt;();
    var dictBA = new Dictionary&amp;lt;int, int&amp;gt;();
    const int inf = (int)1e9;
    for (var i = 0; i &amp;lt; N; i++)
    {
        dictAB[A[i]] = inf;
        dictAB[B[i]] = inf;
        dictBA[A[i]] = inf;
        dictBA[B[i]] = inf;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        dictAB[B[i]] = Math.Min(dictAB[B[i]], i + 1);
        dictBA[A[i]] = Math.Min(dictBA[A[i]], i + 1);
    }

    var cumAB = new int[N + 1];
    var cumBA = new int[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cumAB[i + 1] = Math.Max(cumAB[i], dictAB[A[i]]);
        cumBA[i + 1] = Math.Max(cumBA[i], dictBA[B[i]]);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        var answer = cumAB[x] &amp;lt;= y &amp;amp;&amp;amp; cumBA[y] &amp;lt;= x;
        Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 250の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220423abc249</id>
		<title>ABC249</title>
		<link href="https://blog.aconcavy.dev/posts/20220423abc249" />
		<updated>2022-04-23T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 249の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc249"&gt;https://atcoder.jp/contests/abc249&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31188853"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高橋君の進む距離を考えます。
歩く+休むを1セットとすると、&lt;code&gt;X&lt;/code&gt;秒間に&lt;code&gt;X/(A+C)&lt;/code&gt;セット(端数切り捨て)できるため、距離は合計で&lt;code&gt;セット数*A*B&lt;/code&gt;進むことができます。
また、&lt;code&gt;X&lt;/code&gt;から進んだセット数を引いたあまり&lt;code&gt;X%(A+C)&lt;/code&gt;のうち、最大&lt;code&gt;A&lt;/code&gt;秒間進むこともできるため、&lt;code&gt;Min(あまり,A)*B&lt;/code&gt;進むことができます。
この二つを合わせた距離が高橋君の進む距離となります。
&lt;code&gt;A秒間秒速Bメートルで歩き、C秒間休むことを繰り返した時のX秒後の距離&lt;/code&gt;を関数にすると、&lt;code&gt;F(A,B,C) = X/(A+C)*A*B + Min(X%(A+C),A)*B&lt;/code&gt;に定義できます。&lt;br /&gt;
同様に青木君の距離を求め、どちらが長い距離を進んだかを比較して答えを求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var line = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var (A, B, C) = (line[0], line[1], line[2]);
    var (D, E, F) = (line[3], line[4], line[5]);
    var X = line[6];
    int G(int a, int b, int c)
    {
        return (X / (a + c) * a * b) + Math.Min(X % (a + c), a) * b;
    }

    var takahashi = G(A, B, C);
    var aoki = G(D, E, F);
    var answer = &amp;quot;Draw&amp;quot;;
    if (takahashi &amp;gt; aoki) answer = &amp;quot;Takahashi&amp;quot;;
    if (takahashi &amp;lt; aoki) answer = &amp;quot;Aoki&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31188890"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一つずつ条件を判定していきます。&lt;br /&gt;
C#では、&lt;code&gt;char.IsUpper&lt;/code&gt;関数で文字の大文字判定、&lt;code&gt;char.IsLower&lt;/code&gt;関数で文字の小文字判定を行うことができます。
また、&lt;code&gt;全ての文字が相異なる&lt;/code&gt;ということは、&lt;code&gt;元の文字列の長さ=重複を除いたときの文字列の長さ&lt;/code&gt;といえます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;すべての文字をみて大文字が存在するかを判定する&lt;/li&gt;
&lt;li&gt;すべての文字をみて小文字が存在するかを判定する&lt;/li&gt;
&lt;li&gt;元の文字列の長さ=重複を除いたときの文字列の長さが成り立つかを判定する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;これらすべてが成り立っているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var M = S.Distinct().Count();
    var ok = N == M;
    var big = false;
    var small = false;
    foreach (var c in S)
    {
        big |= char.IsUpper(c);
        small |= char.IsLower(c);
    }

    ok &amp;amp;= big &amp;amp;&amp;amp; small;
    Console.WriteLine(ok ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31188932"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各文字列に対して使うor使わないの2択なため、&lt;code&gt;2^N&lt;/code&gt;個の組み合わせがあり得ます。
制約が&lt;code&gt;N&amp;lt;=15&lt;/code&gt;と少ないので、&lt;code&gt;bit全探索&lt;/code&gt;を行うことで全ての組み合わせを走査することができます。
&lt;code&gt;s&lt;/code&gt;を使用する&lt;code&gt;i&lt;/code&gt;の集合としたとき、&lt;code&gt;s&lt;/code&gt;において&lt;code&gt;i&lt;/code&gt;が使われているかを判定するには、&lt;code&gt;(s&amp;gt;&amp;gt;i&amp;amp;1)==1&lt;/code&gt;で求めることができます。
そして、それぞれの組み合わせにおいて、使う文字列集合を全て走査し、文字の個数が&lt;code&gt;K&lt;/code&gt;個の文字の種類の最大値を求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = 0;
    var exists = new bool[N, 26];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        foreach (var c in S)
        {
            exists[i, c - 'a'] = true;
        }
    }


    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        var count = new int[26];
        for (var i = 0; i &amp;lt; N; i++)
        {
            if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1)
            {
                for (var j = 0; j &amp;lt; 26; j++)
                {
                    count[j] += exists[i, j] ? 1 : 0;
                }
            }
        }

        var sum = 0;
        for (var i = 0; i &amp;lt; 26; i++)
        {
            if (count[i] == K) sum++;
        }

        answer = Math.Max(answer, sum);
    }
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31192606"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に全ての&lt;code&gt;i,j,k&lt;/code&gt;を走査する方法では、計算量が&lt;code&gt;O(N^3)&lt;/code&gt;となり、&lt;code&gt;A[j]*A[k]=A[i]&lt;/code&gt;となる&lt;code&gt;j,k&lt;/code&gt;を走査する方法では、計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となりますが、制約が&lt;code&gt;1&amp;lt;=N&amp;lt;=2e5&lt;/code&gt;と大きいため、実行時間制限内に処理を終わらせることができません。&lt;br /&gt;
そこで、あらかじめAの値の出現回数を数えておき、&lt;code&gt;1&amp;lt;=p,q,r&amp;lt;=2e5&lt;/code&gt;のうち、&lt;code&gt;p=q*r&lt;/code&gt;となる&lt;code&gt;p,q,r&lt;/code&gt;の組における組み合わせの個数の総和を求めます。
組み合わせの個数は&lt;code&gt;pの個数 * qの個数 * rの個数&lt;/code&gt;でもとめることができます。
&lt;code&gt;q&lt;/code&gt;を固定したとき、&lt;code&gt;r&lt;/code&gt;は&lt;code&gt;p/q (p&amp;lt;=2e5)&lt;/code&gt;まで走査すればよいため、計算量&lt;code&gt;O(MlogM)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var max = (int)2e5;
    var count = new long[max + 1];
    foreach (var a in A)
    {
        count[a]++;
    }

    var answer = 0L;
    for (var q = 1; q &amp;lt;= max; q++)
    {
        for (var r = 1; q * r &amp;lt;= max; r++)
        {
            var p = q * r;
            answer += count[p] * count[q] * count[r];
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 249の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220417abc248</id>
		<title>ABC248</title>
		<link href="https://blog.aconcavy.dev/posts/20220417abc248" />
		<updated>2022-04-18T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 248の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248"&gt;https://atcoder.jp/contests/abc248&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31002746"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の合計から登場する数字を全て引いた後の値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var sum = 9 * 10 / 2;
    foreach (var c in S)
    {
        sum -= c - '0';
    }

    Console.WriteLine(sum);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31006946"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初期値を&lt;code&gt;A&lt;/code&gt;として、&lt;code&gt;B&lt;/code&gt;より小さいうちに&lt;code&gt;A&lt;/code&gt;を何回&lt;code&gt;K&lt;/code&gt;倍することができるかを数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, K) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
    var curr = A;
    var answer = 0;
    while (curr &amp;lt; B)
    {
        curr *= K;
        answer++;
    }
        
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31016119"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の値まで決めたときに、それまでの総和が&lt;code&gt;j&lt;/code&gt;であるような数列の総数を動的計画法として答えを数え上げます。
これは、&lt;code&gt;i+1&lt;/code&gt;番目の値は、&lt;code&gt;i&lt;/code&gt;番目までの総和&lt;code&gt;j&lt;/code&gt;に&lt;code&gt;1&amp;lt;=k&amp;lt;=M&lt;/code&gt;の何れかを足した数への遷移することができます。
そのため、&lt;code&gt;dp[0,0]=1 (0番目までの総和は0)&lt;/code&gt;を初期値として遷移していき、&lt;code&gt;N&lt;/code&gt;番目まで見終わったときの&lt;code&gt;1&amp;lt;=k&amp;lt;=M&lt;/code&gt;の合計が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var NM = N * M;
    var dp = new mint[N + 1, NM + 1];
    dp[0, 0] = 1;
                
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= NM; j++)
        {
            for (var k = 1; k &amp;lt;= M; k++)
            {
                if (j + k &amp;lt;= NM) dp[i + 1, j + k] += dp[i, j];
            }
        }
    }
                
    mint answer = 0;
    for (var i = 1; i &amp;lt;= K; i++)
    {
        answer += dp[N, i];
    }
                
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31021126"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに指定された範囲を走査してしまうと、クエリごとの計算量が&lt;code&gt;O(N)&lt;/code&gt;、全体計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまい、実行時間制限内に終えることができないので、クエリごとの計算量を削減する方法を考えます。&lt;br /&gt;
ある値&lt;code&gt;X&lt;/code&gt;を考えたとき、&lt;code&gt;[L,R]&lt;/code&gt;の出現する場所の個数は&lt;code&gt;Rより大きい場所の番目 - L以上の場所の番目&lt;/code&gt;で求めることができます。&lt;br /&gt;
例えば、&lt;code&gt;A=[3,1,4,1,5]、L=1、R=3、X=1&lt;/code&gt;のとき、場所&lt;code&gt;idx[1]=[2,4]&lt;/code&gt;となり、&lt;code&gt;Rより大きい場所の番目 - L以上の場所の番目&lt;/code&gt;は&lt;code&gt;2番目-1番目&lt;/code&gt;なり、&lt;code&gt;1個&lt;/code&gt;となります。&lt;br /&gt;
そのため、あらかじめ値ごとに出現する場所を保持しておき、&lt;code&gt;L&lt;/code&gt;と&lt;code&gt;R&lt;/code&gt;の個数をそれぞれ二部探索することで、クエリごとの計算量が&lt;code&gt;O(logN)&lt;/code&gt;、全体計算量が&lt;code&gt;O(NlogN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var a = A[i];
        if (!dict.ContainsKey(a)) dict[a] = new List&amp;lt;int&amp;gt;();
        dict[a].Add(i);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (L, R, X) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        L--; R--;
        if (dict.ContainsKey(X))
        {
            var list = dict[X];
            var l = LowerBound(list, L);
            var r = UpperBound(list, R);
            Console.WriteLine(r - l);
        }
        else
        {
            Console.WriteLine(0);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31050544"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全ての2点間の傾き&lt;code&gt;a&lt;/code&gt;と切片&lt;code&gt;b&lt;/code&gt;を保持し、直線&lt;code&gt;y=ax+b&lt;/code&gt;が成り立つ点が&lt;code&gt;K&lt;/code&gt;個以上あればその直線は妥当?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WA&lt;/code&gt;が11個でる...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数え上げの方法が間違えていました。
ある点を固定したとき、その点からの傾きが同じものどうしで数え上げ、その傾きをとる頂点の個数が&lt;code&gt;K-1&lt;/code&gt;個ならば、その傾きの直線が妥当であるといえます。このとき
&lt;code&gt;K-1&lt;/code&gt;以上で数えてしまうと、その傾きを取る頂点の個数が&lt;code&gt;K+1、K、K-1&lt;/code&gt;のように重複して数えてしまうことに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    if (K == 1)
    {
        Console.WriteLine(&amp;quot;Infinity&amp;quot;);
        return;
    }

    var P = new (long X, long Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = (x, y);
    }


    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var dict = new Dictionary&amp;lt;Fraction, int&amp;gt;();
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var (x1, y1) = P[i];
            var (x2, y2) = P[j];
            var (dx, dy) = (x2 - x1, y2 - y1);
            var frac = new Fraction(dy, dx);
            if (!dict.ContainsKey(frac)) dict[frac] = 0;
            dict[frac]++;
        }

        foreach (var count in dict.Values)
        {
            if (count == K - 1) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public readonly struct Fraction : IComparable&amp;lt;Fraction&amp;gt;, IEquatable&amp;lt;Fraction&amp;gt;
{
    public long Y { get; }
    public long X { get; }
    public Fraction(long y, long x)
    {
        static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
        var g = Gcd(y, x);
        (Y, X) = (y / g, x / g);
    }
    public static bool operator &amp;lt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt; 0;
    public static bool operator &amp;lt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt;= 0;
    public static bool operator &amp;gt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt; 0;
    public static bool operator &amp;gt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt;= 0;
    public static bool operator ==(Fraction left, Fraction right) =&amp;gt; left.Equals(right);
    public static bool operator !=(Fraction left, Fraction right) =&amp;gt; !left.Equals(right);
    public int CompareTo(Fraction other) =&amp;gt; (Y * other.X).CompareTo(X * other.Y);
    public bool Equals(Fraction other) =&amp;gt; Y == other.Y &amp;amp;&amp;amp; X == other.X;
    public override bool Equals(object obj) =&amp;gt; obj is Fraction other &amp;amp;&amp;amp; Equals(other);
    public override int GetHashCode() =&amp;gt; HashCode.Combine(Y, X);
    public override string ToString() =&amp;gt; $&amp;quot;{Y}/{X}&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 248の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220410abc247</id>
		<title>ABC247</title>
		<link href="https://blog.aconcavy.dev/posts/20220410abc247" />
		<updated>2022-04-10T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 247の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc247"&gt;https://atcoder.jp/contests/abc247&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30847103"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[i+1] (0&amp;lt;=i&amp;lt;=2)&lt;/code&gt;の値を&lt;code&gt;S[i]&lt;/code&gt;に移動し、&lt;code&gt;S[0]&lt;/code&gt;は誰もいなくなるので&lt;code&gt;0&lt;/code&gt;にしたものが答えとなります。
つまり、&lt;code&gt;S&lt;/code&gt;の先頭に&lt;code&gt;0&lt;/code&gt;を追加した先頭4文字が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = &amp;quot;0&amp;quot; + S[0..3];
    Console.WriteLine(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30858089"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目のあだ名&lt;code&gt;ai&lt;/code&gt;を付けることができる条件は、あるあだ名が&lt;code&gt;j!=i&lt;/code&gt;番目の姓&lt;code&gt;sj&lt;/code&gt;と名&lt;code&gt;tj&lt;/code&gt;のいずれも一致しないことであり、あだ名に&lt;code&gt;si&lt;/code&gt;を使った場合と、&lt;code&gt;ti&lt;/code&gt;を使った場合をすべてチェックしてどちらか一方でも使うことができれば、そのあだ名を使うことができます。
これを全ての人に対して判定を行い、全ての人にあだ名を付けることができるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Names = new (string S, string T)[N];
    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, t) = Scanner.Scan&amp;lt;string, string&amp;gt;();
        Names[i] = (s, t);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = true;
        var t = true;
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (i == j) continue;
            s &amp;amp;= Names[i].S != Names[j].S &amp;amp;&amp;amp; Names[i].S != Names[j].T;
            t &amp;amp;= Names[i].T != Names[j].S &amp;amp;&amp;amp; Names[i].T != Names[j].T;
        }

        answer &amp;amp;= s || t;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30859642"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30895077"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初期値を&lt;code&gt;Si=1 (i=1)&lt;/code&gt;とし、&lt;code&gt;2&amp;lt;=i&amp;lt;=N&lt;/code&gt;では&lt;code&gt;S(i-1) i S(i-1)&lt;/code&gt;を文字列として構築することで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = &amp;quot;1&amp;quot;;
    for (var i = 2; i &amp;lt;= N; i++)
    {
        answer = $&amp;quot;{answer} {i} {answer}&amp;quot;;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30865508"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連結リストなどのデータ構造を使って、データを管理します。&lt;br /&gt;
&lt;code&gt;c&lt;/code&gt;の値が大きいため、リストに&lt;code&gt;c&lt;/code&gt;個の値を入れてしまうとクエリ当たりの計算量が&lt;code&gt;O(c)&lt;/code&gt;、全体で&lt;code&gt;O(Qc)&lt;/code&gt;となり、実行時間制限内に処理を終えることができません。
そこで、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;をペアとして管理することで、クエリ当たりの計算量が&lt;code&gt;O(1)&lt;/code&gt;、全体で&lt;code&gt;O(Q)&lt;/code&gt;となり、実行時間制限内に解くことができるようになります。&lt;br /&gt;
クエリが&lt;code&gt;1&lt;/code&gt;のときは&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;をペアとしてリストの後方に追加し、クエリが&lt;code&gt;2&lt;/code&gt;のときは、&lt;code&gt;c&lt;/code&gt;個消費できるまでリストの先頭から消費していきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var deq = new Deque&amp;lt;(long X, long C)&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            deq.PushBack((query[1], query[2]));
        }
        else
        {
            var c = query[1];
            long sum = 0;
            while (c &amp;gt; 0)
            {
                var top = deq.PopFront();
                var use = Math.Min(c, top.C);
                c -= use;
                sum += top.X * use;
                if (use &amp;lt; top.C)
                {
                    deq.PushFront((top.X, top.C - use));
                }
            }

            Console.WriteLine(sum);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30884870"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ai&amp;lt;Y &amp;amp;&amp;amp; X&amp;lt;Ai&lt;/code&gt;となる値が範囲に存在する場合、その範囲は無視することができるので、&lt;code&gt;Y&amp;lt;=Ai&amp;lt;=X&lt;/code&gt;のみで構成される連続部分列に分割し、連続部分列ごとに部分問題として数え上げることができるようになります。
例えば、&lt;code&gt;X=3, Y=2, A=[4,1,3,2,3,2,1,2]&lt;/code&gt;の場合、&lt;code&gt;A=[[3,2,3,2], [2]]&lt;/code&gt;と分割できます。&lt;br /&gt;
部分問題では、愚直に全探索してしまうと計算量&lt;code&gt;O(N^3)&lt;/code&gt;になりますが、尺取り法を用いることで計算量&lt;code&gt;O(N)&lt;/code&gt;で区間の数を数え上げることができます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;はじめ&lt;code&gt;L=1&lt;/code&gt;とする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&amp;lt;=R&amp;lt;=N&lt;/code&gt;において次のことを行う。
&lt;ol&gt;
&lt;li&gt;区間&lt;code&gt;[L,R]&lt;/code&gt;に&lt;code&gt;X&lt;/code&gt;と&lt;code&gt;Y&lt;/code&gt;がそれぞれ1つ以上存在する場合次のことを行う。
&lt;ol&gt;
&lt;li&gt;区間&lt;code&gt;[L,R&amp;lt;=r&amp;lt;=N]&lt;/code&gt;は全て条件を満たし、この個数は&lt;code&gt;N-R+1&lt;/code&gt;(計算量&lt;code&gt;O(1)&lt;/code&gt;)で求めることができる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt;を1進める。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;計算量は全体で&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    bool IsInRange(int v) =&amp;gt; Y &amp;lt;= v &amp;amp;&amp;amp; v &amp;lt;= X;

    var list = new List&amp;lt;List&amp;lt;int&amp;gt;&amp;gt;();
    var tmp = new List&amp;lt;int&amp;gt;();
    foreach (var a in A)
    {
        if (IsInRange(a))
        {
            tmp.Add(a);
        }
        else
        {
            list.Add(tmp.ToList());
            tmp = new List&amp;lt;int&amp;gt;();
        }
    }

    list.Add(tmp.ToList());
    list = list.Where(x =&amp;gt; x.Count &amp;gt; 0).ToList();
    long answer = 0;
    foreach (var group in list)
    {
        var l = 0;
        var M = group.Count;
        var used = new int[X + 1];
        for (var r = 0; r &amp;lt; M; r++)
        {
            used[group[r]]++;
            while (l &amp;lt;= r &amp;amp;&amp;amp; used[X] &amp;gt; 0 &amp;amp;&amp;amp; used[Y] &amp;gt; 0)
            {
                answer += M - r;
                used[group[l]]--;
                l++;
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 247の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>