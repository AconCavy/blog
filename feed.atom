<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title />
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2023 AconCavy</rights>
	<updated>2023-02-04T14:21:52Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230204abc288</id>
		<title>ABC288</title>
		<link href="https://blog.aconcavy.dev/posts/20230204abc288" />
		<updated>2023-02-04T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 288の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc288"&gt;https://atcoder.jp/contests/abc288&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC288/submissions/38605622"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリに対して&lt;code&gt;A+B&lt;/code&gt;の答えを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        var answer = A + B;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC288/submissions/38601324"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上位&lt;code&gt;K&lt;/code&gt;人のみ取得し、辞書順にソートしたものを出力します。
C#では、文字列の配列に対して、&lt;code&gt;Array.Sort&lt;/code&gt;メソッドを使うことでソートすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[K];
    for (var i = 0; i &amp;lt; K; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    Array.Sort(S);
    Console.WriteLine(string.Join(Environment.NewLine, S));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC288/submissions/38595128"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;A&lt;/code&gt;と頂点&lt;code&gt;B&lt;/code&gt;が同じ連結成分である場合、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;に辺を追加してしまうと閉路ができてしまいます。
そのため、&lt;code&gt;DisjointSetUnion&lt;/code&gt;などのデータ構造を使い、辺をつなごうとする頂点同士が同じ連結成分であるかを判定し、同じ連結成分であればその辺を削除します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dsu = new DisjointSetUnion(N);
    var answer = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        if (dsu.IsSame(a, b)) answer++;
        dsu.Merge(a, b);
    }

    Console.WriteLine(answer);
}

public class DisjointSetUnion
{
    public int Length { get; }
    private readonly int[] _parentOrSize;
    public DisjointSetUnion(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _parentOrSize = new int[Length];
        Array.Fill(_parentOrSize, -1);
    }
    public int Merge(int u, int v)
    {
        if (u &amp;lt; 0 || Length &amp;lt;= u) throw new ArgumentOutOfRangeException(nameof(u));
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        var (x, y) = (LeaderOf(u), LeaderOf(v));
        if (x == y) return x;
        if (-_parentOrSize[x] &amp;lt; -_parentOrSize[y]) (x, y) = (y, x);
        _parentOrSize[x] += _parentOrSize[y];
        _parentOrSize[y] = x;
        return x;
    }
    public bool IsSame(int u, int v)
    {
        if (u &amp;lt; 0 || Length &amp;lt;= u) throw new ArgumentOutOfRangeException(nameof(u));
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        return LeaderOf(u) == LeaderOf(v);
    }
    public int LeaderOf(int v)
    {
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        if (_parentOrSize[v] &amp;lt; 0) return v;
        return _parentOrSize[v] = LeaderOf(_parentOrSize[v]);
    }
    public int SizeOf(int v)
    {
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        return -_parentOrSize[LeaderOf(v)];
    }
    public IEnumerable&amp;lt;IReadOnlyCollection&amp;lt;int&amp;gt;&amp;gt; GetGroups()
    {
        var result = new List&amp;lt;int&amp;gt;[Length].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
        for (var i = 0; i &amp;lt; Length; i++) result[LeaderOf(i)].Add(i);
        return result.Where(x =&amp;gt; x.Count &amp;gt; 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けてません;;&lt;/p&gt;
&lt;!-- [コンテスト提出]()  
[復習提出]()

```csharp
``` --&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 288の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230128abc287</id>
		<title>ABC287</title>
		<link href="https://blog.aconcavy.dev/posts/20230128abc287" />
		<updated>2023-01-28T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 287の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287"&gt;https://atcoder.jp/contests/abc287&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38375686"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入力から&lt;code&gt;For&lt;/code&gt;の個数を数え上げ、その個数の2倍が&lt;code&gt;N&lt;/code&gt;より大きければ過半数が提案に賛成しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var f = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        if (S == &amp;quot;For&amp;quot;) f++;
    }

    var answer = f * 2 &amp;gt; N ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38380732"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;S&lt;/code&gt;の末尾3文字が&lt;code&gt;T&lt;/code&gt;のいずれかと一致しているかを各&lt;code&gt;S&lt;/code&gt;と各&lt;code&gt;T&lt;/code&gt;の組み合わせを全探索することで、時間計算量&lt;code&gt;O(NM)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
また、&lt;code&gt;T&lt;/code&gt;の集合を&lt;code&gt;Set&lt;/code&gt;や&lt;code&gt;HashSet&lt;/code&gt;などのデータ構造で管理することで、時間計算量を&lt;code&gt;O(NlogM)&lt;/code&gt;、&lt;code&gt;O(N)&lt;/code&gt;にすることもできます。&lt;br /&gt;
ほかにも、入力が数値のみであることから、大きさが&lt;code&gt;1000&lt;/code&gt;以上の配列を用意して&lt;code&gt;T&lt;/code&gt;を配列のインデックスとして存在判定し、&lt;code&gt;S%1000&lt;/code&gt;でその配列にアクセスすることで、時間計算量&lt;code&gt;O(N+M)&lt;/code&gt;で解くこともできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        S[i] = s[3..];
    }

    var T = new HashSet&amp;lt;string&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var t = Scanner.Scan&amp;lt;string&amp;gt;();
        T.Add(t);
    }

    var answer = 0;
    foreach (var s in S)
    {
        if (T.Contains(s)) answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38385675"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直線になるようなグラフがパスグラフになります。
これは、グラフを構成する辺が&lt;code&gt;N-1&lt;/code&gt;本であり、端点となる2つの頂点は次数が&lt;code&gt;1&lt;/code&gt;、それ以外は次数が&lt;code&gt;2&lt;/code&gt;であり、連結であるグラフです。
グラフが連結であるかどうかは幅/深さ優先探索や&lt;code&gt;DisjointSetUnion&lt;/code&gt;で調べることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    if (M != N - 1 || G.Any(x =&amp;gt; x.Count &amp;gt; 2))
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
        return;
    }

    var used = new bool[N];
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(0);
    used[0] = true;
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        foreach (var v in G[u].Where(x =&amp;gt; !used[x]))
        {
            used[v] = true;
            queue.Enqueue(v);
        }
    }

    var answer = used.All(x =&amp;gt; x);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38402756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の先頭から&lt;code&gt;i&lt;/code&gt;文字が一致しているかを&lt;code&gt;first[i]&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;i==0のとき、
first[0] = true

i&amp;gt;=1のとき、
f1 = S[i] == T[i]
f2 = S[i] == '?'
f3 = T[i] == '?'
first[i] = first[i - 1] &amp;amp;&amp;amp; (f1 || f2 || f3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同様に末尾から&lt;code&gt;i&lt;/code&gt;文字が一致しているかを&lt;code&gt;last[i]&lt;/code&gt;とすると、各&lt;code&gt;x&lt;/code&gt;に対する答えを&lt;code&gt;f(x)&lt;/code&gt;とすると次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;f(x) == first[x] &amp;amp;&amp;amp; last[|T| - x]`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事前に&lt;code&gt;first&lt;/code&gt;と&lt;code&gt;last&lt;/code&gt;を時間計算量&lt;code&gt;O(|T|)&lt;/code&gt;で求めておくことで、&lt;code&gt;f(x)&lt;/code&gt;は時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができ、全体計算量は&lt;code&gt;O(|T|)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = T.Length;
    var first = new bool[N + 1];
    var last = new bool[N + 1];
    first[0] = last[0] = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var sj = S.Length - 1 - i;
        var tj = T.Length - 1 - i;
        var ff = S[i] == '?' || T[i] == '?' || S[i] == T[i];
        var fl = S[sj] == '?' || T[tj] == '?' || S[sj] == T[tj];
        first[i + 1] = first[i] &amp;amp;&amp;amp; ff;
        last[i + 1] = last[i] &amp;amp;&amp;amp; fl;
    }

    for (var x = 0; x &amp;lt;= N; x++)
    {
        var y = N - x;
        var answer = first[x] &amp;amp;&amp;amp; last[y];
        Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38399917"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての文字列において、長さ&lt;code&gt;0&amp;lt;=k&amp;lt;=|S|&lt;/code&gt;の連続部分文字列&lt;code&gt;T&lt;/code&gt;となる個数をあらかじめ求めておき、各&lt;code&gt;i&lt;/code&gt;における長さ&lt;code&gt;k&lt;/code&gt;の&lt;code&gt;T&lt;/code&gt;の個数が2個以上存在する場合、&lt;code&gt;LCP(i,?)==k&lt;/code&gt;が成立するため、その&lt;code&gt;k&lt;/code&gt;の最大が&lt;code&gt;i&lt;/code&gt;に対する答えとなります。
連続部分文字列の管理に&lt;code&gt;RollingHash&lt;/code&gt;などを使うことで、連続部分列の計算を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができ、全体時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new string[N];
    var dict = new Dictionary&amp;lt;ulong, Dictionary&amp;lt;int, int&amp;gt;&amp;gt;();
    var rhs = new RollingHash[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        S[i] = s;
        var rh = new RollingHash(s);
        rhs[i] = rh;
        for (var j = 0; j &amp;lt;= s.Length; j++)
        {
            var h = rh.SlicedHash(0, j);
            if (!dict.ContainsKey(h)) dict[h] = new Dictionary&amp;lt;int, int&amp;gt;();
            if (!dict[h].ContainsKey(j)) dict[h][j] = 0;
            dict[h][j]++;
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var answer = 0;
        for (var j = 0; j &amp;lt;= S[i].Length; j++)
        {
            var h = rhs[i].SlicedHash(0, j);
            if (dict[h].ContainsKey(j) &amp;amp;&amp;amp; dict[h][j] &amp;gt;= 2) answer = j;
        }

        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RollingHash&lt;/code&gt;について、keymoonさんの&lt;a href="https://qiita.com/keymoon/items/11fac5627672a6d6a9f6"&gt;安全で爆速なRollingHashの話&lt;/a&gt;を参考にしました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class RollingHash
{
    private const ulong Mask30 = (1UL &amp;lt;&amp;lt; 30) - 1;
    private const ulong Mask31 = (1UL &amp;lt;&amp;lt; 31) - 1;
    private const ulong Modulo = (1UL &amp;lt;&amp;lt; 61) - 1;
    private const ulong Positivizer = Modulo * ((1UL &amp;lt;&amp;lt; 3) - 1);
    public static readonly ulong Base;
    static RollingHash()
    {
        Base = (ulong)new Random().Next(1 &amp;lt;&amp;lt; 8, int.MaxValue);
    }
    private readonly ulong[] _powers;
    private readonly ulong[] _hash;
    public RollingHash(ReadOnlySpan&amp;lt;char&amp;gt; s)
    {
        _powers = new ulong[s.Length + 1];
        _powers[0] = 1;
        _hash = new ulong[s.Length + 1];
        for (var i = 0; i &amp;lt; s.Length; i++)
        {
            _powers[i + 1] = CalcModulo(Multiply(_powers[i], Base));
            _hash[i + 1] = CalcModulo(Multiply(_hash[i], Base) + s[i]);
        }
    }
    public ulong SlicedHash(int start, int length)
    {
        return CalcModulo(_hash[start + length] + Positivizer - Multiply(_hash[start], _powers[length]));
    }
    private static ulong Multiply(ulong a, ulong b)
    {
        var au = a &amp;gt;&amp;gt; 31;
        var ad = a &amp;amp; Mask31;
        var bu = b &amp;gt;&amp;gt; 31;
        var bd = b &amp;amp; Mask31;
        var m = ad * bu + au * bd;
        var mu = m &amp;gt;&amp;gt; 30;
        var md = m &amp;amp; Mask30;
        return ((au * bu) &amp;lt;&amp;lt; 1) + mu + (md &amp;lt;&amp;lt; 31) + ad * bd;
    }
    private static ulong CalcModulo(ulong v)
    {
        var vu = v &amp;gt;&amp;gt; 61;
        var vd = v &amp;amp; Modulo;
        var x = vu + vd;
        return x &amp;lt; Modulo ? x : x - Modulo;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 287の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230121abc286</id>
		<title>ABC286</title>
		<link href="https://blog.aconcavy.dev/posts/20230121abc286" />
		<updated>2023-01-21T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 286の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc286"&gt;https://atcoder.jp/contests/abc286&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38191422"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入れ替える数列の個数は&lt;code&gt;M=Q-P(==S-R)&lt;/code&gt;個であり、&lt;code&gt;0&amp;lt;=i&amp;lt;M&lt;/code&gt;の&lt;code&gt;A[P+i]&lt;/code&gt;と&lt;code&gt;A[R+i]&lt;/code&gt;を入れ替えたものが&lt;code&gt;B&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P, Q, R, S) = Scanner.Scan&amp;lt;int, int, int, int, int&amp;gt;();
    P--; R--;
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var M = Q - P;
    for (var i = 0; i &amp;lt; M; i++)
    {
        (A[P + i], A[R + i]) = (A[R + i], A[P + i]);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38192528"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;のうち、&lt;code&gt;na&lt;/code&gt;を&lt;code&gt;nya&lt;/code&gt;に置き換えたものが答えとなるので、&lt;code&gt;string&lt;/code&gt;の&lt;code&gt;Replace&lt;/code&gt;メソッドや、文字を順にみていき&lt;code&gt;n&lt;/code&gt;の次に&lt;code&gt;a&lt;/code&gt;がある場合、&lt;code&gt;y&lt;/code&gt;を追加するといったアルゴリズムで解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = S.Replace(&amp;quot;na&amp;quot;, &amp;quot;nya&amp;quot;);
    Console.WriteLine(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var builder = new StringBuilder();
    for (var i = 0; i &amp;lt; N; i++)
    {
        builder.Append(S[i]);
        if(i + 1 &amp;lt; N &amp;amp;&amp;amp; S[i] == 'n' &amp;amp;&amp;amp; S[i + 1] == 'a')
        {
            builder.Append('y');
        }
    }
    var T = builder.ToString();
    Console.WriteLine(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38202828"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に文字列をシフトして、シフトした文字列が回文かどうかを判定することで、時間計算量&lt;code&gt;O(N^2)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    const long inf = (long)1e18;
    var answer = inf;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A * i &amp;gt;= answer) continue;
        var sum = A * i;
        var T = Shift&amp;lt;char&amp;gt;(S, -i);

        for (var j = 0; j * 2 &amp;lt; N; j++)
        {
            if (T[j] == T[N - 1 - j]) continue;
            sum += B;
        }

        answer = Math.Min(answer, sum);
    }

    Console.WriteLine(answer);
}

public static T[] Shift&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, int shift)
{
    shift = (shift + source.Length) % source.Length;
    if (shift == 0) return source.ToArray();
    var result = new T[source.Length];
    source[^shift..].CopyTo(result.AsSpan(..shift));
    source[..^shift].CopyTo(result.AsSpan(shift..));
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38205698"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][j] := i番目まで見たときちょうどj円にする組み合わせを作ることができるか
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、状態は次のような遷移が可能です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i+1][j+a*k] |= dp[i][j] (0&amp;lt;=j&amp;lt;=X, 0&amp;lt;=k&amp;lt;=b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;時間計算量は&lt;code&gt;O(NX^2)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new bool[N + 1, X + 1];
    dp[0, 0] = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        for (var j = 0; j &amp;lt;= X; j++)
        {
            if (!dp[i, j]) continue;
            for (var k = 0; k &amp;lt;= b &amp;amp;&amp;amp; j + a * k &amp;lt;= X; k++)
            {
                dp[i + 1, j + a * k] |= dp[i, j];
            }
        }
    }

    var answer = dp[N, X];
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38218817"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;都市&lt;code&gt;u&lt;/code&gt;から都市&lt;code&gt;v&lt;/code&gt;に移動すると、お土産の価値の合計は&lt;code&gt;A[u]+A[v]&lt;/code&gt;になります。
また、都市&lt;code&gt;u&lt;/code&gt;から都市&lt;code&gt;k&lt;/code&gt;を経由して都市&lt;code&gt;v&lt;/code&gt;に移動すると、お土産の価値の合計は、&lt;code&gt;A[u]+A[k]+A[v]&lt;/code&gt;ですが、これは都市&lt;code&gt;u&lt;/code&gt;から都市&lt;code&gt;k&lt;/code&gt;に移動したときのお土産の価値(&lt;code&gt;A[u]+A[k]&lt;/code&gt;)と都市&lt;code&gt;k&lt;/code&gt;から都市&lt;code&gt;v&lt;/code&gt;に移動したときのお土産の価値(&lt;code&gt;A[k]+A[v]&lt;/code&gt;)から、&lt;code&gt;A[k]&lt;/code&gt;を引いたもの、つまり&lt;code&gt;(A[u]+A[k])+(A[k]+A[v])-A[k]&lt;/code&gt;として求めることができます。&lt;/p&gt;
&lt;p&gt;この法則を利用し、ワーシャルフロイド法で使う直行便の数が最小となる時のお土産の価値の総和を時間計算量&lt;code&gt;O(N^3)&lt;/code&gt;であらかじめ求めておくことで、クエリ当たり時間計算量&lt;code&gt;O(1)&lt;/code&gt;で答えることができるようになります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;から&lt;code&gt;j&lt;/code&gt;に移動するときに使う直行便の数、&lt;code&gt;V[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;から&lt;code&gt;j&lt;/code&gt;に移動するときのお土産の価値としたとき、&lt;code&gt;k&lt;/code&gt;を経由した&lt;code&gt;C[i][j]&lt;/code&gt;と&lt;code&gt;V[i][j]&lt;/code&gt;の更新は、&lt;code&gt;c=C[i][k]+C[k][j]&lt;/code&gt;、&lt;code&gt;v=V[i][k]+V[k][j]-A[k]&lt;/code&gt;としたとき、次のようになります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c == C[i][j]&lt;/code&gt;のとき、&lt;code&gt;V[i][j]=Max(V[i][j], v)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c &amp;lt; C[i][j]&lt;/code&gt;のとき、&lt;code&gt;C[i][j]=c&lt;/code&gt;、&lt;code&gt;V[i][j]=v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        G[i] = S.Select(x =&amp;gt; x == 'Y').ToArray();
    }

    const long inf = (long)1e18;
    var values = new long[N, N];
    var counts = new long[N, N];

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            values[i, j] = G[i][j] ? A[i] + A[j] : -inf;
            counts[i, j] = G[i][j] ? 1 : inf;
        }

        values[i, i] = 0;
        counts[i, i] = 0;
    }

    for (var k = 0; k &amp;lt; N; k++)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                var count = counts[i, k] + counts[k, j];
                var value = values[i, k] + values[k, j] - A[k];
                if (count == counts[i, j])
                {
                    values[i, j] = Math.Max(values[i, j], value);
                }
                else if (count &amp;lt; counts[i, j])
                {
                    counts[i, j] = count;
                    values[i, j] = value;
                }
            }
        }
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        var count = counts[u, v];
        var value = values[u, v];
        if (count == inf)
        {
            Console.WriteLine(&amp;quot;Impossible&amp;quot;);
        }
        else
        {
            Console.WriteLine($&amp;quot;{count} {value}&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 286の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230115abc285</id>
		<title>ABC285</title>
		<link href="https://blog.aconcavy.dev/posts/20230115abc285" />
		<updated>2023-01-15T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 285の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc285"&gt;https://atcoder.jp/contests/abc285&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc285/tasks/abc285_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC285/submissions/38041541"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;図を見て全ての&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;の組み合わせを判定することもできますが、もっと簡単な方法はないか考えます。&lt;br /&gt;
図は完全二分木であり、親&lt;code&gt;x&lt;/code&gt;は、子&lt;code&gt;x*2&lt;/code&gt;と子&lt;code&gt;x*2+1&lt;/code&gt;につながっていることがわかります。
そして、直接結ばれているかどうかは、親子が直接的につながっている必要があることから、&lt;code&gt;a*2==b&lt;/code&gt;または&lt;code&gt;a*2+1==b&lt;/code&gt;であることが判定の条件となります。
また、&lt;code&gt;Floor(b/2)==a&lt;/code&gt;も成り立ちます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = b / 2 == a ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc285/tasks/abc285_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC285/submissions/38047012"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文が複雑ですが、&lt;code&gt;l&lt;/code&gt;は&lt;code&gt;S[k]!=S[k+i]&lt;/code&gt;が&lt;code&gt;k=0&lt;/code&gt;から何回続けることができるかを表します。
そのため、各&lt;code&gt;i(1&amp;lt;=i&amp;lt;=N-1)&lt;/code&gt;において、&lt;code&gt;S[k]!=S[k+i] (0&amp;lt;=k&amp;lt;N-i)&lt;/code&gt;が何回成り立つかを数え上げることで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    for (var i = 1; i &amp;lt;= N - 1; i++)
    {
        var l = 0;
        for (var k = 0; k + i &amp;lt; N; k++)
        {
            if (S[k] != S[k + i]) l++;
            else break;
        }

        Console.WriteLine(l);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc285/tasks/abc285_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC285/submissions/38049184"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A==1,B==2,...,Z==26,AA==27,...&lt;/code&gt;であることから、&lt;code&gt;S&lt;/code&gt;の値を&lt;code&gt;26進数+1&lt;/code&gt;としたとき、10進数で&lt;code&gt;S&lt;/code&gt;の値はいくらかという問題になります。
&lt;code&gt;S=ABC&lt;/code&gt;の場合は&lt;code&gt;1(A)*26^2 + 2(B)*26^1 + 3(C)*26^0&lt;/code&gt;のようになり、各桁の値に26のべき乗を掛けたものとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    long b = 1;
    long answer = 0;
    foreach (var c in S.Select(x =&amp;gt; x - 'A' + 1).Reverse())
    {
        answer += c * b;
        b *= 26;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc285/tasks/abc285_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC285/submissions/38052012"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC285/submissions/38079089"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ユーザ名を頂点とし、ユーザ名の変更を頂点&lt;code&gt;s&lt;/code&gt;から頂点&lt;code&gt;t&lt;/code&gt;への有効辺としたグラフとして考えたとき、グラフに閉路がある場合は変更することができません。(&lt;code&gt;a-&amp;gt;b-&amp;gt;c-&amp;gt;a&lt;/code&gt;としたとき、&lt;code&gt;b&lt;/code&gt;の変更は&lt;code&gt;a&lt;/code&gt;が必要だが、&lt;code&gt;a&lt;/code&gt;の変更は&lt;code&gt;c&lt;/code&gt;が必要であり、&lt;code&gt;c&lt;/code&gt;の変更は&lt;code&gt;b&lt;/code&gt;が必要となる。)
そのため、構築したグラフに閉路があるか判定することで、答えを求めることができます。
閉路の判定は、深さ優先探索や&lt;code&gt;DisjointSetUnion&lt;/code&gt;、トポロジカルソートなどで求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;string, int&amp;gt;();
    var M = N * 2;
    var G = new List&amp;lt;int&amp;gt;[M].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var inDeg = new int[M];
    var idx = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, t) = Scanner.Scan&amp;lt;string, string&amp;gt;();
        if (!dict.ContainsKey(s)) dict[s] = idx++;
        if (!dict.ContainsKey(t)) dict[t] = idx++;
        var (u, v) = (dict[s], dict[t]);
        inDeg[v]++;
        G[u].Add(v);
    }

    var queue = new Queue&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        if (inDeg[i] == 0) queue.Enqueue(i);
    }

    var sorted = new int[M];
    var curr = 0;
    while (queue.TryDequeue(out var u))
    {
        foreach (var v in G[u])
        {
            inDeg[v]--;
            if (inDeg[v] == 0) queue.Enqueue(v);
        }

        sorted[curr++] = u;
    }

    var answer = curr == M;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc285/tasks/abc285_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けていません。&lt;/p&gt;
&lt;!-- [コンテスト提出]()  
[復習提出]()

```csharp
``` --&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc285/tasks/abc285_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC285/submissions/38066519"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC285/submissions/38078379"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[l..r]&lt;/code&gt;が&lt;code&gt;T&lt;/code&gt;の部分文字列であるには、&lt;code&gt;T&lt;/code&gt;が昇順であることから、&lt;code&gt;S[l..r]&lt;/code&gt;も昇順である必要があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[l..r]&lt;/code&gt;が昇順であるかの判定について、&lt;code&gt;S[l..r]&lt;/code&gt;に含まれる文字ごとの個数を順にみていき、&lt;code&gt;ll=l+既にみた文字の個数&lt;/code&gt;、&lt;code&gt;cc=現在の文字の個数&lt;/code&gt;、&lt;code&gt;rr=ll+cc-1&lt;/code&gt;としたとき、&lt;code&gt;S[ll..rr]&lt;/code&gt;に含まれる現在の文字の個数が&lt;code&gt;cc&lt;/code&gt;と等しくなる必要があります。&lt;br /&gt;
例えば、&lt;code&gt;S==aaabcba&lt;/code&gt;、&lt;code&gt;l==3&lt;/code&gt;、&lt;code&gt;r==6&lt;/code&gt;としたとき、&lt;code&gt;T==aaaabbc&lt;/code&gt;、&lt;code&gt;S[l..r]==abcb&lt;/code&gt;になります。
文字&lt;code&gt;a&lt;/code&gt;について考えると、&lt;code&gt;ll=l&lt;/code&gt;、&lt;code&gt;cc=1&lt;/code&gt;、&lt;code&gt;rr=ll&lt;/code&gt;となり、&lt;code&gt;S[ll..rr]==a&lt;/code&gt;であり、&lt;code&gt;cc&lt;/code&gt;と等しくなります。
文字&lt;code&gt;b&lt;/code&gt;について考えると、&lt;code&gt;ll=l+1&lt;/code&gt;、&lt;code&gt;cc=2&lt;/code&gt;、&lt;code&gt;rr=ll+1&lt;/code&gt;となり、&lt;code&gt;S[ll..rr]=bc&lt;/code&gt;であり、&lt;code&gt;cc&lt;/code&gt;と異なるので、&lt;code&gt;S[l..r]&lt;/code&gt;は昇順ではありません。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[l..r]&lt;/code&gt;が昇順であるとき、&lt;code&gt;S[l..r]&lt;/code&gt;が&lt;code&gt;T&lt;/code&gt;の部分文字列であるかの判定について、&lt;code&gt;S[l..r]&lt;/code&gt;に含まれる最も小さい文字&lt;code&gt;a&lt;/code&gt;、最も大きい文字&lt;code&gt;z&lt;/code&gt;としたとき、&lt;code&gt;a&amp;lt;c&amp;lt;z&lt;/code&gt;となる&lt;code&gt;c&lt;/code&gt;の個数は、&lt;code&gt;T&lt;/code&gt;に含まれる&lt;code&gt;c&lt;/code&gt;の個数と一致する必要があります。&lt;br /&gt;
例えば、&lt;code&gt;S==aabccde&lt;/code&gt;、&lt;code&gt;l==2&lt;/code&gt;、&lt;code&gt;r==6&lt;/code&gt;としたとき、&lt;code&gt;T==aabccde&lt;/code&gt;、&lt;code&gt;S[l..r]==abccd&lt;/code&gt;になり、&lt;code&gt;S[l..r]&lt;/code&gt;に含まれる最も小さい文字は&lt;code&gt;a&lt;/code&gt;、最も大きい文字は&lt;code&gt;d&lt;/code&gt;なので、&lt;code&gt;b==1&lt;/code&gt;と&lt;code&gt;c==2&lt;/code&gt;となり&lt;code&gt;T&lt;/code&gt;に含まれる&lt;code&gt;b&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;の数に一致するので、部分文字列となります。
一方、&lt;code&gt;S==aabccdc&lt;/code&gt;、&lt;code&gt;l==2&lt;/code&gt;、&lt;code&gt;r==6&lt;/code&gt;としたとき、&lt;code&gt;T==aabcccd&lt;/code&gt;、&lt;code&gt;S[l..r]==abccd&lt;/code&gt;になり、&lt;code&gt;S[l..r]&lt;/code&gt;に含まれる最も小さい文字は&lt;code&gt;a&lt;/code&gt;、最も大きい文字は&lt;code&gt;d&lt;/code&gt;なので、&lt;code&gt;b==1&lt;/code&gt;と&lt;code&gt;c==2&lt;/code&gt;になりますが、&lt;code&gt;T&lt;/code&gt;に含まれる&lt;code&gt;b&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;の数に一致しないので、部分文字列にはなりません。&lt;/p&gt;
&lt;p&gt;これらのことから、現在の各文字の個数と現在の各文字の指定した範囲にある個数を求められるデータ構造が必要となります。
前者は配列、後者は&lt;code&gt;FenwickTree&lt;/code&gt;などのデータ構造を使うことで求めることができ、クエリ当たりの時間計算量は&lt;code&gt;O(logN)&lt;/code&gt;となり、全体時間計算量は&lt;code&gt;O(N+QlogN)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - 'a').ToArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var fts = new FenwickTree[26].Select(_ =&amp;gt; new FenwickTree(N)).ToArray();
    var sc = new int[26];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i];
        sc[c]++;
        fts[c].Add(i, 1);
    }

    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
        if (query[0] == &amp;quot;1&amp;quot;)
        {
            var (x, c) = (int.Parse(query[1]) - 1, query[2][0] - 'a');
            var p = S[x];
            S[x] = c;
            fts[p].Add(x, -1);
            fts[c].Add(x, 1);
            sc[p]--;
            sc[c]++;
        }
        else
        {
            var (l, r) = (int.Parse(query[1]) - 1, int.Parse(query[2]));
            var tc = new int[26];
            for (var i = 0; i &amp;lt; 26; i++)
            {
                tc[i] = (int)fts[i].Sum(l, r);
            }

            var alpha = 0;
            var ll = l;
            var answer = true;
            while (alpha &amp;lt; 26 &amp;amp;&amp;amp; tc[alpha] == 0) alpha++;

            if (alpha &amp;lt; 26)
            {
                ll += tc[alpha];
                alpha++;
            }

            while (answer &amp;amp;&amp;amp; alpha &amp;lt; 26 &amp;amp;&amp;amp; ll + tc[alpha] &amp;lt;= r)
            {
                var rr = ll + tc[alpha];
                if (rr &amp;lt; r)
                {
                    answer &amp;amp;= sc[alpha] == tc[alpha];
                }
                else
                {
                    answer &amp;amp;= sc[alpha] &amp;gt;= tc[alpha];
                }

                answer &amp;amp;= tc[alpha] == fts[alpha].Sum(ll, rr);
                ll = rr;
                alpha++;
            }

            Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 285の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230107abc284</id>
		<title>ABC284</title>
		<link href="https://blog.aconcavy.dev/posts/20230107abc284" />
		<updated>2023-01-07T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 284の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc284"&gt;https://atcoder.jp/contests/abc284&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc284/tasks/abc284_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC284/submissions/37794799"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列を配列に受け取り、その配列を逆順にしたものを出力します。
インデックスを逆順に参照したり、&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;の&lt;code&gt;Reverse()&lt;/code&gt;で逆順にしたものを得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    Console.WriteLine(string.Join(Environment.NewLine, S.Reverse()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc284/tasks/abc284_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC284/submissions/37797656"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;のうち奇数(2で割ったとき1余るもの)の個数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;
public static void Solve()
{
    var T = Scanner.Scan&amp;lt;int&amp;gt;();
    while (T-- &amp;gt; 0)
    {
        var N = Scanner.Scan&amp;lt;int&amp;gt;();
        var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var answer = A.Count(x =&amp;gt; x % 2 == 1);
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc284/tasks/abc284_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC284/submissions/37800764"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;始点を順に決めて幅優先探索を行ったり、&lt;code&gt;DisjointSetUnion&lt;/code&gt;等のデータ構造を用いることで連結集合の個数を求めることができます。&lt;/p&gt;
&lt;h4 id="section-2"&gt;始点を順に決めて幅優先探索する方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    var answer = 0;
    var queue = new Queue&amp;lt;int&amp;gt;();
    var used = new bool[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (used[i]) continue;
        answer++;
        queue.Enqueue(i);
        while (queue.Count &amp;gt; 0)
        {
            var u = queue.Dequeue();
            foreach (var v in G[u])
            {
                if (used[v]) continue;
                used[v] = true;
                queue.Enqueue(v);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="disjointsetunion"&gt;&lt;code&gt;DisjointSetUnion&lt;/code&gt;を使う方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dsu = new DisjointSetUnion(N);
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        dsu.Merge(u, v);
    }

    var answer = dsu.GetGroups().Count();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc284/tasks/abc284_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC284/submissions/37847198"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある素数&lt;code&gt;a&lt;/code&gt;で&lt;code&gt;N&lt;/code&gt;を割り切れる場合、&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;p&lt;/code&gt;のときと&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;q&lt;/code&gt;の二通りの可能性があります。
&lt;code&gt;p==a&lt;/code&gt;の場合、つまり&lt;code&gt;N/p%p==0&lt;/code&gt;の場合は&lt;code&gt;q=N/p/p&lt;/code&gt;となります。
&lt;code&gt;q==a&lt;/code&gt;の場合、つまり&lt;code&gt;N/q==p*p&lt;/code&gt;の場合は&lt;code&gt;p=Sqrt(N/q)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var T = Scanner.Scan&amp;lt;int&amp;gt;();
    var primes = Prime.Sieve((int)3e7).Select(x =&amp;gt; (long)x).ToArray();
    while (T-- &amp;gt; 0)
    {
        var N = Scanner.Scan&amp;lt;long&amp;gt;();
        foreach (var p in primes)
        {
            if (N % p != 0) continue;
            var n = N / p;
            if (n % p == 0)
            {
                var q = n / p;
                Console.WriteLine($&amp;quot;{p} {q}&amp;quot;);
            }
            else
            {
                bool F(long x) =&amp;gt; x * x &amp;lt;= n;
                var q = BinarySearch((long)3e9, 1, F);
                Console.WriteLine($&amp;quot;{q} {p}&amp;quot;);
            }

            break;
        }
    }
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }

    return ok;
}

public static class Prime
{
    public static IEnumerable&amp;lt;int&amp;gt; Sieve(int value)
    {
        if (value &amp;lt; 2) yield break;
        yield return 2;
        var sieve = new bool[(value + 1) / 2];
        for (var i = 1; i &amp;lt; sieve.Length; i++)
        {
            if (sieve[i]) continue;
            yield return i * 2 + 1;
            for (var j = i; j &amp;lt; sieve.Length; j += i * 2 + 1) sieve[j] = true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc284/tasks/abc284_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC284/submissions/37831298"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行きがけ順で深さ優先探索を行い、パスを数え上げることで答えを求めることができます。
答えの上限は&lt;code&gt;1e6&lt;/code&gt;なので、答えがそれ以上になる場合はその時点で深さ優先探索を打ち切ることで実行時間制限に間に合わせることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--;
        v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    const int inf = (int)1e6;

    var used = new bool[N];
    used[0] = true;
    var answer = 0;

    void Dfs(int u)
    {
        answer++;
        if (answer &amp;gt;= inf) return;
        foreach (var v in G[u])
        {
            if (used[v]) continue;
            used[v] = true;
            Dfs(v);
            used[v] = false;
        }
    }

    Dfs(0);
    answer = Math.Min(answer, inf);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 284の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221224abc283</id>
		<title>ABC283</title>
		<link href="https://blog.aconcavy.dev/posts/20221224abc283" />
		<updated>2022-12-24T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 283の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc283"&gt;https://atcoder.jp/contests/abc283&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37481456"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A^B&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;に&lt;code&gt;A&lt;/code&gt;を&lt;code&gt;B&lt;/code&gt;回掛けたものなので、それを計算します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    long answer = 1;
    while (B-- &amp;gt; 0)
    {
        answer *= A;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37485282"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリが&lt;code&gt;1 k x&lt;/code&gt;の場合は&lt;code&gt;A[k] = x&lt;/code&gt;で更新し、&lt;code&gt;2 k&lt;/code&gt;の場合は&lt;code&gt;A[k]&lt;/code&gt;を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var (k, x) = (query[1] - 1, query[2]);
            A[k] = x;
        }
        else
        {
            var k = query[1] - 1;
            Console.WriteLine(A[k]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37489912"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;以外の場合はそのボタンを1回を押し、&lt;code&gt;0&lt;/code&gt;が1以上連続する場合は&lt;code&gt;0&lt;/code&gt;の数が偶数の場合はその半数の&lt;code&gt;00&lt;/code&gt;ボタンを押し、&lt;code&gt;0&lt;/code&gt;の数が奇数の場合は&lt;code&gt;0&lt;/code&gt;を1回押して残りの半数を&lt;code&gt;00&lt;/code&gt;で押せばいいことがわかります。
そのため、&lt;code&gt;S&lt;/code&gt;を順にみていき、&lt;code&gt;0&lt;/code&gt;以外の場合は1回、&lt;code&gt;0&lt;/code&gt;の場合は&lt;code&gt;Ceil(連続する0の数/2)&lt;/code&gt;回押すことで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var answer = 0;
    var l = 0;
    while (l &amp;lt; N)
    {
        if (S[l] == '0')
        {
            var r = l;
            while (r &amp;lt; N &amp;amp;&amp;amp; S[r] == '0') r++;
            var c = r - l;
            answer += (c + 1) / 2;
            l = r;
        }
        else
        {
            answer++;
            l++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37504595"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を順にみるとき、&lt;code&gt;(&lt;/code&gt;が出現したときにレベルを&lt;code&gt;+1&lt;/code&gt;し、&lt;code&gt;)&lt;/code&gt;が出現したときにレベルを&lt;code&gt;-1&lt;/code&gt;すると、良い文字列のレベルごとに含まれる文字の集合を管理することができます。例えば&lt;code&gt;a(b(c)d(e))&lt;/code&gt;のときは以下のようなレベルになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;L2:    (c) (e)
L1:  (b   d   )
L0: a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このとき、&lt;code&gt;)&lt;/code&gt;の操作は、&lt;code&gt;そのレベルに含まれる文字の箱に入れたボールを箱から取り出す&lt;/code&gt;という操作になります。&lt;br /&gt;
そのため、&lt;code&gt;S&lt;/code&gt;を順にみていき、以下のような操作をすることで答えを求めることができます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(&lt;/code&gt;の場合は、レベルを&lt;code&gt;+1&lt;/code&gt;する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;)&lt;/code&gt;の場合は、現在のレベルに含まれているボールを箱から取り出してレベルを&lt;code&gt;-1&lt;/code&gt;する。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、
&lt;ul&gt;
&lt;li&gt;ボールが箱にある場合は、&lt;code&gt;No&lt;/code&gt;を出力する。&lt;/li&gt;
&lt;li&gt;ボールが箱にない場合は、ボールを箱に入れ、現在のレベルにボールを追加する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全て完了できるならば&lt;code&gt;Yes&lt;/code&gt;を出力する。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var balls = new bool[26];
    var level = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    var curr = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (!level.ContainsKey(curr)) level[curr] = new List&amp;lt;int&amp;gt;();

        if (S[i] == '(')
        {
            curr++;
        }
        else if (S[i] == ')')
        {
            foreach (var c in level[curr])
            {
                balls[c] = false;
            }

            level[curr].Clear();
            curr--;
        }
        else
        {
            var c = S[i] - 'a';
            if (balls[c])
            {
                Console.WriteLine(&amp;quot;No&amp;quot;);
                return;
            }

            balls[c] = true;
            level[curr].Add(c);
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37519410"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作は、&lt;code&gt;i&lt;/code&gt;行目を反転させること、つまり&lt;code&gt;i&lt;/code&gt;行目の全ての列の値を&lt;code&gt;0/1&lt;/code&gt;反転させることになります。&lt;br /&gt;
また、&lt;code&gt;A[i][j]&lt;/code&gt;が孤立しない状態を作ることができるかは、&lt;code&gt;A[i-1][j]&lt;/code&gt;、&lt;code&gt;A[i+1][j]&lt;/code&gt;、&lt;code&gt;A[i][j-1]&lt;/code&gt;、&lt;code&gt;A[i][j+1]&lt;/code&gt;のいずれかが同じ値である必要があり、&lt;code&gt;i&lt;/code&gt;行目の状態&lt;code&gt;curr&lt;/code&gt;、&lt;code&gt;i-1&lt;/code&gt;行目の状態&lt;code&gt;prev&lt;/code&gt;、&lt;code&gt;i+1&lt;/code&gt;行目の状態&lt;code&gt;next&lt;/code&gt;が分かれば、&lt;code&gt;i&lt;/code&gt;行目の全ての列が孤立しない状態として成り立つか判断することができます。
そのため、&lt;code&gt;curr&lt;/code&gt;、&lt;code&gt;prev&lt;/code&gt;、&lt;code&gt;next&lt;/code&gt;がそれぞれ行が反転していない(0),反転している(1)の状態であるとき、&lt;br /&gt;
&lt;code&gt;dp[i][curr][prev][next]:=i行目まで見たとき、それぞれcurr、prev、nextかつi行目が孤立していない状態の最小値&lt;/code&gt;&lt;br /&gt;
とした動的計画法を解くことで操作回数の最小値を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var dp = new int[H, 2, 2, 2];
    const int inf = (int)1e9;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var curr = 0; curr &amp;lt; 2; curr++)
        {
            for (var next = 0; next &amp;lt; 2; next++)
            {
                for (var prev = 0; prev &amp;lt; 2; prev++)
                {
                    dp[i, curr, next, prev] = inf;
                }
            }
        }
    }

    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var curr = 0; curr &amp;lt; 2; curr++)
        {
            for (var next = 0; next &amp;lt; 2; next++)
            {
                for (var prev = 0; prev &amp;lt; 2; prev++)
                {
                    var okW = true;
                    for (var j = 0; j &amp;lt; W; j++)
                    {
                        var ok = false;
                        if (i - 1 &amp;gt;= 0) ok |= (A[i][j] ^ curr) == (A[i - 1][j] ^ prev);
                        if (i + 1 &amp;lt; H) ok |= (A[i][j] ^ curr) == (A[i + 1][j] ^ next);
                        if (j - 1 &amp;gt;= 0) ok |= (A[i][j] ^ curr) == (A[i][j - 1] ^ curr);
                        if (j + 1 &amp;lt; W) ok |= (A[i][j] ^ curr) == (A[i][j + 1] ^ curr);
                        okW &amp;amp;= ok;
                    }

                    if (!okW) continue;
                    var cost = curr;
                    if (i == 0)
                    {
                        dp[i, curr, next, prev] = Math.Min(dp[i, curr, next, prev], cost);
                    }
                    else
                    {
                        dp[i, curr, next, prev] = Math.Min(dp[i, curr, next, prev], dp[i - 1, prev, curr, 0] + cost);
                        dp[i, curr, next, prev] = Math.Min(dp[i, curr, next, prev], dp[i - 1, prev, curr, 1] + cost);
                    }
                }
            }
        }
    }

    var answer = inf;
    for (var curr = 0; curr &amp;lt; 2; curr++)
    {
        for (var next = 0; next &amp;lt; 2; next++)
        {
            for (var prev = 0; prev &amp;lt; 2; prev++)
            {
                answer = Math.Min(answer, dp[H - 1, curr, next, prev]);
            }
        }
    }

    if (answer == inf)
    {
        Console.WriteLine(-1);
    }
    else
    {
        answer = Math.Min(answer, H - answer);
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 283の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221217abc282</id>
		<title>ABC282</title>
		<link href="https://blog.aconcavy.dev/posts/20221217abc282" />
		<updated>2022-12-17T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 282の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282"&gt;https://atcoder.jp/contests/abc282&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37322378"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C++やC#などの言語では、&lt;code&gt;char&lt;/code&gt;型の&lt;code&gt;A&lt;/code&gt;に&lt;code&gt;+0&lt;/code&gt;すると&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;+1&lt;/code&gt;すると&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;+25&lt;/code&gt;すると&lt;code&gt;Z&lt;/code&gt;の文字を取得することができます。
これは、文字&lt;code&gt;A&lt;/code&gt;は数値&lt;code&gt;65&lt;/code&gt;を&lt;code&gt;char&lt;/code&gt;型にしたものに対応しており、文字&lt;code&gt;B&lt;/code&gt;や文字&lt;code&gt;Z&lt;/code&gt;はそれぞれ数値&lt;code&gt;66&lt;/code&gt;と数値&lt;code&gt;90&lt;/code&gt;に対応します。
そのため、&lt;code&gt;A&lt;/code&gt;から&lt;code&gt;i&lt;/code&gt;進んだ数値を&lt;code&gt;char&lt;/code&gt;型に変換することで、&lt;code&gt;A&lt;/code&gt;から&lt;code&gt;i&lt;/code&gt;進んだ文字として得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var builder = new StringBuilder();
    for (var i = 0; i &amp;lt; K; i++)
    {
        builder.Append((char)('A' + i));
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37326045"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&amp;lt;=i&amp;lt;j&amp;lt;=N&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;番と&lt;code&gt;j&lt;/code&gt;番のペアにおいて、&lt;code&gt;M&lt;/code&gt;問全ての問題で少なくともどちらか一方でも解くことができるペアの数を数え上げます。
これは、各ペアを列挙し、&amp;quot;&lt;code&gt;i&lt;/code&gt;番の&lt;code&gt;k&lt;/code&gt;問目と&lt;code&gt;j&lt;/code&gt;番の&lt;code&gt;k&lt;/code&gt;問目の少なくともどちらか一方が&lt;code&gt;o&lt;/code&gt;である&amp;quot;、という小問題を&lt;code&gt;1&amp;lt;=k&amp;lt;=M&lt;/code&gt;全てで満たしている場合の数となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var ok = true;
            for (var k = 0; k &amp;lt; M; k++)
            {
                ok &amp;amp;= S[i][k] == 'o' || S[j][k] == 'o';
            }

            if (ok) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37329954"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在の文字が括られているかの判定は、それまでに出現した&lt;code&gt;&amp;quot;&lt;/code&gt;の数が奇数個であれば括られており、偶数個であれば括られていないことがわかります。
文字を順番に見ていき、現在の文字が括られていないときの&lt;code&gt;,&lt;/code&gt;であれば、&lt;code&gt;.&lt;/code&gt;に変換します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var level = 0;
    var T = new char[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i];
        if (c == '&amp;quot;')
        {
            level ^= 1;
        }
        else
        {
            if (c == ',' &amp;amp;&amp;amp; level == 0)
            {
                c = '.';
            }
        }

        T[i] = c;
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37360871"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あるグラフが連結である場合、始点を白と決めて幅優先探索などを行い、連結している頂点の色を白黒反転したものを決めていくことで、そのグラフが二部グラフであるかどうかを判定することができます。&lt;/p&gt;
&lt;p&gt;二部グラフの性質として、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフが二部グラフではない場合、いずれの頂点どうしを新たに接続しても、二部グラフにすることはできません。&lt;/li&gt;
&lt;li&gt;グラフが二部グラフである場合、色が異なる頂点どうしを新たに接続しても、二部グラフを保つことができます。&lt;/li&gt;
&lt;li&gt;二部グラフ&lt;code&gt;A&lt;/code&gt;と二部グラフ&lt;code&gt;B&lt;/code&gt;があるとき、&lt;code&gt;A&lt;/code&gt;のいずれの頂点と&lt;code&gt;B&lt;/code&gt;のいずれの頂点を接続しても、接続後のグラフは二部グラフを保つことができます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらのことから、連結成分ごとに二部グラフかどうかを判定を行い、二部グラフではない連結成分が存在する場合、いずれの頂点どうしを新たに接続しても二部グラフにすることはできないので、答えは&lt;code&gt;0&lt;/code&gt;になります。
対して、全ての連結成分が二部グラフである場合、次の総和が答えとなります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各連結成分において&lt;code&gt;白の頂点の数*黒の頂点の数-既に接続している辺の数&lt;/code&gt;が新たに追加できる辺の数となります。&lt;/li&gt;
&lt;li&gt;連結成分の数が&lt;code&gt;K&lt;/code&gt;個であるとき、&lt;code&gt;1&amp;lt;=i&amp;lt;j&amp;lt;=K&lt;/code&gt;となる二部グラフ&lt;code&gt;i,j&lt;/code&gt;において、&lt;code&gt;iの頂点の数*jの頂点の数&lt;/code&gt;が新たに追加できる辺の数となります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var E = new (int u, int v)[M];

    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--;
        v--;
        G[u].Add(v);
        G[v].Add(u);
        E[i] = (u, v);
    }

    var colors = new int[N];
    Array.Fill(colors, -1);
    var queue = new Queue&amp;lt;int&amp;gt;();
    var bipartiteSize = new List&amp;lt;long&amp;gt;();
    var isBipartiteNode = new bool[N];

    long answer = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (colors[i] != -1) continue;
        var isBipartite = true;
        queue.Enqueue(i);
        colors[i] = 0;
        long c0 = 0;
        long c1 = 0;
        var list = new List&amp;lt;int&amp;gt;();
        while (queue.Count &amp;gt; 0)
        {
            var u = queue.Dequeue();
            list.Add(u);
            if (colors[u] == 0) c0++;
            else c1++;

            foreach (var v in G[u])
            {
                if (colors[u] == colors[v]) isBipartite = false;
                if (colors[v] != -1) continue;
                colors[v] = colors[u] ^ 1;
                queue.Enqueue(v);
            }
        }

        if (!isBipartite)
        {
            Console.WriteLine(0);
            return;
        }

        bipartiteSize.Add(c0 + c1);
        answer += c0 * c1;
    }

    answer -= E.Count(x =&amp;gt; colors[x.u] != colors[x.v]);

    var cum = bipartiteSize.Sum();
    foreach (var size in bipartiteSize)
    {
        cum -= size;
        answer += size * cum;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37361144"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の頂点と&lt;code&gt;1&amp;lt;=i&amp;lt;j&amp;lt;=N&lt;/code&gt;となる頂点&lt;code&gt;i,j&lt;/code&gt;間の辺の重さが&lt;code&gt;(A[i]^A[j]+A[j]^[i])%M&lt;/code&gt;としたときの最大全域木の重みが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    mint.Modulo = M;
    var list = new List&amp;lt;(long V, int A, int B)&amp;gt;(N * (N - 1));

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var x = A[i];
            var y = A[j];
            var v = mint.Power(x, y) + mint.Power(y, x);
            list.Add((v, i, j));
        }
    }

    var dsu = new DisjointSetUnion(N);
    long answer = 0;
    foreach (var (v, a, b) in list.OrderByDescending(x =&amp;gt; x.V))
    {
        if (dsu.IsSame(a, b)) continue;

        dsu.Merge(a, b);
        answer += v;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 282の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221210abc281</id>
		<title>ABC281</title>
		<link href="https://blog.aconcavy.dev/posts/20221210abc281" />
		<updated>2022-12-11T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 281の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc281"&gt;https://atcoder.jp/contests/abc281&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37136228"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;生成すべき非負整数は、&lt;code&gt;0,1,2,...,N&lt;/code&gt;の&lt;code&gt;N+1&lt;/code&gt;個の整数を逆順に表示したものとなります。
やりやすい方法で解きましょう。&lt;/p&gt;
&lt;h4 id="forn0"&gt;&lt;code&gt;for&lt;/code&gt;文で&lt;code&gt;N&lt;/code&gt;から&lt;code&gt;0&lt;/code&gt;まで逆順に表示する方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = N; i &amp;gt;= 0; i--)
    {
        Console.WriteLine(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="enumerable.range"&gt;&lt;code&gt;Enumerable.Range&lt;/code&gt;で数列を生成して逆順に表示する方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = Enumerable.Range(0, N + 1).Reverse();
    Console.WriteLine(string.Join(Environment.NewLine, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37144142"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;が条件を満たすかどうか、問題文に与えられた条件を詳細に分割して一つずつ判定していきます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の長さは&lt;code&gt;英大文字+6桁の整数+英大文字&lt;/code&gt;の&lt;code&gt;8&lt;/code&gt;であるか。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の先頭の文字は英文字であり、大文字であるか。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の末尾の文字は英文字であり、大文字であるか。&lt;/li&gt;
&lt;li&gt;英大文字に囲まれた文字列は数値に変換でき、&lt;code&gt;100000&lt;/code&gt;以上&lt;code&gt;999999&lt;/code&gt;以下であるか。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全ての条件を満たす場合、答えは&lt;code&gt;Yes&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.Length == 1 + 6 + 1;
    answer &amp;amp;= char.IsLetter(S[0]) &amp;amp;&amp;amp; char.IsUpper(S[0]);
    answer &amp;amp;= char.IsLetter(S[^1]) &amp;amp;&amp;amp; char.IsUpper(S[^1]);
    if (answer)
    {
        answer &amp;amp;= int.TryParse(S[1..7], out var val);
        answer &amp;amp;= 100000 &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= 999999;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37147756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の曲までの時間の累積和をとり、&lt;code&gt;i&lt;/code&gt;番目に&lt;code&gt;T&lt;/code&gt;秒を超えた曲が答えとなる曲であり、&lt;code&gt;T&lt;/code&gt;から&lt;code&gt;i-1&lt;/code&gt;番目の曲が終わった時間を引いた秒数が答えとなる時点となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    T %= cum[N];
    var num = LowerBound(cum, T);
    var time = T - cum[Math.Max(0, num - 1)];
    Console.WriteLine($&amp;quot;{num} {time}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37157390"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][k][d]:=i番目の項までみたときにk項使い、和の余りがdのときの最大値&lt;/code&gt;とした動的計画法を解きます。
遷移として、&lt;code&gt;u&lt;/code&gt;を遷移前の和の余り、&lt;code&gt;v=(u+A[i])%D&lt;/code&gt;を遷移後の和の余りとしたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;番目の項を使わない場合: &lt;code&gt;dp[i+1][k][u] := Max(dp[i+1][k][u], dp[i][k][u])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;番目の項を使う場合 (&lt;code&gt;k&amp;lt;K&lt;/code&gt;): &lt;code&gt;dp[i+1][k][v] := Max(dp[i+1][k+1][v], dp[i][k][u]+A[i])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;番目の項まで見たときに&lt;code&gt;K&lt;/code&gt;項使い、和の余りが&lt;code&gt;0&lt;/code&gt;の時の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K, D) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var dp = new long[N + 1, K + 1, D];
    const long inf = (long)1e18;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var k = 0; k &amp;lt;= K; k++)
        {
            for (var d = 0; d &amp;lt; D; d++)
            {
                dp[i, k, d] = -inf;
            }
        }
    }

    dp[0, 0, 0] = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var k = 0; k &amp;lt;= K; k++)
        {
            for (var u = 0; u &amp;lt; D; u++)
            {
                var v = (u + A[i]) % D;
                dp[i + 1, k, u] = Math.Max(dp[i + 1, k, u], dp[i, k, u]);
                if (k + 1 &amp;lt;= K)
                {
                    dp[i + 1, k + 1, v] = Math.Max(dp[i + 1, k + 1, v], dp[i, k, u] + A[i]);
                }
            }
        }
    }

    var answer = dp[N, K, 0] &amp;lt; 0 ? -1 : dp[N, K, 0];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37175993"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;i&lt;/code&gt;について、毎回配列をソートしてしまうと、全体の時間計算量が&lt;code&gt;O((N-M+1)(NlogN+K))&lt;/code&gt;となり実行時間制限に間に合いません。
そこで、順序付けできる多重集合のデータ構造を使い、各&lt;code&gt;i&lt;/code&gt;における値の集合を管理しながら昇順&lt;code&gt;K&lt;/code&gt;個の総和を計算していきます。&lt;br /&gt;
&lt;code&gt;i==1&lt;/code&gt;について、集合には&lt;code&gt;M&lt;/code&gt;項目までの値があり、総和は&lt;code&gt;M&lt;/code&gt;項までの昇順&lt;code&gt;K&lt;/code&gt;個の総和となります。&lt;br /&gt;
&lt;code&gt;i==2&lt;/code&gt;について、&lt;code&gt;i==1&lt;/code&gt;の総和から&lt;code&gt;A[1]&lt;/code&gt;または集合のうち&lt;code&gt;K&lt;/code&gt;番目の値を引き、集合から&lt;code&gt;A[1]&lt;/code&gt;を削除します。
また、&lt;code&gt;A[2+M]&lt;/code&gt;を集合に追加し、&lt;code&gt;A[2+M]&lt;/code&gt;または集合のうち&lt;code&gt;K&lt;/code&gt;番目の値を総和に足します。&lt;br /&gt;
&lt;code&gt;i&amp;gt;2&lt;/code&gt;についても同様の操作を行うことで、各&lt;code&gt;i&lt;/code&gt;についての総和を時間計算量&lt;code&gt;O(logM)&lt;/code&gt;で求めることができ、全体の時間計算量&lt;code&gt;O((N-M+1)logM)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;p&gt;C#の標準ライブラリでは、多重集合を扱うクラスが存在しないため、多重集合のデータ構造は自前の実装が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var set = new Set&amp;lt;long&amp;gt;(true);
    for (var i = 0; i &amp;lt; M; i++)
    {
        set.Add(A[i]);
    }

    long sum = 0;
    for (var i = 0; i &amp;lt; K; i++)
    {
        sum += set.ElementAt(i);
    }

    var answer = new List&amp;lt;long&amp;gt;(N - M + 1) { sum };

    for (var i = M; i &amp;lt; N; i++)
    {
        var x = A[i - M];
        sum -= Math.Min(x, set.ElementAt(K - 1));
        set.Remove(x);

        set.Add(A[i]);
        sum += Math.Min(A[i], set.ElementAt(K - 1));

        answer.Add(sum);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 281の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221203abc280</id>
		<title>ABC280</title>
		<link href="https://blog.aconcavy.dev/posts/20221203abc280" />
		<updated>2022-12-03T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 280の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280"&gt;https://atcoder.jp/contests/abc280&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/36947925"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列として入力をとり、全ての文字から&lt;code&gt;#&lt;/code&gt;の数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = 0;
    for (var i = 0; i &amp;lt; H; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        foreach (var c in S)
        {
            if (c == '#') answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/36952001"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[k]=A[1]+A[2]+...A[k-1]+A[k]&lt;/code&gt;であることから、&lt;code&gt;S[k]=S[k-1]+A[k]&lt;/code&gt;であることがわかります。
そのため、&lt;code&gt;i==1&lt;/code&gt;のときは&lt;code&gt;A[1]=S[1]&lt;/code&gt;であり、&lt;code&gt;i&amp;gt;1&lt;/code&gt;の場合は&lt;code&gt;A[i]=S[i]-S[i-1]&lt;/code&gt;として、答えとなる数列&lt;code&gt;A&lt;/code&gt;を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var A = new long[N];
    A[0] = S[0];
    for (var i = 1; i &amp;lt; N; i++)
    {
        A[i] = S[i] - S[i - 1];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/36972273"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;の長さの範囲では&lt;code&gt;S[i]!=T[i]&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;が答えとなり、&lt;code&gt;T&lt;/code&gt;が&lt;code&gt;S&lt;/code&gt;の最後に文字が追加されている文字列である場合は、&lt;code&gt;T&lt;/code&gt;の最後が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (S[i] != T[i])
        {
            Console.WriteLine(i + 1);
            return;
        }
    }

    Console.WriteLine(T.Length);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/37000066"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt;について素因数分解を行い、&lt;code&gt;K&lt;/code&gt;の倍数であるために必要な素数とその個数を求めます。
そして、ある素数をその必要な個数以上使ったときの&lt;code&gt;n&lt;/code&gt;の値の最大が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;long&amp;gt;();
    long answer = 0;
    foreach (var (prime, required) in Prime.GetFactorDictionary(K))
    {
        long n = 0;
        var used = 0;
        while (used &amp;lt; required)
        {
            n += prime;
            var x = n;
            while (x % prime == 0)
            {
                x /= prime;
                used++;
            }
        }

        answer = Math.Max(answer, n);
    }

    Console.WriteLine(answer);
}

public static class Prime
{
    public static IDictionary&amp;lt;long, int&amp;gt; GetFactorDictionary(long value)
    {
        var factors = new Dictionary&amp;lt;long, int&amp;gt;();
        if (value &amp;lt; 2) return factors;

        void CountUp(long n)
        {
            if (value % n != 0) return;
            factors[n] = 0;
            while (value % n == 0)
            {
                value /= n;
                factors[n]++;
            }
        }

        CountUp(2);
        for (var i = 3L; i * i &amp;lt;= value; i += 2) CountUp(i);
        if (value &amp;gt; 1) factors[value] = 1;
        return factors;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/37000080"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i] := dp[i+2]*(i+2から遷移する確率) + dp[i+1]*(i+1から遷移する確率) + 1&lt;/code&gt;のような攻撃回数についての期待値dpを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new mint[N + 1];
    var p2 = P * mint.Inverse(100);
    var p1 = 1 - p2;
    for (var i = N - 1; i &amp;gt;= 0; i--)
    {
        dp[i] = dp[Math.Min(N, i + 1)] * p1 + dp[Math.Min(N, i + 2)] * p2 + 1;
    }

    var answer = dp[0];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 280の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221126abc279</id>
		<title>ABC279</title>
		<link href="https://blog.aconcavy.dev/posts/20221126abc279" />
		<updated>2022-11-26T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 279の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc279"&gt;https://atcoder.jp/contests/abc279&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36792996"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;を順にみていき、文字&lt;code&gt;S[i]&lt;/code&gt;が&lt;code&gt;v&lt;/code&gt;なら&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;w&lt;/code&gt;なら&lt;code&gt;2&lt;/code&gt;を足した総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    int F(char c)
    {
        return c switch
        {
            'v' =&amp;gt; 1,
            'w' =&amp;gt; 2,
            _ =&amp;gt; 0,
        };
    }

    var answer = 0;
    foreach (var c in S)
    {
        answer += F(c);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36797148"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;に文字列&lt;code&gt;T&lt;/code&gt;が含まれているかを調べます。
方法としては以下のようなものがあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt;の&lt;code&gt;Contains&lt;/code&gt;メソッド(計算量&lt;code&gt;O(S)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の始点を固定し&lt;code&gt;T&lt;/code&gt;と比較する(計算量&lt;code&gt;O(ST)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%9C%E3%82%A4%E3%83%A4%E3%83%BC-%E3%83%A0%E3%83%BC%E3%82%A2%E6%96%87%E5%AD%97%E5%88%97%E6%A4%9C%E7%B4%A2%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0"&gt;ボイヤームーア法&lt;/a&gt;で探索する(計算量&lt;code&gt;O(S)&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.Contains(T);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36802481"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;の列を並べ替えて&lt;code&gt;T&lt;/code&gt;と等しくできるかどうかは、&lt;code&gt;S&lt;/code&gt;の列の集合と&lt;code&gt;T&lt;/code&gt;の列の集合が一致しているか確認できればいいので、``S&lt;code&gt;の列と&lt;/code&gt;T`の列をそれぞれ文字列として辞書などのデータ構造などで個数を管理することで、集合が一致しているかを比較できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new char[H][];
    var T = new char[H][];
    for (var k = 0; k &amp;lt; 2; k++)
    {
        for (var i = 0; i &amp;lt; H; i++)
        {
            (k == 0 ? S : T)[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        }
    }

    var dictS = new Dictionary&amp;lt;string, int&amp;gt;();
    var dictT = new Dictionary&amp;lt;string, int&amp;gt;();
    for (var j = 0; j &amp;lt; W; j++)
    {
        var builderS = new StringBuilder();
        var builderT = new StringBuilder();
        for (var i = 0; i &amp;lt; H; i++)
        {
            builderS.Append(S[i][j]);
            builderT.Append(T[i][j]);
        }

        var s = builderS.ToString();
        var t = builderT.ToString();
        if (!dictS.ContainsKey(s)) dictS[s] = 0;
        dictS[s]++;
        if (!dictT.ContainsKey(t)) dictT[t] = 0;
        dictT[t]++;
    }

    var answer = true;
    foreach (var (s, c) in dictS)
    {
        answer &amp;amp;= dictT.ContainsKey(s) &amp;amp;&amp;amp; dictT[s] == c;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36815340"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/editorial/5288"&gt;公式解説&lt;/a&gt;にもあるように、&lt;code&gt;F(g)=B(g-1)+A/Sqrt(g)&lt;/code&gt;は下に凸な関数であるため、&lt;code&gt;g&lt;/code&gt;に対する三部探索を行い、最小となる&lt;code&gt;g&lt;/code&gt;を求めます。
この&lt;code&gt;g&lt;/code&gt;は浮動小数点のため、その付近の整数値のうち、&lt;code&gt;F(g)&lt;/code&gt;が最小となる値が答えとなります。
また、三部探索を行う際の範囲として、&lt;code&gt;F(g)&amp;lt;F(1)=A&lt;/code&gt;以下であればいいので、&lt;code&gt;1&amp;lt;=g&amp;lt;=A/B&lt;/code&gt;であれば十分であることがわかります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();

    double F(double g)
    {
        return B * (g - 1) + A / Math.Sqrt(g);
    }

    var r = (A + B - 1) / B;
    var g = (long)TernarySearch(0, r, F, 1e-2);
    var answer = new[] { Math.Max(g - 1, 1), g, g + 1 }.Select(x =&amp;gt; F(x)).Min();
    Console.WriteLine(answer);
}

public static double TernarySearch(double l, double r, Func&amp;lt;double, double&amp;gt; func, double eps = 1e-9)
{
    while (r - l &amp;gt; eps)
    {
        var d = (r - l) / 3;
        var (ml, mr) = (l + d, r - d);
        if (func(ml) &amp;lt; func(mr)) r = mr;
        else l = ml;
    }
    return (l + r) / 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36822297"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直にシミュレーションしてしまうと、時間計算量が&lt;code&gt;O(M^2)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
求めるものは&lt;code&gt;B[j]==1&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;の位置&lt;code&gt;S&lt;/code&gt;であるため、位置&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;の集合を辞書などのデータ構造で管理します。
&lt;code&gt;x=A[k],y=A[k]+1&lt;/code&gt;としたとき、&lt;code&gt;B[x]&lt;/code&gt;と&lt;code&gt;B[y]&lt;/code&gt;を入れ替えるということは、位置&lt;code&gt;x&lt;/code&gt;と位置&lt;code&gt;y&lt;/code&gt;にあるそれぞれの&lt;code&gt;i&lt;/code&gt;の集合を入れ替えることになります。
また、&lt;code&gt;i==k&lt;/code&gt;のときは操作しないということは、入れ替えの操作時に&lt;code&gt;x&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;の集合に&lt;code&gt;k&lt;/code&gt;が含まれていれば、&lt;code&gt;i&lt;/code&gt;以外を&lt;code&gt;y&lt;/code&gt;に移動することになります。
このとき、一つずつ移動をしてしまうと時間計算量が&lt;code&gt;O(M)&lt;/code&gt;になってしまいますが、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;の集合の参照を入れ替えた後に、&lt;code&gt;y&lt;/code&gt;の集合から&lt;code&gt;k&lt;/code&gt;を削除し、&lt;code&gt;x&lt;/code&gt;の集合に&lt;code&gt;k&lt;/code&gt;を追加することで、時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で操作を行うことができます。
全体の時間計算量は&lt;code&gt;O(N+MlogN)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();

    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        dict[i] = new HashSet&amp;lt;int&amp;gt;();
    }

    for (var i = 0; i &amp;lt; M; i++)
    {
        dict[0].Add(i);
    }

    for (var k = 0; k &amp;lt; M; k++)
    {
        var i = k;
        var x = A[k];
        var y = A[k] + 1;
        (dict[x], dict[y]) = (dict[y], dict[x]);
        if (dict[x].Contains(i))
        {
            dict[x].Remove(i);
            dict[y].Add(i);
        }
        else if (dict[y].Contains(i))
        {
            dict[y].Remove(i);
            dict[x].Add(i);
        }
    }

    var answer = new int[M];
    foreach (var (s, set) in dict)
    {
        foreach (var i in set)
        {
            answer[i] = s + 1;
        }
    }

    Console.WriteLine(string.Join(Environment.NewLine, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 279の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>