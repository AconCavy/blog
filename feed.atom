<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title>acon.log</title>
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2023 AconCavy</rights>
	<updated>2023-10-07T14:47:11Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231007abc323</id>
		<title>ABC323</title>
		<link href="https://blog.aconcavy.dev/posts/20231007abc323" />
		<updated>2023-10-07T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 323の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc323"&gt;https://atcoder.jp/contests/abc323&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46279658"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;偶数番目は&lt;code&gt;0-indexed&lt;/code&gt;で奇数番目となり、それらが&lt;code&gt;0&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = true;
    for (var i = 1; i &amp;lt; 16; i += 2)
    {
        answer &amp;amp;= S[i] == '0';
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46279658"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の人の番号と勝利数をペアとしたとき、勝利数を降順、番号を昇順に並べ替えたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new char[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var answer = new (int ID, int C)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer[i] = (i, G[i].Count(x =&amp;gt; x == 'o'));
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.OrderByDescending(x =&amp;gt; x.C).ThenBy(x =&amp;gt; x.ID).Select(x =&amp;gt; x.ID + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46308075"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の人がまだ解いていない問題のうち、スコアが高い問題から順に、現在の総合得点の最大より高くなるまで解くことで条件を達成できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var scores = new long[N];
    var queues = new PriorityQueue&amp;lt;long, long&amp;gt;[N];
    long max = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        queues[i] = new PriorityQueue&amp;lt;long, long&amp;gt;();
        long score = i + 1;
        for (var j = 0; j &amp;lt; M; j++)
        {
            if (S[j] == 'o') score += A[j];
            else queues[i].Enqueue(A[j], -A[j]);
        }

        scores[i] = score;
        max = Math.Max(max, score);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var answer = 0;
        while (queues[i].Count &amp;gt; 0 &amp;amp;&amp;amp; scores[i] &amp;lt; max)
        {
            answer++;
            scores[i] += queues[i].Dequeue();
        }

        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46314486"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スライムの大きさが小さくなることはないので、大きさが小さいものから順にスライムを合成させていくことで、スライムの引数を最小にすることができます。&lt;br /&gt;
この操作は、辞書と優先度付きキューなどを使うことで達成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;long, long&amp;gt;();
    var queue = new PriorityQueue&amp;lt;long, long&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, c) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        if (!dict.ContainsKey(s)) dict[s] = 0;
        dict[s] += c;
        queue.Enqueue(s, s);
    }

    while (queue.Count &amp;gt; 0)
    {
        var s = queue.Dequeue();
        var c = dict[s];
        var ns = s * 2;
        var nc = c / 2;
        if (nc &amp;gt; 0)
        {
            if (!dict.ContainsKey(ns)) dict[ns] = 0;
            dict[ns] += nc;
            dict[s] -= nc * 2;
            queue.Enqueue(ns, ns);
        }
    }

    var answer = dict.Values.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc323/tasks/abc323_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC323/submissions/46314486"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P[t]&lt;/code&gt;を&lt;code&gt;t&lt;/code&gt;秒に曲が切り替わる確率とします。&lt;br /&gt;
&lt;code&gt;(X+0.5)&lt;/code&gt;秒後に曲1が再生されている確率は、&lt;code&gt;X&lt;/code&gt;秒以前に曲1に切り替わり&lt;code&gt;X+1&lt;/code&gt;秒以降に曲1が再生されている確率であり、これは&lt;code&gt;t&amp;lt;=X&amp;lt;t+T[1]&lt;/code&gt;となる&lt;code&gt;P[t]&lt;/code&gt;に曲1が再生される確率&lt;code&gt;1/N&lt;/code&gt;を掛けたものの総和になります。&lt;br /&gt;
よって、&lt;code&gt;Sum(P[t], X-T[1]+1&amp;lt;=t&amp;lt;=X) / N&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;P[t]&lt;/code&gt;は次のように求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;P[0] = 1
P[t+T[i]] = P[t]/N (0&amp;lt;=t&amp;lt;=X, 1&amp;lt;=i&amp;lt;=N)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var T = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var P = new mint[X + 1];
    P[0] = 1;
    var pN = (mint)1 / N;

    for (var i = 0; i &amp;lt;= X; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (i + T[j] &amp;lt;= X) P[i + T[j]] += P[i] * pN;
        }
    }

    mint answer = 0;
    for (var i = Math.Max(0, X - T[0] + 1); i &amp;lt;= X; i++)
    {
        answer += P[i] * pN;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 323の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230930abc322</id>
		<title>ABC322</title>
		<link href="https://blog.aconcavy.dev/posts/20230930abc322" />
		<updated>2023-09-30T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 322の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc322"&gt;https://atcoder.jp/contests/abc322&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46057457"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;code&gt;String.IndexOf&lt;/code&gt;メソッドを使うことで、文字列のうち指定した文字列が最初に出現する位置を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.IndexOf(&amp;quot;ABC&amp;quot;);
    if (answer != -1) answer += 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46068042"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の先頭&lt;code&gt;N&lt;/code&gt;文字が一致しているかを&lt;code&gt;isPrefix&lt;/code&gt;、&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の末尾&lt;code&gt;N&lt;/code&gt;文字が一致しているかを&lt;code&gt;isSuffix&lt;/code&gt;として求めておき、それぞれの条件に対応した答えを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var isPrefix = true;
    var isSuffix = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        isPrefix &amp;amp;= T[i] == S[i];
        isSuffix &amp;amp;= T[M - 1 - i] == S[N - 1 - i];
    }

    if (isPrefix &amp;amp;&amp;amp; isSuffix)
    {
        Console.WriteLine(0);
    }
    else if (isPrefix)
    {
        Console.WriteLine(1);
    }
    else if (isSuffix)
    {
        Console.WriteLine(2);
    }
    else
    {
        Console.WriteLine(3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46070765"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;i&lt;/code&gt;につき愚直に&lt;code&gt;A&lt;/code&gt;を探索すると全体時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になってしまうので、各&lt;code&gt;i&lt;/code&gt;につき&lt;code&gt;A&lt;/code&gt;を二部探索することで全体時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 1; i &amp;lt;= N; i++)
    {
        var lb = LowerBound(A, i);
        Console.WriteLine(A[lb] - i);
    }
}

public static int LowerBound&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; source, T key, IComparer&amp;lt;T&amp;gt;? comparer = null)
    =&amp;gt; LowerBound(System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source), key, comparer);

public static int LowerBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key, IComparer&amp;lt;T&amp;gt;? comparer = null)
{
    comparer ??= Comparer&amp;lt;T&amp;gt;.Default;
    var (lo, hi) = (-1, source.Length);
    while (hi - lo &amp;gt; 1)
    {
        var mi = lo + ((hi - lo) &amp;gt;&amp;gt; 1);
        if (comparer.Compare(source[mi], key) &amp;gt;= 0) hi = mi;
        else lo = mi;
    }

    return hi;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46114358"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全てのポリオミノの回転の組み合わせと全てのポリオミノの平行移動の組み合わせを全探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int N = 4;
    var P = new char[3][,];
    for (var k = 0; k &amp;lt; 3; k++)
    {
        P[k] = new char[N, N];
        for (var i = 0; i &amp;lt; N; i++)
        {
            var p = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
            for (var j = 0; j &amp;lt; N; j++)
            {
                P[k][i, j] = p[j];
            }
        }
    }

    var G = new char[N, N];
    const int Inf = 1 &amp;lt;&amp;lt; 30;

    // グリッドの初期化
    void Init(char[,] g)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                g[i, j] = '.';
            }
        }
    }

    // ポリオミノを回転させ、左上に寄せる
    char[,] Rotate(char[,] p)
    {
        // ポリオミノを回転させる
        var tmp = new char[N, N];
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                tmp[i, j] = p[j, N - 1 - i];
            }
        }

        // 左上に寄せるために#が出現する最小のhとwを求める
        var h = Inf;
        var w = Inf;
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                if (tmp[i, j] == '#')
                {
                    h = Math.Min(h, i);
                    w = Math.Min(w, j);
                }
            }
        }

        // ポリオミノを左上に寄せる
        var result = new char[N, N];
        if (h == Inf) return result;
        for (var i = 0; h + i &amp;lt; N; i++)
        {
            for (var j = 0; w + j &amp;lt; N; j++)
            {
                result[i, j] = tmp[h + i, w + j];
            }
        }

        return result;
    }

    // グリッドに平行移動させたポリオミノを配置できるかを判定する
    bool Fill(char[,] p, int dh, int dw)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                if (p[i, j] == '#')
                {
                    if (dh + i &amp;lt; N &amp;amp;&amp;amp; dw + j &amp;lt; N &amp;amp;&amp;amp; G[dh + i, dw + j] != '#')
                    {
                        G[dh + i, dw + j] = '#';
                    }
                    else
                    {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    // 平行移動
    IEnumerable&amp;lt;(int dh, int dw)&amp;gt; Delta()
    {
        for (var h = 0; h &amp;lt; N; h++)
        {
            for (var w = 0; w &amp;lt; N; w++)
            {
                yield return (h, w);
            }
        }
    }

    for (var a = 0; a &amp;lt; 4; a++)
    {
        P[0] = Rotate(P[0]);
        for (var b = 0; b &amp;lt; 4; b++)
        {
            P[1] = Rotate(P[1]);
            for (var c = 0; c &amp;lt; 4; c++)
            {
                P[2] = Rotate(P[2]);
                foreach (var (dha, dwa) in Delta())
                {
                    foreach (var (dhb, dwb) in Delta())
                    {
                        foreach (var (dhc, dwc) in Delta())
                        {
                            var ok = true;
                            Init(G);
                            ok &amp;amp;= Fill(P[0], dha, dwa);
                            ok &amp;amp;= Fill(P[1], dhb, dwb);
                            ok &amp;amp;= Fill(P[2], dhc, dwc);

                            for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; ok; i++)
                            {
                                for (var j = 0; j &amp;lt; N &amp;amp;&amp;amp; ok; j++)
                                {
                                    ok &amp;amp;= G[i, j] == '#';
                                }
                            }

                            if (ok)
                            {
                                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                                return;
                            }
                        }
                    }
                }
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc322/tasks/abc322_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC322/submissions/46118122"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][s] := i番目までの開発案を見たとき、開発案のパラメータ状態がsのときの最小コスト
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;パラメータ状態は&lt;code&gt;K&lt;/code&gt;個のパラメータの値を連結した文字列とすることで管理することができ、パラメータ状態の数は&lt;code&gt;(P+1)^K&lt;/code&gt;であり、&lt;code&gt;1&amp;lt;=K,P&amp;lt;=5&lt;/code&gt;であることから最大でも&lt;code&gt;6^5=7776&lt;/code&gt;通りになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K, P) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var Plans = new (long C, int[] A)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var array = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        Plans[i] = (array[0], array[1..]);
    }

    var dp = new Dictionary&amp;lt;string, long&amp;gt;();
    const long Inf = 1L &amp;lt;&amp;lt; 60;
    dp[new string('0', K)] = 0;
    var B = new int[K];

    for (var i = 0; i &amp;lt; N; i++)
    {
        var (C, A) = Plans[i];
        var ndp = new Dictionary&amp;lt;string, long&amp;gt;();
        foreach (var (s, c) in dp)
        {
            for (var j = 0; j &amp;lt; K; j++)
            {
                B[j] = A[j];
            }

            for (var j = 0; j &amp;lt; K; j++)
            {
                B[j] += s[j] - '0';
                B[j] = Math.Min(P, B[j]);
            }

            var ns = string.Join(&amp;quot;&amp;quot;, B);
            if (!ndp.ContainsKey(s)) ndp[s] = Inf;
            ndp[s] = Math.Min(ndp[s], c);
            if (!ndp.ContainsKey(ns)) ndp[ns] = Inf;
            ndp[ns] = Math.Min(ndp[ns], C + c);
        }
        dp = ndp;
    }

    var g = new string((char)(P + '0'), K);
    var answer = dp.ContainsKey(g) ? dp[g] : -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 322の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230923abc321</id>
		<title>ABC321</title>
		<link href="https://blog.aconcavy.dev/posts/20230923abc321" />
		<updated>2023-09-23T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 321の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc321"&gt;https://atcoder.jp/contests/abc321&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45817144"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;を文字列としてみたとき、全ての&lt;code&gt;1&amp;lt;=i&amp;lt;=N-1&lt;/code&gt;において&lt;code&gt;N[i]&amp;gt;N[i+1]&lt;/code&gt;が成り立つものが&lt;code&gt;321-like Number&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = true;
    for (var i = 0; i + 1 &amp;lt; N.Length; i++)
    {
        answer &amp;amp;= N[i] &amp;gt; N[i + 1];
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45824801"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後に&lt;code&gt;k&lt;/code&gt;点取ると固定したときの最終結果が&lt;code&gt;X&lt;/code&gt;以上になる&lt;code&gt;k&lt;/code&gt;を全探索します。&lt;br /&gt;
あらかじめ、&lt;code&gt;N-1&lt;/code&gt;試合の合計スコア(&lt;code&gt;sum&lt;/code&gt;)、最低スコア(&lt;code&gt;min&lt;/code&gt;)、最高スコア(&lt;code&gt;max&lt;/code&gt;)を計算しておくと、最終試験で&lt;code&gt;k&lt;/code&gt;点とった場合、最終結果は&lt;code&gt;sum + k - Min(min,k) - Max(max,k)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var min = A.Min();
    var max = A.Max();
    var sum = A.Sum();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var answer = Inf;
    for (var k = 0; k &amp;lt;= 100; k++)
    {
        var mmin = Math.Min(min, k);
        var mmax = Math.Max(max, k);
        var x = sum + k - mmin - mmax;
        if (x &amp;gt;= X)
        {
            answer = Math.Min(answer, k);
        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45887284"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;321-like Number&lt;/code&gt;の各桁に同じ数字が現れることはないため、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の数字をそれぞれ使う/使わないとしたときに、使う数字のみを降順に並べたものが&lt;code&gt;321-like Number&lt;/code&gt;になり得ます。&lt;br /&gt;
このことから、それぞれの数字を使う/使わないとする組み合わせ&lt;code&gt;2^10-1&lt;/code&gt;通りをbit全探索し、全ての&lt;code&gt;321-like Number&lt;/code&gt;を列挙してソートすることで、&lt;code&gt;K&lt;/code&gt;番目の値を得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new List&amp;lt;long&amp;gt;();
    for (var s = 1; s &amp;lt; 1 &amp;lt;&amp;lt; 10; s++)
    {
        var list = new List&amp;lt;int&amp;gt;();
        for (var i = 0; i &amp;lt; 10; i++)
        {
            if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1) list.Add(i);
        }

        list.Sort();
        list.Reverse();
        S.Add(long.Parse(string.Join(&amp;quot;&amp;quot;, list)));
    }

    S.Sort();
    var answer = S[K];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45853839"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある主菜&lt;code&gt;A[i]&lt;/code&gt;を固定したとき、副菜&lt;code&gt;B&lt;/code&gt;のうち価格が&lt;code&gt;P-A[i]&lt;/code&gt;以上のものは価格が&lt;code&gt;P&lt;/code&gt;となることから、&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;P-A[i]&lt;/code&gt;以上のものと&lt;code&gt;P-A[i]&lt;/code&gt;より小さいもので分けて考えることができます。&lt;br /&gt;
&lt;code&gt;P-A[i]&lt;/code&gt;以上のものの個数を&lt;code&gt;X&lt;/code&gt;としたとき、&lt;code&gt;P-A[i]&lt;/code&gt;以上のものの価格の総和は&lt;code&gt;M*P&lt;/code&gt;になります。&lt;br /&gt;
&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの個数は&lt;code&gt;M-X&lt;/code&gt;となり、&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格和を&lt;code&gt;S&lt;/code&gt;とすると、&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格の総和は&lt;code&gt;A[i]*(M-X)+S&lt;/code&gt;となります。
&lt;code&gt;B&lt;/code&gt;をあらかじめソートしておき、累積和を求めておくことで、各&lt;code&gt;A[i]&lt;/code&gt;ごとに&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;P-A[i]&lt;/code&gt;以上の個数を時間計算量&lt;code&gt;O(logM)&lt;/code&gt;で求めることができ、累積和から&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格和を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。&lt;br /&gt;
よって、全体時間計算量&lt;code&gt;O(MlogM + NlogM)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, P) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(B);
    var cumB = new long[M + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        cumB[i + 1] = cumB[i] + B[i];
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var lb = LowerBound(B, Math.Max(0, P - A[i]));
        var x = A[i] * lb + cumB[lb];
        var y = (M - lb) * P;
        answer += x + y;
    }

    Console.WriteLine(answer);
}

public static int LowerBound&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
    =&amp;gt; LowerBound(System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source), key);

public static int LowerBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m].CompareTo(key) &amp;gt;= 0) r = m;
        else l = m;
    }

    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けていません。&lt;/p&gt;
&lt;!-- 
```csharp
``` --&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45887679"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 現在のクエリまでみたとき、総和がsとなる組み合わせの個数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;if op == '+'
dp[j] += dp[i][j-x] (j=K,K-1,..,x+1,x)

if op == '-'
dp[j] -= dp[i][j-x] (j=x,x+1,..,K-1,K)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (Q, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new mint[K + 1];
    dp[0] = 1;
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (op, x) = Scanner.Scan&amp;lt;char, int&amp;gt;();
        if (op == '+')
        {
            for (var j = K; j &amp;gt;= x; j--)
            {
                dp[j] += dp[j - x];
            }
        }
        else
        {
            for (var j = x; j &amp;lt;= K; j++)
            {
                dp[j] -= dp[j - x];
            }
        }

        var answer = dp[K];
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 321の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230916abc320</id>
		<title>ABC320</title>
		<link href="https://blog.aconcavy.dev/posts/20230916abc320" />
		<updated>2023-09-16T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 320の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320"&gt;https://atcoder.jp/contests/abc320&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45588498"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Math.Pow&lt;/code&gt;関数や、&lt;code&gt;for&lt;/code&gt;文で&lt;code&gt;A&lt;/code&gt;を&lt;code&gt;B&lt;/code&gt;回掛けたもの、&lt;code&gt;B&lt;/code&gt;を&lt;code&gt;A&lt;/code&gt;回掛けたものを求め、それぞれを足したものを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answer = Math.Pow(A, B) + Math.Pow(B, A);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45589841"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連続する部分文字列の両端の組み合わせ&lt;code&gt;i,j (i&amp;lt;=j)&lt;/code&gt;を全探索し、その部分文字列が回文であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i; j &amp;lt; N; j++)
        {
            var ok = true;
            for (var k = 0; k &amp;lt;= j - i &amp;amp;&amp;amp; ok; k++)
            {
                var a = i + k;
                var b = j - k;
                ok &amp;amp;= S[a] == S[b];
            }

            if (ok)
            {
                answer = Math.Max(answer, j - i + 1);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45601337"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スロットのリールのうち、どの数字を止めるかを固定して考えます。&lt;br /&gt;
止める数字を固定したとき、各リールでその数字が出現する順番を全探索します。&lt;br /&gt;
出現する順番が一致しているリールが2つのとき、それぞれ1周目と2周目で止めることで、その数字をそろえることができます。&lt;br /&gt;
出現する順番が一致しているリールが3つのとき、それぞれ1周目、2週目、3週目で止めることで、その数字をそろえることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var M = Scanner.Scan&amp;lt;int&amp;gt;();
    var list = new List&amp;lt;int&amp;gt;[3][];
    for (var i = 0; i &amp;lt; 3; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
        list[i] = new List&amp;lt;int&amp;gt;[10].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
        for (var j = 0; j &amp;lt; M; j++)
        {
            list[i][S[j]].Add(j);
        }
    }

    const int Inf = (int)1e9;
    var answer = Inf;
    for (var k = 0; k &amp;lt; 10; k++)
    {
        foreach (var a in list[0][k])
        {
            foreach (var b in list[1][k])
            {
                foreach (var c in list[2][k])
                {
                    var x = a;
                    var y = b;
                    var z = c;
                    if (x == y &amp;amp;&amp;amp; y == z)
                    {
                        x += M;
                        y += M * 2;
                    }
                    else if (x == y)
                    {
                        y += M;
                    }
                    else if (x == z)
                    {
                        z += M;
                    }
                    else if (y == z)
                    {
                        z += M;
                    }

                    answer = Math.Min(answer, Math.Max(Math.Max(x, y), z));
                }
            }

        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45608907"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の頂点に対して、&lt;code&gt;M&lt;/code&gt;個の情報を&lt;code&gt;A[i]&lt;/code&gt;から&lt;code&gt;B[i]&lt;/code&gt;への&lt;code&gt;D(X[i],Y[i])&lt;/code&gt;となる有向辺と&lt;code&gt;B[i]&lt;/code&gt;から&lt;code&gt;A[i]&lt;/code&gt;への&lt;code&gt;D(-X[i],-Y[i])&lt;/code&gt;となる有向辺とした、&lt;code&gt;2M&lt;/code&gt;個の辺からなる有向グラフを構築し、人&lt;code&gt;1&lt;/code&gt;を始点とした幅優先探索を行い、それぞれの人の座標の集合を求めます。&lt;br /&gt;
各人のあり得る座標の集合において、一意に定まる場合はその座標を、それ以外の場合は&lt;code&gt;undecidable&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    const string Undecidable = &amp;quot;undecidable&amp;quot;;
    var G = new HashSet&amp;lt;(int, Point)&amp;gt;[N].Select(x =&amp;gt; new HashSet&amp;lt;(int, Point)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, x, y) = Scanner.Scan&amp;lt;int, int, long, long&amp;gt;();
        a--; b--;
        G[a].Add((b, new(x, y)));
        G[b].Add((a, new(-x, -y)));
    }

    var P = new HashSet&amp;lt;Point&amp;gt;[N].Select(_ =&amp;gt; new HashSet&amp;lt;Point&amp;gt;()).ToArray();
    P[0].Add(new(0, 0));
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(0);
    while (queue.TryDequeue(out var u))
    {
        var cp = P[u].First();
        foreach (var (v, diff) in G[u])
        {
            var (dx, dy) = diff;
            var np = new Point(cp.X + dx, cp.Y + dy);
            if (P[v].Contains(np)) continue;
            P[v].Add(np);
            queue.Enqueue(v);
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (P[i].Count == 1)
        {
            var p = P[i].First();
            Console.WriteLine($&amp;quot;{p.X} {p.Y}&amp;quot;);
        }
        else
        {
            Console.WriteLine(Undecidable);
        }
    }
}

public readonly record struct Point(long X, long Y);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45623544"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待機列の人を番号順に管理できる優先度付きキューと、列から離れた人の番号と帰ってくる時間を時間順に管理できる優先度付きキューを用意し、そうめんが流れてくるごとに、その時間以前の列から離れた人を待機列に追加し、待機列の先頭の人にそうめんを獲得させ、その人を列から離れさせるというシミュレーションを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();

    var leavingID = new PriorityQueue&amp;lt;R&amp;gt;((x, y) =&amp;gt;
    {
        var result = x.Time.CompareTo(y.Time);
        if (result == 0) result = x.ID.CompareTo(y.ID);
        return result;
    });

    for (var i = 0; i &amp;lt; N; i++)
    {
        leavingID.Enqueue(new R(i, 0));
    }

    var waitingID = new PriorityQueue&amp;lt;int&amp;gt;((x, y) =&amp;gt; x.CompareTo(y));
    var answers = new long[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (t, w, s) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        while (leavingID.Count &amp;gt; 0 &amp;amp;&amp;amp; leavingID.Peek().Time &amp;lt;= t)
        {
            var (id, _) = leavingID.Dequeue();
            waitingID.Enqueue(id);
        }

        if (waitingID.Count == 0) continue;
        var waited = waitingID.Dequeue();
        answers[waited] += w;
        var nt = t + s;
        leavingID.Enqueue(new R(waited, nt));
    }

    Console.WriteLine(string.Join(Environment.NewLine, answers));
}

public readonly record struct R(int ID, long Time);

public class PriorityQueue&amp;lt;T&amp;gt; : IReadOnlyCollection&amp;lt;T&amp;gt;
{
    private readonly Comparison&amp;lt;T&amp;gt; _comparison;
    private readonly List&amp;lt;T&amp;gt; _heap;

    public PriorityQueue(IEnumerable&amp;lt;T&amp;gt; items, IComparer&amp;lt;T&amp;gt; comparer = null) : this(comparer)
    {
        foreach (var item in items) Enqueue(item);
    }

    public PriorityQueue(IEnumerable&amp;lt;T&amp;gt; items, Comparison&amp;lt;T&amp;gt; comparison) : this(comparison)
    {
        foreach (var item in items) Enqueue(item);
    }

    public PriorityQueue(IComparer&amp;lt;T&amp;gt; comparer = null) : this((comparer ?? Comparer&amp;lt;T&amp;gt;.Default).Compare) { }

    public PriorityQueue(Comparison&amp;lt;T&amp;gt; comparison)
    {
        _heap = new List&amp;lt;T&amp;gt;();
        _comparison = comparison;
    }

    public int Count =&amp;gt; _heap.Count;
    public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; _heap.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();

    public void Enqueue(T item)
    {
        var child = Count;
        _heap.Add(item);
        while (child &amp;gt; 0)
        {
            var parent = (child - 1) / 2;
            if (_comparison(_heap[parent], _heap[child]) &amp;lt;= 0) break;
            (_heap[parent], _heap[child]) = (_heap[child], _heap[parent]);
            child = parent;
        }
    }

    public T Dequeue()
    {
        if (Count == 0) throw new InvalidOperationException();
        var result = _heap[0];
        _heap[0] = _heap[Count - 1];
        _heap.RemoveAt(Count - 1);
        var parent = 0;
        while (parent * 2 + 1 &amp;lt; Count)
        {
            var left = parent * 2 + 1;
            var right = parent * 2 + 2;
            if (right &amp;lt; Count &amp;amp;&amp;amp; _comparison(_heap[left], _heap[right]) &amp;gt; 0)
                left = right;
            if (_comparison(_heap[parent], _heap[left]) &amp;lt;= 0) break;
            (_heap[parent], _heap[left]) = (_heap[left], _heap[parent]);
            parent = left;
        }

        return result;
    }

    public T Peek()
    {
        if (Count == 0) throw new InvalidOperationException();
        return _heap[0];
    }

    public bool TryDequeue(out T result)
    {
        if (Count &amp;gt; 0)
        {
            result = Dequeue();
            return true;
        }

        result = default;
        return false;
    }

    public bool TryPeek(out T result)
    {
        if (Count &amp;gt; 0)
        {
            result = Peek();
            return true;
        }

        result = default;
        return false;
    }

    public void Clear() =&amp;gt; _heap.Clear();
    public bool Contains(T item) =&amp;gt; _heap.Contains(item);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 320の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230909abc319</id>
		<title>ABC319</title>
		<link href="https://blog.aconcavy.dev/posts/20230909abc319" />
		<updated>2023-09-09T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 319の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc319"&gt;https://atcoder.jp/contests/abc319&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45355649"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名前をキーとして辞書を作成し、対応するレートを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var T = &amp;#64;&amp;quot;tourist 3858
ksun48 3679
Benq 3658
Um_nik 3648
apiad 3638
Stonefeang 3630
ecnerwala 3613
mnbvmar 3555
newbiedmy 3516
semiexp 3481&amp;quot;;

    var dict = new Dictionary&amp;lt;string, string&amp;gt;();
    foreach (var line in T.Replace(&amp;quot;\r&amp;quot;, string.Empty).Split('\n'))
    {
        var array = line.Split(' ');
        dict[array[0]] = array[1];
    }

    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = dict[S];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45360297"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;i (0&amp;lt;=i&amp;lt;=N)&lt;/code&gt;について、条件を満たす&lt;code&gt;j (1&amp;lt;=j&amp;lt;=9)&lt;/code&gt;を全探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new char[N + 1];
    Array.Fill(S, '-');
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 1; j &amp;lt;= 9; j++)
        {
            if (N % j == 0 &amp;amp;&amp;amp; i % (N / j) == 0)
            {
                S[i] = (char)(j + '0');
                break;
            }
        }
    }

    var answer = new string(S);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45379425"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h&lt;/code&gt;行目&lt;code&gt;w&lt;/code&gt;列目(&lt;code&gt;0&amp;lt;=h,w&amp;lt;=2&lt;/code&gt;)のマス番号を&lt;code&gt;h*3+w&lt;/code&gt;とします。
高橋君が知るマス番号の順列について、&lt;code&gt;9!(362880)&lt;/code&gt;通りの全探索を行い、各マス番号の順列について、次の数字を管理しながらがっかりするものかどうかを判定します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt;行目の知った数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt;列目の知った数字&lt;/li&gt;
&lt;li&gt;左上から右下にかけての斜めの知った数字&lt;/li&gt;
&lt;li&gt;右上から左下にかけての斜めの知った数字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(9! - がっかりしたマス番号の順列の個数) / 9!&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var C = new int[3][];
    for (var i = 0; i &amp;lt; 3; i++)
    {
        C[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    (int, int) F(int x) =&amp;gt; (x / 3, x % 3);

    var all = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;
    var p = all;
    var tate = new List&amp;lt;int&amp;gt;[3].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;(3)).ToArray();
    var yoko = new List&amp;lt;int&amp;gt;[3].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;(3)).ToArray();
    var naname1 = new List&amp;lt;int&amp;gt;();
    var naname2 = new List&amp;lt;int&amp;gt;();
    foreach (var items in Enumerable.Range(0, 9).Permute())
    {
        for (var i = 0; i &amp;lt; 3; i++)
        {
            yoko[i].Clear();
            tate[i].Clear();
        }
        naname1.Clear();
        naname2.Clear();

        var ng = false;
        for (var i = 0; i &amp;lt; 9 &amp;amp;&amp;amp; !ng; i++)
        {
            var (h, w) = F(items[i]);
            var v = C[h][w];
            yoko[h].Add(v);
            tate[w].Add(v);
            if (h - w == 0) naname1.Add(v);
            if (h + w == 2) naname2.Add(v);

            ng |= yoko[h].Count == 3 &amp;amp;&amp;amp; yoko[h][0] == yoko[h][1] &amp;amp;&amp;amp; yoko[h][0] != yoko[h][2];
            ng |= tate[w].Count == 3 &amp;amp;&amp;amp; tate[w][0] == tate[w][1] &amp;amp;&amp;amp; tate[w][0] != tate[w][2];
            ng |= naname1.Count == 3 &amp;amp;&amp;amp; naname1[0] == naname1[1] &amp;amp;&amp;amp; naname1[0] != naname1[2];
            ng |= naname2.Count == 3 &amp;amp;&amp;amp; naname2[0] == naname2[1] &amp;amp;&amp;amp; naname2[0] != naname2[2];
        }

        if (ng) p--;
    }

    var answer = (double)p / all;
    Console.WriteLine(answer);
}

public static partial class EnumerableExtension
{
    public static IEnumerable&amp;lt;T[]&amp;gt; Permute&amp;lt;T&amp;gt;(this IEnumerable&amp;lt;T&amp;gt; source)
    {
        if (source is null) throw new ArgumentNullException(nameof(source));
        IEnumerable&amp;lt;T[]&amp;gt; Inner()
        {
            var items = source.ToArray();
            var n = items.Length;
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++)
            {
                indices[i] = i;
            }
            T[] Result()
            {
                var result = new T[n];
                for (var i = 0; i &amp;lt; n; i++)
                {
                    result[i] = items[indices[i]];
                }
                return result;
            }
            yield return Result();
            while (true)
            {
                var (i, j) = (n - 2, n - 1);
                while (i &amp;gt;= 0)
                {
                    if (indices[i] &amp;lt; indices[i + 1]) break;
                    i--;
                }
                if (i == -1) yield break;
                while (true)
                {
                    if (indices[j] &amp;gt; indices[i]) break;
                    j--;
                }
                (indices[i], indices[j]) = (indices[j], indices[i]);
                Array.Reverse(indices, i + 1, n - 1 - i);
                yield return Result();
            }
        }
        return Inner();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45390878"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;幅を&lt;code&gt;W&lt;/code&gt;としたときに文章が&lt;code&gt;M&lt;/code&gt;行以内に収まるという判定式で、答えとなる&lt;code&gt;W&lt;/code&gt;を&lt;code&gt;[Max(L), Sum(L)+N-1)&lt;/code&gt;で二部探索します。&lt;br /&gt;
判定式では、&lt;code&gt;L[i]&lt;/code&gt;を順に見ていき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;現在見ている行の文字数が&lt;code&gt;0&lt;/code&gt;の場合、行の始まりなので文字数に&lt;code&gt;L[i]&lt;/code&gt;を足します。&lt;/li&gt;
&lt;li&gt;現在見ている行の文字数が&lt;code&gt;0&lt;/code&gt;より大きい場合、かつ空白と単語を追加できる場合、文字数に&lt;code&gt;1+L[i]&lt;/code&gt;を足します。&lt;/li&gt;
&lt;li&gt;現在見ている行の文字数が&lt;code&gt;0&lt;/code&gt;より大きい場合、かつ空白と単語を追加できない場合、行数を追加し文字数を&lt;code&gt;L[i]&lt;/code&gt;にします。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全ての&lt;code&gt;i&lt;/code&gt;を見たとき、行数が&lt;code&gt;M&lt;/code&gt;以内であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var L = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var min = L.Max();
    var max = L.Sum() + N - 1;

    bool F(long x)
    {
        var line = 1;
        long cum = 0;
        for (var i = 0; i &amp;lt; N; i++)
        {
            if (cum == 0)
            {
                cum += L[i];
            }
            else
            {
                if (cum + 1 + L[i] &amp;lt;= x)
                {
                    cum += 1 + L[i];
                }
                else
                {
                    cum = L[i];
                    line++;
                }
            }
        }

        return line &amp;lt;= M;
    }

    var answer = BinarySearch(min - 1, max, F);
    Console.WriteLine(answer);
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45420594"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各バスについて&lt;code&gt;P[i]&lt;/code&gt;の周期があることから、全体で&lt;code&gt;Lcm(P)&lt;/code&gt;の周期があることがわかります。&lt;br /&gt;
そのため、高橋君の家から出発する時間をそれぞれ&lt;code&gt;0,1,...,Lcm(P)-1&lt;/code&gt;としたとき、青木君の家までかかる時間の累積和を時間計算量&lt;code&gt;O(Lcm*N)&lt;/code&gt;であらかじめ計算しておくことで、各クエリに対して時間計算量&lt;code&gt;O(1)&lt;/code&gt;で答えを求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var P = new int[N - 1];
    var T = new long[N - 1];
    long lcm = 1;
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (p, t) = Scanner.Scan&amp;lt;int, long&amp;gt;();
        P[i] = p;
        T[i] = t;
        lcm = Lcm(lcm, p);
    }

    var cum = new long[lcm];
    for (var l = 0; l &amp;lt; lcm; l++)
    {
        cum[l] = l + X;
        for (var i = 0; i + 1 &amp;lt; N; i++)
        {
            cum[l] = (cum[l] + P[i] - 1) / P[i] * P[i] + T[i];
        }

        cum[l] += Y;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var q = Scanner.Scan&amp;lt;int&amp;gt;();
        var answer = q / lcm * lcm + cum[q % lcm];
        Console.WriteLine(answer);
    }
}

public static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
public static long Lcm(long a, long b) =&amp;gt; a / Gcd(a, b) * b;
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 319の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230902abc318</id>
		<title>ABC318</title>
		<link href="https://blog.aconcavy.dev/posts/20230902abc318" />
		<updated>2023-09-02T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 318の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc318"&gt;https://atcoder.jp/contests/abc318&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45132398"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;日間のうち&lt;code&gt;M&lt;/code&gt;日目以降の期間は&lt;code&gt;N-M&lt;/code&gt;日間であり、この期間に&lt;code&gt;Floor(N-M)/P&lt;/code&gt;回満月を見ることができます。&lt;br /&gt;
これに&lt;code&gt;M&lt;/code&gt;日目を加えた、&lt;code&gt;Floor(N-M)/P+1&lt;/code&gt;が答えとなります。&lt;br /&gt;
&lt;code&gt;N-M&lt;/code&gt;が負数になることがあるので注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, P) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var answer = (N - M + P) / P;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45136636"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;シートは最大でも&lt;code&gt;0&amp;lt;=x&amp;lt;=100&lt;/code&gt;かつ&lt;code&gt;0&amp;lt;=y&amp;lt;=100&lt;/code&gt;なので、&lt;code&gt;100*100&lt;/code&gt;のグリッドを用意し、その領域がシートで覆われているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var H = 100;
    var W = 100;
    var G = new bool[H + 1, W + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b, c, d) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
        for (var x = a; x &amp;lt; b; x++)
        {
            for (var y = c; y &amp;lt; d; y++)
            {
                G[x, y] = true;
            }
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt;= H; i++)
    {
        for (var j = 0; j &amp;lt;= W; j++)
        {
            if (G[i, j]) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45140727"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周遊パスは好きな日に使うことができるので、&lt;code&gt;F&lt;/code&gt;をソートしても問題ありません。&lt;br /&gt;
次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i] := i日間の旅行でかかる最小金額
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;// i日目の運賃を通常料金で払うとき
dp[i+1] = Min(dp[i+1], dp[i]+F[i])

// i日目の運賃を周遊パスで払うとき
dp[i+D] = Min(dp[i+D], dp[i]+P)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i+D&lt;/code&gt;が&lt;code&gt;N&lt;/code&gt;より大きい場合は&lt;code&gt;N&lt;/code&gt;にまとめることができ、&lt;code&gt;dp[N]&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D, P) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var F = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(F);
    var cum = new long[N + 1];
    const long Inf = (long)1e18;
    Array.Fill(cum, Inf);
    cum[0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = Math.Min(cum[i + 1], cum[i] + F[i]);
        var x = Math.Min(i + D, N);
        cum[x] = Math.Min(cum[x], cum[i] + P);
    }

    var answer = cum[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45149396"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 既に選んだ頂点集合がsのときの選んだ重みの総和の最大値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;i番目の頂点とj番目の頂点がsに含まれていないとき、sにiとjを含んだ頂点集合をtとする。
dp[t] = Max(dp[t], dp[s]+D[i][j])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全ての頂点集合のうち、総和の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = new long[N, N];
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var d = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        for (var j = 0; j &amp;lt; d.Length; j++)
        {
            D[i, i + j + 1] = d[j];
        }
    }

    var dp = new long[1 &amp;lt;&amp;lt; N];
    dp[0] = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = i + 1; j &amp;lt; N; j++)
            {
                if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1 || (s &amp;gt;&amp;gt; j &amp;amp; 1) == 1) continue;
                var t = s | (1 &amp;lt;&amp;lt; i) | (1 &amp;lt;&amp;lt; j);
                dp[t] = Math.Max(dp[t], dp[s] + D[i, j]);
            }
        }
    }

    long answer = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        answer = Math.Max(answer, dp[s]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45196083"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;L[x]&lt;/code&gt;を現在左側にある&lt;code&gt;x&lt;/code&gt;の個数、&lt;code&gt;R[x]&lt;/code&gt;を現在右側にある&lt;code&gt;x&lt;/code&gt;の個数とします。&lt;br /&gt;
&lt;code&gt;j&lt;/code&gt;を固定したとき、&lt;code&gt;j&lt;/code&gt;に対して条件を満たす&lt;code&gt;i,k&lt;/code&gt;の組み合わせの個数は、&lt;code&gt;1&amp;lt;=y&amp;lt;=N&lt;/code&gt;かつ&lt;code&gt;y!=A[j]&lt;/code&gt;の&lt;code&gt;L[y]*R[y]&lt;/code&gt;の総和になります。&lt;br /&gt;
これにより、各&lt;code&gt;j&lt;/code&gt;に対して時間計算量&lt;code&gt;O(N)&lt;/code&gt;で組み合わせの個数を求めることができますが、全体時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、&lt;code&gt;j&lt;/code&gt;を1つずらしたとき、&lt;code&gt;L[A[j]]&lt;/code&gt;が1つ増え、&lt;code&gt;R[A[j]]&lt;/code&gt;が1つ減ることから、組み合わせの個数を累積和として管理し、各&lt;code&gt;j&lt;/code&gt;における差分のみを計算することで、各&lt;code&gt;j&lt;/code&gt;に対して時間計算量&lt;code&gt;O(1)&lt;/code&gt;で組み合わせの個数を求めることができるようになり、全体時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var L = new long[N + 1];
    var R = new long[N + 1];

    foreach (var a in A) R[a]++;

    long answer = 0;
    long cum = 0;
    foreach (var a in A)
    {
        cum -= L[a] * R[a];
        answer += cum;
        R[a]--;
        L[a]++;
        cum += L[a] * R[a];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 318の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230826abc317</id>
		<title>ABC317</title>
		<link href="https://blog.aconcavy.dev/posts/20230826abc317" />
		<updated>2023-08-26T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 317の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc317"&gt;https://atcoder.jp/contests/abc317&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44936354"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;H+P[i]&amp;gt;=X&lt;/code&gt;となる最初の&lt;code&gt;i&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, H, X) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (H + P[i] &amp;gt;= X)
        {
            Console.WriteLine(i + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44940376"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;をソートし、&lt;code&gt;A[i-1]+1==A[i]&lt;/code&gt;ならば、それらの整数は連続しています。&lt;br /&gt;
そのため、&lt;code&gt;A[i-1]+1!=A[i]&lt;/code&gt;ならばそれらの整数が連続しておらず、&lt;code&gt;A[i-1]+1&lt;/code&gt;がなくした整数になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    Array.Sort(A);
    for (var i = 1; i &amp;lt; N; i++)
    {
        if (A[i - 1] + 1 != A[i])
        {
            Console.WriteLine(A[i - 1] + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44945752"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既に訪れた町と、現在通った道路の長さの和を管理しながら深さ優先探索を行います。
時間計算量&lt;code&gt;O(N!)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, c) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        G[a].Add((b, c));
        G[b].Add((a, c));
    }

    long answer = 0;
    var used = new bool[N];

    void Dfs(int u, long s)
    {
        answer = Math.Max(answer, s);
        used[v] = true;
        foreach (var (v, c) in G[u])
        {
            if (used[v]) continue;
            Dfs(v, s + c);
        }
        used[v] = false;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        Dfs(i, 0);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44957520"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44982250"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][s] := i番目の選挙区までみたとき、s議席獲得するために必要な鞍替えさせる必要がある人数の最小値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;v = (Max(0, Y[i]-X[i]) + 1) / 2; // i番目の選挙区において高橋派が過半数を得るために必要な、鞍替えさせる必要がある人数
dp[i+1][s] = Min(dp[i+1][s], dp[i][s-Z[i]] + v);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、&lt;code&gt;N&lt;/code&gt;個の選挙区全体として過半数の議席を獲得するには、全ての議席の数を&lt;code&gt;zs&lt;/code&gt;としたとき、必要な議席&lt;code&gt;req&lt;/code&gt;は&lt;code&gt;(zs+1)/2&lt;/code&gt;以上であるため、&lt;code&gt;dp[req]&lt;/code&gt;から&lt;code&gt;dp[zs]&lt;/code&gt;までの最小値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var V = new (long X, long Y, long Z)[N];
    long zs = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, z) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        V[i] = (x, y, z);
        zs += z;
    }

    const long Inf = (long)1e18;
    var dp = new long[zs + 1];
    Array.Fill(dp, Inf);
    dp[0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, z) = V[i];
        var v = (Math.Max(0, y - x) + 1) / 2;
        for (var s = zs; s &amp;gt;= z; s--)
        {
            dp[s] = Math.Min(dp[s], dp[s - z] + v);
        }
    }

    var req = (zs + 1) / 2;
    var answer = Inf;
    for (var s = req; s &amp;lt;= zs; s++)
    {
        answer = Math.Min(answer, dp[s]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44964613"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各人の視線をあらかじめ計算しておき、幅優先探索を行うことで答えを求めることができます。&lt;br /&gt;
グリッド内のマスのうち、侵入可能な&lt;code&gt;.&lt;/code&gt;、&lt;code&gt;S&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;のマスを侵入可能マス、人や障害物の侵入不可能マスをとしたとき、各人の視線は、各人のマスから各方向に対して侵入不可能マスまでの侵入可能マスを侵入不可能にします。&lt;br /&gt;
このことから&lt;code&gt;X[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目のマスを侵入可能かとしたとき、侵入不可能マスに加えて、侵入可能マスを侵入不可能にしたものに対して、&lt;code&gt;S&lt;/code&gt;のマスから&lt;code&gt;G&lt;/code&gt;のマスまでの最短距離を、グリッド上における4方向の幅優先探索で求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    var (sh, sw) = (-1, -1);
    var (gh, gw) = (-1, -1);
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == 'S') (sh, sw) = (i, j);
            if (G[i][j] == 'G') (gh, gw) = (i, j);
        }
    }

    bool IsPossible(int h, int w)
    {
        return 0 &amp;lt;= h &amp;amp;&amp;amp; h &amp;lt; H &amp;amp;&amp;amp; 0 &amp;lt;= w &amp;amp;&amp;amp; w &amp;lt; W &amp;amp;&amp;amp; (G[h][w] == '.' || G[h][w] == 'S' || G[h][w] == 'G');
    }

    var X = new bool[H, W];
    X[sh, sw] = X[gh, gw] = true;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (IsPossible(i, j)) X[i, j] = true;
        }
    }

    void F(char c)
    {
        var (dh, dw) = (0, 0);
        if (c == '&amp;gt;') dw = 1;
        if (c == 'v') dh = 1;
        if (c == '&amp;lt;') dw = -1;
        if (c == '^') dh = -1;

        for (var i = 0; i &amp;lt; H; i++)
        {
            for (var j = 0; j &amp;lt; W; j++)
            {
                if (G[i][j] == c)
                {
                    var k = 1;
                    while (IsPossible(i + dh * k, j + dw * k))
                    {
                        var ni = i + dh * k;
                        var nj = j + dw * k;
                        X[ni, nj] = false;
                        k++;
                    }
                }
            }
        }
    }

    F('&amp;gt;');
    F('v');
    F('&amp;lt;');
    F('^');

    var dp = new int[H, W];
    const int Inf = (int)1e9;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            dp[i, j] = Inf;
        }
    }

    dp[sh, sw] = 0;

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    var queue = new Queue&amp;lt;(int, int, int)&amp;gt;();
    queue.Enqueue((sh, sw, 0));
    while (queue.TryDequeue(out var top))
    {
        var (ch, cw, cc) = top;
        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            if (!X[nh, nw] || dp[nh, nw] &amp;lt;= cc + 1) continue;
            dp[nh, nw] = cc + 1;
            queue.Enqueue((nh, nw, cc + 1));
        }
    }

    var answer = dp[gh, gw];
    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 317の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230819abc315</id>
		<title>ABC315</title>
		<link href="https://blog.aconcavy.dev/posts/20230819abc315" />
		<updated>2023-08-19T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 315の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315"&gt;https://atcoder.jp/contests/abc315&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44708524"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aeiou&lt;/code&gt;以外の文字を連結したものが答えになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var builder = new StringBuilder();
    const string AEIOU = &amp;quot;aeiou&amp;quot;;
    foreach (var c in S)
    {
        if (!AEIOU.Contains(c)) builder.Append(c);
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44712931"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;真ん中の日&lt;code&gt;mid&lt;/code&gt;は、&lt;code&gt;(Dの総和+1)/2&lt;/code&gt;で求めることができます。&lt;br /&gt;
合計日数を数え上げながら順に月を見ていき、&lt;code&gt;その月以前の合計日数+その月の日数&lt;/code&gt;が&lt;code&gt;mid&lt;/code&gt;以上になったとき、その月が答えの月となり、&lt;code&gt;mid-その月以前の合計日数&lt;/code&gt;でその月の日にちを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var M = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var sum = D.Sum();
    var mid = (sum + 1) / 2;
    var cum = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        if (cum + D[i] &amp;lt; mid)
        {
            cum += D[i];
        }
        else
        {
            Console.WriteLine($&amp;quot;{i + 1} {(mid - cum)}&amp;quot;);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44732908"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2つのカップの組み合わせを愚直に探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、2つのカップの味が異なるときの最大値と、2つのカップの味が一緒の時の最大値を求め、最終的な最大値を求めます。&lt;br /&gt;
2つのカップの味が異なるとき、全てのカップのうち美味しさ&lt;code&gt;S&lt;/code&gt;が最大のものと、それとは異なる味のうち美味しさ&lt;code&gt;S&lt;/code&gt;が最大となるものが最大の満足度となります。&lt;br /&gt;
2つのカップの味が一緒のとき、各味において美味しさ&lt;code&gt;S&lt;/code&gt;が大きい方から2つ選んだものが、各味における満足度の最大となります。&lt;br /&gt;
これにより、2つのカップの味が異なるときの最大値と、各味2つ選んだ時の最大値のうち、最大となるものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new Dictionary&amp;lt;long, Dictionary&amp;lt;int, int&amp;gt;&amp;gt;();
    var ices = new (int F, long S)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (f, s) = Scanner.Scan&amp;lt;int, long&amp;gt;();
        ices[i] = (f, s);
    }

    Array.Sort(ices, (x, y) =&amp;gt; y.S.CompareTo(x.S));

    long answer = 0;
    for (var i = 1; i &amp;lt; N; i++)
    {
        if (ices[i].F != ices[0].F)
        {
            answer = ices[0].S + ices[i].S;
            break;
        }
    }

    var count = new int[N + 1];
    var same = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (f, s) = ices[i];
        if (count[f] == 0)
        {
            count[f]++;
            same[f] += s;
        }
        else if (count[f] == 1)
        {
            count[f]++;
            same[f] += s / 2;
        }
    }

    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer = Math.Max(answer, same[i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;また解けていません。&lt;/p&gt;
&lt;!-- [コンテスト提出]()  
[復習提出]()

```csharp
``` --&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44744826"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本&lt;code&gt;i&lt;/code&gt;の前提となる各本&lt;code&gt;P&lt;/code&gt;を、&lt;code&gt;i&lt;/code&gt;から各&lt;code&gt;P&lt;/code&gt;に対する有向辺としたグラフとしたとき、このグラフに対して&lt;code&gt;1&lt;/code&gt;を始点とした深さ優先探索の帰りがけ順に頂点を並べたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var queue = new Queue&amp;lt;int&amp;gt;();
    var used = new bool[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

        foreach (var v in P.Skip(1).Select(x =&amp;gt; x - 1))
        {
            G[i].Add(v);
        }
    }

    var answer = new List&amp;lt;int&amp;gt;();

    void Dfs(int u)
    {
        foreach (var v in G[u])
        {
            if (used[v]) continue;
            Dfs(v);
        }

        used[u] = true;
        answer.Add(u);
    }

    Dfs(0);

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Select(x =&amp;gt; x + 1).Where(x =&amp;gt; x != 1)));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 315の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230812abc314</id>
		<title>ABC314</title>
		<link href="https://blog.aconcavy.dev/posts/20230812abc314" />
		<updated>2023-08-12T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 314の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314"&gt;https://atcoder.jp/contests/abc314&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44488749"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;円周率を文字列&lt;code&gt;S&lt;/code&gt;としたとき、&lt;code&gt;3.&lt;/code&gt;と小数&lt;code&gt;N&lt;/code&gt;文字が答えとなるので、&lt;code&gt;S&lt;/code&gt;の先頭&lt;code&gt;N+2&lt;/code&gt;文字が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const string PI = &amp;quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&amp;quot;;
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = PI[..(N + 2)];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44495322"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[a,c]&lt;/code&gt;を&lt;code&gt;a&lt;/code&gt;に掛けた人のうち、掛けた個数が&lt;code&gt;c&lt;/code&gt;の人の番号の集合としたとき、空集合ではない&lt;code&gt;S[X,c]&lt;/code&gt;が答えとなり、そのような&lt;code&gt;c&lt;/code&gt;が存在しなければ、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int M = 37;
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new List&amp;lt;int&amp;gt;[M + 1, M + 1];
    for (var i = 0; i &amp;lt;= M; i++)
    {
        for (var j = 0; j &amp;lt;= M; j++)
        {
            S[i, j] = new List&amp;lt;int&amp;gt;();
        }
    }

    for (var i = 1; i &amp;lt;= N; i++)
    {
        var c = Scanner.Scan&amp;lt;int&amp;gt;();
        var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        foreach (var a in A)
        {
            S[a, c].Add(i);
        }
    }

    var X = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt;= M; i++)
    {
        if (S[X, i].Count == 0) continue;
        Console.WriteLine(S[X, i].Count);
        Console.WriteLine(string.Join(&amp;quot; &amp;quot;, S[X, i]));
        return;
    }

    Console.WriteLine(0);
    Console.WriteLine();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44498953"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各色ごとに出現位置を管理し、各文字を右シフトします。&lt;br /&gt;
現在の文字と同じ色の左の文字(一番左の場合は最後の文字)を&lt;code&gt;prev&lt;/code&gt;としたとき、現在の文字と&lt;code&gt;prev&lt;/code&gt;をスワップしていくことで、右シフトを実現できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var ID = new List&amp;lt;int&amp;gt;[M + 1].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        ID[C[i]].Add(i);
    }

    var T = S.ToCharArray();
    for (var i = 1; i &amp;lt;= M; i++)
    {
        if (ID[i].Count &amp;lt;= 1) continue;
        var idx = ID[i];
        var prev = T[idx[^1]];
        for (var j = 0; j &amp;lt; idx.Count; j++)
        {
            (T[idx[j]], prev) = (prev, T[idx[j]]);
        }
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44504779"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリを愚直に操作してしまうと、クエリが&lt;code&gt;t==2&lt;/code&gt;または&lt;code&gt;t==3&lt;/code&gt;のときごとに&lt;code&gt;S&lt;/code&gt;を全て見る必要があるため、全体時間計算量が&lt;code&gt;O(QN)&lt;/code&gt;になってしまい、実行時間制限に間に合いません。&lt;br /&gt;
&lt;code&gt;t==2&lt;/code&gt;のときと&lt;code&gt;t==3&lt;/code&gt;のときの操作を考えたとき、クエリが&lt;code&gt;t==2&lt;/code&gt;のとき、&lt;code&gt;S&lt;/code&gt;は全て小文字になり、&lt;code&gt;t==3&lt;/code&gt;のとき、&lt;code&gt;S&lt;/code&gt;は全て大文字になります。&lt;br /&gt;
このことから、&lt;code&gt;t==2&lt;/code&gt;または&lt;code&gt;t==3&lt;/code&gt;を大小の変更操作としたとき、クエリ全体の最後に出現する大小の変更操作より前の大小の変更操作は上書きされることがわかります。&lt;br /&gt;
あらかじめ、大小の変更操作の最終位置をクエリ先読みしておき、&lt;code&gt;t==1&lt;/code&gt;となるクエリを順に操作しつつ、大小の変更操作の最終位置でのみ&lt;code&gt;S&lt;/code&gt;の大小の変更操作を行うことで、&lt;code&gt;S&lt;/code&gt;を全てを操作することは1回で済むため、全体時間計算量&lt;code&gt;O(Q+N)&lt;/code&gt;で答えを求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var state = 0;
    var changed = -1;
    var T = S.ToCharArray();
    var queries = new (int T, int X, char C)[Q];
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (t, x, c) = Scanner.Scan&amp;lt;int, int, char&amp;gt;();
        x--;
        queries[i] = (t, x, c);
        if (t != 1)
        {
            state = t;
            changed = i;
        }
    }

    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (t, x, c) = queries[i];
        if (i == changed &amp;amp;&amp;amp; state != 1)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                T[j] = state == 2 ? char.ToLower(T[j]) : char.ToUpper(T[j]);
            }
        }

        if (t == 1)
        {
            T[x] = c;
        }
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 314の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230805abc313</id>
		<title>ABC313</title>
		<link href="https://blog.aconcavy.dev/posts/20230805abc313" />
		<updated>2023-08-05T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 313の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313"&gt;https://atcoder.jp/contests/abc313&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44256971"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;が&lt;code&gt;1&lt;/code&gt;のときは、人&lt;code&gt;1&lt;/code&gt;が最強なので、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;br /&gt;
それ以外のときは、人&lt;code&gt;1&lt;/code&gt;以外の最大のプログラミング力に&lt;code&gt;+1&lt;/code&gt;したものから人&lt;code&gt;1&lt;/code&gt;のプログラミング力を引いたものが答えとなります。&lt;br /&gt;
ただし、人&lt;code&gt;1&lt;/code&gt;以外の最大のプログラミング力が人&lt;code&gt;1&lt;/code&gt;のプログラミング力よりも小さい場合、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var max = N &amp;gt; 1 ? P.Skip(1).Max() : 0;
    var answer = Math.Max(max + 1 - P[0], 0);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44268074"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;それぞれの人&lt;code&gt;x&lt;/code&gt;について、人&lt;code&gt;x&lt;/code&gt;よりも強い人の数を&lt;code&gt;deg[x]&lt;/code&gt;としたとき、&lt;code&gt;deg[x]&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;となる人&lt;code&gt;x&lt;/code&gt;が最強のプログラマー候補となります。&lt;br /&gt;
最強のプログラマー候補が複数人いる場合、最強となる人を特定することはできないので、答えは&lt;code&gt;-1&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var deg = new int[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        deg[b]++;
    }

    var answer = -1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (deg[i] != 0) continue;
        if (answer == -1)
        {
            answer = i + 1;
        }
        else
        {
            Console.WriteLine(-1);
            return;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44294553"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作を行ったところで、&lt;code&gt;A&lt;/code&gt;の合計値&lt;code&gt;Sum&lt;/code&gt;は変わらないことから、&lt;code&gt;A&lt;/code&gt;の平均値を&lt;code&gt;Ave&lt;/code&gt;としたとき、各要素は&lt;code&gt;Floor(Ave)&lt;/code&gt;もしくは&lt;code&gt;Ceil(Ave)&lt;/code&gt;にすることで、&lt;code&gt;A&lt;/code&gt;の最小値と最大値の差を&lt;code&gt;1&lt;/code&gt;以下にすることができます。&lt;br /&gt;
そして、&lt;code&gt;Ceil(Ave)&lt;/code&gt;になりうる値は、&lt;code&gt;Sum&lt;/code&gt;を&lt;code&gt;N&lt;/code&gt;で割った余り&lt;code&gt;M&lt;/code&gt;個であればいいことがわかります。&lt;br /&gt;
このことから、&lt;code&gt;A&lt;/code&gt;の大きい方から&lt;code&gt;M&lt;/code&gt;個を&lt;code&gt;Ceil(Ave)&lt;/code&gt;、残りの&lt;code&gt;N-M&lt;/code&gt;個を&lt;code&gt;Floor(Ceil)&lt;/code&gt;にしたときの回数を合わせ、&lt;code&gt;2&lt;/code&gt;で割ったものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    var sum = A.Sum();
    var ave = sum / N;
    var mod = sum % N;
    long answer = 0;
    for (var i = 0; i &amp;lt; N - mod; i++)
    {
        answer += Math.Abs(ave - A[i]);
    }

    for (var i = 0; i &amp;lt; mod; i++)
    {
        answer += Math.Abs(A[N - 1 - i] - (ave + 1));
    }

    answer = answer / 2;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 313の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>