<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://aconcavy.github.io/blog/</id>
	<title />
	<link rel="self" href="https://aconcavy.github.io/blog/" />
	<rights>Copyright © 2020-2022 AconCavy</rights>
	<updated>2022-05-06T02:44:01Z</updated>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220423abc249</id>
		<title>ABC249</title>
		<link href="https://aconcavy.github.io/blog/posts/20220423abc249" />
		<updated>2022-04-23T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 249の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc249"&gt;https://atcoder.jp/contests/abc249&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31188853"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高橋君の進む距離を考えます。
歩く+休むを1セットとすると、&lt;code&gt;X&lt;/code&gt;秒間に&lt;code&gt;X/(A+C)&lt;/code&gt;セット(端数切り捨て)できるため、距離は合計で&lt;code&gt;セット数*A*B&lt;/code&gt;進むことができます。
また、&lt;code&gt;X&lt;/code&gt;から進んだセット数を引いたあまり&lt;code&gt;X%(A+C)&lt;/code&gt;のうち、最大&lt;code&gt;A&lt;/code&gt;秒間進むこともできるため、&lt;code&gt;Min(あまり,A)*B&lt;/code&gt;進むことができます。
この二つを合わせた距離が高橋君の進む距離となります。
&lt;code&gt;A秒間秒速Bメートルで歩き、C秒間休むことを繰り返した時のX秒後の距離&lt;/code&gt;を関数にすると、&lt;code&gt;F(A,B,C) = X/(A+C)*A*B + Min(X%(A+C),A)*B&lt;/code&gt;に定義できます。&lt;br /&gt;
同様に青木君の距離を求め、どちらが長い距離を進んだかを比較して答えを求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var line = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var (A, B, C) = (line[0], line[1], line[2]);
    var (D, E, F) = (line[3], line[4], line[5]);
    var X = line[6];
    int G(int a, int b, int c)
    {
        return (X / (a + c) * a * b) + Math.Min(X % (a + c), a) * b;
    }

    var takahashi = G(A, B, C);
    var aoki = G(D, E, F);
    var answer = &amp;quot;Draw&amp;quot;;
    if (takahashi &amp;gt; aoki) answer = &amp;quot;Takahashi&amp;quot;;
    if (takahashi &amp;lt; aoki) answer = &amp;quot;Aoki&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31188890"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一つずつ条件を判定していきます。&lt;br /&gt;
C#では、&lt;code&gt;char.IsUpper&lt;/code&gt;関数で文字の大文字判定、&lt;code&gt;char.IsLower&lt;/code&gt;関数で文字の小文字判定を行うことができます。
また、&lt;code&gt;全ての文字が相異なる&lt;/code&gt;ということは、&lt;code&gt;元の文字列の長さ=重複を除いたときの文字列の長さ&lt;/code&gt;といえます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;すべての文字をみて大文字が存在するかを判定する&lt;/li&gt;
&lt;li&gt;すべての文字をみて小文字が存在するかを判定する&lt;/li&gt;
&lt;li&gt;元の文字列の長さ=重複を除いたときの文字列の長さが成り立つかを判定する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;これらすべてが成り立っているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var M = S.Distinct().Count();
    var ok = N == M;
    var big = false;
    var small = false;
    foreach (var c in S)
    {
        big |= char.IsUpper(c);
        small |= char.IsLower(c);
    }

    ok &amp;amp;= big &amp;amp;&amp;amp; small;
    Console.WriteLine(ok ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31188932"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各文字列に対して使うor使わないの2択なため、&lt;code&gt;2^N&lt;/code&gt;個の組み合わせがあり得ます。
制約が&lt;code&gt;N&amp;lt;=15&lt;/code&gt;と少ないので、&lt;code&gt;bit全探索&lt;/code&gt;を行うことで全ての組み合わせを走査することができます。
&lt;code&gt;s&lt;/code&gt;を使用する&lt;code&gt;i&lt;/code&gt;の集合としたとき、&lt;code&gt;s&lt;/code&gt;において&lt;code&gt;i&lt;/code&gt;が使われているかを判定するには、&lt;code&gt;(s&amp;gt;&amp;gt;i&amp;amp;1)==1&lt;/code&gt;で求めることができます。
そして、それぞれの組み合わせにおいて、使う文字列集合を全て走査し、文字の個数が&lt;code&gt;K&lt;/code&gt;個の文字の種類の最大値を求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = 0;
    var exists = new bool[N, 26];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        foreach (var c in S)
        {
            exists[i, c - 'a'] = true;
        }
    }


    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        var count = new int[26];
        for (var i = 0; i &amp;lt; N; i++)
        {
            if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1)
            {
                for (var j = 0; j &amp;lt; 26; j++)
                {
                    count[j] += exists[i, j] ? 1 : 0;
                }
            }
        }

        var sum = 0;
        for (var i = 0; i &amp;lt; 26; i++)
        {
            if (count[i] == K) sum++;
        }

        answer = Math.Max(answer, sum);
    }
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc249/tasks/abc249_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC249/submissions/31192606"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に全ての&lt;code&gt;i,j,k&lt;/code&gt;を走査する方法では、計算量が&lt;code&gt;O(N^3)&lt;/code&gt;となり、&lt;code&gt;A[j]*A[k]=A[i]&lt;/code&gt;となる&lt;code&gt;j,k&lt;/code&gt;を走査する方法では、計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となりますが、制約が&lt;code&gt;1&amp;lt;=N&amp;lt;=2e5&lt;/code&gt;と大きいため、実行時間制限内に処理を終わらせることができません。&lt;br /&gt;
そこで、あらかじめAの値の出現回数を数えておき、&lt;code&gt;1&amp;lt;=p,q,r&amp;lt;=2e5&lt;/code&gt;のうち、&lt;code&gt;p=q*r&lt;/code&gt;となる&lt;code&gt;p,q,r&lt;/code&gt;の組における組み合わせの個数の総和を求めます。
組み合わせの個数は&lt;code&gt;pの個数 * qの個数 * rの個数&lt;/code&gt;でもとめることができます。
&lt;code&gt;q&lt;/code&gt;を固定したとき、&lt;code&gt;r&lt;/code&gt;は&lt;code&gt;p/q (p&amp;lt;=2e5)&lt;/code&gt;まで走査すればよいため、計算量&lt;code&gt;O(MlogM)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var max = (int)2e5;
    var count = new long[max + 1];
    foreach (var a in A)
    {
        count[a]++;
    }

    var answer = 0L;
    for (var q = 1; q &amp;lt;= max; q++)
    {
        for (var r = 1; q * r &amp;lt;= max; r++)
        {
            var p = q * r;
            answer += count[p] * count[q] * count[r];
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 249の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220417abc248</id>
		<title>ABC248</title>
		<link href="https://aconcavy.github.io/blog/posts/20220417abc248" />
		<updated>2022-04-18T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 248の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248"&gt;https://atcoder.jp/contests/abc248&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31002746"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の合計から登場する数字を全て引いた後の値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var sum = 9 * 10 / 2;
    foreach (var c in S)
    {
        sum -= c - '0';
    }

    Console.WriteLine(sum);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31006946"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初期値を&lt;code&gt;A&lt;/code&gt;として、&lt;code&gt;B&lt;/code&gt;より小さいうちに&lt;code&gt;A&lt;/code&gt;を何回&lt;code&gt;K&lt;/code&gt;倍することができるかを数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, K) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
    var curr = A;
    var answer = 0;
    while (curr &amp;lt; B)
    {
        curr *= K;
        answer++;
    }
        
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31016119"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の値まで決めたときに、それまでの総和が&lt;code&gt;j&lt;/code&gt;であるような数列の総数を動的計画法として答えを数え上げます。
これは、&lt;code&gt;i+1&lt;/code&gt;番目の値は、&lt;code&gt;i&lt;/code&gt;番目までの総和&lt;code&gt;j&lt;/code&gt;に&lt;code&gt;1&amp;lt;=k&amp;lt;=M&lt;/code&gt;の何れかを足した数への遷移することができます。
そのため、&lt;code&gt;dp[0,0]=1 (0番目までの総和は0)&lt;/code&gt;を初期値として遷移していき、&lt;code&gt;N&lt;/code&gt;番目まで見終わったときの&lt;code&gt;1&amp;lt;=k&amp;lt;=M&lt;/code&gt;の合計が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var NM = N * M;
    var dp = new mint[N + 1, NM + 1];
    dp[0, 0] = 1;
                
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= NM; j++)
        {
            for (var k = 1; k &amp;lt;= M; k++)
            {
                if (j + k &amp;lt;= NM) dp[i + 1, j + k] += dp[i, j];
            }
        }
    }
                
    mint answer = 0;
    for (var i = 1; i &amp;lt;= K; i++)
    {
        answer += dp[N, i];
    }
                
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31021126"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに指定された範囲を走査してしまうと、クエリごとの計算量が&lt;code&gt;O(N)&lt;/code&gt;、全体計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまい、実行時間制限内に終えることができないので、クエリごとの計算量を削減する方法を考えます。&lt;br /&gt;
ある値&lt;code&gt;X&lt;/code&gt;を考えたとき、&lt;code&gt;[L,R]&lt;/code&gt;の出現する場所の個数は&lt;code&gt;Rより大きい場所の番目 - L以上の場所の番目&lt;/code&gt;で求めることができます。&lt;br /&gt;
例えば、&lt;code&gt;A=[3,1,4,1,5]、L=1、R=3、X=1&lt;/code&gt;のとき、場所&lt;code&gt;idx[1]=[2,4]&lt;/code&gt;となり、&lt;code&gt;Rより大きい場所の番目 - L以上の場所の番目&lt;/code&gt;は&lt;code&gt;2番目-1番目&lt;/code&gt;なり、&lt;code&gt;1個&lt;/code&gt;となります。&lt;br /&gt;
そのため、あらかじめ値ごとに出現する場所を保持しておき、&lt;code&gt;L&lt;/code&gt;と&lt;code&gt;R&lt;/code&gt;の個数をそれぞれ二部探索することで、クエリごとの計算量が&lt;code&gt;O(logN)&lt;/code&gt;、全体計算量が&lt;code&gt;O(NlogN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var a = A[i];
        if (!dict.ContainsKey(a)) dict[a] = new List&amp;lt;int&amp;gt;();
        dict[a].Add(i);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (L, R, X) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        L--; R--;
        if (dict.ContainsKey(X))
        {
            var list = dict[X];
            var l = LowerBound(list, L);
            var r = UpperBound(list, R);
            Console.WriteLine(r - l);
        }
        else
        {
            Console.WriteLine(0);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc248/tasks/abc248_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc248/submissions/31050544"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全ての2点間の傾き&lt;code&gt;a&lt;/code&gt;と切片&lt;code&gt;b&lt;/code&gt;を保持し、直線&lt;code&gt;y=ax+b&lt;/code&gt;が成り立つ点が&lt;code&gt;K&lt;/code&gt;個以上あればその直線は妥当?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WA&lt;/code&gt;が11個でる...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数え上げの方法が間違えていました。
ある点を固定したとき、その点からの傾きが同じものどうしで数え上げ、その傾きをとる頂点の個数が&lt;code&gt;K-1&lt;/code&gt;個ならば、その傾きの直線が妥当であるといえます。このとき
&lt;code&gt;K-1&lt;/code&gt;以上で数えてしまうと、その傾きを取る頂点の個数が&lt;code&gt;K+1、K、K-1&lt;/code&gt;のように重複して数えてしまうことに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    if (K == 1)
    {
        Console.WriteLine(&amp;quot;Infinity&amp;quot;);
        return;
    }

    var P = new (long X, long Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = (x, y);
    }


    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var dict = new Dictionary&amp;lt;Fraction, int&amp;gt;();
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var (x1, y1) = P[i];
            var (x2, y2) = P[j];
            var (dx, dy) = (x2 - x1, y2 - y1);
            var frac = new Fraction(dy, dx);
            if (!dict.ContainsKey(frac)) dict[frac] = 0;
            dict[frac]++;
        }

        foreach (var count in dict.Values)
        {
            if (count == K - 1) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public readonly struct Fraction : IComparable&amp;lt;Fraction&amp;gt;, IEquatable&amp;lt;Fraction&amp;gt;
{
    public long Y { get; }
    public long X { get; }
    public Fraction(long y, long x)
    {
        static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
        var g = Gcd(y, x);
        (Y, X) = (y / g, x / g);
    }
    public static bool operator &amp;lt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt; 0;
    public static bool operator &amp;lt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt;= 0;
    public static bool operator &amp;gt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt; 0;
    public static bool operator &amp;gt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt;= 0;
    public static bool operator ==(Fraction left, Fraction right) =&amp;gt; left.Equals(right);
    public static bool operator !=(Fraction left, Fraction right) =&amp;gt; !left.Equals(right);
    public int CompareTo(Fraction other) =&amp;gt; (Y * other.X).CompareTo(X * other.Y);
    public bool Equals(Fraction other) =&amp;gt; Y == other.Y &amp;amp;&amp;amp; X == other.X;
    public override bool Equals(object obj) =&amp;gt; obj is Fraction other &amp;amp;&amp;amp; Equals(other);
    public override int GetHashCode() =&amp;gt; HashCode.Combine(Y, X);
    public override string ToString() =&amp;gt; $&amp;quot;{Y}/{X}&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 248の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220410abc247</id>
		<title>ABC247</title>
		<link href="https://aconcavy.github.io/blog/posts/20220410abc247" />
		<updated>2022-04-10T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 247の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc247"&gt;https://atcoder.jp/contests/abc247&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30847103"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[i+1] (0&amp;lt;=i&amp;lt;=2)&lt;/code&gt;の値を&lt;code&gt;S[i]&lt;/code&gt;に移動し、&lt;code&gt;S[0]&lt;/code&gt;は誰もいなくなるので&lt;code&gt;0&lt;/code&gt;にしたものが答えとなります。
つまり、&lt;code&gt;S&lt;/code&gt;の先頭に&lt;code&gt;0&lt;/code&gt;を追加した先頭4文字が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = &amp;quot;0&amp;quot; + S[0..3];
    Console.WriteLine(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30858089"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目のあだ名&lt;code&gt;ai&lt;/code&gt;を付けることができる条件は、あるあだ名が&lt;code&gt;j!=i&lt;/code&gt;番目の姓&lt;code&gt;sj&lt;/code&gt;と名&lt;code&gt;tj&lt;/code&gt;のいずれも一致しないことであり、あだ名に&lt;code&gt;si&lt;/code&gt;を使った場合と、&lt;code&gt;ti&lt;/code&gt;を使った場合をすべてチェックしてどちらか一方でも使うことができれば、そのあだ名を使うことができます。
これを全ての人に対して判定を行い、全ての人にあだ名を付けることができるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Names = new (string S, string T)[N];
    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, t) = Scanner.Scan&amp;lt;string, string&amp;gt;();
        Names[i] = (s, t);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = true;
        var t = true;
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (i == j) continue;
            s &amp;amp;= Names[i].S != Names[j].S &amp;amp;&amp;amp; Names[i].S != Names[j].T;
            t &amp;amp;= Names[i].T != Names[j].S &amp;amp;&amp;amp; Names[i].T != Names[j].T;
        }

        answer &amp;amp;= s || t;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30859642"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30895077"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初期値を&lt;code&gt;Si=1 (i=1)&lt;/code&gt;とし、&lt;code&gt;2&amp;lt;=i&amp;lt;=N&lt;/code&gt;では&lt;code&gt;S(i-1) i S(i-1)&lt;/code&gt;を文字列として構築することで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = &amp;quot;1&amp;quot;;
    for (var i = 2; i &amp;lt;= N; i++)
    {
        answer = $&amp;quot;{answer} {i} {answer}&amp;quot;;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30865508"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連結リストなどのデータ構造を使って、データを管理します。&lt;br /&gt;
&lt;code&gt;c&lt;/code&gt;の値が大きいため、リストに&lt;code&gt;c&lt;/code&gt;個の値を入れてしまうとクエリ当たりの計算量が&lt;code&gt;O(c)&lt;/code&gt;、全体で&lt;code&gt;O(Qc)&lt;/code&gt;となり、実行時間制限内に処理を終えることができません。
そこで、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;をペアとして管理することで、クエリ当たりの計算量が&lt;code&gt;O(1)&lt;/code&gt;、全体で&lt;code&gt;O(Q)&lt;/code&gt;となり、実行時間制限内に解くことができるようになります。&lt;br /&gt;
クエリが&lt;code&gt;1&lt;/code&gt;のときは&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;c&lt;/code&gt;をペアとしてリストの後方に追加し、クエリが&lt;code&gt;2&lt;/code&gt;のときは、&lt;code&gt;c&lt;/code&gt;個消費できるまでリストの先頭から消費していきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var deq = new Deque&amp;lt;(long X, long C)&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            deq.PushBack((query[1], query[2]));
        }
        else
        {
            var c = query[1];
            long sum = 0;
            while (c &amp;gt; 0)
            {
                var top = deq.PopFront();
                var use = Math.Min(c, top.C);
                c -= use;
                sum += top.X * use;
                if (use &amp;lt; top.C)
                {
                    deq.PushFront((top.X, top.C - use));
                }
            }

            Console.WriteLine(sum);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc247/tasks/abc247_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC247/submissions/30884870"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ai&amp;lt;Y &amp;amp;&amp;amp; X&amp;lt;Ai&lt;/code&gt;となる値が範囲に存在する場合、その範囲は無視することができるので、&lt;code&gt;Y&amp;lt;=Ai&amp;lt;=X&lt;/code&gt;のみで構成される連続部分列に分割し、連続部分列ごとに部分問題として数え上げることができるようになります。
例えば、&lt;code&gt;X=3, Y=2, A=[4,1,3,2,3,2,1,2]&lt;/code&gt;の場合、&lt;code&gt;A=[[3,2,3,2], [2]]&lt;/code&gt;と分割できます。&lt;br /&gt;
部分問題では、愚直に全探索してしまうと計算量&lt;code&gt;O(N^3)&lt;/code&gt;になりますが、尺取り法を用いることで計算量&lt;code&gt;O(N)&lt;/code&gt;で区間の数を数え上げることができます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;はじめ&lt;code&gt;L=1&lt;/code&gt;とする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&amp;lt;=R&amp;lt;=N&lt;/code&gt;において次のことを行う。
&lt;ol&gt;
&lt;li&gt;区間&lt;code&gt;[L,R]&lt;/code&gt;に&lt;code&gt;X&lt;/code&gt;と&lt;code&gt;Y&lt;/code&gt;がそれぞれ1つ以上存在する場合次のことを行う。
&lt;ol&gt;
&lt;li&gt;区間&lt;code&gt;[L,R&amp;lt;=r&amp;lt;=N]&lt;/code&gt;は全て条件を満たし、この個数は&lt;code&gt;N-R+1&lt;/code&gt;(計算量&lt;code&gt;O(1)&lt;/code&gt;)で求めることができる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt;を1進める。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;計算量は全体で&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    bool IsInRange(int v) =&amp;gt; Y &amp;lt;= v &amp;amp;&amp;amp; v &amp;lt;= X;

    var list = new List&amp;lt;List&amp;lt;int&amp;gt;&amp;gt;();
    var tmp = new List&amp;lt;int&amp;gt;();
    foreach (var a in A)
    {
        if (IsInRange(a))
        {
            tmp.Add(a);
        }
        else
        {
            list.Add(tmp.ToList());
            tmp = new List&amp;lt;int&amp;gt;();
        }
    }

    list.Add(tmp.ToList());
    list = list.Where(x =&amp;gt; x.Count &amp;gt; 0).ToList();
    long answer = 0;
    foreach (var group in list)
    {
        var l = 0;
        var M = group.Count;
        var used = new int[X + 1];
        for (var r = 0; r &amp;lt; M; r++)
        {
            used[group[r]]++;
            while (l &amp;lt;= r &amp;amp;&amp;amp; used[X] &amp;gt; 0 &amp;amp;&amp;amp; used[Y] &amp;gt; 0)
            {
                answer += M - r;
                used[group[l]]--;
                l++;
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 247の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220402abc246</id>
		<title>ABC246</title>
		<link href="https://aconcavy.github.io/blog/posts/20220402abc246" />
		<updated>2022-04-03T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 246の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc246"&gt;https://atcoder.jp/contests/abc246&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc246/tasks/abc246_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC246/submissions/30625941"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各辺は&lt;code&gt;X&lt;/code&gt;軸または&lt;code&gt;Y&lt;/code&gt;軸に平行な長方形なので、&lt;code&gt;X&lt;/code&gt;が同じ頂点のペアが2つと&lt;code&gt;Y&lt;/code&gt;が同じ頂点のペアが2つが存在することになります。&lt;br /&gt;
そのため、&lt;code&gt;X&lt;/code&gt;と&lt;code&gt;Y&lt;/code&gt;それぞれ値に対するペアの存在を管理し、余った&lt;code&gt;X&lt;/code&gt;と&lt;code&gt;Y&lt;/code&gt;の値が残りの頂点の座標となります。&lt;br /&gt;
実装では、集合を管理する&lt;code&gt;HashSet&lt;/code&gt;を使って、ペアとなる値が存在するならそのペアを削除し、存在しないならば値を追加するという方法で管理しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var X = new HashSet&amp;lt;int&amp;gt;();
    var Y = new HashSet&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; 3; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (X.Contains(x)) X.Remove(x);
        else X.Add(x);

        if (Y.Contains(y)) Y.Remove(y);
        else Y.Add(y);
    }

    var xx = X.First();
    var yy = Y.First();
    Console.WriteLine($&amp;quot;{xx} {yy}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Xor&lt;/code&gt;演算を使うことでも求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var x = 0;
    var y = 0;
    for (var i = 0; i &amp;lt; 3; i++)
    {
        var (X, Y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x ^= X;
        y ^= Y;
    }

    Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc246/tasks/abc246_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC246/submissions/30629082"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2点間の距離は&lt;code&gt;D=Sqrt(A*A+B*B)&lt;/code&gt;なので、&lt;code&gt;(A/D, B/D)&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var d = Math.Sqrt(A * A + B * B);
    var (x, y) = (A / d, B / d);
    Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、C#では、&lt;code&gt;System.Numerics&lt;/code&gt;名前空間にある&lt;code&gt;Vector2&lt;/code&gt;という構造体を使って、正規化したベクトルを取ることでも答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var v = new Vector2(A, B);
    var answer = Vector2.Normalize(v);
    Console.WriteLine($&amp;quot;{answer.X} {answer.Y}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc246/tasks/abc246_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC246/submissions/30633790"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;まず、1枚のクーポンにつき&lt;code&gt;X&lt;/code&gt;円安くできるため、可能な限り&lt;code&gt;X&lt;/code&gt;円安くすることを考えます。&lt;br /&gt;
これは、&lt;code&gt;A[i]&amp;gt;=X&lt;/code&gt;となる&lt;code&gt;A[i]&lt;/code&gt;はクーポンがある限り&lt;code&gt;A[i]-X&lt;/code&gt;にすることができ、使うことができるクーポンの数が&lt;code&gt;k&lt;/code&gt;のとき、&lt;code&gt;A[i]=A[i]-k*X&lt;/code&gt;とすることができます。
&lt;code&gt;k&lt;/code&gt;枚のクーポンを持っていて値段が&lt;code&gt;P&lt;/code&gt;のとき、&lt;code&gt;Min(k, P/X)&lt;/code&gt;枚のクーポンを使うことができるため、クーポンの数を更新しながら&lt;code&gt;A&lt;/code&gt;を順にみていくことで、&lt;code&gt;A&lt;/code&gt;の値を可能な限り&lt;code&gt;X&lt;/code&gt;円安くした値にすることができます。&lt;br /&gt;
その後、まだクーポンが余っている場合は、&lt;code&gt;A&lt;/code&gt;の全ての値は&lt;code&gt;A[i]&amp;lt;X&lt;/code&gt;となっているため、&lt;code&gt;A&lt;/code&gt;の値が大きい順にクーポンを使って&lt;code&gt;0&lt;/code&gt;円にすることができます。&lt;br /&gt;
そして、全ての操作を終えたときの和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K, X) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var k = Math.Min(K, A[i] / X);
        A[i] = A[i] - k * X;
        K -= k;
    }

    Array.Sort(A);
    Array.Reverse(A);
    for (var i = 0; i &amp;lt; Math.Min(N, K); i++)
    {
        A[i] = 0;
    }

    var answer = A.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc246/tasks/abc246_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC246/submissions/30679687"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;は最大でも&lt;code&gt;1e6&lt;/code&gt;になりそう。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F(a,b)=aaa+aab+abb+bbb&lt;/code&gt;のとき、&lt;code&gt;a+b=c&lt;/code&gt;かつ&lt;code&gt;F(a,b)&amp;gt;=N&lt;/code&gt;となる&lt;code&gt;c&lt;/code&gt;を二部探索して&lt;code&gt;0&amp;lt;=a&amp;lt;=c&lt;/code&gt;のときの最小?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説では尺取り法でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();

    long F(long a, long b) =&amp;gt; (a * a * a) + (a * a * b) + (a * b * b) + (b * b * b);

    const long inf = (long)1e6;
    var answer = inf * inf * inf;
    var b = inf;
    for (var a = 0; a &amp;lt;= b; a++)
    {
        while (F(a, b) &amp;gt;= N &amp;amp;&amp;amp; b &amp;gt;= a)
        {
            answer = Math.Min(answer, F(a, b));
            b--;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc246/tasks/abc246_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC246/submissions/30677572"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;マスは最大4方向から移動してくる可能性があることに注意し、Dijkstra法で最短経路を求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var (Ah, Aw) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    Ah--; Aw--;
    var (Bh, Bw) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    Bh--; Bw--;
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    var H = N;
    var W = N;
    var G = new int[H, W];
    const int inf = (int)1e9;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            G[i, j] = inf;
        }
    }

    var used = new bool[H, W];

    G[Ah, Aw] = 0;
    var D4 = new[] { (1, 1), (-1, -1), (1, -1), (-1, 1) };

    var queue = new Queue&amp;lt;(int, int)&amp;gt;();
    queue.Enqueue((Ah, Aw));

    while (queue.Count &amp;gt; 0)
    {
        var (ch, cw) = queue.Dequeue();
        if (used[ch, cw]) continue; // マスをみるのは訪れた最初の1回だけ
        used[ch, cw] = true;
        var cc = G[ch, cw];

        // 各方向に広げていく
        foreach (var (dh, dw) in D4)
        {
            for (var d = 1; d &amp;lt; N; d++)
            {
                var (nh, nw) = (ch + dh * d, cw + dw * d);
                // 次のマスが範囲外またはブロックならそれ以上この方向に進むことができないからbreak
                if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) break; 
                if (S[nh][nw] == '#') break;
                var nc = cc + 1;

                // 少ない移動回数で訪れているなら、この方向は既にqueueに入っているからbreak
                // 同じ移動回数の場合は、交差する点の可能性があるため、queueにいれる
                if (G[nh, nw] &amp;lt; nc) break;
                G[nh, nw] = nc;
                queue.Enqueue((nh, nw));
            }
        }
    }

    var answer = G[Bh, Bw] == inf ? -1 : G[Bh, Bw];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 246の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220326abc245</id>
		<title>ABC245</title>
		<link href="https://aconcavy.github.io/blog/posts/20220326abc245" />
		<updated>2022-03-27T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 245の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc245"&gt;https://atcoder.jp/contests/abc245&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc245/tasks/abc245_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc245/submissions/30430680"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;時刻が早いといえるのは、&lt;code&gt;A&lt;/code&gt;時のほうが&lt;code&gt;C&lt;/code&gt;時より早い(&lt;code&gt;A&amp;lt;C&lt;/code&gt;)とき、あるいは時が同じとき(&lt;code&gt;A==C&lt;/code&gt;)に&lt;code&gt;B&lt;/code&gt;分のほうが&lt;code&gt;D&lt;/code&gt;分より早い(&lt;code&gt;B&amp;lt;D&lt;/code&gt;)ときとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, C, D) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    var answer = A &amp;lt; C;
    if (A == C) answer |= B &amp;lt;= D;

    Console.WriteLine(answer ? &amp;quot;Takahashi&amp;quot; : &amp;quot;Aoki&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc245/tasks/abc245_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc245/submissions/30433167"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小さい順に数字を見ていき、その数字が&lt;code&gt;A&lt;/code&gt;に含まれているかを確認することで、&lt;code&gt;O(N^2)&lt;/code&gt;で答えを求めることができます。
また、&lt;code&gt;A&lt;/code&gt;に含まれているものをメモしておき、&lt;code&gt;A&lt;/code&gt;に含まれていない最小の数値を答えることで、&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var used = new bool[2001];
    foreach (var a in A)
    {
        used[a] = true;
    }

    for (var i = 0; i &amp;lt;= 2000; i++)
    {
        if (!used[i])
        {
            Console.WriteLine(i);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc245/tasks/abc245_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc245/submissions/30442020"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の要素の組み合わせを考えると、&lt;code&gt;O(2^N)&lt;/code&gt;となってしまい、&lt;code&gt;N&lt;/code&gt;が大きい場合は実行制限時間内に答えを求めることができません。&lt;br /&gt;
そのため、計算量を抑えて答えを求める方法を考える必要があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の&lt;code&gt;i (0&amp;lt;i&amp;lt;N)&lt;/code&gt;番目の要素が&lt;code&gt;X&lt;/code&gt;の数列として採用されることがあり得るか考えたとき、&lt;code&gt;i-1&lt;/code&gt;番目に採用した数と差の絶対値が&lt;code&gt;K&lt;/code&gt;未満であれば採用することができます。&lt;br /&gt;
まず始めに、&lt;code&gt;X[0]&lt;/code&gt;としてあり得る数を考えたとき、&lt;code&gt;A[0]&lt;/code&gt;と&lt;code&gt;B[0]&lt;/code&gt;の二つが存在するため、それぞれを&lt;code&gt;X[0]&lt;/code&gt;の候補として保持しておきます。&lt;br /&gt;
次に、&lt;code&gt;X[1]&lt;/code&gt;を考えたとき、&lt;code&gt;A[1]&lt;/code&gt;があり得るためには、&lt;code&gt;A[0]&lt;/code&gt;との差が&lt;code&gt;K&lt;/code&gt;以下、あるいは&lt;code&gt;B[0]&lt;/code&gt;との差が&lt;code&gt;K&lt;/code&gt;以下である必要があります。
どちらか一方でも条件を満たす場合は、&lt;code&gt;X[1]&lt;/code&gt;の候補として&lt;code&gt;A[1]&lt;/code&gt;を保持し、満たさない場合は&lt;code&gt;A[1]&lt;/code&gt;は&lt;code&gt;X[1]&lt;/code&gt;の候補としてあり得ないため除外します。
同様に、&lt;code&gt;B[1]&lt;/code&gt;も考えます。
&lt;code&gt;X[2]&lt;/code&gt;以降も同様に、&lt;code&gt;X[i-1]&lt;/code&gt;であり得る可能性のある数との差が&lt;code&gt;K&lt;/code&gt;以下であるかを確認して候補を保持していきます。
そして、最後まで見たときに、あり得る数が存在するかどうかが答えとなり、&lt;code&gt;O(N)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dp1 = new HashSet&amp;lt;int&amp;gt; { A[0], B[0] };
    for (var i = 1; i &amp;lt; N; i++)
    {
        var dp2 = new HashSet&amp;lt;int&amp;gt;();
        var (a, b) = (A[i], B[i]);
        foreach (var v in dp1)
        {
            if (Math.Abs(v - a) &amp;lt;= K) dp2.Add(a);
            if (Math.Abs(v - b) &amp;lt;= K) dp2.Add(b);
        }

        dp1 = dp2;
    }

    var answer = dp1.Count &amp;gt; 0;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc245/tasks/abc245_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc245/submissions/30469582"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc245/submissions/30487152"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;B=C/A&lt;/code&gt;となる数列&lt;code&gt;B&lt;/code&gt;を求める問題です。&lt;/p&gt;
&lt;p&gt;まず、&lt;code&gt;C&lt;/code&gt;がどんな数列かを考えます。
C#のコードで書くと以下のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var ai = 0; ai &amp;lt;= N; ai++)
{
    for(var bi = 0; bi &amp;lt;= M; bi++)
    {
        C[ai + bi] += A[ai] * B[bi];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の次元&lt;code&gt;0&amp;lt;=ai&amp;lt;=N&lt;/code&gt;と&lt;code&gt;0&amp;lt;=B&amp;lt;=M&lt;/code&gt;の次元&lt;code&gt;bi&lt;/code&gt;を考えたとき、&lt;code&gt;ai&lt;/code&gt;と&lt;code&gt;bi&lt;/code&gt;は&lt;code&gt;C[ai+bi]&lt;/code&gt;に影響を与えます。&lt;br /&gt;
&lt;code&gt;B&lt;/code&gt;の最上位の次元の係数を考えたとき、&lt;code&gt;B[M]&lt;/code&gt;は&lt;code&gt;C[N+M]/A[N]&lt;/code&gt;で求められることがわかります。&lt;br /&gt;
そして、&lt;code&gt;B&lt;/code&gt;の最上位の次元の係数が決定すると、&lt;code&gt;B&lt;/code&gt;の最上位の次元と&lt;code&gt;A&lt;/code&gt;の各次元が影響を与える&lt;code&gt;C[ai+M]&lt;/code&gt;から、&lt;code&gt;A[ai]*B[M]&lt;/code&gt;を引くことで、&lt;code&gt;C&lt;/code&gt;の各係数から&lt;code&gt;B&lt;/code&gt;の最上位の係数が与えた影響をとり除くことができます。&lt;/p&gt;
&lt;p&gt;このことから、&lt;code&gt;B&lt;/code&gt;の最上位の次元から順に&lt;code&gt;bi&lt;/code&gt;と&lt;code&gt;ai&lt;/code&gt;を固定しながら&lt;code&gt;C[ai+bi]&lt;/code&gt;の値を更新していくことで、&lt;code&gt;B&lt;/code&gt;の次元の係数を確定していくことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var C = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = new long[M + 1];

    for (var bi = M; bi &amp;gt;= 0; bi--)
    {
        B[bi] = C[bi + N] / A[N];
        for (var ai = N; ai &amp;gt;= 0; ai--)
        {
            C[ai + bi] -= A[ai] * B[bi];
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc245/tasks/abc245_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc245/submissions/30487009"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;チョコレートが大きい順に処理したい(縦?横?縦+横?面積?)。&lt;/li&gt;
&lt;li&gt;座標圧縮とFenwickTreeで使える箱があるかどうかは確認できそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説では、チョコレートと箱をまとめて縦の降順にみていき、ソート可能なセットを使って横の長さを管理する方法が紹介されていました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    var chocos = A.Zip(B).Select(x =&amp;gt; new Element(0, x.First, x.Second));
    var cases = C.Zip(D).Select(x =&amp;gt; new Element(1, x.First, x.Second));
    var list = chocos.Concat(cases).ToList();
    list.Sort((x, y) =&amp;gt;
    {
        var result = y.H.CompareTo(x.H);
        return result != 0 ? result : y.Type.CompareTo(x.Type);
    });

    var set = new RandomizedBinarySearchTree&amp;lt;int&amp;gt;();
    foreach (var e in list)
    {
        if (e.Type == 0)
        {
            var lb = set.LowerBound(e.W);
            if (lb &amp;lt; 0 || set.Count &amp;lt;= lb)
            {
                Console.WriteLine(&amp;quot;No&amp;quot;);
                return;
            }

            set.RemoveAt(lb);
        }
        else
        {
            set.Insert(e.W);
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc245/tasks/abc245_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc245/submissions/30487303"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var deg = new int[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[v].Add(u);
        deg[u]++;
    }

    var queue = new Queue&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (deg[i] == 0) queue.Enqueue(i);
    }

    var answer = N;
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        answer--;

        foreach (var v in G[u])
        {
            deg[v]--;
            if (deg[v] == 0) queue.Enqueue(v);
        }
    }

    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 245の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220320abc244</id>
		<title>ABC244</title>
		<link href="https://aconcavy.github.io/blog/posts/20220320abc244" />
		<updated>2022-03-21T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 244の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc244"&gt;https://atcoder.jp/contests/abc244&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc244/tasks/abc244_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC244/submissions/30269043"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列の長さが&lt;code&gt;N&lt;/code&gt;なので、文字列の&lt;code&gt;N-1&lt;/code&gt;のインデックスにアクセスすることで、末尾を参照することができます。&lt;br /&gt;
また、C#8.0以降の環境では配列に対して&lt;code&gt;A[^i]&lt;/code&gt;のような記述をすることにより、後ろから&lt;code&gt;i&lt;/code&gt;番目の要素を参照することができるので、これを使うことでも末尾を参照することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var S = Scanner.Scan&amp;lt;string&amp;gt;();
var answer = S[^1];
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc244/tasks/abc244_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC244/submissions/30274402"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;東西南北それぞれ移動するときの&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;移動量を用意し、現在の移動がどの向きに対して行われるかをインデックスとして管理することで簡単に記述することができます。&lt;br /&gt;
はじめの向きは&lt;code&gt;東&lt;/code&gt;で、&lt;code&gt;ti=R&lt;/code&gt;ならば右に90度回転するため、&lt;code&gt;東、南、西、北、東、...&lt;/code&gt;の順番で向きが変化することがわかります。
そのため、&lt;code&gt;東、南、西、北&lt;/code&gt;の順で移動量を用意し、回転させたときに&lt;code&gt;北&lt;/code&gt;の次は&lt;code&gt;東&lt;/code&gt;になるようにインデックスを4で割ったあまりとすることでインデックスをループさせることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var T = Scanner.Scan&amp;lt;string&amp;gt;();
var D4 = new[] { (1, 0), (0, -1), (-1, 0), (0, 1) }; // 東、南、西、北
var (x, y) = (0, 0);
var curr = 0;
foreach (var c in T)
{
    if (c == 'S')
    {
        x += D4[curr].Item1;
        y += D4[curr].Item2;
    }
    else
    {
        curr++;
        curr %= 4;
    }
}

Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc244/tasks/abc244_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC244/submissions/30277799"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インタラクティブな問題なので、出力を毎回Flushする必要があることに注意しましょう。&lt;br /&gt;
既に使った数字を記録しておき、まだ使っていない数字を出力すればよいです。&lt;br /&gt;
制約は&lt;code&gt;1&amp;lt;=N&amp;lt;=1000&lt;/code&gt;なので、数字をすべて走査し使っていない数字を探す方法でも&lt;code&gt;O(N^2)&lt;/code&gt;で間に合います。&lt;br /&gt;
また、&lt;code&gt;Queue&lt;/code&gt;のようなデータ構造を使って、既に使用したものを&lt;code&gt;Dequeue&lt;/code&gt;していくことで、&lt;code&gt;O(N)&lt;/code&gt;で解答することもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var queue = new Queue&amp;lt;int&amp;gt;(Enumerable.Range(1, N * 2 + 1));
var used = new bool[N * 2 + 2];
while (true)
{
    while (queue.Count &amp;gt; 0 &amp;amp;&amp;amp; used[queue.Peek()]) queue.Dequeue();
    var x = queue.Dequeue();
    used[x] = true;
    Console.WriteLine(x);
    var y = Scanner.Scan&amp;lt;int&amp;gt;();
    if (y == 0)
    {
        return;
    }
    used[y] = true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc244/tasks/abc244_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC244/submissions/30284560"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を&lt;code&gt;RGB&lt;/code&gt;に並べ替えても対応する&lt;code&gt;T&lt;/code&gt;は変わらないので、&lt;code&gt;S=RGB&lt;/code&gt;としたときの&lt;code&gt;T&lt;/code&gt;を考えます。&lt;br /&gt;
このとき、&lt;code&gt;T&lt;/code&gt;がなりえる値は&lt;code&gt;RGB&lt;/code&gt;、&lt;code&gt;RBG&lt;/code&gt;、&lt;code&gt;BRG&lt;/code&gt;、&lt;code&gt;BGR&lt;/code&gt;、&lt;code&gt;GRB&lt;/code&gt;、&lt;code&gt;GBR&lt;/code&gt;の6通りしかありません。&lt;br /&gt;
&lt;code&gt;S=RGB&lt;/code&gt;からそれぞれの値になるためのスワップ回数を見ると、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0回: &lt;code&gt;RGB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1回: &lt;code&gt;RBG&lt;/code&gt;、&lt;code&gt;BGR&lt;/code&gt;、&lt;code&gt;GRB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2回: &lt;code&gt;RGB&lt;/code&gt;、&lt;code&gt;BRG&lt;/code&gt;、&lt;code&gt;GBR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3回: &lt;code&gt;RBG&lt;/code&gt;、&lt;code&gt;BGR&lt;/code&gt;、&lt;code&gt;GRB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;のように分類できます。&lt;br /&gt;
このことから、スワップのグループを奇数回、偶数回で分けることができ、ぴったり&lt;code&gt;1e18&lt;/code&gt;回目に&lt;code&gt;S&lt;/code&gt;が&lt;code&gt;T&lt;/code&gt;になるようにスワップ操作をするには、&lt;code&gt;T&lt;/code&gt;が偶数グループに所属していることが条件となります。&lt;/p&gt;
&lt;p&gt;実装では、&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の対応する値が異なる数が&lt;code&gt;2&lt;/code&gt;である(&lt;code&gt;スワップ回数が1回&lt;/code&gt;)ときは答えは&lt;code&gt;No&lt;/code&gt;になり、それ以外の場合は&lt;code&gt;Yes&lt;/code&gt;となるような実装を行いました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (S1, S2, S3) = Scanner.Scan&amp;lt;char, char, char&amp;gt;();
var (T1, T2, T3) = Scanner.Scan&amp;lt;char, char, char&amp;gt;();
var S = new[] { S1, S2, S3 };
var T = new[] { T1, T2, T3 };
var x = 0;
for (var i = 0; i &amp;lt; 3; i++)
{
    if (S[i] != T[i]) x++;
}

var answer = x != 2;
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc244/tasks/abc244_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC244/submissions/30292730"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[k][u][x] := k回目の移動で頂点uにいるとき、頂点Xに訪れた回数の偶奇(x)の通り数&lt;/code&gt;とした動的計画法を解いたときの&lt;code&gt;dp[K][T][0]&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;p&gt;グラフにたいして状態を&lt;code&gt;(現在の頂点、移動回数、頂点Xに訪れた回数の偶奇)&lt;/code&gt;として幅優先探索を行い、既に訪れた状態を重複して数えないようし、遷移先が&lt;code&gt;X&lt;/code&gt;の場合は、遷移先のXの偶奇を変更し、それ以外の場合は遷移先の偶奇を変えずに遷移させます。
&lt;code&gt;mint&lt;/code&gt;は指定したあまりを取った値を持つ整数型です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M, K, S, T, X) = Scanner.Scan&amp;lt;int, int, int, int, int, int&amp;gt;();
S--; T--; X--;
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; M; i++)
{
    var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    u--; v--;
    G[u].Add(v);
    G[v].Add(u);
}

var dp = new mint[K + 1, N, 2];
dp[0, S, 0] = 1;
var used = new bool[K + 1, N, 2];
var queue = new Queue&amp;lt;(int U, int T, int X)&amp;gt;();
queue.Enqueue((S, 0, 0));
while (queue.Count &amp;gt; 0)
{
    var (u, t, x) = queue.Dequeue();
    if (t == K || used[t, u, x]) continue;
    used[t, u, x] = true;
    foreach (var v in G[u])
    {
        if (v == X)
        {
            dp[t + 1, v, x ^ 1] += dp[t, u, x];
            queue.Enqueue((v, t + 1, x ^ 1));
        }
        else
        {
            dp[t + 1, v, x] += dp[t, u, x];
            queue.Enqueue((v, t + 1, x));
        }
    }
}

var answer = dp[K, T, 0];
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc244/tasks/abc244_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC244/submissions/30304848"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;状態&lt;code&gt;s&lt;/code&gt;を&lt;code&gt;(パスの状態, 頂点)&lt;/code&gt;としたときのパスの長さの最小値を考えます。
これは、各頂点を始点として、現在の&lt;code&gt;(パスの状態、頂点、パスの長さ)&lt;/code&gt;を持ち、状態&lt;code&gt;s&lt;/code&gt;におけるパスの最小値を記録しながら幅優先探索を行うことで、全ての状態を求めることができます。&lt;br /&gt;
このとき、現在のパスの長さが、記録されている状態&lt;code&gt;s&lt;/code&gt;の長さよりも短い場合のみ探索することで、&lt;code&gt;O(N^2*2^N)&lt;/code&gt;で探索することができます。&lt;br /&gt;
そして、全てのパスの状態における各頂点を終点としたときの長さがわかるので、各パスの状態ごとのパスの長さの最小値の和が求める答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; M; i++)
{
    var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    u--; v--;
    G[u].Add(v);
    G[v].Add(u);
}

const int inf = (int)1e9;
var dp = new int[1 &amp;lt;&amp;lt; N, N];
for (var i = 1; i &amp;lt; 1 &amp;lt;&amp;lt; N; i++)
{
    for (var j = 0; j &amp;lt; N; j++)
    {
        dp[i, j] = inf;
    }
}

var queue = new Queue&amp;lt;(int U, int S, int L)&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    var s = 1 &amp;lt;&amp;lt; i;
    var l = 1;
    dp[s, i] = l;
    queue.Enqueue((i, s, l));
    while (queue.Count &amp;gt; 0)
    {
        var (u, cs, cl) = queue.Dequeue();
        if (l &amp;gt; dp[cs, u]) continue;
        foreach (var v in G[u])
        {
            var ns = (cs &amp;gt;&amp;gt; v &amp;amp; 1) == 0 ? cs + (1 &amp;lt;&amp;lt; v) : cs - (1 &amp;lt;&amp;lt; v);
            var nl = cl + 1;
            if (nl &amp;gt;= dp[ns, v]) continue;
            dp[ns, v] = nl;
            queue.Enqueue((v, ns, nl));
        }
    }
}

var answer = 0;
for (var i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; N; i++)
{
    var min = inf;
    for (var j = 0; j &amp;lt; N; j++)
    {
        min = Math.Min(min, dp[i, j]);
    }

    answer += min;
}
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 244の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220312abc243</id>
		<title>ABC243</title>
		<link href="https://aconcavy.github.io/blog/posts/20220312abc243" />
		<updated>2022-03-13T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 243の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc243"&gt;https://atcoder.jp/contests/abc243&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc243/tasks/abc243_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC243/submissions/30026790"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;V&lt;/code&gt;ミリリットルを使い切る周を考えるために、1周で使う量である&lt;code&gt;A+B+C&lt;/code&gt;で余りを取ってから考えます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;残りの量が&lt;code&gt;A&lt;/code&gt;未満ならば、&lt;code&gt;F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;残りの量が&lt;code&gt;A+B&lt;/code&gt;未満ならば、&lt;code&gt;M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;それ以外ならば、&lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (V, A, B, C) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
V %= A + B + C;
if (V &amp;lt; A) { Console.WriteLine(&amp;quot;F&amp;quot;); }
else if (V &amp;lt; A + B) { Console.WriteLine(&amp;quot;M&amp;quot;); }
else { Console.WriteLine(&amp;quot;T&amp;quot;); }

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc243/tasks/abc243_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC243/submissions/30030964"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あらかじめ&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の要素をキーとして、位置をそれぞれ別の辞書に保持しておきます。
そして、&lt;code&gt;A&lt;/code&gt;の要素を順番に見ていき、&lt;code&gt;A&lt;/code&gt;の要素が&lt;code&gt;B&lt;/code&gt;の辞書に存在するとき、位置が一致する場合と一致しない場合をそれぞれ数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

var dictA = new Dictionary&amp;lt;int, int&amp;gt;();
var dictB = new Dictionary&amp;lt;int, int&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    dictA[A[i]] = i;
    dictB[B[i]] = i;
}

var ans1 = 0;
var ans2 = 0;
foreach (var a in A)
{
    if (dictB.ContainsKey(a))
    {
        if (dictA[a] == dictB[a]) ans1++;
        else ans2++;
    }
}

Console.WriteLine(ans1);
Console.WriteLine(ans2);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc243/tasks/abc243_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC243/submissions/30038745"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC243/submissions/30081816"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直にシミュレーションしてしまうと実行時間制限に間に合わないので、処理を高速化する必要があります。
まず、動く方向は左右の2つしかないので、&lt;code&gt;Y&lt;/code&gt;の値が同じ人が衝突する可能性があると考えられます。
そこで、左に動く人たちと右に動く人たちをそれぞれ&lt;code&gt;Y&lt;/code&gt;ごとに分けて管理することを考えます。
そして、左に動く人たちと右に動く人たちの&lt;code&gt;Y&lt;/code&gt;が同じとき、右に動く人のうち最も左の位置(&lt;code&gt;RX&lt;/code&gt;)と、左に動く人のうち最も右の位置(&lt;code&gt;LX&lt;/code&gt;)において&lt;code&gt;RX&amp;lt;=LX&lt;/code&gt;が成り立てば、衝突が発生します。
このことから、&lt;code&gt;Y&lt;/code&gt;の値をキーとして、左に動く人たちの最も右の&lt;code&gt;X&lt;/code&gt;と右に動く人たちの最も左の&lt;code&gt;X&lt;/code&gt;をそれぞれ辞書を作成し、&lt;code&gt;Y&lt;/code&gt;の値につき計算量&lt;code&gt;O(1)&lt;/code&gt;で衝突するかの判定をすることができ、全体で計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var P = new (int X, int Y)[N];
for (var i = 0; i &amp;lt; N; i++)
{
    P[i] = Scanner.Scan&amp;lt;int, int&amp;gt;();
}

var S = Scanner.Scan&amp;lt;string&amp;gt;();
var L = new Dictionary&amp;lt;int, int&amp;gt;();
var R = new Dictionary&amp;lt;int, int&amp;gt;();
const int inf = (int)1e9;
for (var i = 0; i &amp;lt; N; i++)
{
    var (x, y) = P[i];
    if (S[i] == 'L')
    {
        if (!L.ContainsKey(y)) L[y] = 0;
        L[y] = Math.Max(L[y], x);
    }
    else
    {
        if (!R.ContainsKey(y)) R[y] = inf;
        R[y] = Math.Min(R[y], x);
    }
}

foreach (var (y, x) in R)
{
    if (L.ContainsKey(y) &amp;amp;&amp;amp; x &amp;lt;= L[y])
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }
}

Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc243/tasks/abc243_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC243/submissions/30044374"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;回の移動後にいる頂点の番号は&lt;code&gt;10^18&lt;/code&gt;以下であることが制約で保証されていますが、愚直にシミュレーションしてしまうと、制約&lt;code&gt;N&amp;lt;=10^6&lt;/code&gt;より、シミュレーション中の頂点の値が最大で&lt;code&gt;X*2^(N/2)&lt;/code&gt;になり、現在のコンピュータの整数型では正しく計算することができません。
そこで、子に移動して親に戻るといった、無駄な移動を省くことで、シミュレーション中でも頂点の値が&lt;code&gt;10^18&lt;/code&gt;を超えないようにすることを考えます。
これは、&lt;code&gt;S&lt;/code&gt;を順にみていったとき&lt;code&gt;U&lt;/code&gt;の直前にが&lt;code&gt;L&lt;/code&gt;または&lt;code&gt;R&lt;/code&gt;が存在すれば、&lt;code&gt;LU&lt;/code&gt;、&lt;code&gt;RU&lt;/code&gt;の操作を省くことができます。
また、&lt;code&gt;S=LRUU&lt;/code&gt;の操作ような場合、&lt;code&gt;RU&lt;/code&gt;を省くと、&lt;code&gt;LU&lt;/code&gt;としてつながり、さらに省くことができます。
このことから、&lt;code&gt;Stack&lt;/code&gt;のようなデータ構造を用いて直前の操作を保持しながら&lt;code&gt;S&lt;/code&gt;を順にみていき、&lt;code&gt;U&lt;/code&gt;の操作のとき、直前に&lt;code&gt;L&lt;/code&gt;または&lt;code&gt;R&lt;/code&gt;が存在するならば直前の操作を削除し、そうでなければ直前の操作を更新します。
そして、&lt;code&gt;Stack&lt;/code&gt;に残った操作をシミュレーションすることで、&lt;code&gt;10^18&lt;/code&gt;の値を超えないように操作することができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, X) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var S = Scanner.Scan&amp;lt;string&amp;gt;();
var stack = new Stack&amp;lt;char&amp;gt;();
foreach (var c in S)
{
    if (stack.Count &amp;gt; 0 &amp;amp;&amp;amp; stack.Peek() != 'U' &amp;amp;&amp;amp; c == 'U')
    {
        stack.Pop();
    }
    else
    {
        stack.Push(c);
    }
}

var T = stack.ToArray();
Array.Reverse(T);

var answer = X;
foreach (var c in T)
{
    if (c == 'U')
    {
        answer /= 2;
    }
    else if (c == 'L')
    {
        answer *= 2;
    }
    else
    {
        answer *= 2;
        answer++;
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc243/tasks/abc243_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC243/submissions/30080632"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ワーシャルフロイド法で最短距離を求める?&lt;/li&gt;
&lt;li&gt;最小全域木の頂点ごとの最短距離が元のグラフの頂点ごとの最短距離より大きいならば、一致するような辺を追加する?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;TLE&lt;/code&gt;と時間切れでした。&lt;/p&gt;
&lt;p&gt;ワーシャルフロイド法で最短距離を求め、辺を見ていったとき、頂点&lt;code&gt;u&lt;/code&gt;と頂点&lt;code&gt;v&lt;/code&gt;を結ぶ辺のコストが&lt;code&gt;c&lt;/code&gt;だった場合、頂点&lt;code&gt;k&lt;/code&gt;を中継点とする&lt;code&gt;u-&amp;gt;k-&amp;gt;v&lt;/code&gt;となるルートのコストが&lt;code&gt;c&lt;/code&gt;以下だった場合、その辺は不要ということがわかります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
const long inf = (long)1e18;
var G = new long[N, N];
for (var i = 0; i &amp;lt; N; i++)
{
    for (var j = 0; j &amp;lt; N; j++)
    {
        G[i, j] = inf;
    }
}

var E = new (int U, int V, long C)[M];
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b, c) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    a--; b--;
    G[a, b] = G[b, a] = c;
    E[i] = (a, b, c);
}

for (var k = 0; k &amp;lt; N; k++)
{
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            G[i, j] = Math.Min(G[i, j], G[i, k] + G[k, j]);
        }
    }
}

var answer = 0;
foreach (var (i, j, c) in E)
{
    var unused = false;
    for (var k = 0; k &amp;lt; N; k++)
    {
        if (i == k || j == k) continue;
        unused |= G[i, k] + G[k, j] &amp;lt;= c;
    }

    if (unused) answer++;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 243の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220305abc242</id>
		<title>ABC242</title>
		<link href="https://aconcavy.github.io/blog/posts/20220305abc242" />
		<updated>2022-03-06T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 242の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc242"&gt;https://atcoder.jp/contests/abc242&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29883827"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;それぞれどの条件に当てはまるかで確率を求めます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X &amp;lt;= A&lt;/code&gt;ならば確率は&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A+1 &amp;lt;= X &amp;lt;= B&lt;/code&gt; ならば確率は&lt;code&gt;C/(B-A)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B &amp;lt; X&lt;/code&gt;ならば確率は&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (A, B, C, X) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
var answer = 0d;
if (X &amp;lt;= A) answer = 1d;
if (A + 1 &amp;lt;= X &amp;amp;&amp;amp; X &amp;lt;= B) answer = (double)C / (B - A);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29869226"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書順最小となる文字列は、文字列&lt;code&gt;S&lt;/code&gt;を構成する文字のうち、小さいものを左から順に並べたものになります。
そのため、文字列&lt;code&gt;S&lt;/code&gt;をソートした文字列が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
Array.Sort(S);
var answer = new string(S);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29875962"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;動的計画法で答えとなる個数を数え上げます。
初期値として、1桁目は&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;である個数をそれぞれ&lt;code&gt;1&lt;/code&gt;とします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;桁目の数値が&lt;code&gt;j&lt;/code&gt;のとき、&lt;code&gt;i+1&lt;/code&gt;桁目には、&lt;code&gt;j-1&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;j+1&lt;/code&gt;に遷移することができます。
&lt;code&gt;N&lt;/code&gt;桁目まで確定したときの、&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;までの個数の和が答えとなります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数え上げのときに&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;10&lt;/code&gt;に遷移できるスペースを確保しておくと、&lt;code&gt;j=0&lt;/code&gt;の時の&lt;code&gt;j-1&lt;/code&gt;の遷移と&lt;code&gt;j=9&lt;/code&gt;のときの&lt;code&gt;j+1&lt;/code&gt;で&lt;code&gt;if&lt;/code&gt;文が不要になります。
&lt;code&gt;mint&lt;/code&gt;は、&lt;code&gt;Mod&lt;/code&gt;として指定した数値で余りをとった整数をもつ構造体です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var dp = new mint[N + 1, 11];
for (var i = 1; i &amp;lt; 10; i++)
{
    dp[1, i] = 1;
}

for (var i = 1; i &amp;lt; N; i++)
{
    for (var j = 1; j &amp;lt; 10; j++)
    {
        dp[i + 1, j - 1] += dp[i, j];
        dp[i + 1, j] += dp[i, j];
        dp[i + 1, j + 1] += dp[i, j];
    }
}

mint answer = 0;
for (var i = 1; i &amp;lt; 10; i++)
{
    answer += dp[N, i];
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29901915"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t=0&lt;/code&gt;ならば、&lt;code&gt;S[k]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k=0&lt;/code&gt;ならば、&lt;code&gt;S[0]+t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&amp;gt;60&lt;/code&gt;ならば、&lt;code&gt;S[0]&lt;/code&gt;から派生したところになりそう。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&amp;gt;0&lt;/code&gt;かつ&lt;code&gt;k&amp;gt;0&lt;/code&gt;のときの周期は?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説では、&lt;code&gt;F(t,k)&lt;/code&gt;となる文字は、再帰的に求めることができるそうです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t=0&lt;/code&gt;ならば、&lt;code&gt;F(t,k)=S[k]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k=0&lt;/code&gt;ならば、&lt;code&gt;F(t,k)=S[0]+t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;それ以外ならば、&lt;code&gt;F(t,k)&lt;/code&gt;=&lt;code&gt;F(t-1,k/2)+k%2+1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;F&lt;/code&gt;は&lt;code&gt;O(logk)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();
var N = S.Length;
var Q = Scanner.Scan&amp;lt;int&amp;gt;();
while (Q-- &amp;gt; 0)
{
    var (t, k) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answer = F(t, k - 1);
    Console.WriteLine(answer);
}

char G(char c, long d)
{
    return (char)((c - 'A' + d) % 3 + 'A');
}

char F(long t, long k)
{
    if (t == 0) return S[(int)k];
    if (k == 0) return G(S[0], t);
    return G(F(t - 1, k / 2), k % 2 + 1);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29902510"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書順で文字列&lt;code&gt;S&lt;/code&gt;以下の文字列を考えます。
回文のため、文字列&lt;code&gt;S&lt;/code&gt;の前半分の文字列&lt;code&gt;S'&lt;/code&gt;において、&lt;code&gt;S'&lt;/code&gt;未満の個数を数え上げを行います。
この数え上げは、&lt;code&gt;S'&lt;/code&gt;の文字をそれぞれ&lt;code&gt;0-25&lt;/code&gt;の26進数としたときの個数として数え上げることができます。
また、文字列&lt;code&gt;S&lt;/code&gt;の前半分を回文にした文字列を&lt;code&gt;T&lt;/code&gt;としたとき、&lt;code&gt;S&lt;/code&gt;以下ならば、答えを1増やします。&lt;/p&gt;
&lt;p&gt;例えば、&lt;code&gt;S=ABCDE&lt;/code&gt;ならば、&lt;code&gt;S'=ABC&lt;/code&gt;なので、前半の数え上げは&lt;code&gt;26^2*0 + 26^1*1 + 26^0*2 = 28&lt;/code&gt;となり、&lt;code&gt;T=ABCBA&amp;lt;=S&lt;/code&gt;なので答えは&lt;code&gt;29&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var Q = Scanner.Scan&amp;lt;int&amp;gt;();
while (Q-- &amp;gt; 0)
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = S.ToCharArray();

    for (var i = 0; i &amp;lt; (N + 1) / 2; i++)
    {
        T[N - 1 - i] = T[i];
    }

    mint answer = 0;
    for (var i = 0; i &amp;lt; (N + 1) / 2; i++)
    {
        answer *= 26;
        answer += T[i] - 'A';
    }

    if (new string(T).CompareTo(S) &amp;lt;= 0) answer++;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 242の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220226abc241</id>
		<title>ABC241</title>
		<link href="https://aconcavy.github.io/blog/posts/20220226abc241" />
		<updated>2022-02-27T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 241の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241"&gt;https://atcoder.jp/contests/abc241&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29662070"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在の値を&lt;code&gt;curr&lt;/code&gt;とし、現在の値を&lt;code&gt;A[curr]&lt;/code&gt;で更新します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var curr = 0;
for (var i = 0; i &amp;lt; 3; i++)
{
    curr = A[curr];
}

Console.WriteLine(curr);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29664697"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あらかじめ麵の長さ&lt;code&gt;A&lt;/code&gt;の個数を辞書に持ち、&lt;code&gt;B&lt;/code&gt;を順番に見たときに、1個以上ある場合は辞書の&lt;code&gt;B&lt;/code&gt;の値をデクリメントし、0個または辞書に存在しない場合は答えは&lt;code&gt;No&lt;/code&gt;になります。最終的にすべてを見ることができれば、答えは&lt;code&gt;Yes&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;int, int&amp;gt;();
foreach (var a in A)
{
    if (!dict.ContainsKey(a))
    {
        dict[a] = 0;
    }

    dict[a]++;
}

foreach (var b in B)
{
    if (!dict.ContainsKey(b) || dict[b] == 0)
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
        return;
    }

    dict[b]--;
}

Console.WriteLine(&amp;quot;Yes&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29675472"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;マスを順にみて、端を&lt;code&gt;(i,j)&lt;/code&gt;に固定したときに連続した区間のうち4つ以上&lt;code&gt;#&lt;/code&gt;が存在すれば、答えは&lt;code&gt;Yes&lt;/code&gt;となります。
縦の場合は&lt;code&gt;(i,j)&lt;/code&gt;から&lt;code&gt;(i+5,j)&lt;/code&gt;まで、横の場合は&lt;code&gt;(i,j)&lt;/code&gt;から&lt;code&gt;(i,j+5)&lt;/code&gt;まで、斜めの場合は&lt;code&gt;(i,j)&lt;/code&gt;から&lt;code&gt;(i+5,j+5)&lt;/code&gt;と&lt;code&gt;(i+5,j-5)&lt;/code&gt;を確かめます。
検査時に範囲外に出ないように注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var G = new string[N];
for (var i = 0; i &amp;lt; N; i++)
{
    G[i] = Scanner.ScanLine();
}

for (var i = 0; i &amp;lt; N; i++)
{
    for (var j = 0; j &amp;lt; N; j++)
    {
        var ok = false;
        if (i + 5 &amp;lt; N)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i + k][j] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (j + 5 &amp;lt; N)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i][j + k] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (i + 5 &amp;lt; N &amp;amp;&amp;amp; j + 5 &amp;lt; N)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i + k][j + k] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (i + 5 &amp;lt; N &amp;amp;&amp;amp; j - 5 &amp;gt;= 0)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i + k][j - k] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (ok)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }

    }
}

Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29715030"&gt;復習提出 (FenwickTree)&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/abc241/submissions/29716771"&gt;復習提出 (平衡二分探索木)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FenwickTree&lt;/code&gt;を使った場合の解き方です。
&lt;code&gt;x&lt;/code&gt;の値が大きいので、あらかじめクエリを先読みし、出現する座標を圧縮します。
圧縮した&lt;code&gt;x&lt;/code&gt;の値を&lt;code&gt;cx&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が1であれば、&lt;code&gt;FenwickTree&lt;/code&gt;の&lt;code&gt;cx&lt;/code&gt;に1を追加します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が2であれば、&lt;code&gt;FenwickTree&lt;/code&gt;の区間&lt;code&gt;[idx, cx]&lt;/code&gt;の値が&lt;code&gt;k&lt;/code&gt;以上の場所を二部探索し、存在するならばその時の&lt;code&gt;idx&lt;/code&gt;の対応する値が答えとなります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が2であれば、&lt;code&gt;FenwickTree&lt;/code&gt;の区間&lt;code&gt;[cx, idx]&lt;/code&gt;の値が&lt;code&gt;k&lt;/code&gt;以上の場所を二部探索し、存在するならばその時の&lt;code&gt;idx&lt;/code&gt;の対応する値が答えとなります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var Q = Scanner.Scan&amp;lt;int&amp;gt;();
var query = new (int, long, int)[Q];
var set = new HashSet&amp;lt;long&amp;gt;();
for (var i = 0; i &amp;lt; Q; i++)
{
    var line = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var (t, x) = ((int)line[0], line[1]);
    var k = t == 1 ? -1 : (int)line[2];
    query[i] = (t, x, k);
    set.Add(x);
}
 
var (map, remap) = Compress(set);
var N = map.Count;
var ft = new FenwickTree(N);
foreach (var (t, x, k) in query)
{
    if (t == 1)
    {
        ft.Add(map[x], 1);
    }
    else if (t == 2)
    {
        bool F(int idx) =&amp;gt; ft.Sum(idx, map[x] + 1) &amp;gt;= k;
        var idx = BinarySearch(map[x] + 1, 0, F);
        var answer = F(idx) ? remap[idx] : -1;
        Console.WriteLine(answer);
    }
    else
    {
        bool F(int idx) =&amp;gt; ft.Sum(map[x], idx + 1) &amp;gt;= k;
        var idx = BinarySearch(map[x] - 1, N - 1, F);
        var answer = F(idx) ? remap[idx] : -1;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static int BinarySearch(int ng, int ok, Func&amp;lt;int, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }

    return ok;
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }

    return (map, remap);
}

public class FenwickTree
{
    private readonly long[] _data;
    private readonly int _length;

    public FenwickTree(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        _length = length;
        _data = new long[length];
    }

    public void Add(int index, long item)
    {
        if (index &amp;lt; 0 || _length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index++;
        while (index &amp;lt;= _length)
        {
            _data[index - 1] += item;
            index += index &amp;amp; -index;
        }
    }

    public long Sum(int length)
    {
        if (length &amp;lt; 0 || _length &amp;lt; length) throw new ArgumentOutOfRangeException(nameof(length));
        var s = 0L;
        while (length &amp;gt; 0)
        {
            s += _data[length - 1];
            length -= length &amp;amp; -length;
        }

        return s;
    }

    public long Sum(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || _length &amp;lt; right) throw new ArgumentOutOfRangeException();
        return Sum(right) - Sum(left);
    }

    public int LowerBound(long item) =&amp;gt; CommonBound(item, LessThanOrEqual);
    public int UpperBound(long item) =&amp;gt; CommonBound(item, LessThan);

    private int CommonBound(long item, Func&amp;lt;long, long, bool&amp;gt; compare)
    {
        if (compare(item, _data[0])) return 0;
        var x = 0;
        var r = 1;
        while (r &amp;lt; _length) r &amp;lt;&amp;lt;= 1;
        for (var k = r; k &amp;gt; 0; k &amp;gt;&amp;gt;= 1)
        {
            if (x + k - 1 &amp;gt;= _length || compare(item, _data[x + k - 1])) continue;
            item -= _data[x + k - 1];
            x += k;
        }

        return x;
    }

    private static bool LessThanOrEqual(long x, long y) =&amp;gt; x &amp;lt;= y;
    private static bool LessThan(long x, long y) =&amp;gt; x &amp;lt; y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;平衡二分探索木を使った時の解き方です。
C#では&lt;code&gt;MultiSet&lt;/code&gt;が存在しないので、平衡二分探索木を自作する必要があります。
降順、昇順の平衡二分探索木を用意し、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が1であれば、両方の平衡二分探索木に&lt;code&gt;x&lt;/code&gt;を追加します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が2であれば、降順の平衡二分探索木において&lt;code&gt;x&lt;/code&gt;以上になるインデックス&lt;code&gt;(idx)&lt;/code&gt;を取得し、&lt;code&gt;idx+k-1&lt;/code&gt;となる値が存在するならば、その値が答えとなります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が3であれば、昇順の平衡二分探索木において、&lt;code&gt;x&lt;/code&gt;以下になるインデックス&lt;code&gt;(idx)&lt;/code&gt;を取得し、&lt;code&gt;idx+k-1&lt;/code&gt;となる値が存在するならば、その値が答えとなります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var Q = Scanner.Scan&amp;lt;int&amp;gt;();
var asc = new RandomizedBinarySearchTree&amp;lt;long&amp;gt;();
var desc = new RandomizedBinarySearchTree&amp;lt;long&amp;gt;((x, y) =&amp;gt; y.CompareTo(x));

while (Q-- &amp;gt; 0)
{
    var line = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var (t, x) = (line[0], line[1]);
    if (t == 1)
    {
        asc.Insert(x);
        desc.Insert(x);
    }
    else
    {
        var k = (int)line[2] - 1;
        var set = t == 2 ? desc : asc;
        if (set.Count() == 0)
        {
            Console.WriteLine(-1);
            continue;
        }
        var lb = set.LowerBound(x);
        var answer = lb + k &amp;lt; set.Count() ? set.ElementAt(lb + k) : -1;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次のような平衡二分探索木を使用しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class RandomizedBinarySearchTree&amp;lt;T&amp;gt; : IEnumerable&amp;lt;T&amp;gt;
{
    private readonly Comparison&amp;lt;T&amp;gt; _comparison;
    private readonly Compare _lowerBound;
    private readonly Compare _upperBound;
    private readonly Random _random;

    private Node _root;
    private int _count;

    public RandomizedBinarySearchTree(int seed = 0) : this(comparer: null, seed) { }

    public RandomizedBinarySearchTree(Comparer&amp;lt;T&amp;gt; comparer, int seed = 0) : this(
        (comparer ?? Comparer&amp;lt;T&amp;gt;.Default).Compare, seed)
    {
    }

    public RandomizedBinarySearchTree(Comparison&amp;lt;T&amp;gt; comparison, int seed = 0)
    {
        _comparison = comparison;
        _lowerBound = (x, y) =&amp;gt; _comparison(x, y) &amp;gt;= 0;
        _upperBound = (x, y) =&amp;gt; _comparison(x, y) &amp;gt; 0;
        _random = new Random(seed);
    }

    public delegate bool Compare(T x, T y);

    public void Insert(T value)
    {
        if (_root is null) _root = new Node(value);
        else InsertAt(LowerBound(value), value);
    }

    public void InsertAt(int index, T value)
    {
        var (l, r) = Split(_root, index);
        _root = Merge(Merge(l, new Node(value)), r);
    }

    public void Erase(T value)
    {
        EraseAt(LowerBound(value));
    }

    public void EraseAt(int index)
    {
        var (l, r1) = Split(_root, index);
        var (_, r2) = Split(r1, 1);
        _root = Merge(l, r2);
    }

    public T ElementAt(int index)
    {
        if (index &amp;lt; 0 || Count(_root) &amp;lt;= index) throw new ArgumentNullException(nameof(index));
        var node = _root;
        var idx = Count(node) - Count(node.R) - 1;
        while (node is { })
        {
            if (idx == index) return node.Value;
            if (idx &amp;gt; index)
            {
                node = node.L;
                idx -= Count(node?.R) + 1;
            }
            else
            {
                node = node.R;
                idx += Count(node?.L) + 1;
            }
        }

        throw new ArgumentOutOfRangeException(nameof(index));
    }

    public bool Contains(T value)
    {
        return Find(value) is { };
    }

    public int Count() =&amp;gt; Count(_root);

    public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; Enumerate(_root).GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();

    public int UpperBound(T value) =&amp;gt; CommonBound(value, _upperBound);
    public int LowerBound(T value) =&amp;gt; CommonBound(value, _lowerBound);

    public int CommonBound(T value, Compare compare)
    {
        var node = _root;
        if (node is null) return -1;
        var bound = Count(node);
        var idx = bound - Count(node.R) - 1;
        while (node is { })
        {
            if (compare(node.Value, value))
            {
                node = node.L;
                bound = Math.Min(bound, idx);
                idx -= Count(node?.R) + 1;
            }
            else
            {
                node = node.R;
                idx += Count(node?.L) + 1;
            }
        }

        return bound;
    }

    private double GetProbability() =&amp;gt; _random.NextDouble();

    private Node Merge(Node l, Node r)
    {
        if (l is null || r is null) return l ?? r;
        var (n, m) = (Count(l), Count(r));
        if ((double)n / (n + m) &amp;gt; GetProbability())
        {
            l.R = Merge(l.R, r);
            return l;
        }
        else
        {
            r.L = Merge(l, r.L);
            return r;
        }
    }

    private (Node, Node) Split(Node node, int k)
    {
        if (node is null) return (null, null);

        if (k &amp;lt;= Count(node.L))
        {
            var (l, r) = Split(node.L, k);
            node.L = r;
            return (l, node);
        }
        else
        {
            var (l, r) = Split(node.R, k - Count(node.L) - 1);
            node.R = l;
            return (node, r);
        }
    }

    private Node Find(T value)
    {
        var node = _root;
        while (node is { })
        {
            var cmp = _comparison(node.Value, value);
            if (cmp &amp;gt; 0) node = node.L;
            else if (cmp &amp;lt; 0) node = node.R;
            else break;
        }

        return node;
    }

    private static int Count(Node node) =&amp;gt; node?.Count ?? 0;

    private static IEnumerable&amp;lt;T&amp;gt; Enumerate(Node node = null)
    {
        if (node is null) yield break;
        foreach (var value in Enumerate(node.L)) yield return value;
        yield return node.Value;
        foreach (var value in Enumerate(node.R)) yield return value;
    }

    private class Node
    {
        public T Value { get; }

        public Node L
        {
            get =&amp;gt; _l;
            set
            {
                _l = value;
                UpdateCount();
            }
        }

        public Node R
        {
            get =&amp;gt; _r;
            set
            {
                _r = value;
                UpdateCount();
            }
        }

        public int Count { get; private set; }

        private Node _l;
        private Node _r;

        public Node(T value)
        {
            Value = value;
            Count = 1;
        }

        private void UpdateCount()
        {
            Count = (L?.Count ?? 0) + (R?.Count ?? 0) + 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29701801"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mod&lt;/code&gt;の性質上、最大でも&lt;code&gt;N&lt;/code&gt;回でループすることがわかります。
そのため、答えは&lt;code&gt;(1回のループ中の和 * ループ回数) + (ループに入るまでの和 + ループの端数の和)&lt;/code&gt;で求めることができます。
実装としては、&lt;code&gt;idx&lt;/code&gt;のときの合計値と、&lt;code&gt;idx&lt;/code&gt;の時に&lt;code&gt;A&lt;/code&gt;の値を参照したことを保持しながら順にみていきます。
一度見たことがある&lt;code&gt;A&lt;/code&gt;を参照する場合、&lt;code&gt;現在の合計値 - 1度目のidxの合計値&lt;/code&gt;から1回のループ中の和がわかり、&lt;code&gt;2度目のidx - 1度目のidx&lt;/code&gt;からループの長さが求まり、&lt;code&gt;(K - 1度目のidx) / ループの長さ&lt;/code&gt;でループの回数がわかるので、&lt;code&gt;(1回のループ中の和 * ループ回数)&lt;/code&gt;を求めることができます。
また、&lt;code&gt;(K - 1度目のidx) % ループの長さ&lt;/code&gt;でループの端数となる残りの&lt;code&gt;idx&lt;/code&gt;を求めることができ、&lt;code&gt;一度目のidx + 残りのidx&lt;/code&gt;のときの合計値をみることで、&lt;code&gt;(ループに入るまでの和 + ループの端数の和)&lt;/code&gt;を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;int, int&amp;gt;();
var steps = new List&amp;lt;long&amp;gt;();

int F(long x) =&amp;gt; (int)(x % N);
var current = 0L;
for (var i = 0; i &amp;lt; K; i++)
{
    var x = F(current);
    if (dict.ContainsKey(x))
    {
        var noloop = dict[x];
        var loop = i - dict[x];
        var div = (K - noloop) / loop;
        current = (current - steps[noloop]) * div;
        var mod = (int)((K - noloop) % loop);
        if (mod &amp;lt; 0) mod += loop;
        current += steps[noloop + mod];
        break;
    }

    dict[x] = i;
    steps.Add(current);
    current += A[x];
}

Console.WriteLine(current);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 241の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220220abc240</id>
		<title>ABC240</title>
		<link href="https://aconcavy.github.io/blog/posts/20220220abc240" />
		<updated>2022-02-20T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 240の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240"&gt;https://atcoder.jp/contests/abc240&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29503598"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10で割ったときのあまりの値を比較することで、ループを再現することができます。
また、隣り合っていることは差が1であればいいので、それを確かめます。
例えば、&lt;code&gt;a=2, b=3&lt;/code&gt;のときは、&lt;code&gt;2+1==3&lt;/code&gt;となり、&lt;code&gt;a=1,b=10&lt;/code&gt;の時は&lt;code&gt;1==0+1&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var answer = (A + 1) % 10 == B % 10 || (B + 1) % 10 == A % 10;
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29506402"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重複を削除したときの個数が答えとなります。
C#のLINQには、&lt;code&gt;Distinct&lt;/code&gt;というシーケンス内の重複を除いたシーケンスを返すメソッドがあるため、それを使い個数を数えます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var answer = A.Distinct().Count();
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29511865"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;動的計画法で答えを求めます。
&lt;code&gt;i&lt;/code&gt;番目のジャンプを座標&lt;code&gt;j(0&amp;lt;=j&amp;lt;=X)&lt;/code&gt;から行うと、&lt;code&gt;i+1&lt;/code&gt;番目では、&lt;code&gt;j+a&lt;/code&gt;または&lt;code&gt;j+b&lt;/code&gt;に存在することができます。初期状態の&lt;code&gt;0&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;としたとき、そこからの遷移を計算し、&lt;code&gt;N&lt;/code&gt;回ジャンプ後の&lt;code&gt;X&lt;/code&gt;の値が&lt;code&gt;true&lt;/code&gt;ならば存在することができると表現できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var dp = new bool[N + 1, X + 1];
dp[0, 0] = true;
for (var i = 0; i &amp;lt; N; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    for (var j = 0; j &amp;lt;= X; j++)
    {
        if (j + a &amp;lt;= X) dp[i + 1, j + a] |= dp[i, j];
        if (j + b &amp;lt;= X) dp[i + 1, j + b] |= dp[i, j];
    }
}

var answer = dp[N, X];
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29521922"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スタックに順番にボールを追加していき、同じ数字がK個連続した場合は削除する操作を行います。このとき一つの数字につき1つの値を入れていると、計算量は&lt;code&gt;O(N^2)&lt;/code&gt;になってしまうので、連続した値は値と個数の一つのオブジェクトとしてまとめ、スタックに入っているボールの個数を管理することで、計算量を&lt;code&gt;O(N)&lt;/code&gt;に抑えることができます。
具体的には、もしスタックが空またはスタックのトップと異なる値の場合は、値と個数1をタプルとしてまとめてスタックに追加し、もしスタックのトップと同じ値の場合は、スタックのトップの個数を更新します。その後、スタックのトップを順にみていき、値と個数が同じ場合はスタックから取り除き、現在の個数も減少させます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var curr = 0;
var stack = new Stack&amp;lt;(int V, int C)&amp;gt;();
foreach (var a in A)
{
    curr++;
    if (stack.Count == 0)
    {
        stack.Push((a, 1));
        Console.WriteLine(curr);
        continue;
    }

    var (v, c) = stack.Pop();

    if (a == v)
    {
        c++;
        stack.Push((v, c));
    }
    else
    {
        stack.Push((v, c));
        stack.Push((a, 1));
    }

    while (stack.Count &amp;gt; 0)
    {
        (v, c) = stack.Peek();
        if (v == c)
        {
            stack.Pop();
            curr -= c;
        }
        else
        {
            break;
        }
    }

    Console.WriteLine(curr);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29533033"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文の根付き木について、子を持たない頂点に対してそれぞれ異なる値を与えたときに、部分木&lt;code&gt;i&lt;/code&gt;が持つ値群の最小値と最大値をそれぞれ&lt;code&gt;Li&lt;/code&gt;と&lt;code&gt;Ri&lt;/code&gt;としたとき、頂点&lt;code&gt;i&lt;/code&gt;は区間&lt;code&gt;[Li, Ri]&lt;/code&gt;を持つと解釈することができます。
そのため、深さ優先探索を行い、子を持たない頂点の場合はそれまでに出現していない値を&lt;code&gt;Li&lt;/code&gt;と&lt;code&gt;Ri&lt;/code&gt;に設定し、子を持つ頂点は、子の&lt;code&gt;Li&lt;/code&gt;と&lt;code&gt;Ri&lt;/code&gt;の中でそれぞれ最小、最大となるものを選択することで、答えとなる区間を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; N - 1; i++)
{
    var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    u--; v--;
    G[u].Add(v);
    G[v].Add(u);
}

const int inf = (int)1e9;
var L = new int[N];
var R = new int[N];
var curr = 1;
(int L, int R) Dfs(int u, int p)
{
    var l = inf;
    var r = -inf;
    foreach (var v in G[u])
    {
        if (v == p) continue;
        var (ll, rr) = Dfs(v, u);
        l = Math.Min(l, ll);
        r = Math.Max(r, rr);
    }

    if (l == inf)
    {
        L[u] = curr;
        R[u] = curr;
        curr++;
    }
    else
    {
        L[u] = l;
        R[u] = r;
    }

    return (L[u], R[u]);
}

Dfs(0, -1);

foreach (var (l, r) in L.Zip(R))
{
    Console.WriteLine($&amp;quot;{l} {r}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 240の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>