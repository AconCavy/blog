<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title />
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2022 AconCavy</rights>
	<updated>2022-07-31T14:16:37Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220731abc262</id>
		<title>ABC262</title>
		<link href="https://blog.aconcavy.dev/posts/20220731abc262" />
		<updated>2022-07-31T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 262の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc262"&gt;https://atcoder.jp/contests/abc262&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33660849"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数&lt;/code&gt;ならば2年後、&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数+1&lt;/code&gt;ならば1年後、&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数+2&lt;/code&gt;ならばその年、&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数+3&lt;/code&gt;ならば3年後が答えとなります。
&lt;code&gt;Y&lt;/code&gt;を4で割った余りが&lt;code&gt;4の倍数+n&lt;/code&gt;の&lt;code&gt;n&lt;/code&gt;なので、その値によって答えを求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Y = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = Y;
    if (Y % 4 == 0) answer += 2;
    if (Y % 4 == 1) answer += 1;
    if (Y % 4 == 3) answer += 3;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33662725"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;U&lt;/code&gt;と&lt;code&gt;V&lt;/code&gt;間に辺があるかどうかを二次元配列&lt;code&gt;G&lt;/code&gt;で表現し、&lt;code&gt;G[a,b]&lt;/code&gt;、&lt;code&gt;G[b,c]&lt;/code&gt;、&lt;code&gt;G[c,a]&lt;/code&gt;のすべてに辺が存在するときの総数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new bool[N, N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--;
        v--;
        G[u, v] = G[v, u] = true;
    }

    var answer = 0;
    for (var a = 0; a &amp;lt; N; a++)
    {
        for (var b = a + 1; b &amp;lt; N; b++)
        {
            for (var c = b + 1; c &amp;lt; N; c++)
            {
                if (G[a, b] &amp;amp;&amp;amp; G[b, c] &amp;amp;&amp;amp; G[c, a]) answer++;
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33669451"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;条件となる&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;を全探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり、実行時間制限内に答えを求めることはできません。
条件を満たす要素を考えてみると、&lt;code&gt;(i==A[i], j==A[j])&lt;/code&gt;と&lt;code&gt;(i==A[j], j==A[i])&lt;/code&gt;となる組み合わせが対象となります。
前者の場合、&lt;code&gt;[1, x, x, 4, 5]&lt;/code&gt;のような&lt;code&gt;A&lt;/code&gt;があったとすると、&lt;code&gt;(1,4)&lt;/code&gt;、&lt;code&gt;(1,5)&lt;/code&gt;、&lt;code&gt;(4,5)&lt;/code&gt;が答えとなり、&lt;code&gt;i==A[i]&lt;/code&gt;となる要素から2つ選ぶ組み合わせとなるので、&lt;code&gt;i==A[i]&lt;/code&gt;の個数を&lt;code&gt;C&lt;/code&gt;とすると、&lt;code&gt;C*(C-1)/2&lt;/code&gt;が前者の組み合わせの数となります。
一方、後者の場合、&lt;code&gt;i&amp;lt;j&lt;/code&gt;より&lt;code&gt;A[i]&amp;gt;i&lt;/code&gt;かつ&lt;code&gt;A[A[i]]==i&lt;/code&gt;となるものがペアとして成り立ち、その総和が後者の組み合わせの数となります。
よって、これらの総和が答えとなります。
&lt;code&gt;N&lt;/code&gt;が最大&lt;code&gt;5*10^5&lt;/code&gt;なので、&lt;code&gt;int&lt;/code&gt;では収まらないので注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var answer = 0L;
    var same = 0L;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A[i] == i) same++;
        else if (A[i] &amp;gt; i &amp;amp;&amp;amp; A[A[i]] == i) answer++;
    }

    answer += same * (same - 1) / 2;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33689722"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の項を選ぶ個数を1つ決めたときの和の余りを動的計画法で求め、全て求めたときのあまりが&lt;code&gt;0&lt;/code&gt;の数の&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;までの総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    mint answer = 0;

    for (var c = 1; c &amp;lt;= N; c++)
    {
        var dp = new mint[N + 1, N + 1, N];
        dp[0, 0, 0]++;
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                for (var k = 0; k &amp;lt; N; k++)
                {
                    dp[i + 1, j + 1, (k + A[i]) % c] += dp[i, j, k];
                    dp[i + 1, j, k] += dp[i, j, k];
                }
            }
        }

        answer += dp[N, c, 0];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 262の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220723abc261</id>
		<title>ABC261</title>
		<link href="https://blog.aconcavy.dev/posts/20220723abc261" />
		<updated>2022-07-23T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 261の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261"&gt;https://atcoder.jp/contests/abc261&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33429389"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;100&lt;/code&gt;の範囲を全て見て、値&lt;code&gt;x&lt;/code&gt;のときにどちらの色も塗られている(&lt;code&gt;L1&amp;lt;=x&amp;lt;=R1 &amp;amp;&amp;amp; L2&amp;lt;=x&amp;lt;=R1&lt;/code&gt;)場合の数を数え上げることで答えを求めることができます。
また、共通する範囲のうち、&lt;code&gt;L&lt;/code&gt;は&lt;code&gt;Max(L1,L2)&lt;/code&gt;、&lt;code&gt;R&lt;/code&gt;は&lt;code&gt;Min(R1,R2)&lt;/code&gt;で求められるので、&lt;code&gt;Min(R1,R2)-Max(L1,L2)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
この場合、&lt;code&gt;L&amp;gt;R&lt;/code&gt;になる場合があるので、&lt;code&gt;0&lt;/code&gt;未満にならないように注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L1, R1, L2, R2) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    var answer = Math.Max(0, Math.Min(R1, R2) - Math.Max(L1, L2));
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33435312"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i!=j&lt;/code&gt;において、表の&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列を見たとき、表の&lt;code&gt;j&lt;/code&gt;行&lt;code&gt;i&lt;/code&gt;列の値が対応するものになっているかを判断します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A[i][j]==W&lt;/code&gt;のとき&lt;code&gt;A[j][i]==L&lt;/code&gt;である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A[i][j]==L&lt;/code&gt;のとき&lt;code&gt;A[j][i]==W&lt;/code&gt;である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A[i][j]==D&lt;/code&gt;のとき&lt;code&gt;A[j][i]==D&lt;/code&gt;である。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全ての値が対応するものになっていれば&lt;code&gt;correct&lt;/code&gt;、そうでなければ&lt;code&gt;incorrect&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = true;
    var A = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            answer &amp;amp;= A[i][j] == 'W' &amp;amp;&amp;amp; A[j][i] == 'L' ||
                      A[i][j] == 'L' &amp;amp;&amp;amp; A[j][i] == 'W' ||
                      A[i][j] == 'D' &amp;amp;&amp;amp; A[j][i] == 'D';
        }
    }

    Console.WriteLine(answer ? &amp;quot;correct&amp;quot; : &amp;quot;incorrect&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33437954"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列が既に何回出ているかを愚直に探索してしまうと、1回の探索の時間計算量が&lt;code&gt;O(N)&lt;/code&gt;、全体の時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまい、実行時間制限に間に合いません。
辞書のようなデータ構造を使って文字列が何回出ているかを管理することで、データ構造の構築に&lt;code&gt;O(logN)&lt;/code&gt;、値の取得に&lt;code&gt;O(1)&lt;/code&gt;、全体の時間計算量を&lt;code&gt;O(NlogN)&lt;/code&gt;に抑えることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;string, int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        if (dict.ContainsKey(S))
        {
            Console.WriteLine($&amp;quot;{S}({dict[S]})&amp;quot;);
            dict[S] += 1;
        }
        else
        {
            Console.WriteLine(S);
            dict[S] = 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33446633"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コインの表裏の状態が&lt;code&gt;N&lt;/code&gt;回あるので、あり得る場合の数は&lt;code&gt;2^N&lt;/code&gt;通りとなり、全探索をしてしまうと時間計算量が&lt;code&gt;O(2^N)&lt;/code&gt;となり実行時間制限内に答えを求めることはできません。&lt;br /&gt;
そこで、&lt;code&gt;dp[i][j] := i回目のコイントスを終えてカウンタの数値がjのときのもらえる円の最大値&lt;/code&gt;とした動的計画法を解くことで時間計算量を抑えます。
&lt;code&gt;X[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;回目のコイントスで表が出たときもらえる円、&lt;code&gt;C[j]&lt;/code&gt;をカウンタの数値が&lt;code&gt;j&lt;/code&gt;のときのボーナスでもらえる円としたとき、&lt;code&gt;i+1&lt;/code&gt;回目への遷移は次のようになります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;回目のコイントスで表の時: &lt;code&gt;Max(dp[i+1][j+1], dp[i][j]+X[i]+C[j+1])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;回目のコイントスで裏の時: &lt;code&gt;Max(dp[i+1][0], dp[i][j])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;回遷移が終わった後のそれぞれのカウンタ状態の最大値が答えとなり、全体の時間計算量は&lt;code&gt;O(N^2)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var C = new long[N + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (c, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        C[c] = y;
    }

    var dp = new long[N + 1, N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            dp[i + 1, j + 1] = Math.Max(dp[i + 1, j + 1], dp[i, j] + X[i] + C[j + 1]);
            dp[i + 1, 0] = Math.Max(dp[i + 1, 0], dp[i, j]);
        }
    }

    var answer = 0L;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        answer = Math.Max(answer, dp[N, i]);
    }

    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33477238"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作が全てビット演算なので、ビットごとに操作が独立していることがわかります。&lt;br /&gt;
&lt;code&gt;k&lt;/code&gt;番目のビットが&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;の二通りの状態に&lt;code&gt;i&lt;/code&gt;番目までの操作を累積したものを用意し、&lt;code&gt;C&lt;/code&gt;の&lt;code&gt;k&lt;/code&gt;番目のビットの値に&lt;code&gt;i&lt;/code&gt;番目まで累積した操作を適用したものが、&lt;code&gt;i&lt;/code&gt;行目の答えの&lt;code&gt;k&lt;/code&gt;番目ビット目になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var Ops = new (int T, int A)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        Ops[i] = Scanner.Scan&amp;lt;int, int&amp;gt;();
    }

    var answer = new int[N];
    for (var k = 0; k &amp;lt; 30; k++)
    {
        var bit = C &amp;gt;&amp;gt; k &amp;amp; 1;
        var cum = new int[] { 0, 1 };
        for (var i = 0; i &amp;lt; N; i++)
        {
            var (t, a) = Ops[i];
            var b = a &amp;gt;&amp;gt; k &amp;amp; 1;
            var f = new int[] { 0, 1 };
            for (var j = 0; j &amp;lt; 2; j++)
            {
                if (t == 1) f[j] &amp;amp;= b;
                if (t == 2) f[j] |= b;
                if (t == 3) f[j] ^= b;
            }

            for (var j = 0; j &amp;lt; 2; j++)
            {
                cum[j] = f[cum[j]];
            }

            bit = cum[bit];
            answer[i] |= bit &amp;lt;&amp;lt; k;
        }
    }

    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 261の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220717abc260</id>
		<title>ABC260</title>
		<link href="https://blog.aconcavy.dev/posts/20220717abc260" />
		<updated>2022-07-17T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 260の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260"&gt;https://atcoder.jp/contests/abc260&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33290941"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字ごとの出現数を数え上げ、出現数が1つのみ文字を出力します。&lt;br /&gt;
C#の場合、&lt;code&gt;char&lt;/code&gt;型を数値として扱い、小文字のアルファベットから&lt;code&gt;a&lt;/code&gt;を引くことで&lt;code&gt;a,b,c,...&lt;/code&gt;を&lt;code&gt;0,1,2,...&lt;/code&gt;として管理することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var count = new int[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    for (var i = 0; i &amp;lt; 26; i++)
    {
        if (count[i] == 1)
        {
            Console.WriteLine((char)('a' + i));
            return;
        }
    }

    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33297423"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;受験生の番目、数学のスコア、英語のスコアを&lt;code&gt;Tuple&lt;/code&gt;などのデータクラスとして管理します。&lt;br /&gt;
&lt;code&gt;i&lt;/code&gt;番目の学生が合格したかをフラグとして管理し、それぞれの条件ごとにソートして合格となっていない受験生が対象となるかを判定することで、時間計算量&lt;code&gt;O(NlogN+N)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
C#の場合、&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array.sort?view=net-6.0#system-array-sort-1(-0()-system-comparison((-0)))"&gt;Array.Sort メソッド&lt;/a&gt;に&lt;code&gt;Comparison&amp;lt;T&amp;gt;&lt;/code&gt;を指定することで、比較関数を与えてソートすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y, Z) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var accepts = new bool[N];
    var C = A.Zip(B).Select((x, i) =&amp;gt; (A: x.First, B: x.Second, ID: i)).ToArray();

    Array.Sort(C, (x, y) =&amp;gt;
    {
        var result = y.A.CompareTo(x.A);
        return result == 0 ? x.ID.CompareTo(y.ID) : result;
    });
    for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; X &amp;gt; 0; i++)
    {
        if (accepts[C[i].ID]) continue;
        accepts[C[i].ID] = true;
        X--;
    }

    Array.Sort(C, (x, y) =&amp;gt;
    {
        var result = y.B.CompareTo(x.B);
        return result == 0 ? x.ID.CompareTo(y.ID) : result;
    });
    for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; Y &amp;gt; 0; i++)
    {
        if (accepts[C[i].ID]) continue;
        accepts[C[i].ID] = true;
        Y--;
    }

    Array.Sort(C, (x, y) =&amp;gt;
    {
        var result = (y.A + y.B).CompareTo(x.A + x.B);
        return result == 0 ? x.ID.CompareTo(y.ID) : result;
    });
    for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; Z &amp;gt; 0; i++)
    {
        if (accepts[C[i].ID]) continue;
        accepts[C[i].ID] = true;
        Z--;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (accepts[i])
        {
            Console.WriteLine(i + 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33301206"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;動的計画法で答えを求めます。
赤い宝石と青い宝石のレベルごとの個数をそれぞれ管理し、レベル&lt;code&gt;N&lt;/code&gt;からレベル&lt;code&gt;2&lt;/code&gt;まで計算します。
遷移としては、レベルごとに先に赤い宝石を変換し、次に青い宝石を変換します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var Red = new long[N + 1];
    var Blue = new long[N + 1];
    Red[N] = 1;
    for (var i = N; i &amp;gt;= 2; i--)
    {
        Red[i - 1] += Red[i];
        Blue[i] += Red[i] * X;
        Red[i - 1] += Blue[i];
        Blue[i - 1] += Blue[i] * Y;
    }

    var answer = Blue[1];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33307596"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc260/submissions/33325990"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表になっているカードの集合のうち&lt;code&gt;X&lt;/code&gt;以上の値を高速に求められるようなデータ構造と、カードの山を管理するデータ構造を使って何ターン目に食べられるかを判定します。
前者のデータ構造では、&lt;code&gt;X&lt;/code&gt;以上の値を時間計算量&lt;code&gt;O(N)&lt;/code&gt;で探索してしまうと、全体の時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまい実行時間制限に間に合いません。&lt;br /&gt;
そのため、二部探索のような時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で探索できるようなデータ構造(C++の場合は&lt;code&gt;set&lt;/code&gt;、C#の場合は&lt;code&gt;SortedSet&lt;/code&gt;)が必要です。&lt;br /&gt;
&lt;code&gt;SortedSet&lt;/code&gt;から&lt;code&gt;GetViewBetween&lt;/code&gt;したサブセットの&lt;code&gt;Count&lt;/code&gt;プロパティが、場合によっては時間計算量&lt;code&gt;O(1)&lt;/code&gt;ではなさそうなので、&lt;code&gt;LINQ&lt;/code&gt;の&lt;code&gt;Any&lt;/code&gt;で存在判定をしたほうが良さそうです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = new int[N + 1];
    Array.Fill(answer, -1);
    var set = new SortedSet&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    var root = new int[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var p = P[i];
        var r = root[p] = p;
        var subset = set.GetViewBetween(p, N);

        if (subset.Any())
        {
            var q = subset.Min;
            r = root[p] = root[q];
            set.Remove(q);
        }
        else
        {
            dict[r] = new List&amp;lt;int&amp;gt;();
        }
        
        set.Add(p);
        dict[r].Add(p);

        if (dict[r].Count &amp;gt;= K)
        {
            foreach (var v in dict[r])
            {
                answer[v] = i + 1;
            }

            set.Remove(p);
            dict.Remove(r);
        }
    }

    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer.Skip(1)));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 260の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220709abc259</id>
		<title>ABC259</title>
		<link href="https://blog.aconcavy.dev/posts/20220709abc259" />
		<updated>2022-07-09T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 259の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259"&gt;https://atcoder.jp/contests/abc259&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33074995"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M&amp;lt;X&lt;/code&gt;のとき、&lt;code&gt;D&lt;/code&gt;ずつ&lt;code&gt;X-M&lt;/code&gt;年分変化したので、最終的な身長からその変化分を引いた数&lt;code&gt;T-D*(X-M)&lt;/code&gt;が答えとなります。&lt;br /&gt;
&lt;code&gt;X&amp;lt;=M&lt;/code&gt;のとき、&lt;code&gt;X&lt;/code&gt;歳にはすでに&lt;code&gt;T&lt;/code&gt;であるため、&lt;code&gt;M&lt;/code&gt;歳の時も&lt;code&gt;T&lt;/code&gt;です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, X, T, D) = Scanner.Scan&amp;lt;int, int, int, int, int&amp;gt;();
    var answer = T - D * Math.Max(X - M, 0);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33081607"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ベクトル&lt;code&gt;(a,b)&lt;/code&gt;に対して&lt;code&gt;d&lt;/code&gt;度の回転の操作を行います。
これは、&lt;code&gt;x' = x * cos(rad(d)) - y * sin(rad(d))&lt;/code&gt;, &lt;code&gt;y' = x * sin(rad(d)) + y * cos(rad(d))&lt;/code&gt;で表すことができます。
度から弧度法(ラジアン)を求めるには、&lt;code&gt;度 * PI / 180度&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, D) = Scanner.Scan&amp;lt;double, double, double&amp;gt;();
    var rad = D * Math.PI / 180.0;
    var sin = Math.Sin(rad);
    var cos = Math.Cos(rad);
    var x = A * cos - B * sin;
    var y = A * sin + B * cos;
    Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33110149"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列が一致するということは、同じ文字が連続した区間ごとに分割し、区間順にみたときに次の条件を全ての文字の区間が満たすときになります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の区間で出現する文字が一致する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の区間で文字が連続する長さが両方とも&lt;code&gt;1&lt;/code&gt;である。または、文字が連続する長さが両方とも&lt;code&gt;2&lt;/code&gt;以上かつ&lt;code&gt;T&lt;/code&gt;の文字が連続する長さが&lt;code&gt;S&lt;/code&gt;の文字が連続する長さ以上である。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();

    List&amp;lt;(char, int)&amp;gt; F(ReadOnlySpan&amp;lt;char&amp;gt; s)
    {
        var result = new List&amp;lt;(char, int)&amp;gt;();
        var r = 0;
        for (var l = 0; l &amp;lt; s.Length;)
        {
            r = l;
            while (r &amp;lt; s.Length &amp;amp;&amp;amp; s[r] == s[l]) r++;
            result.Add((s[l], r - l));
            l = r;
        }

        return result;
    }

    var ss = F(S);
    var tt = F(T);
    var answer = ss.Count == tt.Count;
    if (answer)
    {
        for (var i = 0; i &amp;lt; ss.Count; i++)
        {
            var (s, cs) = ss[i];
            var (t, ct) = tt[i];
            answer &amp;amp;= s == t;
            answer &amp;amp;= cs == ct || cs &amp;gt; 1 &amp;amp;&amp;amp; ct &amp;gt; 1 &amp;amp;&amp;amp; cs &amp;lt; ct;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33103648"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各円を頂点としたとき、円どうしで移動可能な場合に辺が存在すると考えると、グラフ問題として考えることができます。
ある二つの円が移動可能ということは、その二つの円が共有点を持つということになります。
共有点が存在するかどうかは、一つ目の円の半径を&lt;code&gt;r1&lt;/code&gt;、二つ目の円の半径を&lt;code&gt;r2&lt;/code&gt;、二つの円の中心間の距離を&lt;code&gt;d&lt;/code&gt;としたとき、&lt;code&gt;abs(r1-r2)&amp;lt;=d&amp;lt;=r1+r2&lt;/code&gt;が満たされれるかどうかで判断することができます。
&lt;code&gt;Disjoint Set Union&lt;/code&gt;などのデータ構造や深さ優先探索、幅優先探索などで、&lt;code&gt;(sx,sy)&lt;/code&gt;が含まれる円と&lt;code&gt;(tx,ty)&lt;/code&gt;が含まれる円が連結であるかの判定を行うことで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var (sx, sy, tx, ty) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();
    var s = new Point(sx, sy);
    var t = new Point(tx, ty);

    var P = new (Point P, long R)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, r) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        P[i] = (new Point(x, y), r);
    }

    long SqD(Point p1, Point p2)
    {
        var dx = p1.X - p2.X;
        var dy = p1.Y - p2.Y;
        return dx * dx + dy * dy;
    }

    var okS = new bool[N];
    var okT = new bool[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        okS[i] = SqD(s, P[i].P) == P[i].R * P[i].R;
        okT[i] = SqD(t, P[i].P) == P[i].R * P[i].R;
    }

    var dsu = new DisjointSetUnion(N);

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var sqd = SqD(P[i].P, P[j].P);
            var rr1 = P[i].R + P[j].R;
            var rr2 = P[i].R - P[j].R;
            if (rr2 * rr2 &amp;lt;= sqd &amp;amp;&amp;amp; sqd &amp;lt;= rr1 * rr1)
            {
                dsu.Merge(i, j);
            }
        }
    }

    var answer = false;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {

            answer |= okS[i] &amp;amp;&amp;amp; okT[j] &amp;amp;&amp;amp; dsu.IsSame(i, j);
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}

public readonly struct Point
{
    public readonly long X;
    public readonly long Y;
    public Point(long x, long y) =&amp;gt; (X, Y) = (x, y);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 259の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220702abc258</id>
		<title>ABC258</title>
		<link href="https://blog.aconcavy.dev/posts/20220702abc258" />
		<updated>2022-07-02T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 258の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258"&gt;https://atcoder.jp/contests/abc258&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32886264"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1時間は60分なので、Kを60で割った商が経過時、Kを60で割った余りが経過分となるので、&lt;code&gt;21+K/60&lt;/code&gt;時&lt;code&gt;K%60&lt;/code&gt;分が答えとなります。&lt;br /&gt;
C#では文字列補間で&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/standard/base-types/custom-numeric-format-strings"&gt;カスタム数値形式文字列&lt;/a&gt;を使うことで、数値を&lt;code&gt;0&lt;/code&gt;埋めで表示することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var x = K / 60;
    var y = K % 60;
    Console.WriteLine($&amp;quot;{21 + x}:{y:00}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32895144"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全てのマスから縦横斜めの8方向にずらした数値を全探索します。&lt;br /&gt;
8方向全てを書くのは大変なので、行と列のそれぞれの移動差分を用意することで、差分に移動量を掛けて範囲内に収まるように&lt;code&gt;N&lt;/code&gt;で割った余りを取ることで、簡単に記述することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.ScanLine().Select(x =&amp;gt; x - '0').ToArray();
    }

    var D8 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1) };

    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            foreach (var (di, dj) in D8)
            {
                long v = 0;
                for (var k = 0; k &amp;lt; N; k++)
                {
                    var ii = (i + di * k + N) % N;
                    var jj = (j + dj * k + N) % N;
                    v = v * 10 + A[ii][jj];
                }

                answer = Math.Max(answer, v);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32897344"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに文字列を操作してしまうと、クエリごとの計算量が&lt;code&gt;O(N)&lt;/code&gt;、全体の計算量が&lt;code&gt;O(QN)&lt;/code&gt;になってしまい、実行時間制限に間に合わないため、計算量を改善する必要があります。&lt;/p&gt;
&lt;p&gt;クエリ1に注目すると、&lt;code&gt;N&lt;/code&gt;文字目の次を&lt;code&gt;1&lt;/code&gt;文字目としたとき、文字列を&lt;code&gt;x&lt;/code&gt;回右にシフトしてることがわかります。&lt;br /&gt;
そして、文字列を右にシフトすると、先頭の位置は&lt;code&gt;-x&lt;/code&gt;分移動し、移動先が負の場合は&lt;code&gt;N&lt;/code&gt;を足した位置が先頭になります。&lt;br /&gt;
このように、文字列の先頭の位置がどこであるかのみを管理することで、クエリごとの計算量を&lt;code&gt;O(1)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var idx = 0;
    while (Q-- &amp;gt; 0)
    {
        var (t, x) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (t == 1)
        {
            idx = (idx - x + N) % N;
        }
        else
        {
            var i = (idx + x - 1) % N;
            Console.WriteLine(S[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32901859"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i番目のステージまでに必要な最小の時間 + 初回攻略時間 + (i番目のステージで必要な時間 * 残り回数全てを)&lt;/code&gt;が&lt;code&gt;i&lt;/code&gt;番目のステージおける時間の最小値となるとなるので、全てのステージにおける時間の最小値の最小値が答えとなります。
ステージごとに毎度&lt;code&gt;i&lt;/code&gt;番目のステージまでに必要な最小の時間を計算してしまうと時間計算量が&lt;code&gt;O(N)&lt;/code&gt;かかってしまうので、累積和を用いることで&lt;code&gt;O(1)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var AB = new (long A, long B)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        AB[i] = Scanner.Scan&amp;lt;long, long&amp;gt;();
    }

    var minStarts = new long[N];
    for (var i = 1; i &amp;lt; N; i++)
    {
        minStarts[i] = minStarts[i - 1] + AB[i - 1].A + AB[i - 1].B;
    }

    const long inf = (long)4e18;
    var answer = inf;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var x = Math.Max(0, X - (i + 1));
        var time = sum + AB[i].A + AB[i].B + x * AB[i].B;
        answer = Math.Min(answer, time);
        sum += AB[i].A + AB[i].B;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32937679"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目のじゃがいもを開始位置としたとき、1つの箱に必要なじゃがいもの個数を&lt;code&gt;C[i]&lt;/code&gt;とすると、次の箱に使うじゃがいもの開始位置は&lt;code&gt;(i+C[i])%N&lt;/code&gt;となり、開始位置の集合は最大でも&lt;code&gt;N&lt;/code&gt;の有向グラフとして表すことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;# 入力例1
# 3 2 5
# 3 4 1
# 1
# 2

0番目のじゃがいもから箱を作る: {0, 1}    =&amp;gt; 2個 =&amp;gt; 次は (0+2)%3 = 2番目のじゃがいも
2番目のじゃがいもから箱を作る: {2, 0, 1} =&amp;gt; 3個 =&amp;gt; 次は (2+3)%3 = 2番目のじゃがいも
2番目のじゃがいもから箱を作る: {2, 0, 1} =&amp;gt; 3個 =&amp;gt; 次は (2+3)%3 = 2番目のじゃがいも
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このことから、有効グラフのK番目の頂点に値する開始位置における必要なじゃがいもの個数が答えとなります。
時間計算量について、&lt;code&gt;C[i]&lt;/code&gt;は累積和と尺取り法を使うことで&lt;code&gt;O(N)&lt;/code&gt;、有効グラフも&lt;code&gt;O(N)&lt;/code&gt;で事前に計算でき、クエリに対して&lt;code&gt;O(1)&lt;/code&gt;で答えを求めることができるので、全体の時間計算量は&lt;code&gt;O(N+Q)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q, X) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var W = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var sum = W.Sum();

    var cumW = new long[N * 2 + 1];
    for (var i = 0; i &amp;lt; N * 2; i++)
    {
        cumW[i + 1] = cumW[i] + W[i % N];
    }

    var counts = new long[N];
    {
        var r = 0;
        var x = X % sum;
        for (var l = 0; l &amp;lt; N; l++)
        {
            counts[l] = X / sum * N;
            while (cumW[r] - cumW[l] &amp;lt; x) r++;
            counts[l] += r - l;
        }
    }

    var next = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        next[i] = (int)((i + counts[i]) % N);
    }

    var steps = new List&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, int&amp;gt;();
    var noLoopLength = 0;
    var loopLength = 0;
    {
        var curr = 0;
        for (var i = 0;; i++)
        {
            if (dict.ContainsKey(curr))
            {
                noLoopLength = dict[curr];
                loopLength = i - dict[curr];
                break;
            }

            dict[curr] = i;
            steps.Add(curr);
            curr = next[curr];
        }
    }

    while (Q-- &amp;gt; 0)
    {
        var K = Scanner.Scan&amp;lt;long&amp;gt;() - 1;
        if (K &amp;lt;= noLoopLength)
        {
            var box = steps[(int)K];
            Console.WriteLine(counts[box]);
        }
        else
        {
            var mod = (K - noLoopLength) % loopLength;
            var box = steps[(int)(noLoopLength + mod)];
            Console.WriteLine(counts[box]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 258の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220625abc257</id>
		<title>ABC257</title>
		<link href="https://blog.aconcavy.dev/posts/20220625abc257" />
		<updated>2022-06-25T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 257の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc257"&gt;https://atcoder.jp/contests/abc257&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc257/tasks/abc257_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc257/submissions/32714875"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長さ&lt;code&gt;N*26&lt;/code&gt;の文字列の&lt;code&gt;X&lt;/code&gt;番目の文字は何かと言い換えられるので、&lt;code&gt;X&lt;/code&gt;を&lt;code&gt;0-indexed&lt;/code&gt;に変換した&lt;code&gt;X-1&lt;/code&gt;番目を&lt;code&gt;N&lt;/code&gt;で割った番目のアルファベットが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = (char)((X - 1) / N + 'A');
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc257/tasks/abc257_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc257/submissions/32714940"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の位置と番号のペアとして位置を昇順にソートしたものを&lt;code&gt;B&lt;/code&gt;、駒のあるマスを&lt;code&gt;X&lt;/code&gt;、各クエリを&lt;code&gt;l&lt;/code&gt;番目の駒に対する操作としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;l+1&amp;lt;K&lt;/code&gt;のとき、&lt;code&gt;B[l]のX&lt;/code&gt;と&lt;code&gt;B[l+1]のX&lt;/code&gt;が隣り合っていなければ&lt;code&gt;B[l]のX&lt;/code&gt;を&lt;code&gt;+1&lt;/code&gt;する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l==K&lt;/code&gt;のとき、&lt;code&gt;B[l]のX&lt;/code&gt;が&lt;code&gt;N&lt;/code&gt;未満であれば&lt;code&gt;B[l]のX&lt;/code&gt;を&lt;code&gt;+1&lt;/code&gt;する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;のように操作し、すべての操作が終わったときの&lt;code&gt;X&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K, Q) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var L = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = A.Select((x, i) =&amp;gt; (x, i)).ToArray();
    Array.Sort(B, (x, y) =&amp;gt; x.x.CompareTo(y.x));
    foreach (var l in L.Select(x =&amp;gt; x - 1))
    {
        if (l + 1 &amp;lt; K)
        {
            if (B[l].x + 1 != B[l + 1].x) B[l].x++;
        }
        else
        {
            if (B[l].x &amp;lt; N) B[l].x++;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B.Select(x =&amp;gt; x.x)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc257/tasks/abc257_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc257/submissions/32722188"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X=0&lt;/code&gt;のとき&lt;code&gt;f(X)=大人の数&lt;/code&gt;であり、&lt;code&gt;X=infinity&lt;/code&gt;のとき&lt;code&gt;f(X)=子供の数&lt;/code&gt;であることから、答えは最小でも&lt;code&gt;Max(f(0), f(1e9+1))&lt;/code&gt;であることがわかります。
そして、子供と大人の座標を別々に管理しそれぞれを昇順でソートしておくことで、体重&lt;code&gt;X&lt;/code&gt;未満の子供の数と体重&lt;code&gt;X&lt;/code&gt;以上の大人の数を二部探索で調べることができるようになるので、境界としてありえる&lt;code&gt;N&lt;/code&gt;人全ての&lt;code&gt;W&lt;/code&gt;について調べることで答えを求めることができます。
計算量は子供と大人の分類に&lt;code&gt;O(N)&lt;/code&gt;、ソートに&lt;code&gt;(NlogN)&lt;/code&gt;、各クエリごとに&lt;code&gt;O(logN)&lt;/code&gt;なので、全体で&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var W = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToList();

    var child = new List&amp;lt;int&amp;gt;();
    var adult = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        (S[i] == '0' ? child : adult).Add(W[i]);
    }

    child.Sort();
    adult.Sort();

    var answer = Math.Max(child.Count, adult.Count);
    foreach (var w in W)
    {
        var c1 = LowerBound(child, w);
        var c2 = adult.Count - LowerBound(adult, w);
        answer = Math.Max(answer, c1 + c2);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc257/tasks/abc257_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc257/submissions/32737230"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各始点について、全てのジャンプ台に移動可能な最小の&lt;code&gt;S&lt;/code&gt;について二部探索をおこない、その最小を求めます。
二部探索の判定式として、始点から幅優先探索を行うことで&lt;code&gt;O(N^2)&lt;/code&gt;で全てのジャンプ台に移動可能かを判定することができます。
全体計算量&lt;code&gt;O(N^3logN)&lt;/code&gt;で答えを求めることができます。
あるジャンプ台から別のジャンプ台へ移動可能か判定する際に、&lt;code&gt;P*S&amp;gt;=|x0-x1|+|y0-x1|&lt;/code&gt;の右辺は最大で&lt;code&gt;4e9&lt;/code&gt;であることに注意しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Jumps = new Jump[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, p) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        Jumps[i] = new Jump(x, y, p);
    }

    bool CanMove(Jump from, Jump to, long s)
    {
        var d = Math.Abs(from.X - to.X) + Math.Abs(from.Y - to.Y);
        return s &amp;gt;= d || from.P * s &amp;gt;= d;
    }

    const long inf = (long)4e9;
    var answer = inf;
    for (var k = 0; k &amp;lt; N; k++)
    {
        bool F(long s)
        {
            var queue = new Queue&amp;lt;Jump&amp;gt;();
            var used = new bool[N];

            used[k] = true;
            queue.Enqueue(Jumps[k]);

            while (queue.Count &amp;gt; 0)
            {
                var u = queue.Dequeue();
                for (var i = 0; i &amp;lt; N; i++)
                {
                    if (!used[i] &amp;amp;&amp;amp; CanMove(u, Jumps[i], s))
                    {
                        used[i] = true;
                        queue.Enqueue(Jumps[i]);
                    }
                }
            }

            return used.All(x =&amp;gt; x);
        }

        var s = BinarySearch(-1, inf, F);
        answer = Math.Min(answer, s);
    }

    Console.WriteLine(answer);
}

public readonly struct Jump
{
    public readonly long X;
    public readonly long Y;
    public readonly long P;
    public Jump(long x, long y, long p) =&amp;gt; (X, Y, P) = (x, y, p);
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc257/tasks/abc257_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc257/submissions/32752336"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;の最小を&lt;code&gt;min&lt;/code&gt;としたとき、桁数は最大でも&lt;code&gt;N/min&lt;/code&gt;になります。
その桁数が構成できるもののうち、ある桁の値&lt;code&gt;d&lt;/code&gt;は、&lt;code&gt;C[d]&lt;/code&gt;とその桁より右側を&lt;code&gt;min&lt;/code&gt;にしたときの和であり、その和がその時点で採用することができれば、その桁を&lt;code&gt;d&lt;/code&gt;とすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var min = C.Min();
    var length = N / min;
    var builder = new StringBuilder();
    for (var i = 0; i &amp;lt; length; i++)
    {
        for (var d = 9; d &amp;gt;= 1; j--)
        {
            if (min * (length - 1 - i) + C[d - 1] &amp;lt;= N)
            {
                N -= C[d - 1];
                builder.Append((char)(d + '0'));
                break;
            }
        }
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 257の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220618abc256</id>
		<title>ABC256</title>
		<link href="https://blog.aconcavy.dev/posts/20220618abc256" />
		<updated>2022-06-18T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 256の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc256"&gt;https://atcoder.jp/contests/abc256&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32536346"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Math.Pow(2, N)&lt;/code&gt;や&lt;code&gt;1&lt;/code&gt;をNビットシフトした値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = 1L &amp;lt;&amp;lt; N;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32541675"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各ターンの初めに位置&lt;code&gt;0&lt;/code&gt;に1を足し、位置&lt;code&gt;3,2,1,0&lt;/code&gt;の順で&lt;code&gt;Min(現在の位置+a,4)&lt;/code&gt;に移動させるシミュレーションを行います。
位置の操作を&lt;code&gt;0,1,2,3&lt;/code&gt;ではなく逆順で処理することで、移動した後の現在の位置を&lt;code&gt;0&lt;/code&gt;にすることができるので、何個移動させたかを記録せずに操作できるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var g = new int[5];
    foreach (var a in A)
    {
        g[0]++;
        for (var i = 3; i &amp;gt;= 0; i--)
        {
            g[Math.Min(i + a, 4)] += g[i];
            g[i] = 0;
        }
    }

    var answer = g[4];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32554919"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全てのマスを全探索してしまうと&lt;code&gt;30^9&lt;/code&gt;通りとなり、実行時間制限に間に合いません。
しかし、左上の&lt;code&gt;2x2&lt;/code&gt;マスさえわかれば、3行目と3列目の数字が固定されるので、&lt;code&gt;30^4&lt;/code&gt;の全探索で済むようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H1, H2, H3, W1, W2, W3) = Scanner.Scan&amp;lt;int, int, int, int, int, int&amp;gt;();
    var answer = 0;
    for (var h1w1 = 1; h1w1 &amp;lt; Math.Min(H1, W1); h1w1++)
    {
        for (var h2w1 = 1; h1w1 + h2w1 &amp;lt; W1; h2w1++)
        {
            for (var h1w2 = 1; h1w1 + h1w2 &amp;lt; H1; h1w2++)
            {
                for (var h2w2 = 1; h1w2 + h2w2 &amp;lt; W2 &amp;amp;&amp;amp; h2w1 + h2w2 &amp;lt; H2; h2w2++)
                {
                    var h3w1 = W1 - h1w1 - h2w1;
                    var h3w2 = W2 - h1w2 - h2w2;
                    var h1w3 = H1 - h1w1 - h1w2;
                    var h2w3 = H2 - h2w1 - h2w2;
                    if (H3 - h3w1 - h3w2 == W3 - h1w3 - h2w3 &amp;amp;&amp;amp; W3 - h1w3 - h2w3 &amp;gt; 0)
                    {
                        answer++;
                    }
                }
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32558635"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;区間の左側を昇順で並べたときに、ある区間の左側よりもその直前区間の右側が大きい場合、その二つの区間をマージすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var range = new (int L, int R)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        range[i] = Scanner.Scan&amp;lt;int, int&amp;gt;();
    }

    Array.Sort(range, (x, y) =&amp;gt; x.L.CompareTo(y.L));
    var answer = new List&amp;lt;(int L, int R)&amp;gt;();
    answer.Add(range[0]);

    foreach (var (l, r) in range.Skip(1))
    {
        if (answer[^1].R &amp;gt;= l)
        {
            answer[^1] = (Math.Min(answer[^1].L, l), Math.Max(answer[^1].R, r));
        }
        else
        {
            answer.Add((l, r));
        }
    }

    answer.Sort((x, y) =&amp;gt; x.L.CompareTo(y.L));
    foreach (var (l, r) in answer)
    {
        Console.WriteLine($&amp;quot;{l} {r}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc256/tasks/abc256_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC256/submissions/32565127"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嫌いな人との関係を有効辺として考えることで、グラフとして考えることができるようになります。&lt;br /&gt;
N頂点N辺のグラフであることから、連結成分ごとにサイクルは多くても1個であることがわかります。&lt;br /&gt;
そこで、グラフを強連結成分ごとに分解し、サイクル内の最小の不満を受け入れることで、サイクルごとの不満度を最小にすることができます。&lt;br /&gt;
そして、サイクルごとの不満度の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var C = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var scc = new StronglyConnectedComponent(N);
    for (var i = 0; i &amp;lt; N; i++)
    {
        scc.AddEdge(i, X[i]);
    }

    const long inf = (long)1e18;
    var answer = 0L;
    foreach (var graph in scc.GetGraph())
    {
        if (graph.Count == 1) continue;
        var min = inf;
        foreach (var u in graph)
        {
            min = Math.Min(min, C[u]);
        }

        answer += min;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;強連結成分は&lt;code&gt;ACL&lt;/code&gt;の&lt;code&gt;scc&lt;/code&gt;等で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class StronglyConnectedComponent
{
    public int Length { get; }
    private readonly List&amp;lt;(int, Edge)&amp;gt; _edges;

    public StronglyConnectedComponent(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _edges = new List&amp;lt;(int, Edge)&amp;gt;();
    }

    public void AddEdge(int from, int to)
    {
        if (from &amp;lt; 0 || Length &amp;lt;= from) throw new ArgumentOutOfRangeException(nameof(from));
        if (to &amp;lt; 0 || Length &amp;lt;= to) throw new ArgumentOutOfRangeException(nameof(to));
        _edges.Add((from, new Edge(to)));
    }

    public (int GroupCount, int[] IDs) GetIDs()
    {
        var g = new CompressedSparseRow&amp;lt;Edge&amp;gt;(Length, _edges);
        var (nowOrd, groupCount) = (0, 0);
        var visited = new Stack&amp;lt;int&amp;gt;(Length);
        var low = new int[Length];
        var ord = new int[Length];
        Array.Fill(ord, -1);
        var ids = new int[Length];

        void Dfs(int v)
        {
            low[v] = ord[v] = nowOrd++;
            visited.Push(v);
            for (var i = g.Start[v]; i &amp;lt; g.Start[v + 1]; i++)
            {
                var to = g.Edges[i].To;
                if (ord[to] == -1)
                {
                    Dfs(to);
                    low[v] = Math.Min(low[v], low[to]);
                }
                else
                {
                    low[v] = Math.Min(low[v], ord[to]);
                }
            }

            if (low[v] != ord[v]) return;
            while (true)
            {
                var u = visited.Pop();
                ord[u] = Length;
                ids[u] = groupCount;
                if (u == v) break;
            }

            groupCount++;
        }

        for (var i = 0; i &amp;lt; Length; i++)
        {
            if (ord[i] == -1)
                Dfs(i);
        }

        for (var i = 0; i &amp;lt; Length; i++)
        {
            ids[i] = groupCount - 1 - ids[i];
        }

        return (groupCount, ids);
    }

    public IReadOnlyList&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; GetGraph()
    {
        var (groupCount, ids) = GetIDs();
        var groups = new List&amp;lt;int&amp;gt;[groupCount];
        for (var i = 0; i &amp;lt; groups.Length; i++)
        {
            groups[i] = new List&amp;lt;int&amp;gt;();
        }

        foreach (var (id, index) in ids.Select((x, i) =&amp;gt; (x, i)))
        {
            groups[id].Add(index);
        }

        return groups;
    }

    private readonly struct Edge
    {
        public readonly int To;
        public Edge(int to) =&amp;gt; To = to;
    }
}

public class CompressedSparseRow&amp;lt;T&amp;gt;
{
    public CompressedSparseRow(int length, IEnumerable&amp;lt;(int ID, T)&amp;gt; edges)
    {
        Start = new int[length + 1];
        var es = edges.ToArray();
        Edges = new T[es.Length];
        foreach (var e in es) Start[e.ID + 1]++;
        for (var i = 0; i &amp;lt; length; i++) Start[i + 1] += Start[i];
        var counter = new int[length + 1];
        Start.AsSpan().CopyTo(counter.AsSpan());
        foreach (var (i, t) in es) Edges[counter[i]++] = t;
    }

    public int[] Start { get; }
    public T[] Edges { get; }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 256の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220611abc255</id>
		<title>ABC255</title>
		<link href="https://blog.aconcavy.dev/posts/20220611abc255" />
		<updated>2022-06-11T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 255の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc255"&gt;https://atcoder.jp/contests/abc255&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32372739"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;R&lt;/code&gt;と&lt;code&gt;C&lt;/code&gt;の値ごとに場合分けして答えることもできますが(4通り)、&lt;code&gt;2*2&lt;/code&gt;の行列&lt;code&gt;M&lt;/code&gt;として値を保持して&lt;code&gt;M[R][C]&lt;/code&gt;の値を答えることもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (R, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    R--; C--;
    var M = new int[2][];
    for (var i = 0; i &amp;lt; 2; i++)
    {
        M[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var answer = M[R][C];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32381972"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある人を照らすために必要な&lt;code&gt;R&lt;/code&gt;は、何れかの明かりを持つことができる人の位置からの最小距離であり、その&lt;code&gt;R&lt;/code&gt;の最大値を求めることで全ての人をカバーすることができます。&lt;br /&gt;
距離&lt;code&gt;D&lt;/code&gt;は二点の&lt;code&gt;X&lt;/code&gt;の差分&lt;code&gt;dx&lt;/code&gt;と&lt;code&gt;Y&lt;/code&gt;の差分を&lt;code&gt;dy&lt;/code&gt;としたとき、&lt;code&gt;D = Sqrt(dx^2 + dy^2)&lt;/code&gt;で求めることができますが、&lt;code&gt;D &amp;lt; D'&lt;/code&gt;ならば、&lt;code&gt;D^2 &amp;lt; D'^2&lt;/code&gt;なので、距離の二乗の値で走査することで、最後に答えを求めるときを除いて実数による誤差を無視することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var P = new (long X, long Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = (x, y);
    }

    var answer = 0L;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var min = inf;
        for (var i = 0; i &amp;lt; N; i++)
        {
            var dx = P[a].X - P[i].X;
            var dy = P[a].Y - P[i].Y;
            var d = dx * dx + dy * dy;
            min = Math.Min(min, d);
        }

        answer = Math.Max(answer, min);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答え&lt;code&gt;R&lt;/code&gt;の二部探索でも答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var P = new (long X, long Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = (x, y);
    }

    bool F(long x)
    {
        var ok = new bool[N];
        foreach (var a in A)
        {
            for (var i = 0; i &amp;lt; N; i++)
            {
                var dx = P[a].X - P[i].X;
                var dy = P[a].Y - P[i].Y;
                var d = dx * dx + dy * dy;
                ok[i] |= d &amp;lt;= x;
            }
        }

        return ok.All(x =&amp;gt; x);
    }

    const long inf = (long)1e18;
    var answer = Math.Sqrt(BinarySearch(-1, inf, F));
    Console.WriteLine(answer);
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32396621"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32418071"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D=0&lt;/code&gt;のときは明らかに、&lt;code&gt;Abs(X-A)&lt;/code&gt;となります。
以下それ以外のときに&lt;code&gt;d=(X-A)/D&lt;/code&gt;とし、&lt;code&gt;x&lt;/code&gt;を初項を除く項数の数として&lt;code&gt;F(x)=Abs(X-(A+D*x))&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&amp;lt;=d&amp;lt;=N-2&lt;/code&gt;のとき、&lt;code&gt;初項+d項目&lt;/code&gt;と&lt;code&gt;初項+(d+1)項目&lt;/code&gt;の間に&lt;code&gt;X&lt;/code&gt;が存在するため、&lt;code&gt;F(d)&lt;/code&gt;と&lt;code&gt;F(d+1)&lt;/code&gt;の回数が小さいほうが答えとなります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d=N-1&lt;/code&gt;のとき、&lt;code&gt;N&lt;/code&gt;項より大きな項にすることができないため、&lt;code&gt;F(N-1)&lt;/code&gt;となります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&amp;lt;0&lt;/code&gt;のとき、&lt;code&gt;1&lt;/code&gt;項より小さな項にすることができないため、&lt;code&gt;F(0)&lt;/code&gt;となります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このことから、&lt;code&gt;d&lt;/code&gt;を&lt;code&gt;0&amp;lt;=d&amp;lt;=N-1&lt;/code&gt;に制限したときの&lt;code&gt;F(d)&lt;/code&gt;と&lt;code&gt;d+1&amp;lt;=N-1&lt;/code&gt;ならば&lt;code&gt;F(d+1)&lt;/code&gt;の回数が小さいほうが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, A, D, N) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();

    long F(long n)
    {
        return Math.Abs(X - (A + n * D));
    }

    if (D == 0)
    {
        Console.WriteLine(F(0));
        return;
    }

    var n = Math.Max(0, Math.Min(N - 1, (X - A) / D));
    var answer = F(n);
    if (n + 1 &amp;lt;= N - 1) answer = Math.Min(answer, F(n + 1));
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32399982"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32418084"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに&lt;code&gt;A&lt;/code&gt;の値を走査してしまうと、&lt;code&gt;O(QN)&lt;/code&gt;かかってしまい、実行時間制限に間に合いません。
そこで、&lt;code&gt;A&lt;/code&gt;の値をソートし、&lt;code&gt;A&lt;/code&gt;において&lt;code&gt;X&lt;/code&gt;以上が現れる位置&lt;code&gt;i (0-indexed)&lt;/code&gt;において左右に二つに分けた場合、左側の操作に必要な回数は&lt;code&gt;X*左側の個数 - A[0..i)の合計&lt;/code&gt;となり、右側の操作に必要な回数は&lt;code&gt;A[i..N)の合計 - X*右側の個数&lt;/code&gt;となることがわかります。&lt;br /&gt;
そのため、あらかじめ&lt;code&gt;A&lt;/code&gt;の累積和を求めておき、クエリごとに&lt;code&gt;A&lt;/code&gt;において&lt;code&gt;X&lt;/code&gt;以上が現れる位置を二部探索で求めることで、位置を求めることに&lt;code&gt;O(logN)&lt;/code&gt;、左側の合計と右側の合計を求めることに&lt;code&gt;O(1)&lt;/code&gt;で対応することができ、全体で&lt;code&gt;O(QlogN)&lt;/code&gt;で求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    while (Q-- &amp;gt; 0)
    {
        var X = Scanner.Scan&amp;lt;long&amp;gt;();
        var l = LowerBound(A, X);
        var r = N - l;
        var answer = Math.Abs(cum[l] - X * l) + Math.Abs((cum[N] - cum[l]) - X * r);
        Console.WriteLine(answer);
    }
}

public static int LowerBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m].CompareTo(key) &amp;gt;= 0) r = m;
        else l = m;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc255/tasks/abc255_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC255/submissions/32416252"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var X = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var B = new long[N];
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        B[i + 1] = S[i] - B[i];
    }

    var dict = new Dictionary&amp;lt;long, long&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; M; j++)
        {
            var c = X[j] - B[i];
            if (i % 2 == 1) c *= -1;
            if (!dict.ContainsKey(c)) dict[c] = 0;
            dict[c]++;
        }
    }

    var answer = dict.Values.Max();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 255の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220604abc254</id>
		<title>ABC254</title>
		<link href="https://blog.aconcavy.dev/posts/20220604abc254" />
		<updated>2022-06-04T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 254の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc254"&gt;https://atcoder.jp/contests/abc254&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32198774"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列として入力を取り、文字列の後ろ2文字を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = N[^2..];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32202968"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文に沿って実装をします。
これはパスカルの三角形、二項係数を表します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var nCk = new long[N, N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            if (j == 0 || j == i) nCk[i, j] = 1;
            else nCk[i, j] = nCk[i - 1, j - 1] + nCk[i - 1, j];
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            Console.Write(nCk[i, j]);
            Console.Write(j == i ? '\n' : ' ');
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32210520"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;が入れ替え可能な位置として、&lt;code&gt;A[i+K]&lt;/code&gt;や&lt;code&gt;A[i+k*2]&lt;/code&gt;のように&lt;code&gt;i+Kの倍数&lt;/code&gt;の何れかの値と入れ替えることができることがわかります。
そのため、&lt;code&gt;i%K番目&lt;/code&gt;のグループごとに値をソートし、数列&lt;code&gt;B&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目に&lt;code&gt;i%K番目&lt;/code&gt;のグループの&lt;code&gt;i/K&lt;/code&gt;番目の値を復元してできたものが、&lt;code&gt;A&lt;/code&gt;をソートしたものと一致かを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;A = [3, 4, 1, 3, 4]
G[0] = [3, 1, 4] -&amp;gt; [1, 3, 4]
G[1] = [4, 3] -&amp;gt; [3, 4]
B = [1, 3, 3, 4, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var G = new int[K][].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i % K].Add(A[i]);
    }

    for (var i = 0; i &amp;lt; K; i++)
    {
        G[i].Sort();
    }

    var B = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        B.Add(G[i % K][i / K]);
    }

    var C = A.OrderBy(x =&amp;gt; x).ToArray();
    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer &amp;amp;= B[i] == C[i];
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32245869"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var sq = new bool[N + 1];
    for (var i = 1; i * i &amp;lt;= N; i++)
    {
        sq[i * i] = true;
    }

    var count = new long[N + 1];
    for (var i = 1; i &amp;lt;= N; i++)
    {
        long j = 0;
        foreach (var d in GetDivisors(i))
        {
            if (sq[d]) j = Math.Max(j, d);
        }

        count[i / j]++;
    }

    var answer = 0L;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer += count[i] * count[i];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc254/tasks/abc254_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC254/submissions/32243464"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリに対して、全ての頂点をメモしてDFSやBFSをしてしまうと、時間計算量が&lt;code&gt;O(QM)&lt;/code&gt;となってしまい、実行時間制限に間に合いません。
しかし、制約にグラフの各頂点の時数は&lt;code&gt;3&lt;/code&gt;以下であり、&lt;code&gt;0&amp;lt;=k&amp;lt;=3&lt;/code&gt;とあることから、クエリあたり最大でも距離が&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;3&lt;/code&gt;の頂点の和&lt;code&gt;1+3^1+3^2+3^3=1+3+9+27=40&lt;/code&gt;しかないことがわかります。
そのため、訪れた頂点のみを&lt;code&gt;HashSet&lt;/code&gt;などで管理することで、実行時間制限に間に合わせることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        G[a].Add(b);
        G[b].Add(a);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (x, k) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--;
        var set = new HashSet&amp;lt;long&amp;gt;();
        var queue = new Queue&amp;lt;(int, int)&amp;gt;();
        set.Add(x);
        queue.Enqueue((x, 0));
        while (queue.Count &amp;gt; 0)
        {
            var (u, d) = queue.Dequeue();
            if (d == k) continue;
            foreach (var v in G[u])
            {
                if (set.Contains(v)) continue;
                set.Add(v);
                queue.Enqueue((v, d + 1));
            }
        }

        var answer = set.Sum() + set.Count;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 254の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220528abc253</id>
		<title>ABC253</title>
		<link href="https://blog.aconcavy.dev/posts/20220528abc253" />
		<updated>2022-05-28T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 253の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253"&gt;https://atcoder.jp/contests/abc253&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/31997507"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要素が3つしかないため、3つの値の合計から最大値と最小値を引いた値が中央値として求めることができるので、中央値が&lt;code&gt;B&lt;/code&gt;と一致しているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var mid = A.Sum() - A.Min() - A.Max();
    var answer = A[1] == mid ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32003197"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(h1,w1)&lt;/code&gt;から&lt;code&gt;(h2,w2)&lt;/code&gt;への移動回数は縦横の差分の合計&lt;code&gt;Abs(h2-h1) + Abs(w2-w1)&lt;/code&gt;で求めることができます。&lt;br /&gt;
2つの&lt;code&gt;o&lt;/code&gt;の位置を取得は、1つ目ならば&lt;code&gt;(h1,w1)&lt;/code&gt;を更新し、2つ目ならば&lt;code&gt;(h2,w2)&lt;/code&gt;を更新するようにフラグなどで管理することで判定できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new string[H];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    var (h1, w1) = (0, 0);
    var (h2, w2) = (0, 0);
    var ok = false;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == '-') continue;
            if (!ok)
            {
                (h1, w1) = (i, j);
                ok = true;
            }
            else
            {
                (h2, w2) = (i, j);
            }
        }
    }

    var answer = Math.Abs(h2 - h1) + Math.Abs(w2 - w1);
    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32010454"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;リストを使って集合の管理をしてしまうと、クエリごとの最悪時間計算量が&lt;code&gt;O(NlogN)&lt;/code&gt;になってしまい、全体で&lt;code&gt;O(QNlogN)&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、ソートされている集合(C#では&lt;code&gt;SortedSet&lt;/code&gt;)等を実際に集合に存在する値に対して使うことで、要素の追加を&lt;code&gt;O(logN)&lt;/code&gt;、最大値の最小値の取得を&lt;code&gt;O(1)&lt;/code&gt;で行うことができ、全体で&lt;code&gt;O(QlogN)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var set = new SortedSet&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var x = query[1];
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x]++;
            set.Add(x);
        }
        else if (query[0] == 2)
        {
            var (x, c) = (query[1], query[2]);
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x] -= Math.Min(dict[x], c);
            if (dict[x] == 0)
            {
                set.Remove(x);
            }
        }
        else
        {
            var answer = set.Max - set.Min;
            Console.WriteLine(answer);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32035460"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc253/submissions/32057974"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;以下の値を全て捜査してしまうと、時間計算量が&lt;code&gt;O(N)&lt;/code&gt;になってしまい、&lt;code&gt;N=1e9&lt;/code&gt;の場合に間に合いません。
そこで、&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;までの総和から、&lt;code&gt;A&lt;/code&gt;の倍数の総和と&lt;code&gt;B&lt;/code&gt;の倍数の総和を引き、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の最小公倍数の総和を足すことで&lt;code&gt;O(logMin(a,b))&lt;/code&gt;で求めることができます。&lt;br /&gt;
&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;x&lt;/code&gt;までの総和は、&lt;code&gt;F(x) = x * (x+1) / 2&lt;/code&gt;で求められるので、1から&lt;code&gt;N&lt;/code&gt;までの総和は&lt;code&gt;F(N)&lt;/code&gt;で求めることができます。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;以下の&lt;code&gt;X&lt;/code&gt;の倍数の総和は、&lt;code&gt;N&lt;/code&gt;以下に&lt;code&gt;X&lt;/code&gt;の倍数は&lt;code&gt;N/X&lt;/code&gt;個あるため、&lt;code&gt;M=N/X&lt;/code&gt;としたとき、&lt;code&gt;X*F(M)&lt;/code&gt;で求めることができます。
よって、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;の最小公倍数を&lt;code&gt;LCM(x,y)&lt;/code&gt;としたとき、&lt;code&gt;F(N) - F(N/A)*A - F(N/B)*B + F(N/LCM(A,B))*LCM(A,B)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();

    long F(long x) =&amp;gt; x * (x + 1) / 2;
    long G(long n, long a, long b)
    {
        var result = F(n);
        result -= a * F(n / a);
        result -= b * F(n / b);
        var lcm = Lcm(a, b);
        result += lcm * F(n / lcm);
        return result;
    }

    var answer = G(N, A, B);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc253/tasks/abc253_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc253/submissions/32057606"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;累積和を求めながら動的計画法をすることで求めることができます。
初期状態として、&lt;code&gt;[1,M]&lt;/code&gt;は各&lt;code&gt;1&lt;/code&gt;になり、&lt;code&gt;i+1&lt;/code&gt;項目への遷移は&lt;code&gt;dp[i][0..j-k] + dp[i][j+k..M]&lt;/code&gt;の総和となります。
区間和&lt;code&gt;dp[i][0..j-k] + dp[i][j+k..M]&lt;/code&gt;を各&lt;code&gt;j&lt;/code&gt;に対して求めてしまうと、時間計算量が&lt;code&gt;O(M)&lt;/code&gt;かかってしまうので、あらかじめ累積和を取っておくことで、&lt;code&gt;j&lt;/code&gt;ごとに&lt;code&gt;O(1)&lt;/code&gt;で区間和を求めることができます。
&lt;code&gt;K=0&lt;/code&gt;のときには注意が必要で、&lt;code&gt;dp[i][1..M]&lt;/code&gt;の総和が遷移します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var dp = new mint[N + 1, M + 10];
    for (var j = 1; j &amp;lt;= M; j++)
    {
        dp[0, j] = 1;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var cum = new mint[M + 10];
        for (var j = 1; j &amp;lt;= M; j++)
        {
            cum[j + 1] = cum[j] + dp[i, j];
        }

        for (var j = 1; j &amp;lt;= M; j++)
        {
            if (K &amp;gt; 0)
            {
                var l1 = 0;
                var r1 = Math.Max(0, j - K) + 1;
                var l2 = Math.Min(M + 1, j + K);
                var r2 = M + 1;
                dp[i + 1, j] += cum[r1] - cum[l1] + cum[r2] - cum[l2];
            }
            else
            {
                dp[i + 1, j] += cum[M + 1];
            }
        }
    }

    mint answer = 0;
    for (var i = 1; i &amp;lt;= M; i++)
    {
        answer += dp[N - 1, i];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 253の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>