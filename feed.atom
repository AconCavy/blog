<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title>acon.log</title>
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2023 AconCavy</rights>
	<updated>2023-07-19T04:20:43Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230715abc310</id>
		<title>ABC310</title>
		<link href="https://blog.aconcavy.dev/posts/20230715abc310" />
		<updated>2023-07-15T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 310の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc310"&gt;https://atcoder.jp/contests/abc310&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43582409"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ドリンクのみか、割引券とともに最安値の料理を注文するかの方法のうち、安くなる方が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P, Q) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = Math.Min(P, Q + D.Min());
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43597894"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;価格&lt;code&gt;P&lt;/code&gt;の集合&lt;code&gt;S&lt;/code&gt;と、価格&lt;code&gt;Q&lt;/code&gt;の集合&lt;code&gt;T&lt;/code&gt;を比較したときに、&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;一致しているかつ値段が異なる、または&lt;code&gt;T&lt;/code&gt;は&lt;code&gt;S&lt;/code&gt;の部分集合かつ&lt;code&gt;|S|&amp;gt;|T|&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var PS = new (int P, HashSet&amp;lt;int&amp;gt; S)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var array = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var p = array[0];
        var c = array[1];
        var s = new HashSet&amp;lt;int&amp;gt;(array.Skip(2));
        PS[i] = (p, s);
    }

    Array.Sort(PS, (x, y) =&amp;gt; x.P.CompareTo(y.P));

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var (p, s) = PS[i];
            var (q, t) = PS[j];

            if ((s.SetEquals(t) &amp;amp;&amp;amp; p &amp;lt; q) || t.IsSubsetOf(s) &amp;amp;&amp;amp; s.Count &amp;gt; t.Count)
            {
                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43600578"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列を順にみていき、その文字列とその文字列を反転させたものがそれまでに出現しているかを判定していきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var set = new HashSet&amp;lt;string&amp;gt;();
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        var T = new string(S.Reverse().ToArray());
        if (!set.Contains(S) &amp;amp;&amp;amp; !set.Contains(T))
        {
            set.Add(S);
            set.Add(T);
            answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43646845"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全探索を行います。&lt;br /&gt;
現在できているチームを管理しながら、相性の悪い組ができないように選手を順番に追加していきます。&lt;br /&gt;
場合分けとして、現在できているチームのいずれかに選手を追加することができます。&lt;br /&gt;
また、現在できているチーム数が&lt;code&gt;T&lt;/code&gt;未満の場合、新しくチームを作成して選手を追加することができます。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;人全ての選手をチームに追加したときのチーム数が&lt;code&gt;T&lt;/code&gt;組であるときの組み合わせを数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T, M) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var ng = new int[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        ng[a] |= 1 &amp;lt;&amp;lt; b;
        ng[b] |= 1 &amp;lt;&amp;lt; a;
    }

    var teams = new List&amp;lt;int&amp;gt;(T);

    int Dfs(int i)
    {
        if (i == N)
        {
            return teams.Count == T ? 1 : 0;
        }

        var sum = 0;
        for (var t = 0; t &amp;lt; teams.Count; t++)
        {
            if ((teams[t] &amp;amp; ng[i]) != 0) continue;
            teams[t] += 1 &amp;lt;&amp;lt; i;
            sum += Dfs(i + 1);
            teams[t] -= 1 &amp;lt;&amp;lt; i;
        }

        if (teams.Count &amp;lt; T)
        {
            teams.Add(1 &amp;lt;&amp;lt; i);
            sum += Dfs(i + 1);
            teams.RemoveAt(teams.Count - 1);
        }

        return sum;
    }

    var answer = Dfs(0);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43647339"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,f] := i番目までみたときのf(0|1)の個数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;に対して否定論理積をとる場合、&lt;code&gt;0⊼0=1&lt;/code&gt;、&lt;code&gt;1⊼0=1&lt;/code&gt;であることから、それまでの&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;の個数が&lt;code&gt;1&lt;/code&gt;になることがわかります。
また、&lt;code&gt;1&lt;/code&gt;に対して否定論理積をとる場合、&lt;code&gt;0⊼1=1&lt;/code&gt;、&lt;code&gt;1⊼1=0&lt;/code&gt;であることから、それまでの&lt;code&gt;0&lt;/code&gt;の個数が&lt;code&gt;1&lt;/code&gt;になり、それまでの&lt;code&gt;1&lt;/code&gt;の個数が&lt;code&gt;0&lt;/code&gt;になることがわかります。&lt;br /&gt;
これらのことから、遷移としては、次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;S[i]==0のとき
dp[i+1,0] += 1       // S[i]
dp[i+1,1] += dp[i,0] // 0⊼0=1
dp[i+1,1] += dp[i,1] // 1⊼0=1

S[i]==1のとき
dp[i+1,0] += dp[i,1] // 1⊼1=0
dp[i+1,1] += dp[i,0] // 0⊼1=1
dp[i+1,1] += 1       // S[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各&lt;code&gt;i&lt;/code&gt;番目までみたときの&lt;code&gt;1&lt;/code&gt;の個数の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var dp = new long[N + 1, 2];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var f = S[i] - '0';
        dp[i + 1, f]++;
        if (f == 0)
        {
            dp[i + 1, 1] += dp[i, 0] + dp[i, 1];
        }
        else
        {
            dp[i + 1, 0] += dp[i, 1];
            dp[i + 1, 1] += dp[i, 0];
        }
    }

    long answer = 0;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer += dp[i, 1];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 310の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230708abc309</id>
		<title>ABC309</title>
		<link href="https://blog.aconcavy.dev/posts/20230708abc309" />
		<updated>2023-07-08T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 309の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc309"&gt;https://atcoder.jp/contests/abc309&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43337977"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&amp;lt;B&lt;/code&gt;であることから、&lt;code&gt;A+1==B&lt;/code&gt;であることが条件の一つとなります。
また、&lt;code&gt;A&lt;/code&gt;が&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;6&lt;/code&gt;、&lt;code&gt;9&lt;/code&gt;の場合、右に隣接する&lt;code&gt;B&lt;/code&gt;は存在しないため、&lt;code&gt;A&lt;/code&gt;が3の倍数ではないときが、もう一つの条件となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = A + 1 == B &amp;amp;&amp;amp; (A % 3 != 0);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43351302"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;時計回りに&lt;code&gt;1&lt;/code&gt;行目、&lt;code&gt;N&lt;/code&gt;列目、&lt;code&gt;N&lt;/code&gt;行目、&lt;code&gt;1&lt;/code&gt;列目を更新していくことを考えます。&lt;br /&gt;
ある場所を更新するとき、その直前に更新した値がその場所に移動し、更新された値が次の場所に移動することがわかります。&lt;br /&gt;
このことから、直前に更新した値を保持しながら外側のマスを順番に更新していくことで、答えを得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
    }

    var tmp1 = A[1][0];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var tmp2 = A[0][i];
        A[0][i] = tmp1;
        tmp1 = tmp2;
    }

    for (var i = 1; i &amp;lt; N; i++)
    {
        var tmp2 = A[i][N - 1];
        A[i][N - 1] = tmp1;
        tmp1 = tmp2;
    }

    for (var i = N - 2; i &amp;gt;= 0; i--)
    {
        var tmp2 = A[N - 1][i];
        A[N - 1][i] = tmp1;
        tmp1 = tmp2;
    }

    for (var i = N - 2; i &amp;gt;= 0; i--)
    {
        var tmp2 = A[i][0];
        A[i][0] = tmp1;
        tmp1 = tmp2;
    }

    Printer.Print2D(A);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43355518"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初日に飲む必要がある薬は&lt;code&gt;b&lt;/code&gt;の総和となり、各&lt;code&gt;a+1&lt;/code&gt;日目に飲む分は&lt;code&gt;b&lt;/code&gt;錠減ることがわかります。&lt;br /&gt;
このことから、各&lt;code&gt;a+1&lt;/code&gt;日目に何錠減るかをまとめ、薬が減る日が早い順に飲む必要がある薬を減らしていき、&lt;code&gt;K&lt;/code&gt;以下になった日が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var dict = new Dictionary&amp;lt;long, long&amp;gt;();
    dict[1] = 0;
    long cum = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        cum += b;
        if (!dict.ContainsKey(a + 1)) dict[a + 1] = 0;
        dict[a + 1] += b;
    }


    foreach (var (a, b) in dict.OrderBy(x =&amp;gt; x.Key))
    {
        cum -= b;
        if (cum &amp;lt;= K)
        {
            Console.WriteLine(a);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43359818"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;1&lt;/code&gt;から頂点&lt;code&gt;N1+N2&lt;/code&gt;への最長となる経路は、頂点&lt;code&gt;1&lt;/code&gt;から最も遠い頂点と頂点&lt;code&gt;N1+N2&lt;/code&gt;から最も遠い頂点間に辺を結ぶことで達成することができます。&lt;br /&gt;
このことから、&lt;code&gt;N1&lt;/code&gt;個の頂点からなるグラフ&lt;code&gt;G1&lt;/code&gt;において頂点&lt;code&gt;1&lt;/code&gt;から距離と、&lt;code&gt;N2&lt;/code&gt;個の頂点からなるグラフ&lt;code&gt;G2&lt;/code&gt;において頂点&lt;code&gt;N1+N2&lt;/code&gt;からの距離をそれぞれ幅優先探索などを行い求め、各距離の最大値に辺を一つ追加したものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N1, N2, M) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G1 = new List&amp;lt;int&amp;gt;[N1].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var G2 = new List&amp;lt;int&amp;gt;[N2].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        if (a &amp;lt; N1)
        {
            G1[a].Add(b);
            G1[b].Add(a);
        }
        else
        {
            a -= N1;
            b -= N1;
            G2[a].Add(b);
            G2[b].Add(a);
        }
    }

    int MaxDist(List&amp;lt;int&amp;gt;[] G, int N, int s)
    {
        var dist = new int[N];
        Array.Fill(dist, -1);
        var queue = new Queue&amp;lt;int&amp;gt;();
        queue.Enqueue(s);
        dist[s] = 0;
        while (queue.Count &amp;gt; 0)
        {
            var u = queue.Dequeue();
            foreach (var v in G[u])
            {
                if (dist[v] != -1) continue;
                dist[v] = dist[u] + 1;
                queue.Enqueue(v);
            }
        }

        return dist.Max();
    }

    var answer = MaxDist(G1, N1, 0) + MaxDist(G2, N2, N2 - 1) + 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43370895"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各親&lt;code&gt;u&lt;/code&gt;から子&lt;code&gt;v&lt;/code&gt;への有向辺を張ったグラフを&lt;code&gt;G&lt;/code&gt;とします。&lt;br /&gt;
人&lt;code&gt;i&lt;/code&gt;からみた保証対象となる代の最大値を&lt;code&gt;dp[i]&lt;/code&gt;、親を&lt;code&gt;u&lt;/code&gt;、子を&lt;code&gt;v&lt;/code&gt;としたとき、&lt;code&gt;dp[v]&lt;/code&gt;の最大値は&lt;code&gt;Max(dp[v],dp[u]-1)&lt;/code&gt;になります。
&lt;code&gt;P[i]&amp;lt;=i-1&lt;/code&gt;であることから、親を順に走査して子に最大値を伝播してくことで各&lt;code&gt;dp[i]&lt;/code&gt;の値を求めることができ、&lt;code&gt;dp[i]&amp;gt;=0&lt;/code&gt;となる人の数が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();

    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; P.Length; i++)
    {
        var u = P[i] - 1;
        var v = i + 1;
        G[u].Add(v);
    }

    var dp = new int[N];
    Array.Fill(dp, -1);
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--;
        dp[x] = Math.Max(dp[x], y);
    }

    var answer = 0;
    for (var u = 0; u &amp;lt; N; u++)
    {
        foreach (var v in G[u])
        {
            dp[v] = Math.Max(dp[v], dp[u] - 1);
        }

        if (dp[u] &amp;gt;= 0) answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 309の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230701abc308</id>
		<title>ABC308</title>
		<link href="https://blog.aconcavy.dev/posts/20230701abc308" />
		<updated>2023-07-01T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 308の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308"&gt;https://atcoder.jp/contests/abc308&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43089067"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての&lt;code&gt;S[i]&lt;/code&gt;において各条件を満たすかどうかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    bool F1(int x) =&amp;gt; 100 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= 675;
    bool F2(int x) =&amp;gt; x % 25 == 0;
    var answer = F1(A[0]) &amp;amp;&amp;amp; F2(A[1]);
    for (var i = 1; i &amp;lt; A.Length; i++)
    {
        answer &amp;amp;= A[i] &amp;gt;= A[i - 1] &amp;amp;&amp;amp; F1(A[i]) &amp;amp;&amp;amp; F2(A[i]);
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43094426"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書などを使って料理名に対して値段を設定し、食べた料理の価格の合計を計算します。&lt;br /&gt;
&lt;code&gt;D&lt;/code&gt;に存在しない料理名の価格は&lt;code&gt;P[0]&lt;/code&gt;になることに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
    var D = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
    var P = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;string, long&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        dict[D[i]] = P[i + 1];
    }

    var answer = C.Sum(x =&amp;gt; dict.ContainsKey(x) ? dict[x] : P[0]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43098637"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;成功率を浮動小数点で計算してしまうと誤差が発生してしまうため、整数型で管理できるようにします。
ある確率&lt;code&gt;X&lt;/code&gt;が整数&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;で&lt;code&gt;a/b&lt;/code&gt;、確率&lt;code&gt;Y&lt;/code&gt;が整数&lt;code&gt;c&lt;/code&gt;と&lt;code&gt;d&lt;/code&gt;で&lt;code&gt;c/d&lt;/code&gt;で表すことができるとき、不等式&lt;code&gt;X&amp;gt;Y&lt;/code&gt;は&lt;code&gt;a/b&amp;gt;c/d&lt;/code&gt;となりますが、両辺に&lt;code&gt;b*d&lt;/code&gt;を掛けることで、&lt;code&gt;a*d&amp;gt;c*b&lt;/code&gt;とすることができ、整数型で比較を行うことができるようになります。
そのため、整数型で分母と分子を管理しながら成功率が高い順に並べることで、答えを求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = new Fraction[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = new Fraction(a, a + b);
    }

    var H = Enumerable.Range(0, N).ToArray();
    Array.Sort(H, (x, y) =&amp;gt;
    {
        var result = P[y].CompareTo(P[x]);
        return result == 0 ? x.CompareTo(y) : result;
    });

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, H.Select(x =&amp;gt; x + 1)));
}

public readonly struct Fraction : IComparable&amp;lt;Fraction&amp;gt;, IEquatable&amp;lt;Fraction&amp;gt;
{
    public long Y { get; }
    public long X { get; }

    public Fraction(long y, long x)
    {
        static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
        var g = Gcd(y, x);
        (Y, X) = (y / g, x / g);
    }

    public static bool operator &amp;lt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt; 0;
    public static bool operator &amp;lt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt;= 0;
    public static bool operator &amp;gt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt; 0;
    public static bool operator &amp;gt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt;= 0;
    public static bool operator ==(Fraction left, Fraction right) =&amp;gt; left.Equals(right);
    public static bool operator !=(Fraction left, Fraction right) =&amp;gt; !left.Equals(right);
    public int CompareTo(Fraction other) =&amp;gt; (Y * other.X).CompareTo(X * other.Y);
    public bool Equals(Fraction other) =&amp;gt; Y == other.Y &amp;amp;&amp;amp; X == other.X;
    public override bool Equals(object obj) =&amp;gt; obj is Fraction other &amp;amp;&amp;amp; Equals(other);
    public override int GetHashCode() =&amp;gt; HashCode.Combine(Y, X);
    public override string ToString() =&amp;gt; $&amp;quot;{Y}/{X}&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43105604"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各マスを頂点とし、現在の文字が&lt;code&gt;snuke&lt;/code&gt;文字列の何番目であるかを管理しながら、幅優先探索を行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; F(x)).ToArray();
    }

    int F(char c)
    {
        return c switch
        {
            's' =&amp;gt; 0,
            'n' =&amp;gt; 1,
            'u' =&amp;gt; 2,
            'k' =&amp;gt; 3,
            'e' =&amp;gt; 4,
            _ =&amp;gt; -1,
        };
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    var used = new bool[H, W];
    var queue = new Queue&amp;lt;(int H, int W, int S)&amp;gt;();
    if (G[0][0] == 0)
    {
        used[0, 0] = true;
        queue.Enqueue((0, 0, 0));
    }

    while (queue.Count &amp;gt; 0)
    {
        var (ch, cw, cs) = queue.Dequeue();
        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            var ns = G[nh][nw];
            if (ns == (cs + 1) % 5 &amp;amp;&amp;amp; !used[nh, nw])
            {
                used[nh, nw] = true;
                queue.Enqueue((nh, nw, ns));
            }
        }
    }

    var answer = used[H - 1, W - 1];
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43154883"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;j&lt;/code&gt;を固定したとき、その&lt;code&gt;j&lt;/code&gt;からありえる&lt;code&gt;MEX&lt;/code&gt;の組み合わせは、&lt;code&gt;A[i]&lt;/code&gt;の値が&lt;code&gt;0,1,2&lt;/code&gt;の3通りと&lt;code&gt;A[k]&lt;/code&gt;の値が&lt;code&gt;0,1,2&lt;/code&gt;の3通りの合計9通りになります。&lt;br /&gt;
&lt;code&gt;j&lt;/code&gt;までに出現する&lt;code&gt;{0,1,2}&lt;/code&gt;の個数、&lt;code&gt;j&lt;/code&gt;以降に出現する&lt;code&gt;{0,1,2}&lt;/code&gt;の個数に対して&lt;code&gt;mex({0,1,2},A[j],{0,1,2})&lt;/code&gt;を掛けることで、その&lt;code&gt;j&lt;/code&gt;に対する&lt;code&gt;mex(A[i],A[j],A[k])&lt;/code&gt;の総和を求めることができます。&lt;br /&gt;
あらかじめ累積和で各値が出現する個数を求めておくことで、&lt;code&gt;j&lt;/code&gt;における各&lt;code&gt;mex(A[i],A[j],A[k])&lt;/code&gt;の値を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができ、全体で時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    var countM = new long[N + 1, 3];
    var countX = new long[N + 1, 3];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var m = 0; m &amp;lt; 3; m++)
        {
            countM[i + 1, m] += countM[i, m];
            countX[i + 1, m] += countX[i, m];
        }

        if (S[i] == 'M') countM[i + 1, A[i]]++;
        if (S[i] == 'X') countX[i + 1, A[i]]++;
    }

    int Mex(int a, int b, int c)
    {
        for (var mex = 0; mex &amp;lt; 3; mex++)
        {
            if (mex != a &amp;amp;&amp;amp; mex != b &amp;amp;&amp;amp; mex != c) return mex;
        }

        return 3;
    }

    long answer = 0;
    for (var j = 0; j &amp;lt; N; j++)
    {
        if (S[j] != 'E') continue;
        for (var i = 0; i &amp;lt; 3; i++)
        {
            for (var k = 0; k &amp;lt; 3; k++)
            {
                var ci = countM[j, i];
                var ck = countX[N, k] - countX[j, k];
                answer += ci * ck * Mex(i, A[j], k);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43152464"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P&lt;/code&gt;を小さい順に見ていき、各&lt;code&gt;P[i]&lt;/code&gt;に対して利用可能な最大の&lt;code&gt;D[j]&lt;/code&gt;を使用していくことで、最小値を求めることができます。
利用可能な最大の&lt;code&gt;D[j]&lt;/code&gt;は、&lt;code&gt;L[j]&lt;/code&gt;を小さい順にソートし、現在見ている&lt;code&gt;P[i]&lt;/code&gt;以下の&lt;code&gt;L[j]&lt;/code&gt;に対応する&lt;code&gt;D[j]&lt;/code&gt;を優先度付きキューに挿入していき、優先度付きキューの先頭にあるものを消費することで求めることができ、全体時間計算量`O(NlogN+MlogM)で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var L = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var D = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var LD = L.Zip(D).ToArray();
    Array.Sort(P, (x, y) =&amp;gt; x.CompareTo(y));
    Array.Sort(LD, (x, y) =&amp;gt; x.First.CompareTo(y.First));

    var queue = new PriorityQueue&amp;lt;long&amp;gt;((x, y) =&amp;gt; y.CompareTo(x));
    var idx = 0;
    long answer = 0;
    foreach (var p in P)
    {
        answer += p;
        while (idx &amp;lt; M &amp;amp;&amp;amp; LD[idx].First &amp;lt;= p)
        {
            queue.Enqueue(LD[idx++].Second);
        }

        if (queue.Count &amp;gt; 0)
        {
            answer -= queue.Dequeue();
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 308の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230624abc307</id>
		<title>ABC307</title>
		<link href="https://blog.aconcavy.dev/posts/20230624abc307" />
		<updated>2023-06-24T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 307の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc307"&gt;https://atcoder.jp/contests/abc307&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc307/tasks/abc307_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc307/submissions/42892805"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i (0-indexed)&lt;/code&gt;番目の歩数は、&lt;code&gt;Floor(i/7)&lt;/code&gt;週目の歩数になることに注意して、総和を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answers = new long[N];
    for (var i = 0; i &amp;lt; N * 7; i++)
    {
        answers[i / 7] += A[i];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc307/tasks/abc307_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc307/submissions/42896048"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i!=j&lt;/code&gt;となる&lt;code&gt;S[i]&lt;/code&gt;、&lt;code&gt;S[j]&lt;/code&gt;を繋げた文字が回文であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (i == j) continue;
            var T = S[i] + S[j];
            var m = T.Length;
            var ok = true;
            for (var k = 0; k &amp;lt; m - 1 - k; k++)
            {
                ok &amp;amp;= T[k] == T[m - 1 - k];
            }

            if (ok)
            {
                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc307/tasks/abc307_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc307/submissions/42934012"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;縦&lt;code&gt;H&lt;/code&gt;マス、横&lt;code&gt;W&lt;/code&gt;マスのシートの配置方法は、&lt;code&gt;(H*2-1)*(W*2-1)&lt;/code&gt;通りあります。&lt;br /&gt;
シート&lt;code&gt;A&lt;/code&gt;とシート&lt;code&gt;B&lt;/code&gt;をそれぞれ&lt;code&gt;(H*2-1)*(W*2-1)&lt;/code&gt;通りずつ配置し、黒いマスの座標の集合がシート&lt;code&gt;X&lt;/code&gt;の座標の集合と一致しているかを判定します。
このとき、配置されたシート&lt;code&gt;A&lt;/code&gt;の座標の集合は、シート&lt;code&gt;X&lt;/code&gt;の座標の集合の部分集合である必要があるため、配置されたシート&lt;code&gt;A&lt;/code&gt;の座標の集合がシート&lt;code&gt;X&lt;/code&gt;の座標の集合の部分集合ではない場合に枝刈りすることで高速化することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var P = new HashSet&amp;lt;(int H, int W)&amp;gt;[3];
    for (var k = 0; k &amp;lt; 3; k++)
    {
        P[k] = new HashSet&amp;lt;(int H, int W)&amp;gt;();
        var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();

        for (var i = 0; i &amp;lt; H; i++)
        {
            var s = Scanner.Scan&amp;lt;string&amp;gt;();
            for (var j = 0; j &amp;lt; W; j++)
            {
                if (s[j] == '#')
                {
                    P[k].Add((i, j));
                }
            }
        }
    }

    var A = P[0];
    var B = P[1];
    var X = P[2];

    for (var dia = -10; dia &amp;lt;= 10; dia++)
    {
        for (var dja = -10; dja &amp;lt;= 10; dja++)
        {
            var a = A.Select(p =&amp;gt; (p.H + dia, p.W + dja)).ToHashSet();
            if (!a.IsSubsetOf(X)) continue;
            for (var dib = -10; dib &amp;lt;= 10; dib++)
            {
                for (var djb = -10; djb &amp;lt;= 10; djb++)
                {
                    var b = B.Select(p =&amp;gt; (p.H + dib, p.W + djb));
                    if (a.Concat(b).ToHashSet().SetEquals(X))
                    {
                        Console.WriteLine(&amp;quot;Yes&amp;quot;);
                        return;
                    }
                }
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc307/tasks/abc307_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc307/submissions/42909932"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc307/submissions/42934863"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;削除すべき文字列の区間は、&lt;code&gt;(&lt;/code&gt;が出現してから初めて出現する&lt;code&gt;)&lt;/code&gt;までの区間となります。&lt;br /&gt;
これは、文字列&lt;code&gt;S&lt;/code&gt;を順にみていき、&lt;code&gt;)&lt;/code&gt;が出現したときに対応する&lt;code&gt;(&lt;/code&gt;までの文字を削除することで、答えを得ることができます。&lt;br /&gt;
ただし、&lt;code&gt;)&lt;/code&gt;に対応する&lt;code&gt;(&lt;/code&gt;が存在しない場合があります。&lt;br /&gt;
そこで、ある文字が何個の&lt;code&gt;()&lt;/code&gt;で囲まれているかを&lt;code&gt;level&lt;/code&gt;としたとき、&lt;code&gt;(&lt;/code&gt;が出現したときは&lt;code&gt;level&lt;/code&gt;を&lt;code&gt;+1&lt;/code&gt;、&lt;code&gt;)&lt;/code&gt;が出現したときは&lt;code&gt;level&lt;/code&gt;を&lt;code&gt;-1&lt;/code&gt;とすると、&lt;code&gt;level&lt;/code&gt;が負のとき、&lt;code&gt;)&lt;/code&gt;に対応する&lt;code&gt;(&lt;/code&gt;が存在しないことを判定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var level = 0;
    var T = new char[N];
    var idx = 0;
    foreach (var c in S)
    {
        if (c == ')' &amp;amp;&amp;amp; level &amp;gt; 0)
        {
            while (idx &amp;gt;= 0 &amp;amp;&amp;amp; T[idx - 1] != '(') idx--;
            idx--;
            level--;
        }
        else
        {
            T[idx++] = c;
            if (c == '(') level++;
        }
    }

    var answer = new string(T[..idx]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 307の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230617abc306</id>
		<title>ABC306</title>
		<link href="https://blog.aconcavy.dev/posts/20230617abc306" />
		<updated>2023-06-17T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 306の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc306"&gt;https://atcoder.jp/contests/abc306&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc306/tasks/abc306_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC306/submissions/42316809"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各文字を2回繰り返したものを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var builder = new StringBuilder();
    foreach (var c in S)
    {
        builder.Append($&amp;quot;{c}{c}&amp;quot;);
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc306/tasks/abc306_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC306/submissions/42326644"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;ビットシフトすると、&lt;code&gt;2^i&lt;/code&gt;になるので、&lt;code&gt;A[i]&amp;lt;&amp;lt;i&lt;/code&gt;を足していくことで答えを求めることができます。&lt;br /&gt;
符号あり64bit整数型の&lt;code&gt;long&lt;/code&gt;型だと、&lt;code&gt;2^63-1&lt;/code&gt;までしか格納できないので、&lt;code&gt;ulong&lt;/code&gt;型などの符号なし64bit整数型を使うことに注意が必要です(1敗)。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    ulong answer = 0;
    for (var i = 0; i &amp;lt; A.Length; i++)
    {
        answer |= (ulong)A[i] &amp;lt;&amp;lt; i;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc306/tasks/abc306_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC306/submissions/42325473"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2回目に出現する値からなる数列が答えとなります。&lt;br /&gt;
各値が何回出現したかを管理しながら&lt;code&gt;A&lt;/code&gt;を順に走査し、値が2回目に出現したものを答えの数列に追加することで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var count = new int[N + 1];
    var answer = new List&amp;lt;int&amp;gt;(N);
    foreach (var a in A)
    {
        count[a]++;
        if (count[a] == 2) answer.Add(a);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc306/tasks/abc306_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC306/submissions/42333604"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][f] := i番目の料理まで見たとき、高橋くんがおなかの状態(f=壊している|壊していない)のときの食べた料理のおいしさの総和の最大値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;f=0 // おなかを壊していない
f=1 // おなかを壊している

i番目の料理を下げてもらうとき
dp[i+1][0] = Max(dp[i+1][0], dp[i][0])
dp[i+1][1] = Max(dp[i+1][1], dp[i][1])

i番目の解毒剤入りの料理を食べるとき(x==0)
dp[i+1][0] = Max(dp[i+1][0], dp[i][0]+y, dp[i][1]+y)

i番目の毒入りの料理を食べるとき(y==0)
dp[i+1][1] = Max(dp[i+1][1], dp[i][0]+y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;番目の料理まで見たときのおなかを壊していないときとおなかを壊しているときのうち、最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dp = new long[N + 1, 2];
    const int Inf = (int)1e9;
    dp[0, 1] = -Inf;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        dp[i + 1, 0] = Math.Max(dp[i + 1, 0], dp[i, 0]);
        dp[i + 1, 1] = Math.Max(dp[i + 1, 1], dp[i, 1]);

        if (x == 0)
        {
            dp[i + 1, 0] = Math.Max(dp[i + 1, 0], dp[i, 0] + y);
            dp[i + 1, 0] = Math.Max(dp[i + 1, 0], dp[i, 1] + y);
        }
        else
        {
            dp[i + 1, 1] = Math.Max(dp[i + 1, 1], dp[i, 0] + y);
        }
    }

    var answer = Math.Max(dp[N, 0], dp[N, 1]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc306/tasks/abc306_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC306/submissions/42355592"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに&lt;code&gt;A&lt;/code&gt;に対してソートを行い、降順&lt;code&gt;K&lt;/code&gt;個の和を計算してしまうと、クエリ当たりの時間計算量が&lt;code&gt;O(NlogN)&lt;/code&gt;、全体の時間計算量が&lt;code&gt;O(QNlogN)&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;f(A)&lt;/code&gt;は&lt;code&gt;A&lt;/code&gt;のうちの降順&lt;code&gt;K&lt;/code&gt;個の総和であり、&lt;code&gt;K&lt;/code&gt;個の中からある値&lt;code&gt;v&lt;/code&gt;が引かれたとき、&lt;code&gt;f(A)&lt;/code&gt;から&lt;code&gt;v&lt;/code&gt;が引かれ、&lt;code&gt;K+1&lt;/code&gt;番目の値が&lt;code&gt;f(A)&lt;/code&gt;に加えられます。
対して、&lt;code&gt;K&lt;/code&gt;個の中にある値&lt;code&gt;v&lt;/code&gt;が加えられたとき、&lt;code&gt;f(A)&lt;/code&gt;には&lt;code&gt;v&lt;/code&gt;が加えられ、&lt;code&gt;K+1&lt;/code&gt;番目の値が&lt;code&gt;f(A)&lt;/code&gt;から引かれます。&lt;/p&gt;
&lt;p&gt;つまり、更新前の&lt;code&gt;A[x]&lt;/code&gt;が&lt;code&gt;K&lt;/code&gt;番目以内であれば、&lt;code&gt;f(A)&lt;/code&gt;から&lt;code&gt;A[x]&lt;/code&gt;を引き、&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;K+1&lt;/code&gt;番目の値を&lt;code&gt;f(A)&lt;/code&gt;に加えます。&lt;br /&gt;
&lt;code&gt;A[x]=y&lt;/code&gt;として&lt;code&gt;A&lt;/code&gt;を更新後、&lt;code&gt;A[x]&lt;/code&gt;が&lt;code&gt;K&lt;/code&gt;番以内であれば、&lt;code&gt;f(A)&lt;/code&gt;に&lt;code&gt;A[x]&lt;/code&gt;を加え、&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;K+1&lt;/code&gt;番目の値を&lt;code&gt;f(A)&lt;/code&gt;から引きます。&lt;/p&gt;
&lt;p&gt;現在の&lt;code&gt;A&lt;/code&gt;を管理しながら&lt;code&gt;f(A)&lt;/code&gt;を更新していくことで答えを求めることができます。
クエリにおいて、現在の&lt;code&gt;A&lt;/code&gt;の中から&lt;code&gt;K&lt;/code&gt;番目の値を高速に求める必要があり、重複を許す順序集合を使うことで、時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で値を取得することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K, Q) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = new long[N + 1];
    var set = new Set&amp;lt;long&amp;gt;((x, y) =&amp;gt; y.CompareTo(x), true);
    for (var i = 0; i &amp;lt;= N; i++)
    {
        set.Add(0);
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, long&amp;gt;();
        var lb1 = set.LowerBound(A[x]);
        if (lb1 &amp;lt; K)
        {
            answer -= A[x];
            answer += set.ElementAt(K);
        }

        set.Remove(A[x]);

        A[x] = y;
        set.Add(y);

        var lb2 = set.LowerBound(y);
        if (lb2 &amp;lt; K)
        {
            answer += y;
            answer -= set.ElementAt(K);
        }

        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;details&gt;
&lt;summary&gt;Set&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class Set&amp;lt;T&amp;gt; : IReadOnlyCollection&amp;lt;T&amp;gt;
{
    private readonly RandomizedBinarySearchTree&amp;lt;T&amp;gt; _tree;
    private readonly bool _allowDuplication;
    public Set(bool allowDuplication = false) : this(Comparer&amp;lt;T&amp;gt;.Default, allowDuplication) { }

    public Set(IEnumerable&amp;lt;T&amp;gt; source, bool allowDuplication = false) : this(allowDuplication)
    {
        foreach (var value in source) Add(value);
    }

    public Set(IEnumerable&amp;lt;T&amp;gt; source, IComparer&amp;lt;T&amp;gt; comparer, bool allowDuplication = false)
        : this(comparer, allowDuplication)
    {
        foreach (var value in source) Add(value);
    }

    public Set(IEnumerable&amp;lt;T&amp;gt; source, Comparison&amp;lt;T&amp;gt; comparison, bool allowDuplication = false)
        : this(comparison, allowDuplication)
    {
        foreach (var value in source) Add(value);
    }

    public Set(IComparer&amp;lt;T&amp;gt; comparer, bool allowDuplication = false)
        : this((comparer ?? Comparer&amp;lt;T&amp;gt;.Default).Compare, allowDuplication)
    {
    }

    public Set(Comparison&amp;lt;T&amp;gt; comparison, bool allowDuplication = false)
    {
        _tree = new RandomizedBinarySearchTree&amp;lt;T&amp;gt;(comparison);
        _allowDuplication = allowDuplication;
    }

    public void Add(T value)
    {
        if (_allowDuplication || !_tree.Contains(value)) _tree.Insert(value);
    }

    public void Remove(T value)
    {
        _tree.Remove(value);
    }

    public bool Contains(T value)
    {
        return _tree.Contains(value);
    }

    public T ElementAt(int index)
    {
        return _tree.ElementAt(index);
    }

    public int LowerBound(T value)
    {
        return _tree.LowerBound(value);
    }

    public int UpperBound(T value)
    {
        return _tree.UpperBound(value);
    }

    public int Count =&amp;gt; _tree.Count;
    public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; _tree.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Randomized Binary Search Tree&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;
public class RandomizedBinarySearchTree&amp;lt;T&amp;gt; : IReadOnlyCollection&amp;lt;T&amp;gt;
{
    private readonly Comparison&amp;lt;T&amp;gt; _comparison;
    private readonly Random _random;
    private Node _root;
    public RandomizedBinarySearchTree(int seed = 0) : this(comparer: null, seed) { }

    public RandomizedBinarySearchTree(Comparer&amp;lt;T&amp;gt; comparer, int seed = 0) : this(
        (comparer ?? Comparer&amp;lt;T&amp;gt;.Default).Compare, seed)
    {
    }

    public RandomizedBinarySearchTree(Comparison&amp;lt;T&amp;gt; comparison, int seed = 0)
    {
        _comparison = comparison;
        _random = new Random(seed);
    }

    public void Insert(T value)
    {
        if (_root is null) _root = new Node(value);
        else InsertAt(LowerBound(value), value);
    }

    public bool Remove(T value)
    {
        var index = LowerBound(value);
        if (index &amp;lt; 0) return false;
        RemoveAt(index);
        return true;
    }

    public T ElementAt(int index)
    {
        if (index &amp;lt; 0 || Count &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        var node = _root;
        var idx = CountOf(node) - CountOf(node.R) - 1;
        while (node is { })
        {
            if (idx == index) return node.Value;
            if (idx &amp;gt; index)
            {
                node = node.L;
                idx -= CountOf(node?.R) + 1;
            }
            else
            {
                node = node.R;
                idx += CountOf(node?.L) + 1;
            }
        }

        throw new ArgumentOutOfRangeException(nameof(index));
    }

    public bool Contains(T value)
    {
        return Find(value) is { };
    }

    public int Count =&amp;gt; CountOf(_root);
    public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; Enumerate(_root).GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();
    public int UpperBound(T value) =&amp;gt; Bound(value, (x, y) =&amp;gt; _comparison(x, y) &amp;gt; 0);
    public int LowerBound(T value) =&amp;gt; Bound(value, (x, y) =&amp;gt; _comparison(x, y) &amp;gt;= 0);

    public int Bound(T value, Func&amp;lt;T, T, bool&amp;gt; compare)
    {
        var node = _root;
        if (node is null) return -1;
        var bound = CountOf(node);
        var idx = bound - CountOf(node.R) - 1;
        while (node is { })
        {
            if (compare(node.Value, value))
            {
                node = node.L;
                bound = Math.Min(bound, idx);
                idx -= CountOf(node?.R) + 1;
            }
            else
            {
                node = node.R;
                idx += CountOf(node?.L) + 1;
            }
        }

        return bound;
    }

    private double GetProbability() =&amp;gt; _random.NextDouble();

    private void InsertAt(int index, T value)
    {
        var (l, r) = Split(_root, index);
        _root = Merge(Merge(l, new Node(value)), r);
    }

    private void RemoveAt(int index)
    {
        var (l, r1) = Split(_root, index);
        var (_, r2) = Split(r1, 1);
        _root = Merge(l, r2);
    }

    private Node Merge(Node l, Node r)
    {
        if (l is null || r is null) return l ?? r;
        var (n, m) = (CountOf(l), CountOf(r));
        if ((double)n / (n + m) &amp;gt; GetProbability())
        {
            l.R = Merge(l.R, r);
            return l;
        }
        else
        {
            r.L = Merge(l, r.L);
            return r;
        }
    }

    private (Node, Node) Split(Node node, int k)
    {
        if (node is null) return (null, null);
        if (k &amp;lt;= CountOf(node.L))
        {
            var (l, r) = Split(node.L, k);
            node.L = r;
            return (l, node);
        }
        else
        {
            var (l, r) = Split(node.R, k - CountOf(node.L) - 1);
            node.R = l;
            return (node, r);
        }
    }

    private Node Find(T value)
    {
        var node = _root;
        while (node is { })
        {
            var cmp = _comparison(node.Value, value);
            if (cmp &amp;gt; 0) node = node.L;
            else if (cmp &amp;lt; 0) node = node.R;
            else break;
        }

        return node;
    }

    private static int CountOf(Node node) =&amp;gt; node?.Count ?? 0;

    private static IEnumerable&amp;lt;T&amp;gt; Enumerate(Node node = null)
    {
        if (node is null) yield break;
        foreach (var value in Enumerate(node.L)) yield return value;
        yield return node.Value;
        foreach (var value in Enumerate(node.R)) yield return value;
    }

    private class Node
    {
        internal T Value { get; }

        internal Node L
        {
            get =&amp;gt; _l;
            set
            {
                _l = value;
                UpdateCount();
            }
        }

        internal Node R
        {
            get =&amp;gt; _r;
            set
            {
                _r = value;
                UpdateCount();
            }
        }

        internal int Count { get; private set; }
        private Node _l;
        private Node _r;

        internal Node(T value)
        {
            Value = value;
            Count = 1;
        }

        private void UpdateCount()
        {
            Count = (L?.Count ?? 0) + (R?.Count ?? 0) + 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 306の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230610abc305</id>
		<title>ABC305</title>
		<link href="https://blog.aconcavy.dev/posts/20230610abc305" />
		<updated>2023-06-10T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 305の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc305"&gt;https://atcoder.jp/contests/abc305&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc305/tasks/abc305_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC305/submissions/42119754"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;の付近にある給水所は、&lt;code&gt;Floor(N/5)*5&lt;/code&gt;もしくは&lt;code&gt;Ceil(N/5)*5&lt;/code&gt;kmの地点になり、より近い方が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var L = N / 5 * 5;
    var R = (N + 4) / 5 * 5;
    var Answer = L;
    if (N - L &amp;gt; R - N) answer = R;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc305/tasks/abc305_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC305/submissions/42123223"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;A-G&lt;/code&gt;をそれぞれ配列の添え字に対応させたとき、&lt;code&gt;AB&lt;/code&gt;間の距離は&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;BC&lt;/code&gt;間の距離は&lt;code&gt;1&lt;/code&gt;、...と添え字の点からその次の点までの距離に対応させることができます。&lt;br /&gt;
このことから、与えられた2点の左右を区別し、左の点から右の点の手前の点までの距離の和を取ることで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (p, q) = Scanner.Scan&amp;lt;char, char&amp;gt;();
    var D = new int[] { 3, 1, 4, 1, 5, 9 };
    var L = p - 'A';
    var R = q - 'A';
    if (L &amp;gt; R) (L, R) = (R, L);
    var answer = 0;
    for (var k = L; k &amp;lt; R; k++)
    {
        answer += D[k];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc305/tasks/abc305_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC305/submissions/42130169"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC305/submissions/42170949"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;グリッドを走査し、次の値を求めます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: クッキーがある行の最小値&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;: クッキーがある行の最大値&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt;: クッキーがある列の最小値&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: クッキーがある列の最大値&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして、&lt;code&gt;a&amp;lt;=i&amp;lt;=b, c&amp;lt;=j&amp;lt;=d&lt;/code&gt;において、クッキーが置かれていないマスが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    const int Inf = (int)1e9;
    var (a, b, c, d) = (Inf, 0, Inf, 0);
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == '#')
            {
                a = Math.Min(a, i);
                b = Math.Max(b, i);
                c = Math.Min(c, j);
                d = Math.Max(d, j);
            }
        }
    }

    for (var i = a; i &amp;lt;= b; i++)
    {
        for (var j = c; j &amp;lt;= d; j++)
        {
            if (G[i][j] == '.')
            {
                Console.WriteLine($&amp;quot;{i + 1} {j + 1}&amp;quot;);
                return;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc305/tasks/abc305_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC305/submissions/42148588"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;寝ている時間の累積和をとり、各クエリに対して時間計算量&lt;code&gt;O(1)&lt;/code&gt;で答えられるようにします。
1秒ごとの累積和を取ってしまうと、最大で&lt;code&gt;1e9&lt;/code&gt;となってしまうため、クエリを先読みして必要なタイムスタンプだけを使えるように圧縮します。&lt;br /&gt;
定義より、&lt;code&gt;A&lt;/code&gt;の偶数番目のタイムスタンプから、奇数番目のタイムスタンプまでが睡眠期間なので、この間にある全てのタイムスタンプは全て睡眠期間となります。&lt;br /&gt;
&lt;code&gt;t&lt;/code&gt;番目のタイムスタンプまでの累積睡眠時間を&lt;code&gt;Cum[t]&lt;/code&gt;とすると、&lt;code&gt;l&lt;/code&gt;番目のタイムスタンプと&lt;code&gt;r&lt;/code&gt;番目のタイムスタンプ間の睡眠時間は&lt;code&gt;Cum[r]-cum[l]&lt;/code&gt;で求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var query = new (int L, int R)[Q];
    var timeline = new HashSet&amp;lt;int&amp;gt;(A);
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (l, r) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        query[i] = (l, r);
        timeline.Add(l);
        timeline.Add(r);
    }

    var (map, remap) = Compress(timeline);
    var cum = new long[map.Count + 1];
    for (var i = 1; i &amp;lt; N; i += 2)
    {
        var ml = map[A[i]];
        var mr = map[A[i + 1]];
        for (var j = ml; j &amp;lt; mr; j++)
        {
            cum[j + 1] += remap[j + 1] - remap[j];
        }
    }

    for (var i = 0; i + 1 &amp;lt; cum.Length; i++)
    {
        cum[i + 1] += cum[i];
    }

    foreach (var (l, r) in query)
    {
        var ml = map[l];
        var mr = map[r];
        var answer = cum[mr] - cum[ml];
        Console.WriteLine(answer);
    }
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }
    return (map, remap);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc305/tasks/abc305_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC305/submissions/42154655"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hp[u]&lt;/code&gt;を頂点&lt;code&gt;u&lt;/code&gt;における警備員の最大の体力としたとき、&lt;code&gt;hp[u]&amp;gt;=0&lt;/code&gt;となる頂点&lt;code&gt;u&lt;/code&gt;は、警備されている頂点とすることができます。&lt;br /&gt;
探索できる頂点のうち警備員の体力が最大となる頂点を優先して探索するダイクストラ法を行うことで、各頂点の警備員の最大の体力を時間計算量&lt;code&gt;O((N+M)log(N+M))&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        G[a].Add(b);
        G[b].Add(a);
    }

    var guards = new (int P, int H)[K];
    for (var i = 0; i &amp;lt; K; i++)
    {
        var (p, h) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        p--;
        guards[i] = (p, h);
    }

    var hp = new int[N];
    Array.Fill(hp, -1);
    var queue = new PriorityQueue&amp;lt;(int U, int H)&amp;gt;((x, y) =&amp;gt; y.H.CompareTo(x.H));
    foreach (var (p, h) in guards)
    {
        hp[p] = h;
        queue.Enqueue((p, h));
    }

    while (queue.Count &amp;gt; 0)
    {
        var (u, h) = queue.Dequeue();
        if (hp[u] &amp;gt; h) continue;
        foreach (var v in G[u])
        {
            if (h - 1 &amp;gt; hp[v])
            {
                hp[v] = h - 1;
                queue.Enqueue((v, h - 1));
            }
        }
    }

    var answer = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (hp[i] &amp;gt;= 0) answer.Add(i + 1);
    }

    Console.WriteLine(answer.Count);
    if (answer.Count &amp;gt; 0) Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 305の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230603abc304</id>
		<title>ABC304</title>
		<link href="https://blog.aconcavy.dev/posts/20230603abc304" />
		<updated>2023-06-03T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 304の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc304"&gt;https://atcoder.jp/contests/abc304&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41937503"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;が最も小さい番号の人の順番を&lt;code&gt;k (0-indexed)&lt;/code&gt;としたとき、&lt;code&gt;i&lt;/code&gt;番目に出力すべき人は&lt;code&gt;(k+i-1)%N&lt;/code&gt;番の人となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new string[N];
    var A = new int[N];
    var first = -1;
    const int Inf = (int)1e9;
    var min = Inf;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (s, a) = Scanner.Scan&amp;lt;string, int&amp;gt;();
        S[i] = s;
        A[i] = a;
        if (a &amp;lt; min)
        {
            min = a;
            first = i;
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        Console.WriteLine(S[(first + i) % N]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41937568"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;が&lt;code&gt;M&lt;/code&gt;桁の数値であるとき、下位&lt;code&gt;Max(0,M-3)&lt;/code&gt;桁を切り捨てたものが答えとなります。
そのため、&lt;code&gt;K=Max(0,M-3)&lt;/code&gt;としたとき、&lt;code&gt;Floor(N/K)*K&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var M = N.ToString().Length - 3;
    var k = 1;
    for (var i = 0; i &amp;lt; M; i++)
    {
        k *= 10;
    }

    Console.WriteLine(N / k * k);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41941546"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各番号の人を頂点としたBFSを行います。
遷移できるかの判定において、距離の2乗で判定を行うことで、浮動小数点による誤差を無視して判定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = new (int X, int Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        P[i] = (x, y);
    }

    var used = new bool[N];
    used[0] = true;
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(0);
    var D2 = D * D;
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        for (var v = 0; v &amp;lt; N; v++)
        {
            if (used[v]) continue;
            var (dx, dy) = (P[u].X - P[v].X, P[u].Y - P[v].Y);
            var d = dx * dx + dy * dy;
            if (d &amp;lt;= D2)
            {
                used[v] = true;
                queue.Enqueue(v);
            }
        }
    }

    Console.WriteLine(string.Join(Environment.NewLine, used.Select(x =&amp;gt; x ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41963721"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分割されたケーキのピースをそれぞれ、横&lt;code&gt;i (1&amp;lt;=i&amp;lt;=A+1)&lt;/code&gt;番目、縦&lt;code&gt;j (1&amp;lt;=j&amp;lt;=B+1)&lt;/code&gt;番目のピースとし、それぞれのピースにイチゴが何個乗っているかを数え上げます。&lt;/p&gt;
&lt;p&gt;このとき、イチゴがどのピースに乗っているかを二次元配列で管理してしまうと、計算量が&lt;code&gt;O((A+1)(B+1))&lt;/code&gt;になってしまいますが、イチゴの数は高々&lt;code&gt;N&lt;/code&gt;個なので、ピース&lt;code&gt;(i,j)&lt;/code&gt;をキーとする辞書などのデータ構造を使うことで、計算量を&lt;code&gt;O(log(N))&lt;/code&gt;に抑えて管理することができます。&lt;/p&gt;
&lt;p&gt;また、イチゴがどの位置のピースに乗っているかについて、愚直に探索してしまうと、イチゴごとに時間計算量&lt;code&gt;O(A+B)&lt;/code&gt;かかりますが、二部探索をおこなうことで時間計算量&lt;code&gt;O(logA+logB)&lt;/code&gt;に抑えることができます。&lt;br /&gt;
これにより、イチゴがあるピースにおける最小値と最大値を求めることができます。
しかし、この最小値はイチゴがないピースは対象としていないため、イチゴがないピースが存在した場合は最小は&lt;code&gt;0&lt;/code&gt;となります。&lt;br /&gt;
これは、&lt;code&gt;(i,j)&lt;/code&gt;の組み合わせのピースを全て走査することで判定することができますが、イチゴの数は&lt;code&gt;N&lt;/code&gt;個なので、&lt;code&gt;Min(N+1,(A+1)(B+1))&lt;/code&gt;個の組み合わせを調べるだけで、イチゴがないピースが存在するかを判定することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (W, H) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Berries = new (int X, int Y)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        Berries[i] = (x, y);
    }
    var AN = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToList();
    var BN = Scanner.Scan&amp;lt;int&amp;gt;();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToList();
    A.Insert(0, 0);
    B.Insert(0, 0);

    var dict = new Dictionary&amp;lt;(int, int), int&amp;gt;();
    foreach (var (x, y) in Berries)
    {
        var i = LowerBound(A, x);
        var j = LowerBound(B, y);
        if (!dict.ContainsKey((i, j))) dict[(i, j)] = 0;
        dict[(i, j)]++;
    }

    const int Inf = (int)1e9;
    var min = Inf;
    var max = 0;
    foreach (var v in dict.Values)
    {
        min = Math.Min(min, v);
        max = Math.Max(max, v);
    }

    var ok = false;
    for (var i = 1; i &amp;lt;= AN + 1 &amp;amp;&amp;amp; !ok; i++)
    {
        for (var j = 1; j &amp;lt;= BN + 1 &amp;amp;&amp;amp; !ok; j++)
        {
            if (!dict.ContainsKey((i, j)))
            {
                min = 0;
                ok = true;
            }
        }
    }

    Console.WriteLine($&amp;quot;{min} {max}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc304/tasks/abc304_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC304/submissions/41972347"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G&lt;/code&gt;上で頂点&lt;code&gt;x&lt;/code&gt;と頂点&lt;code&gt;y&lt;/code&gt;を結ぶパスが存在しないということは、&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;y&lt;/code&gt;が属する連結成分を&lt;code&gt;gx&lt;/code&gt;、&lt;code&gt;gy&lt;/code&gt;としたとき、&lt;code&gt;gx&lt;/code&gt;と&lt;code&gt;gy&lt;/code&gt;が別の連結成分であることが良いグラフである条件になります。&lt;br /&gt;
このことから、&lt;code&gt;gx&lt;/code&gt;と&lt;code&gt;gy&lt;/code&gt;を接続する辺を追加したときは、&lt;code&gt;G&lt;/code&gt;は良いグラフではなくなります。&lt;br /&gt;
そのため、連結成分ごとに互いに接続してはいけない連結成分を管理し、クエリごとに&lt;code&gt;p&lt;/code&gt;、&lt;code&gt;q&lt;/code&gt;が互いに接続してはいけない連結成分に属していないかを判定することで答えを求めることができます。&lt;br /&gt;
各頂点がどの連結成分に属しているかは、&lt;code&gt;DisjointSetUnion&lt;/code&gt;を使って各連結成分の代表となる頂点をインデックスにするなどの方法で管理することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dsu = new DisjointSetUnion(N);
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        dsu.Merge(u, v);
    }

    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; K; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--; y--;
        var xl = dsu.LeaderOf(x);
        var yl = dsu.LeaderOf(y);
        if (!dict.ContainsKey(xl)) dict[xl] = new HashSet&amp;lt;int&amp;gt;();
        if (!dict.ContainsKey(yl)) dict[yl] = new HashSet&amp;lt;int&amp;gt;();
        dict[xl].Add(yl);
        dict[yl].Add(xl);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (p, q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        p--; q--;
        var pl = dsu.LeaderOf(p);
        var ql = dsu.LeaderOf(q);
        var answer = true;
        if (dict.ContainsKey(pl)) answer &amp;amp;= !dict[pl].Contains(ql);
        if (dict.ContainsKey(ql)) answer &amp;amp;= !dict[ql].Contains(pl);

        Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 304の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230527abc303</id>
		<title>ABC303</title>
		<link href="https://blog.aconcavy.dev/posts/20230527abc303" />
		<updated>2023-05-27T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 303の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc303"&gt;https://atcoder.jp/contests/abc303&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41726568"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;両方の文字列の&lt;code&gt;1&lt;/code&gt;を&lt;code&gt;l&lt;/code&gt;に、&lt;code&gt;0&lt;/code&gt;を&lt;code&gt;o&lt;/code&gt;に変換した文字列が一致する場合、似た文字列となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    string F(string str) =&amp;gt; str.Replace('1', 'l').Replace('0', 'o');
    var answer = F(S) == F(T);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41733840"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G[x][y]&lt;/code&gt;を番号&lt;code&gt;x&lt;/code&gt;と番号&lt;code&gt;y&lt;/code&gt;の人が隣り合ったことがあるかを判定する&lt;code&gt;bool&lt;/code&gt;行列、&lt;code&gt;A[i][j]&lt;/code&gt;を&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;A[i][j+1]&lt;/code&gt;を&lt;code&gt;v&lt;/code&gt;すると、&lt;code&gt;G[u][v]&lt;/code&gt;と&lt;code&gt;G[v][u]&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;にすることができます。&lt;br /&gt;
そして、&lt;code&gt;u&amp;lt;v&lt;/code&gt;となる組み合わせのうち&lt;code&gt;G[u][v]&lt;/code&gt;が&lt;code&gt;false&lt;/code&gt;である組み合わせの数が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[M][].Select(_ =&amp;gt; Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray()).ToArray();
    var G = new bool[N, N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        for (var j = 0; j + 1 &amp;lt; N; j++)
        {
            var u = A[i][j] - 1;
            var v = A[i][j + 1] - 1;
            G[u, v] = true;
            G[v, u] = true;
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            if (!G[i, j]) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41740054"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文の通りにシミュレーションを行います。
ただし、&lt;code&gt;|x|,|y|&amp;lt;=2e5&lt;/code&gt;であるため、アイテムの位置を二次元座標を配列として管理してしまうと、計算量が&lt;code&gt;O(Max(|x|,|y|)^2)&lt;/code&gt;となり実行時間制限に間に合いません。
そのため、アイテムの位置を&lt;code&gt;Set&lt;/code&gt;や&lt;code&gt;HashSet&lt;/code&gt;などで管理することで、時間計算量&lt;code&gt;O(Nlog(M))&lt;/code&gt;や&lt;code&gt;O(N)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, H, K) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    var items = new HashSet&amp;lt;(int X, int Y)&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        items.Add((x, y));
    }

    (int Nx, int Ny) F(int x, int y, char c)
    {
        return c switch
        {
            'R' =&amp;gt; (x + 1, y),
            'L' =&amp;gt; (x - 1, y),
            'U' =&amp;gt; (x, y + 1),
            'D' =&amp;gt; (x, y - 1),
            _ =&amp;gt; (x, y),
        };
    }

    var (cx, cy) = (0, 0);
    foreach (var c in S)
    {
        (cx, cy) = F(cx, cy, c);
        H--;
        if (H &amp;lt; 0)
        {
            Console.WriteLine(&amp;quot;No&amp;quot;);
            return;
        }

        if (items.Contains((cx, cy)) &amp;amp;&amp;amp; H &amp;lt; K)
        {
            items.Remove((cx, cy));
            H = K;
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41746026"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,f] := i番目の文字を入力するときにCapsLockキーのランプがf(OFF|ON)のときの最短の時間
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4種類の操作があり得ます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Xミリ秒でaキーを押す&lt;/li&gt;
&lt;li&gt;Yミリ秒でShiftキーとaキーを押す&lt;/li&gt;
&lt;li&gt;Zミリ秒でCapsLockキーを押した後にaキーを押す&lt;/li&gt;
&lt;li&gt;Zミリ秒でCapsLockキーを押した後にShiftキーとaキーを押す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;初期値
dp[0,OFF]   = 0
dp[1,ON]    = INF

S[i]がaのとき
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,OFF]+X)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,ON] +Y)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,OFF]+Z+Y)
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,ON] +Z+X)

S[i]がAのとき
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,OFF]+Y)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,ON] +Y)
dp[i+1,ON]  = Min(dp[i+1,ON],  dp[i,OFF]+Z+X)
dp[i+1,OFF] = Min(dp[i+1,OFF], dp[i,ON] +Z+Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;まとめると次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;S[i]がaのときf=0,Aのときf=1とする
dp[i+1,f]   = Min(dp[i+1,f],   dp[i,f]  +X)
dp[i+1,f^1] = Min(dp[i+1,f^1], dp[i,f^1]+Y)
dp[i+1,f]   = Min(dp[i+1,f],   dp[i,f^1]+Z+X)
dp[i+1,f^1] = Min(dp[i+1,f^1], dp[i,f]  +Z+Y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;文字目まで入力後の&lt;code&gt;Min(dp[N,OFF],dp[N,ON])&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, Z) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var dp = new long[N + 1, 2];
    const long Inf = (long)1e18;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        dp[i, 0] = dp[i, 1] = Inf;
    }

    dp[0, 0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var f = S[i] == 'a' ? 0 : 1;
        var g = f ^ 1;
        dp[i + 1, f] = Math.Min(dp[i + 1, f], dp[i, f] + X);
        dp[i + 1, g] = Math.Min(dp[i + 1, g], dp[i, g] + Y);
        dp[i + 1, f] = Math.Min(dp[i + 1, f], dp[i, g] + Z + X);
        dp[i + 1, g] = Math.Min(dp[i + 1, g], dp[i, f] + Z + Y);
    }

    var answer = Math.Min(dp[N, 0], dp[N, 1]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc303/tasks/abc303_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC303/submissions/41770653"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;星の中心となる頂点は、葉となる頂点と辺で結ばれている頂点になります。&lt;br /&gt;
また、星の中心となる頂点と辺で結ばれている頂点はすべて葉である必要があります。&lt;br /&gt;
そのため、葉となる頂点&lt;code&gt;u&lt;/code&gt;を順番に見ていき、その葉を含む星の中心となる頂点&lt;code&gt;v&lt;/code&gt;と辺で結ばれている頂点&lt;code&gt;w&lt;/code&gt;に結ばれている辺のうち、&lt;code&gt;v&lt;/code&gt;以外の辺を全て取り除くことで、&lt;code&gt;v&lt;/code&gt;の辺の数がレベルとなる星にすることができます。&lt;br /&gt;
また、グラフは木であるため、&lt;code&gt;w&lt;/code&gt;と結ばれている辺を削除した頂点&lt;code&gt;x&lt;/code&gt;は新しく葉となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;  u -- v -- w
            |
  z -- y -- x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var deg = new int[N];
    var G = new HashSet&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new HashSet&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--;
        v--;
        G[u].Add(v);
        G[v].Add(u);
        deg[u]++;
        deg[v]++;
    }

    var queue = new Queue&amp;lt;int&amp;gt;();

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (deg[i] == 1) queue.Enqueue(i);
    }

    var answer = new List&amp;lt;int&amp;gt;();
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        if (G[u].Count &amp;lt; 1) continue;
        var v = G[u].First();
        var vd = G[v].Count;
        answer.Add(vd);

        var removed = new List&amp;lt;(int, int)&amp;gt;();
        foreach (var w in G[v])
        {
            foreach (var x in G[w])
            {
                removed.Add((w, x));
                deg[w]--;
                deg[x]--;
                queue.Enqueue(x);
            }
        }

        foreach (var (x, y) in removed)
        {
            G[x].Remove(y);
            G[y].Remove(x);
        }
    }

    answer.Sort();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 303の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230520abc302</id>
		<title>ABC302</title>
		<link href="https://blog.aconcavy.dev/posts/20230520abc302" />
		<updated>2023-05-21T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 302の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc302"&gt;https://atcoder.jp/contests/abc302&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41536854"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ceil(A/B)&lt;/code&gt;が答えになるので、&lt;code&gt;(A+B-1)/B&lt;/code&gt;で切り上げた値を得ることができます。&lt;br /&gt;
また、double型などの浮動小数点型だと、精度の問題で正しい値を求めることができないことがあります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answer = (A + B - 1) / B;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41548153"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;snuke&lt;/code&gt;文字列の始点のマスの位置を&lt;code&gt;(ch,cw)&lt;/code&gt;、&lt;code&gt;snuke&lt;/code&gt;文字列が続く方向を&lt;code&gt;(dh,dw)&lt;/code&gt;とすると、&lt;code&gt;snuke&lt;/code&gt;文字列の&lt;code&gt;k&lt;/code&gt;文字目は&lt;code&gt;(ch+dh*k,cw+dw*k)&lt;/code&gt;の位置のマスになります。この位置のマスがグリッド上にあり、5文字全て一致している場合、始点から順に出力することで答えを得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new char[H][];
    const string Snuke = &amp;quot;snuke&amp;quot;;

    for (var i = 0; i &amp;lt; H; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    for (var ch = 0; ch &amp;lt; H; ch++)
    {
        for (var cw = 0; cw &amp;lt; W; cw++)
        {
            for (var dh = -1; dh &amp;lt;= 1; dh++)
            {
                for (var dw = -1; dw &amp;lt;= 1; dw++)
                {
                    var ok = true;
                    for (var k = 0; k &amp;lt; 5 &amp;amp;&amp;amp; ok; k++)
                    {
                        var nh = ch + dh * k;
                        var nw = cw + dw * k;
                        if (nh &amp;lt; 0 || nh &amp;gt;= H || nw &amp;lt; 0 || nw &amp;gt;= W)
                        {
                            ok = false;
                            break;
                        }

                        ok &amp;amp;= S[nh][nw] == Snuke[k];
                    }

                    if (ok)
                    {
                        for (var k = 0; k &amp;lt; 5; k++)
                        {
                            Console.WriteLine($&amp;quot;{ch + 1 + dh * k} {cw + 1 + dw * k}&amp;quot;);
                        }
                        return;
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41550544"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の文字列の順列を全探索し、いずれかの場合において条件を満たすことができるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    foreach (var perm in Permute(Enumerable.Range(0, N)))
    {
        var answer = true;
        for (var k = 0; k + 1 &amp;lt; N; k++)
        {
            var curr = perm[k];
            var next = perm[k + 1];
            var diff = 0;
            for (var i = 0; i &amp;lt; M; i++)
            {
                if (S[curr][i] != S[next][i]) diff++;
            }

            answer &amp;amp;= diff == 1;
        }

        if (answer)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}

public static IEnumerable&amp;lt;T[]&amp;gt; Permute&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    if (source is null) throw new ArgumentNullException(nameof(source));
    IEnumerable&amp;lt;T[]&amp;gt; Inner()
    {
        var items = source.ToArray();
        var n = items.Length;
        var indices = new int[n];
        for (var i = 0; i &amp;lt; indices.Length; i++)
        {
            indices[i] = i;
        }
        T[] Result()
        {
            var result = new T[n];
            for (var i = 0; i &amp;lt; n; i++)
            {
                result[i] = items[indices[i]];
            }
            return result;
        }
        yield return Result();
        while (true)
        {
            var (i, j) = (n - 2, n - 1);
            while (i &amp;gt;= 0)
            {
                if (indices[i] &amp;lt; indices[i + 1]) break;
                i--;
            }
            if (i == -1) yield break;
            while (true)
            {
                if (indices[j] &amp;gt; indices[i]) break;
                j--;
            }
            (indices[i], indices[j]) = (indices[j], indices[i]);
            Array.Reverse(indices, i + 1, n - 1 - i);
            yield return Result();
        }
    }
    return Inner();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41557498"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての組み合わせを考えてしまうと、時間計算量が&lt;code&gt;O(NM)&lt;/code&gt;になり、実行時間制限に間に合いません。
&lt;code&gt;A&lt;/code&gt;を固定して考えたとき、&lt;code&gt;A[i]&lt;/code&gt;に対して選ぶことができる&lt;code&gt;B&lt;/code&gt;の最大の贈り物は&lt;code&gt;A[i]+D&lt;/code&gt;以下のものになります。&lt;br /&gt;
ここで、&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;A[i]+D&lt;/code&gt;以下になる最大のものを&lt;code&gt;B&lt;/code&gt;をソートして二部探索で求めることで、各&lt;code&gt;A[i]&lt;/code&gt;に対して時間計算量&lt;code&gt;O(logM)&lt;/code&gt;で求めることができ、まとめると時間計算量&lt;code&gt;O(NlogM)&lt;/code&gt;で求めることができます。
同様に、&lt;code&gt;B&lt;/code&gt;を固定して考えたとき、時間計算量&lt;code&gt;O(MlogN)&lt;/code&gt;で求めることができるため、全体時間計算量は&lt;code&gt;O(NlogM+MlogN)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, D) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    Array.Sort(A);
    Array.Sort(B);
    long answer = -1;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var a = A[i];
        var j = Math.Max(0, UpperBound(B, a + D) - 1);
        var b = B[j];
        if (Math.Abs(a - b) &amp;lt;= D)
        {
            answer = Math.Max(answer, a + b);
        }
    }

    for (var i = 0; i &amp;lt; M; i++)
    {
        var b = B[i];
        var j = Math.Max(0, UpperBound(A, b + D) - 1);
        var a = A[j];
        if (Math.Abs(b - a) &amp;lt;= D)
        {
            answer = Math.Max(answer, b + a);
        }
    }

    Console.WriteLine(answer);
}

public static int UpperBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m].CompareTo(key) &amp;gt; 0) r = m;
        else l = m;
    }

    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41563876"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点ごとに辺で結ばれている頂点の集合を管理しながら、クエリごとにシミュレートを行います。&lt;br /&gt;
「他のどの頂点とも辺で結ばれていない頂点」の数を&lt;code&gt;answer&lt;/code&gt;とします。
初期状態として、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;N&lt;/code&gt;になります。&lt;/p&gt;
&lt;p&gt;1番のクエリについて、頂点&lt;code&gt;u&lt;/code&gt;がその時点でほかのどの頂点とも辺で結ばれていない場合、頂点&lt;code&gt;v&lt;/code&gt;と辺で結ばれるため、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;-1&lt;/code&gt;されます。
同様に、頂点&lt;code&gt;v&lt;/code&gt;の場合も、その時点でほかのどの頂点とも辺で結ばれていない場合、頂点&lt;code&gt;u&lt;/code&gt;と辺で結ばれるため、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;-1&lt;/code&gt;されます。&lt;/p&gt;
&lt;p&gt;2番のクエリについて、頂点&lt;code&gt;v&lt;/code&gt;がその時点でいずれかの頂点と辺で結ばれている場合、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;+1&lt;/code&gt;されます。
また、頂点&lt;code&gt;v&lt;/code&gt;と辺で結ばれている各頂点について、その頂点の辺で結ばれている頂点集合から頂点&lt;code&gt;v&lt;/code&gt;を削除した後、その頂点の辺で結ばれている頂点が存在しない場合、&lt;code&gt;answer&lt;/code&gt;は&lt;code&gt;+1&lt;/code&gt;されます。
その後、頂点&lt;code&gt;v&lt;/code&gt;の辺で結ばれている頂点の集合をすべて削除します。&lt;/p&gt;
&lt;p&gt;辺で結ばれている頂点の集合を&lt;code&gt;HashSet&lt;/code&gt;などのデータ構造を用いることで、追加と削除を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で行うことができ、全体時間計算量&lt;code&gt;O(Q)&lt;/code&gt;でシミュレートすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var connected = new HashSet&amp;lt;int&amp;gt;[N].Select(_ =&amp;gt; new HashSet&amp;lt;int&amp;gt;()).ToArray();
    var answer = N;

    for (var i = 0; i &amp;lt; Q; i++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var queryType = query[0];
        var queryArgs = query.AsSpan(1);

        void QF1(ReadOnlySpan&amp;lt;int&amp;gt; queryArgs)
        {
            var (u, v) = (queryArgs[0] - 1, queryArgs[1] - 1);
            if (connected[u].Count == 0) answer--;
            if (connected[v].Count == 0) answer--;
            connected[u].Add(v);
            connected[v].Add(u);
            Console.WriteLine(answer);
        }

        void QF2(ReadOnlySpan&amp;lt;int&amp;gt; queryArgs)
        {
            var u = queryArgs[0] - 1;
            if (connected[u].Count != 0) answer++;
            foreach (var v in connected[u])
            {
                connected[v].Remove(u);
                if (connected[v].Count == 0) answer++;
            }
            connected[u].Clear();

            Console.WriteLine(answer);
        }

        switch (queryType)
        {
            case 1:
                QF1(queryArgs);
                break;
            case 2:
                QF2(queryArgs);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc302/tasks/abc302_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC302/submissions/41573888"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;各集合を頂点とした幅優先探索を行います。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;整数&lt;code&gt;x&lt;/code&gt;が属する集合群を&lt;code&gt;Has[x]&lt;/code&gt;としたとき、始点は&lt;code&gt;Has[1]&lt;/code&gt;に属する集合群になります。&lt;/del&gt;
&lt;del&gt;また、&lt;code&gt;Has[1]&lt;/code&gt;に属する集合を&lt;code&gt;u&lt;/code&gt;としたとき、&lt;code&gt;S[u]&lt;/code&gt;の整数集合の最小操作回数は&lt;code&gt;0&lt;/code&gt;になります。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;幅優先探索において、遷移元の集合を&lt;code&gt;u&lt;/code&gt;としたとき、&lt;code&gt;u&lt;/code&gt;から遷移することができる集合群は、整数&lt;code&gt;S[u][i] (1&amp;lt;=i&amp;lt;=A[u])&lt;/code&gt;を含む集合、つまり&lt;code&gt;Has[S[u][i]]&lt;/code&gt;の集合群になります。&lt;/del&gt;
&lt;del&gt;整数&lt;code&gt;S[u][i]&lt;/code&gt;を&lt;code&gt;s1&lt;/code&gt;、&lt;code&gt;s1&lt;/code&gt;を含む集合を&lt;code&gt;v&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;に含まれる整数&lt;code&gt;S[u][j] (1&amp;lt;=j&amp;lt;=A[v])&lt;/code&gt;を&lt;code&gt;s2&lt;/code&gt;、整数&lt;code&gt;x&lt;/code&gt;への最小操作回数を&lt;code&gt;costs[x]&lt;/code&gt;としたとき、&lt;code&gt;s2&lt;/code&gt;への遷移回数は&lt;code&gt;Min(costs[s2],costs[s1]+1)&lt;/code&gt;になります。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;よって、時間計算量&lt;code&gt;O(N+M+Sum(A))&lt;/code&gt;で答えを求めることができます。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023/05/22更新&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;を集合の番号、頂点&lt;code&gt;N+1&lt;/code&gt;から&lt;code&gt;N+M&lt;/code&gt;を&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;M&lt;/code&gt;の整数に対応させ、集合から整数、整数から集合に対してそれぞれコスト1の辺を張ったグラフを作成し、幅優先探索を行います。&lt;/p&gt;
&lt;p&gt;集合から整数、整数から集合に対しての移動で2回の移動をしているため、答えが2倍になることに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new int[N][];
    var G = new List&amp;lt;int&amp;gt;[N + M + 1].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        _ = Scanner.Scan&amp;lt;int&amp;gt;();
        S[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        foreach (var s in S[i])
        {
            G[i + 1].Add(N + s);
            G[N + s].Add(i + 1);
        }
    }

    var queue = new Queue&amp;lt;int&amp;gt;();
    var costs = new int[N + M + 1];
    Array.Fill(costs, -1);
    costs[N + 1] = 0;
    queue.Enqueue(N + 1);

    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        foreach (var v in G[u])
        {
            if (costs[v] != -1) continue;
            costs[v] = costs[u] + 1;
            queue.Enqueue(v);
        }
    }

    var answer = costs[N + M];
    if (answer != -1) answer = (answer - 1) / 2;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 302の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20230513abc301</id>
		<title>ABC301</title>
		<link href="https://blog.aconcavy.dev/posts/20230513abc301" />
		<updated>2023-05-13T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 301の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301"&gt;https://atcoder.jp/contests/abc301&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41344570"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;勝った試合の数が多い方が総合勝者ということは、総合勝者は半分以上の試合で勝っていることになります。
また、勝ち数が同じ場合は先にその勝ち数に達したものが総合勝者となるので、順に勝ち数を数え上げ、先に過半数を取得した方が総合勝者になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var t = 0;
    var a = 0;
    foreach (var c in S)
    {
        if (c == 'T') t++;
        else a++;
        if (t * 2 &amp;gt;= N)
        {
            Console.WriteLine(&amp;quot;T&amp;quot;);
            return;
        }
        else if (a * 2 &amp;gt;= N)
        {
            Console.WriteLine(&amp;quot;A&amp;quot;);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41350380"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数列の1項目は&lt;code&gt;A&lt;/code&gt;の1項目になります。&lt;br /&gt;
&lt;code&gt;A&lt;/code&gt;の2項目以降を考えます。
数列に最後に追加した値を&lt;code&gt;x&lt;/code&gt;、&lt;code&gt;A&lt;/code&gt;の次の項を&lt;code&gt;a&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&amp;lt;a&lt;/code&gt;の間は、次に&lt;code&gt;x+1&lt;/code&gt;を追加する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&amp;gt;a&lt;/code&gt;の間は、次に&lt;code&gt;x-1&lt;/code&gt;を追加する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x==a&lt;/code&gt;の場合は、&lt;code&gt;a&lt;/code&gt;を&lt;code&gt;A&lt;/code&gt;の次の項に更新する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という操作を繰り返すことで、答えとなる数列を生成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    IEnumerable&amp;lt;int&amp;gt; F()
    {
        var x = A[0];
        yield return x;
        foreach (var a in A.Skip(1))
        {
            while (x &amp;lt; a) yield return ++x;
            while (x &amp;gt; a) yield return --x;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, F()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41358374"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二つの文字列を構成する文字の個数が全て一致する必要があります。
&lt;code&gt;atcoder&lt;/code&gt;の各文字の個数が一致しない場合、少ない方の個数をその文字列にある&lt;code&gt;&amp;#64;&lt;/code&gt;の個数以内で補うことができます。
補う操作を行ったうえで&lt;code&gt;atcoder&lt;/code&gt;の文字の個数が一致し、ほかの文字の個数もすべて一致した場合のみ答えは&lt;code&gt;Yes&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;

    int[] F(string str)
    {
        var used = new int[27];
        foreach (var c in str)
        {
            if (c == '&amp;#64;') used[26]++;
            else used[c - 'a']++;
        }

        return used;
    }

    var usedS = F(S);
    var usedT = F(T);
    var answer = true;

    bool G(int i)
    {
        foreach (var c in &amp;quot;atcoder&amp;quot;)
        {
            if (c - 'a' == i) return true;
        }

        return false;
    }

    for (var i = 0; i &amp;lt; 26; i++)
    {
        var s = usedS[i];
        var t = usedT[i];
        if (s == t) continue;
        if (G(i))
        {
            if (s &amp;gt; t)
            {
                var d = s - t;
                answer &amp;amp;= usedT[26] &amp;gt;= d;
                usedT[26] -= d;
            }
            else
            {
                var d = t - s;
                answer &amp;amp;= usedS[26] &amp;gt;= d;
                usedS[26] -= d;
            }
        }
        else
        {
            answer = false;
            break;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41372439"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt;の部分を全て&lt;code&gt;0&lt;/code&gt;にした値が&lt;code&gt;N&lt;/code&gt;より大きい場合、答えは&lt;code&gt;-1&lt;/code&gt;となります。
それ以外の場合、桁の大きいところから順にみていき、その&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;1&lt;/code&gt;にした値が&lt;code&gt;N&lt;/code&gt;以下であるかを判定していくことで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    var N = Scanner.Scan&amp;lt;long&amp;gt;();

    long answer = 0;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        if (S[i] != '?') answer |= (long)(S[i] - '0') &amp;lt;&amp;lt; (S.Length - 1 - i);
    }

    if (answer &amp;gt; N)
    {
        Console.WriteLine(-1);
        return;
    }

    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        if (S[i] != '?') continue;
        var v = answer | (1L &amp;lt;&amp;lt; (S.Length - 1 - i));
        if (v &amp;lt;= N) answer = v;
    }

    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc301/tasks/abc301_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc301/submissions/41395116"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スタートマスからゴールマスの最小移動回数が&lt;code&gt;T&lt;/code&gt;より大きいとき、答えは&lt;code&gt;-1&lt;/code&gt;になります。
それ以外のとき、次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s][u] := 訪れたお菓子のマスの集合がs、現在値がお菓子のマスがuのときの最小移動回数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;初期値:
dp[1&amp;lt;&amp;lt;u][u] = スタートマスからお菓子のマスuへの最小移動回数

遷移:
訪れたお菓子のマスの集合がs、お菓子のマスuからお菓子のマスvにD(u,v)の移動回数がかかるとき、
dp[s|(1&amp;lt;&amp;lt;v)][v] = Min(dp[s|(1&amp;lt;&amp;lt;v)][v], dp[s][u]+D(u,v))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、各状態からゴールマスへの移動回数を足したものが&lt;code&gt;T&lt;/code&gt;回以下であるときの訪れたお菓子のマスの個数の最大値が答えとなります。&lt;br /&gt;
お菓子のマスの個数を&lt;code&gt;M&lt;/code&gt;とすると、各お菓子のマスを始点とした幅優先探索を行うことで、&lt;code&gt;D(u,v)&lt;/code&gt;は時間計算量&lt;code&gt;O(MHW)&lt;/code&gt;で求めることができます。
よって、時間計算量&lt;code&gt;O(MHW+(2^M)*M^2)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, T) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = new char[H][];
    var G = new bool[H][];
    var (sh, sw) = (0, 0);
    var (gh, gw) = (0, 0);
    var map = new Dictionary&amp;lt;(int, int), int&amp;gt;();
    var M = 0;
    var snacks = new List&amp;lt;(int H, int W)&amp;gt;();

    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        G[i] = new bool[W];
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (A[i][j] == 'S') (sh, sw) = (i, j);
            if (A[i][j] == 'G') (gh, gw) = (i, j);
            if (A[i][j] == 'o')
            {
                map[(i, j)] = M++;
                snacks.Add((i, j));
            }

            G[i][j] = A[i][j] != '#';
        }
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };
    const int Inf = (int)1e9;

    int[][] GetDistance(int h, int w)
    {
        var result = new int[H][];
        for (var i = 0; i &amp;lt; H; i++)
        {
            result[i] = new int[W];
            for (var j = 0; j &amp;lt; W; j++)
            {
                result[i][j] = Inf;
            }
        }

        result[h][w] = 0;
        var queue = new Queue&amp;lt;(int, int)&amp;gt;();
        queue.Enqueue((h, w));
        while (queue.Count &amp;gt; 0)
        {
            var (ch, cw) = queue.Dequeue();
            foreach (var (dh, dw) in D4)
            {
                var (nh, nw) = (ch + dh, cw + dw);
                if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
                if (!G[nh][nw] || result[nh][nw] != Inf) continue;
                result[nh][nw] = result[ch][cw] + 1;
                queue.Enqueue((nh, nw));
            }
        }

        return result;
    }

    var startToGoal = GetDistance(sh, sw)[gh][gw];
    if (startToGoal &amp;gt; T)
    {
        Console.WriteLine(-1);
        return;
    }

    var snackDistances = new int[M][][];
    for (var k = 0; k &amp;lt; M; k++)
    {
        var (h, w) = snacks[k];
        snackDistances[k] = GetDistance(h, w);
    }

    var dp = new int[1 &amp;lt;&amp;lt; M, M];
    for (var i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; M; i++)
    {
        for (var j = 0; j &amp;lt; M; j++)
        {
            dp[i, j] = Inf;
        }
    }

    for (var u = 0; u &amp;lt; M; u++)
    {
        dp[1 &amp;lt;&amp;lt; u, u] = snackDistances[u][sh][sw];
    }

    for (var cs = 0; cs &amp;lt; 1 &amp;lt;&amp;lt; M; cs++)
    {
        for (var u = 0; u &amp;lt; M; u++)
        {
            if ((cs &amp;gt;&amp;gt; u &amp;amp; 1) == 0) continue;
            for (var v = 0; v &amp;lt; M; v++)
            {
                if ((cs &amp;gt;&amp;gt; v &amp;amp; 1) == 1) continue;
                var (nh, nw) = snacks[v];
                var nd = dp[cs, u] + snackDistances[u][nh][nw];
                var ns = cs | (1 &amp;lt;&amp;lt; v);
                dp[ns, v] = Math.Min(dp[ns, v], nd);
            }
        }
    }

    var answer = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; M; s++)
    {
        for (var u = 0; u &amp;lt; M; u++)
        {
            var gd = dp[s, u] + snackDistances[u][gh][gw];
            if (gd &amp;lt;= T)
            {
                var count = 0;
                for (var i = 0; i &amp;lt; M; i++)
                {
                    count += (s &amp;gt;&amp;gt; i) &amp;amp; 1;
                }

                answer = Math.Max(answer, count);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 301の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>