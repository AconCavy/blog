<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title />
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2022 AconCavy</rights>
	<updated>2022-11-19T17:02:26Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221119abc278</id>
		<title>ABC278</title>
		<link href="https://blog.aconcavy.dev/posts/20221119abc278" />
		<updated>2022-11-19T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 278の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc278"&gt;https://atcoder.jp/contests/abc278&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36599335"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;で初期化した長さ&lt;code&gt;N&lt;/code&gt;の配列に先頭から&lt;code&gt;A[i+K]&lt;/code&gt;の値を&lt;code&gt;N-K&lt;/code&gt;回代入することで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = new int[N];
    for (var i = 0; i &amp;lt; N - K; i++)
    {
        B[i] = A[i + K];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36606958"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;見間違えやすい時刻は、元の時刻の&lt;code&gt;AB:CD&lt;/code&gt;となる時刻であり、&lt;code&gt;AB&lt;/code&gt;は時の&lt;code&gt;10&lt;/code&gt;の位と分の&lt;code&gt;10&lt;/code&gt;の位の値、&lt;code&gt;CD&lt;/code&gt;は時の&lt;code&gt;1&lt;/code&gt;の位と分の&lt;code&gt;1&lt;/code&gt;の位の値になり、&lt;code&gt;0&amp;lt;=AB&amp;lt;24&lt;/code&gt;かつ&lt;code&gt;0&amp;lt;=AB&amp;lt;60&lt;/code&gt;であることが必要です。
順に時刻をみていき、条件を満たす時刻が答えとなります。&lt;br /&gt;
&lt;code&gt;h=23, m=59&lt;/code&gt;のときなど、&lt;code&gt;00 00&lt;/code&gt;が答えとなることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    for (var h = H; h &amp;lt; 24; h++)
    {
        for (var m = 0; m &amp;lt; 60; m++)
        {
            if (h == H &amp;amp;&amp;amp; m &amp;lt; M) continue;
            var ab = h / 10 * 10 + m / 10;
            var cd = h % 10 * 10 + m % 10;
            if (ab &amp;lt; 24 &amp;amp;&amp;amp; cd &amp;lt; 60)
            {
                Console.WriteLine($&amp;quot;{h} {m}&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;0 0&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36610705"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ユーザがフォローしている人の集合を辞書で管理し、&lt;code&gt;t==1,2&lt;/code&gt;のときは集合を更新、&lt;code&gt;t==3&lt;/code&gt;のときはそれぞれのユーザがフォローしている人の集合に存在しているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (t, a, b) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        if (!dict.ContainsKey(a)) dict[a] = new HashSet&amp;lt;int&amp;gt;();
        if (!dict.ContainsKey(b)) dict[b] = new HashSet&amp;lt;int&amp;gt;();

        if (t == 1)
        {
            dict[a].Add(b);
        }
        else if (t == 2)
        {
            dict[a].Remove(b);
        }
        else
        {
            var answer = dict[a].Contains(b) &amp;amp;&amp;amp; dict[b].Contains(a);
            Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36621868"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36652094"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに配列のすべての値を更新してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になり、実行時間制限に間に合いません。&lt;br /&gt;
クエリの形式が&lt;code&gt;1&lt;/code&gt;における最新の全体更新の時間と値、数列&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目の値が最後に更新された時間を管理し、クエリの形式が&lt;code&gt;2&lt;/code&gt;か&lt;code&gt;3&lt;/code&gt;のときに&lt;code&gt;i&lt;/code&gt;番目の更新された時間が最新の全体更新の時間よりも前ならば、&lt;code&gt;i&lt;/code&gt;番目の値を最新の全体更新の値に変更してから処理を行うことで、時間計算量&lt;code&gt;O(N+Q)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
区間変更区間更新が可能な遅延セグメント木などのデータ構造を用いてクエリごとに値を更新することでも、時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var latest = (T: -1, X: 0);
    var updated = new int[N];
    Array.Fill(updated, -1);

    void Update(int i, int x)
    {
        if (updated[i] &amp;lt; latest.T) A[i] = latest.X;
    }

    for (var t = 0; t &amp;lt; Q; t++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var q = query[0];
        if (q == 1)
        {
            var x = query[1];
            latest = (t, x);
        }
        else if (q == 2)
        {
            var (i, x) = (query[1] - 1, query[2]);
            Update(i);
            A[i] += x;
            updated[i] = t;
        }
        else
        {
            var i = query[1] - 1;
            Update(i);
            Console.WriteLine(A[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36626239"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に範囲にある数を計算してしまうと、時間計算量が&lt;code&gt;O(H^2W^2)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
そこで、マスに書かれている値&lt;code&gt;c&lt;/code&gt;ごとの二次元累積和を求めておくと、マス目全体の&lt;code&gt;c&lt;/code&gt;の数と黒く塗りつぶした部分の&lt;code&gt;c&lt;/code&gt;の数を引くことで、塗りつぶされていないマスに書かれている&lt;code&gt;c&lt;/code&gt;の数を数え上げることができます。
これにより、二次元累積和の構築には時間計算量&lt;code&gt;O(HW)&lt;/code&gt;がかかり、&lt;code&gt;c&lt;/code&gt;の数え上げには時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。&lt;br /&gt;
そして、各&lt;code&gt;(k,l)&lt;/code&gt;ごとに&lt;code&gt;N&lt;/code&gt;種類の&lt;code&gt;c&lt;/code&gt;の数を求めることになるので、全体計算量&lt;code&gt;O(HW+HWN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, N, h, w) = Scanner.Scan&amp;lt;int, int, int, int, int&amp;gt;();
    var A = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var cum = new CumulativeSum2D[N].Select(_ =&amp;gt; new CumulativeSum2D(H, W)).ToArray();
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            var a = A[i][j] - 1;
            cum[a].Add(i, j, 1);
        }
    }

    var answer = new int[H - h + 1].Select(_ =&amp;gt; new int[W - w + 1]).ToArray();

    for (var i = 0; i &amp;lt; H - h + 1; i++)
    {
        for (var j = 0; j &amp;lt; W - w + 1; j++)
        {
            var sum = 0;
            for (var k = 0; k &amp;lt; N; k++)
            {
                var all = cum[k].Sum(H, W);
                var blak = cum[k].Sum(i, j, i + h, j + w);
                if (all - blak &amp;gt; 0) sum++;
            }

            answer[i][j] = sum;
        }
    }

    Printer.Print2D(answer, &amp;quot; &amp;quot;);
}

public class CumulativeSum2D
{
    public int Height { get; }
    public int Width { get; }
    private readonly long[] _data;
    private readonly long[] _sum;
    private bool _isUpdated;

    public CumulativeSum2D(int height, int width)
    {
        if (height &amp;lt;= 0) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt;= 0) throw new ArgumentOutOfRangeException(nameof(width));
        Height = height;
        Width = width;
        _data = new long[height * width];
        _sum = new long[(height + 1) * (width + 1)];
    }

    public void Add(int height, int width, long value)
    {
        if (height &amp;lt; 0 || Height &amp;lt;= height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt;= width) throw new ArgumentOutOfRangeException(nameof(width));
        _isUpdated = false;
        _data[height * Width + width] += value;
    }

    public void Set(int height, int width, long value)
    {
        if (height &amp;lt; 0 || Height &amp;lt;= height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt;= width) throw new ArgumentOutOfRangeException(nameof(width));
        _isUpdated = false;
        _data[height * Width + width] = value;
    }

    public long Get(int height, int width)
    {
        if (height &amp;lt; 0 || Height &amp;lt;= height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt;= width) throw new ArgumentOutOfRangeException(nameof(width));
        return _data[height * Width + width];
    }

    public long Sum(int height, int width)
    {
        if (height &amp;lt; 0 || Height &amp;lt; height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt; width) throw new ArgumentOutOfRangeException(nameof(width));
        if (!_isUpdated) Build();
        return _sum[height * (Width + 1) + width];
    }

    public long Sum(int height1, int width1, int height2, int width2)
    {
        if (height1 &amp;lt; 0 || Height &amp;lt; height1) throw new ArgumentOutOfRangeException(nameof(height1));
        if (width1 &amp;lt; 0 || Width &amp;lt; width1) throw new ArgumentOutOfRangeException(nameof(width1));
        if (height2 &amp;lt; 0 || Height &amp;lt; height2) throw new ArgumentOutOfRangeException(nameof(height2));
        if (width2 &amp;lt; 0 || Width &amp;lt; width2) throw new ArgumentOutOfRangeException(nameof(width2));
        if (!_isUpdated) Build();
        var w1 = Width + 1;
        return _sum[height1 * w1 + width1]
               + _sum[height2 * w1 + width2]
               - _sum[height2 * w1 + width1]
               - _sum[height1 * w1 + width2];
    }

    private void Build()
    {
        _isUpdated = true;
        var w1 = Width + 1;
        _sum[0] = _sum[w1] = _sum[1] = 0;
        for (var i = 1; i &amp;lt;= Height; i++)
        for (var j = 1; j &amp;lt;= Width; j++)
            _sum[i * w1 + j] =
                _sum[i * w1 + (j - 1)]
                + _sum[(i - 1) * w1 + j]
                - _sum[(i - 1) * w1 + (j - 1)]
                + _data[(i - 1) * Width + (j - 1)];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 278の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221112abc277</id>
		<title>ABC277</title>
		<link href="https://blog.aconcavy.dev/posts/20221112abc277" />
		<updated>2022-11-12T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 277の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc277"&gt;https://atcoder.jp/contests/abc277&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36407369"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;を順にみていき、&lt;code&gt;A[i]==X&lt;/code&gt;となる位置が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A[i] == X) answer = i + 1;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36412022"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一つ一つの文字を条件式として判別しても答えを求めることが可能ですが、2文字目の判定の対象が多いので、配列や&lt;code&gt;HashSet&lt;/code&gt;等のデータ構造に集合として値を用意し、その集合に含まれているかどうかを判定することで、簡単に記述することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = true;
    var F = new HashSet&amp;lt;char&amp;gt; { 'H', 'D', 'C', 'S' };
    var G = new HashSet&amp;lt;char&amp;gt; { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
    var memo = new HashSet&amp;lt;string&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        answer &amp;amp;= F.Contains(s[0]);
        answer &amp;amp;= G.Contains(s[1]);
        answer &amp;amp;= !memo.Contains(s);
        memo.Add(s);
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36416984"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;階層を頂点としたグラフを構築し、深さ優先探索や幅優先探索を行うことで、行くことができる階層を探索して最高の階層を求めます。&lt;br /&gt;
階層をそのまま頂点としたグラフを配列で構築してしまうと、はしごがつながっていない階層含めて&lt;code&gt;1e9&lt;/code&gt;もの空間計算量が必要になってしまい、実行時間制限に間に合わなくなってしまいます。
そこで、頂点を圧縮したり、辞書などのデータ構造を用いることで、はしごがつながっていない階層を無視することができ、最大でも&lt;code&gt;4e5&lt;/code&gt;程度の空間計算量で収まり、実行時間制限内に処理することができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (!G.ContainsKey(a)) G[a] = new List&amp;lt;int&amp;gt;();
        if (!G.ContainsKey(b)) G[b] = new List&amp;lt;int&amp;gt;();
        G[a].Add(b);
        G[b].Add(a);
    }

    var used = new HashSet&amp;lt;int&amp;gt; { 1 };
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(1);
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        if (!G.ContainsKey(u)) continue;
        foreach (var v in G[u])
        {
            if (used.Contains(v)) continue;
            used.Add(v);
            queue.Enqueue(v);
        }
    }

    var answer = used.Max();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36436734"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36455348"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作について、あるカードの整数&lt;code&gt;v&lt;/code&gt;をテーブルに置いたとき、次に出すことができるカードは&lt;code&gt;v&lt;/code&gt;または&lt;code&gt;(v+1)%M&lt;/code&gt;であることから、整数&lt;code&gt;v&lt;/code&gt;のカードを出した時は、整数&lt;code&gt;v&lt;/code&gt;のカードを全て出すことができます。
そのため、カードの整数ごとに出すことのできる枚数や総和を辞書などでまとめあげることができます。
整数&lt;code&gt;v&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を出した時の総和&lt;code&gt;s&lt;/code&gt;のペアを&lt;code&gt;P&lt;/code&gt;とし、&lt;code&gt;P&lt;/code&gt;を&lt;code&gt;v&lt;/code&gt;でソートすると、&lt;code&gt;P[i+1].v%M==(P[i].v+1)%M&lt;/code&gt;となる区間の総和が出すことができるカードの総和となります。
この区間の総和は尺取り法で求めることができ、その最大値を&lt;code&gt;A&lt;/code&gt;の総和から引いたものが答えとなります。
また、&lt;code&gt;v==M-1&lt;/code&gt;のとき&lt;code&gt;(v+1)%M&lt;/code&gt;は&lt;code&gt;0&lt;/code&gt;になり、円環になることがあるので注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    long sum = 0;
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    foreach (var a in A)
    {
        if (!dict.ContainsKey(a)) dict[a] = 0;
        dict[a] += a;
        sum += a;
    }

    var K = dict.Count;
    var B = new List&amp;lt;(int V, long S)&amp;gt;(dict.Select(kv =&amp;gt; (kv.Key, kv.Value)));
    B.Sort();
    var l = 0;
    var r = 0;

    const long inf = (long)1e18;
    var answer = inf;
    while (l &amp;lt; K)
    {
        r = l;
        var s = B[r].S;
        while (r + 1 &amp;lt; l + K &amp;amp;&amp;amp; (B[(r + 1) % K].V % M) == (B[r % K].V + 1) % M)
        {
            s += B[(r + 1) % K].S;
            r++;
        }

        answer = Math.Min(answer, sum - s);
        l = r + 1;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36429660"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スイッチは2回押すと元の状態に戻るので、スイッチの状態2通りについての各頂点のコストを管理し、現在のスイッチの状態を持ちながら幅優先探索を行うことで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G = new List&amp;lt;(int U, int A)&amp;gt;[N];
    G = new List&amp;lt;(int U, int A)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int U, int A)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v, a) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        u--;
        v--;
        G[u].Add((v, a));
        G[v].Add((u, a));
    }

    var T = new HashSet&amp;lt;int&amp;gt;();
    if (K &amp;gt; 0)
    {
        var S = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
        T = new HashSet&amp;lt;int&amp;gt;(S);
    }

    const int inf = (int)1e9;
    var costs = new int[2][].Select(_ =&amp;gt; new int[N]).ToArray();
    Array.Fill(costs[0], inf);
    Array.Fill(costs[1], inf);
    costs[0][0] = 0;

    var queue = new Queue&amp;lt;(int T, int U, long Cost)&amp;gt;();
    queue.Enqueue((0, 0, 0));
    while (queue.Count &amp;gt; 0)
    {
        var (ut, u, uc) = queue.Dequeue();
        var vt = ut;

        for (var i = 0; i &amp;lt; 2; i++)
        {
            foreach (var (v, a) in G[u])
            {
                if (a == vt) continue;
                var c = costs[ut][u] + 1;
                if (costs[vt][v] &amp;lt;= c) continue;
                costs[vt][v] = c;
                queue.Enqueue((vt, v, c));
            }

            if (T.Contains(u)) vt = ut ^ 1;
            else break;
        }
    }

    var answer = Math.Min(costs[0][N - 1], costs[1][N - 1]);
    if (answer == inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 277の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221105abc276</id>
		<title>ABC276</title>
		<link href="https://blog.aconcavy.dev/posts/20221105abc276" />
		<updated>2022-11-05T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 276の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276"&gt;https://atcoder.jp/contests/abc276&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36221467"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;を左から順番に調べて、&lt;code&gt;a&lt;/code&gt;が出現した場所を更新し、最後に更新された場所が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = -1;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        if (S[i] == 'a') answer = i + 1;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36225653"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G[u][v]&lt;/code&gt;のように二次元配列で頂点&lt;code&gt;u&lt;/code&gt;が頂点&lt;code&gt;v&lt;/code&gt;と接続しているかを持ってしまうと、空間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまいます。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;が最大で&lt;code&gt;10^5&lt;/code&gt;なので、二乗の&lt;code&gt;10^10&lt;/code&gt;の空間計算量が必要となってしまい、実行時間制限に間に合いません。
そこで、頂点ごとにリストを持ち、接続されている頂点を追加していくことで、空間計算量が最大でも&lt;code&gt;10^5*2&lt;/code&gt;に収まり、ソートの計算量とあわせて全体で&lt;code&gt;O(logN+N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--;
        b--;
        G[a].Add(b);
        G[b].Add(a);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i].Sort();
        var c = G[i].Count;
        if (c == 0) Console.WriteLine(0);
        else Console.WriteLine($&amp;quot;{c} {string.Join(&amp;quot; &amp;quot;, G[i].Select(x =&amp;gt; x + 1))}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36257482"&gt;コンテスト提出&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/abc276/submissions/36264063"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例を見てみると、&lt;code&gt;P&lt;/code&gt;の末尾が単調増加している部分の一つ手前(位置&lt;code&gt;i&lt;/code&gt;)から右側が変化していることがわかります。&lt;br /&gt;
また、変化後の&lt;code&gt;P[i]&lt;/code&gt;は、もとの&lt;code&gt;P[i]&lt;/code&gt;より小さいものと入れ替わっており、&lt;code&gt;i&lt;/code&gt;より右側が逆順にソートされていることがわかります。&lt;br /&gt;
ここで、&lt;code&gt;P[i]&lt;/code&gt;と入れ替える値は、&lt;code&gt;P[i]&lt;/code&gt;より小さいもので最大の値であり、&lt;code&gt;P&lt;/code&gt;の末尾は単調増加していることから、末尾から見て&lt;code&gt;P[i]&lt;/code&gt;より小さくなった値と入れ替えることで、辞書順の直前にすることができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;/code&gt;などでは&lt;code&gt;prev_permutation()&lt;/code&gt;メソッドを使って求めることもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var j = N - 2;
    var k = N - 1;
    while (P[j] &amp;lt; P[j + 1]) j--;
    while (P[j] &amp;lt; P[k]) k--;
    (P[j], P[k]) = (P[k], P[j]);
    Array.Sort(P, j + 1, N - (j + 1));
    for (var (l, r) = (j + 1, N - 1); l &amp;lt; r; l++, r--)
    {
        (P[l], P[r]) = (P[r], P[l]);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, P));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36253185"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;が操作後に全て一致するには、&lt;code&gt;A[i] = 2^x * 3^y * V[i]&lt;/code&gt;で表すことができ、かつ&lt;code&gt;V[i]==V[j]&lt;/code&gt;である必要があります。
そして、&lt;code&gt;A&lt;/code&gt;における最大公約数を&lt;code&gt;g&lt;/code&gt;とすると、&lt;code&gt;A[i] = 2^x * 3^y * g&lt;/code&gt;で表すことができます。
このことから、&lt;code&gt;A[i]/g == 2^x * 3^y&lt;/code&gt;が成り立つかどうかを判定しつつ、全ての&lt;code&gt;A&lt;/code&gt;における&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var g = A.Aggregate(0L, Gcd);
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var k = A[i] / g;

        while (k % 2 == 0)
        {
            k /= 2;
            answer++;
        }

        while (k % 3 == 0)
        {
            k /= 3;
            answer++;
        }

        if (k != 1)
        {
            Console.WriteLine(-1);
            return;
        }
    }

    Console.WriteLine(answer);
}

public static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36250764"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4方向のみ移動可能であるため、直前にいたマスに戻らずに同じマスに訪れることができた場合は、&lt;code&gt;n&amp;gt;=4&lt;/code&gt;であることが確定します。
そのため、直前に訪れたマスをメモしながら深さ優先探索を行い、開始始点にたどり着くことができるかを判定することで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    var (sh, sw) = (0, 0);
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == 'S') (sh, sw) = (i, j);
        }
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    var used = new bool[H * W];
    var prev = new int[H * W];
    var s = sh * W + sw;

    bool Dfs(int ch, int cw)
    {
        var u = ch * W + cw;
        used[u] = true;
        var result = false;

        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            var v = nh * W + nw;
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            if (G[nh][nw] == '#') continue;
            if (v == s &amp;amp;&amp;amp; v != prev[u]) result |= true;
            if (used[v]) continue;
            prev[v] = u;

            result |= Dfs(nh, nw);
        }

        return result;
    }

    var answer = Dfs(sh, sw);

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36263019"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G[i][j]:=Max(1回目のカードA[i], 2回目のカードA[j])&lt;/code&gt;とすると、&lt;code&gt;k&lt;/code&gt;番目の期待値は&lt;code&gt;G[i][j] {i,j=1..k}&lt;/code&gt;の和を&lt;code&gt;k*k&lt;/code&gt;で割ったものとなります。
&lt;code&gt;k&lt;/code&gt;番目の試行を考えたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1回目に&lt;code&gt;k-1&lt;/code&gt;番目までのカードがでて、2回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでるとすると、&lt;code&gt;G[i][k]=Max(A[i],A[k])&lt;/code&gt;になる。&lt;/li&gt;
&lt;li&gt;1回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでて、2回目に&lt;code&gt;k-1&lt;/code&gt;番目までのカードがでるとすると、&lt;code&gt;G[k][i]=Max(A[k],A[i])&lt;/code&gt;になる。&lt;/li&gt;
&lt;li&gt;1回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでて、2回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでるとすると、&lt;code&gt;G[k][k]=A[k]&lt;/code&gt;になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;k-1&lt;/code&gt;番目の&lt;code&gt;G[i][j] {i,j=1..(k-1)}&lt;/code&gt;の総和を&lt;code&gt;prev&lt;/code&gt;とすると、&lt;code&gt;k&lt;/code&gt;番目の&lt;code&gt;G[i][j] {i,j=1..k}&lt;/code&gt;の総和は、&lt;code&gt;prev + G[i][k]{i..(k-1)} + G[k][i] {i..(k-1)} + G[k][k]&lt;/code&gt;となります。
このとき、&lt;code&gt;G[i][k]{i..(k-1)}&lt;/code&gt;は、&lt;code&gt;k-1番目までのA[k]より小さい数*A[k]&lt;/code&gt;を&lt;code&gt;sumS&lt;/code&gt;、&lt;code&gt;k-1番目までのA[k]より大きい数の和&lt;/code&gt;を&lt;code&gt;sumL&lt;/code&gt;とし、&lt;code&gt;G[i][k]{i..(k-1)}==G[k][i] {i..(k-1)}&lt;/code&gt;であることから、&lt;code&gt;k-1&lt;/code&gt;から&lt;code&gt;k&lt;/code&gt;の総和の増分は&lt;code&gt;(sumS + sumL)*2 + A[k]&lt;/code&gt;であることがわかります。&lt;br /&gt;
このことから、&lt;code&gt;FenwickTree&lt;/code&gt;等を使って&lt;code&gt;k&lt;/code&gt;番目までの&lt;code&gt;A[k]&lt;/code&gt;より小さい数の個数と&lt;code&gt;A[k]&lt;/code&gt;より大きな数の和を管理しながら&lt;code&gt;k&lt;/code&gt;番目における合計&lt;code&gt;S[k]=S[k-1]+(sumS+sumL)*2+A[k]&lt;/code&gt;を計算していくことで、&lt;code&gt;k&lt;/code&gt;番目における期待値&lt;code&gt;S[k]/(k*k)&lt;/code&gt;を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var (map, _) = Compress(A);
    var ft1 = new FenwickTree(N);
    var ft2 = new FenwickTree(N);
    var dp = new mint[N];
    dp[0] = A[0];
    ft1.Add(map[A[0]], 1);
    ft2.Add(map[A[0]], A[0]);

    for (var i = 1; i &amp;lt; N; i++)
    {
        var sumS = ft1.Sum(map[A[i]] + 1) * A[i];
        var sumL = ft2.Sum(map[A[i]] + 1, N);
        dp[i] = dp[i - 1] + (sumS + sumL) * 2 + A[i];

        ft1.Add(map[A[i]], 1);
        ft2.Add(map[A[i]], A[i]);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var curr = (mint)(i + 1) * (i + 1);
        Console.WriteLine(dp[i] / curr);
    }
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }

    return (map, remap);
}

public class FenwickTree
{
    public int Length { get; }
    private readonly mint[] _data;

    public FenwickTree(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _data = new mint[length];
    }

    public void Add(int index, long value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index++;
        while (index &amp;lt;= Length)
        {
            _data[index - 1] += value;
            index += index &amp;amp; -index;
        }
    }

    public mint Sum(int length)
    {
        if (length &amp;lt; 0 || Length &amp;lt; length) throw new ArgumentOutOfRangeException(nameof(length));
        mint s = 0;
        while (length &amp;gt; 0)
        {
            s += _data[length - 1];
            length -= length &amp;amp; -length;
        }

        return s;
    }

    public mint Sum(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        return Sum(right) - Sum(left);
    }

    public int LowerBound(long value) =&amp;gt; Bound(value, (x, y) =&amp;gt; x &amp;lt;= y);
    public int UpperBound(long value) =&amp;gt; Bound(value, (x, y) =&amp;gt; x &amp;lt; y);

    private int Bound(long value, Func&amp;lt;long, long, bool&amp;gt; compare)
    {
        if (Length == 0 || compare(value, _data[0])) return 0;
        var x = 0;
        var r = 1;
        while (r &amp;lt; Length) r &amp;lt;&amp;lt;= 1;
        for (var k = r; k &amp;gt; 0; k &amp;gt;&amp;gt;= 1)
        {
            if (x + k - 1 &amp;gt;= Length || compare(value, _data[x + k - 1])) continue;
            value -= _data[x + k - 1];
            x += k;
        }

        return x;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 276の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221029abc275</id>
		<title>ABC275</title>
		<link href="https://blog.aconcavy.dev/posts/20221029abc275" />
		<updated>2022-10-29T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 275の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc275"&gt;https://atcoder.jp/contests/abc275&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36033017"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;順番に&lt;code&gt;A&lt;/code&gt;の値を見ていき、それまでの最大値より大きい場合、最大値と答えを更新し、最後まで見たときの最大値の順番が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var H = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = 0;
    var max = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (max &amp;lt; H[i])
        {
            max = H[i];
            answer = i + 1;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36036335"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;64bit&lt;/code&gt;整数型を使っても、&lt;code&gt;10^18^6&lt;/code&gt;は整数型に収まりません。
&lt;code&gt;(X*Y)%M&lt;/code&gt;の値は&lt;code&gt;(X%M)*(Y%M)&lt;/code&gt;の値と等しくなるように、余りをとる&lt;code&gt;+,-,*&lt;/code&gt;の演算は計算の途中で余りをとっても最終的な余りと等しくなります。
そのため、各演算ごとに余りを取ることで、各項最大でも&lt;code&gt;10^9&lt;/code&gt;に収まり、掛け算でも&lt;code&gt;10^9 * 10^9&lt;/code&gt;で&lt;code&gt;10^18&lt;/code&gt;に収まります。
引き算を行うことで値が負の値になる可能性があるので、余りを足すことで正の値にすることに注意します。
余りをとる整数型の構造体をライブラリとして作っておくと便利です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, C, D, E, F) = Scanner.Scan&amp;lt;long, long, long, long, long, long&amp;gt;();
    var answer = ((mint)A * (mint)B * (mint)C) - ((mint)D * (mint)E * (mint)F);
    Console.WriteLine(answer);
}

public readonly struct ModuloInteger : IEquatable&amp;lt;ModuloInteger&amp;gt;
{
    public long Value { get; }

    // The modulo will be used as an editable property.
    // public static long Modulo { get; set; } = 998244353;
    // The constant modulo will be recommended to use for performances in use cases.
    public const long Modulo = 998244353;

    public ModuloInteger(int value)
    {
        Value = value % Modulo;
        if (Value &amp;lt; 0) Value += Modulo;
    }

    public ModuloInteger(long value)
    {
        Value = value % Modulo;
        if (Value &amp;lt; 0) Value += Modulo;
    }

    public static implicit operator int(ModuloInteger mint) =&amp;gt; (int)mint.Value;
    public static implicit operator long(ModuloInteger mint) =&amp;gt; mint.Value;
    public static implicit operator ModuloInteger(int value) =&amp;gt; new ModuloInteger(value);
    public static implicit operator ModuloInteger(long value) =&amp;gt; new ModuloInteger(value);
    public static ModuloInteger operator +(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Value + b.Value;
    public static ModuloInteger operator -(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Value - b.Value;
    public static ModuloInteger operator *(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Value * b.Value;
    public static ModuloInteger operator /(ModuloInteger a, ModuloInteger b) =&amp;gt; a * b.Inverse();
    public static bool operator ==(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Equals(b);
    public static bool operator !=(ModuloInteger a, ModuloInteger b) =&amp;gt; !a.Equals(b);
    public bool Equals(ModuloInteger other) =&amp;gt; Value == other.Value;
    public override bool Equals(object obj) =&amp;gt; obj is ModuloInteger other &amp;amp;&amp;amp; Equals(other);
    public override int GetHashCode() =&amp;gt; Value.GetHashCode();
    public override string ToString() =&amp;gt; Value.ToString();
    public ModuloInteger Inverse() =&amp;gt; Inverse(Value);

    public static ModuloInteger Inverse(long value)
    {
        if (value == 0) return 0;
        var (s, t, m0, m1) = (Modulo, value, 0L, 1L);
        while (t &amp;gt; 0)
        {
            var u = s / t;
            s -= t * u;
            m0 -= m1 * u;
            (s, t) = (t, s);
            (m0, m1) = (m1, m0);
        }

        if (m0 &amp;lt; 0) m0 += Modulo / s;
        return m0;
    }

    public ModuloInteger Power(long n) =&amp;gt; Power(Value, n);

    public static ModuloInteger Power(long value, long n)
    {
        if (n &amp;lt; 0) throw new ArgumentException(nameof(n));
        var result = 1L;
        while (n &amp;gt; 0)
        {
            if ((n &amp;amp; 1) &amp;gt; 0) result = result * value % Modulo;
            value = value * value % Modulo;
            n &amp;gt;&amp;gt;= 1;
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36052389"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正方形となる4つの頂点を全探索し、正方形となる頂点の組み合わせを数え上げます。
正方形の左上の頂点を&lt;code&gt;p1&lt;/code&gt;、右上の頂点を&lt;code&gt;p2&lt;/code&gt;、左下の頂点を&lt;code&gt;p3&lt;/code&gt;、右下を&lt;code&gt;p4&lt;/code&gt;としたとき、&lt;code&gt;p1-p2&lt;/code&gt;のベクトルと、&lt;code&gt;p3-p4&lt;/code&gt;のベクトルは一致し、&lt;code&gt;p1-p3&lt;/code&gt;のベクトルは、&lt;code&gt;p1-p2&lt;/code&gt;を90度回転させたものと一致する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = 9;
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x == '#').ToArray();
    }

    var answer = 0;

    IEnumerable&amp;lt;(int H, int W)&amp;gt; F()
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                yield return (i, j);
            }
        }
    }

    foreach (var p1 in F())
    {
        foreach (var p2 in F())
        {
            foreach (var p3 in F())
            {
                foreach (var p4 in F())
                {
                    if (p1 == p2 || p1 == p3 || p1 == p4 || p2 == p3 || p2 == p4 || p3 == p4) continue;
                    var e1 = (p2.H - p1.H, p2.W - p1.W);
                    var e3 = (p4.H - p3.H, p4.W - p3.W);
                    var e2 = (p3.W - p1.W, -(p3.H - p1.H));
                    var ok = e1 == e3 &amp;amp;&amp;amp; e1 == e2;
                    ok &amp;amp;= G[p1.H][p1.W];
                    ok &amp;amp;= G[p2.H][p2.W];
                    ok &amp;amp;= G[p3.H][p3.W];
                    ok &amp;amp;= G[p4.H][p4.W];
                    if (ok) answer++;
                }
            }
        }
    }

    answer /= 4;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36053607"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての&lt;code&gt;F(x)&lt;/code&gt;を都度求めてしまうと、何度も同じ計算を行ってしまい、&lt;code&gt;N&lt;/code&gt;が大きい場合、実行時間制限に間に合いません。
そこで、一度計算した値を保持しておくことで(メモ化再帰)、同じ計算を省略することで、実行時間制限に間に合わせることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var dp = new Dictionary&amp;lt;long, long&amp;gt;();
    dp[0] = 1;

    long F(long x)
    {
        if (dp.ContainsKey(x)) return dp[x];
        return dp[x] = F(x / 2) + F(x / 3);
    }

    var answer = F(N);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36065330"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]:=ルーレットをi回まわした時にマスjにいる確率&lt;/code&gt;とした動的計画法を解きます。
遷移としては、&lt;code&gt;今いるマスの確率/M&lt;/code&gt;が次のいるマスの確率に寄与します。
&lt;code&gt;M&lt;/code&gt;の逆元を求めることに&lt;code&gt;O(logMod)&lt;/code&gt;かかるので、前計算しておくことで高速化できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var dp = new mint[K + 1, N + 1];
    dp[0, 0] = 1;
    var im = mint.Inverse(M);

    for (var k = 0; k &amp;lt; K; k++)
    {
        for (var m = 1; m &amp;lt;= M; m++)
        {
            for (var n = 0; n &amp;lt; N; n++)
            {
                var x = n + m;
                if (x &amp;gt; N) x = Math.Max(0, N - (x - N));
                dp[k + 1, x] += dp[k, n] * im;
            }
        }
    }

    mint answer = 0;
    for (var k = 0; k &amp;lt;= K; k++)
    {
        answer += dp[k, N];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 275の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221022abc274</id>
		<title>ABC274</title>
		<link href="https://blog.aconcavy.dev/posts/20221022abc274" />
		<updated>2022-10-22T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 274の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc274"&gt;https://atcoder.jp/contests/abc274&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35862184"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt;型で&lt;code&gt;B/A&lt;/code&gt;をとり、カスタム数値形式文字列の&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/custom-numeric-format-strings#Specifier0"&gt;0カスタム指定子&lt;/a&gt;で桁数を指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;double, double&amp;gt;();
    var answer = B / A;
    Console.WriteLine($&amp;quot;{answer:0.000}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35864895"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二次元配列の入力を受け取り、列ごとにその行にある&lt;code&gt;#&lt;/code&gt;の数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToArray();
    }

    var X = new int[W];
    for (var j = 0; j &amp;lt; W; j++)
    {
        for (var i = 0; i &amp;lt; H; i++)
        {
            X[j] += G[i][j] == '#' ? 1 : 0;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, X));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35873509"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書型などで番号&lt;code&gt;k&lt;/code&gt;の親の数を管理します。
初期値である番号&lt;code&gt;1&lt;/code&gt;のアメーバが&lt;code&gt;0&lt;/code&gt;であり、&lt;code&gt;1&lt;/code&gt;が分裂すると&lt;code&gt;1*2=2&lt;/code&gt;番目と&lt;code&gt;1*3&lt;/code&gt;番目のアメーバは&lt;code&gt;1&lt;/code&gt;番目のアメーバの数&lt;code&gt;+1&lt;/code&gt;されたものがたどることができる親の数となります。
そのため、&lt;code&gt;dict[i*2] = dict[i*2+1] = dict[A[i]]+1&lt;/code&gt;のように順番にそのアメーバのたどることができる親の数を数え上げることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;int, int&amp;gt;();
    dict[1] = 0;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        dict[i * 2] = dict[i * 2 + 1] = dict[A[i - 1]] + 1;
    }

    for (var i = 1; i &amp;lt;= N * 2 + 1; i++)
    {
        Console.WriteLine(dict[k]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35880846"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移動について、&lt;code&gt;i&lt;/code&gt;が奇数番目の時は&lt;code&gt;X&lt;/code&gt;の移動、偶数の時は&lt;code&gt;Y&lt;/code&gt;の移動であることに注目し、&lt;code&gt;X&lt;/code&gt;の移動と&lt;code&gt;Y&lt;/code&gt;の移動それぞれについて&lt;code&gt;i&lt;/code&gt;回目の移動で座標&lt;code&gt;P&lt;/code&gt;行くことができるか、という動的計画法をとき、最終的に&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;にたどり着くことができるかを判定します。
初期値&lt;code&gt;dpX{A[0]}, dpY{0}&lt;/code&gt;とし、&lt;code&gt;i&lt;/code&gt;が奇数番目の時は&lt;code&gt;dpX&lt;/code&gt;の集合であり、ある頂点&lt;code&gt;px&lt;/code&gt;が&lt;code&gt;px+A[i]&lt;/code&gt;と&lt;code&gt;px-A[i]&lt;/code&gt;に遷移します。
同様に&lt;code&gt;i&lt;/code&gt;が偶数番目の時は&lt;code&gt;dpY&lt;/code&gt;の集合である頂点&lt;code&gt;py&lt;/code&gt;が&lt;code&gt;py+A[i]&lt;/code&gt;と&lt;code&gt;py-A[i]&lt;/code&gt;に遷移します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, x, y) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dpX = new HashSet&amp;lt;int&amp;gt;();
    var dpY = new HashSet&amp;lt;int&amp;gt;();
    dpX.Add(A[0]);
    dpY.Add(0);
    for (var i = 1; i &amp;lt; N; i++)
    {
        var tmp = new HashSet&amp;lt;int&amp;gt;();
        var target = i % 2 == 0 ? dpX : dpY;
        foreach (var p in target)
        {
            tmp.Add(p + A[i]);
            tmp.Add(p - A[i]);
        }

        if (i % 2 == 0) dpX = tmp;
        else dpY = tmp;
    }

    var answer = dpX.Contains(x) &amp;amp;&amp;amp; dpY.Contains(y);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35898361"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての組み合わせを愚直に探索してしまうと、時間計算量が&lt;code&gt;O((N+M)!)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
そこで、原点と町と宝箱を頂点とした集合について、&lt;code&gt;dp[s][u]:=既に訪れている頂点集合sで現在地がuのときの距離の最小値&lt;/code&gt;とした&lt;code&gt;bitDP&lt;/code&gt;を行うことで、時間計算量&lt;code&gt;O(2^(N+M)*(N+M)^2)&lt;/code&gt;で求めることができます。&lt;br /&gt;
&lt;code&gt;bitDP&lt;/code&gt;をおこない、すべての町を訪れている集合&lt;code&gt;s&lt;/code&gt;、現在地が&lt;code&gt;u&lt;/code&gt;、訪れた宝箱の数が&lt;code&gt;k&lt;/code&gt;、&lt;code&gt;Boost&lt;/code&gt;を単位時間に対する倍率としたとき、&lt;code&gt;Min(dp[s,u]+D[u,0]*Boost[k])&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = N + M + 1;
    var P = new (int X, int Y)[S];
    P[0] = (0, 0);
    for (var i = 1; i &amp;lt; S; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        P[i] = (x, y);
    }

    double Distance(double x1, double y1, double x2, double y2)
    {
        var dx = x1 - x2;
        var dy = y1 - y2;
        return Math.Sqrt(dx * dx + dy * dy);
    }

    var D = new double[S, S];
    for (var i = 0; i &amp;lt; S; i++)
    {
        for (var j = 0; j &amp;lt; S; j++)
        {
            D[i, j] = Distance(P[i].X, P[i].Y, P[j].X, P[j].Y);
        }
    }

    const double inf = 7e18;

    var p2 = new double[M + 1];
    p2[0] = 1;
    for (var i = 1; i &amp;lt;= M; i++)
    {
        p2[i] = p2[i - 1] / 2.0;
    }

    var dp = new double[1 &amp;lt;&amp;lt; S, S];
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; S; s++)
    {
        for (var u = 0; u &amp;lt; S; u++)
        {
            dp[s, u] = inf;
        }
    }

    dp[1, 0] = 0;

    int CountM(int s)
    {
        var k = 0;
        for (var i = 0; i &amp;lt; M; i++)
        {
            k += (s &amp;gt;&amp;gt; (N + 1 + i)) &amp;amp; 1;
        }

        return k;
    }

    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; S; s++)
    {
        var k = CountM(s);
        for (var u = 0; u &amp;lt; S; u++)
        {
            for (var v = 0; v &amp;lt; S; v++)
            {
                var t = s | (1 &amp;lt;&amp;lt; v);
                dp[t, v] = Math.Min(dp[t, v], dp[s, u] + D[u, v] * p2[k]);
            }
        }
    }

    var answer = inf;
    var mask = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        mask |= 1 &amp;lt;&amp;lt; (1 + i);
    }

    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; S; s++)
    {
        if ((s &amp;amp; mask) != mask) continue;
        var k = CountM(s);
        for (var u = 0; u &amp;lt; S; u++)
        {
            answer = Math.Min(answer, dp[s, u] + D[u, 0] * p2[k]);
        }
    }
    
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 274の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221015abc273</id>
		<title>ABC273</title>
		<link href="https://blog.aconcavy.dev/posts/20221015abc273" />
		<updated>2022-10-15T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 273の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc273"&gt;https://atcoder.jp/contests/abc273&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC273/submissions/35661854"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;制約が&lt;code&gt;N&amp;lt;=10&lt;/code&gt;と小さいので、下のような関数で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;long F(x) =&amp;gt; x == 0 ? 1 : x * F(x - 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;しかし、何度も同じ関数が呼ばれてしまい、&lt;code&gt;F(10)&lt;/code&gt;のときには&lt;code&gt;10!&lt;/code&gt;回もの関数が呼ばれてしまいます。
そこで、あらかじめ&lt;code&gt;F(1), F(2), F(...)&lt;/code&gt;の計算結果をメモしながら次の値を求めていくことで、計算量を大幅に削減することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var dp = new long[N + 1];
    dp[0] = 1;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        dp[i] = dp[i - 1] * i;
    }

    var answer = dp[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC273/submissions/35670133"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四捨五入する桁(&lt;code&gt;10^k&lt;/code&gt;の桁)の値を&lt;code&gt;v&lt;/code&gt;としたとき、&lt;code&gt;v = X / 10^k % 10&lt;/code&gt;で求めることができます。&lt;br /&gt;
そして、&lt;code&gt;v&lt;/code&gt;が&lt;code&gt;4以下&lt;/code&gt;のとき&lt;code&gt;X&lt;/code&gt;の&lt;code&gt;10^k&lt;/code&gt;の桁を&lt;code&gt;0&lt;/code&gt;にします。&lt;br /&gt;
あるいは、&lt;code&gt;v&lt;/code&gt;が&lt;code&gt;5以上&lt;/code&gt;のとき&lt;code&gt;X&lt;/code&gt;の&lt;code&gt;10^k&lt;/code&gt;の桁を&lt;code&gt;0&lt;/code&gt;にし、&lt;code&gt;10^(k+1)&lt;/code&gt;の桁を&lt;code&gt;+1&lt;/code&gt;します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, K) = Scanner.Scan&amp;lt;long, int&amp;gt;();
    var pow10 = 1L;
    for (var i = 0; i &amp;lt; K; i++)
    {
        var v = X / pow10 % 10;
        X -= v * pow10;
        if (v &amp;gt;= 5) X += pow10 * 10;
        pow10 *= 10;
    }

    Console.WriteLine(X);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC273/submissions/35675303"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の値はとても大きなものもありますが、求められるものは大小関係なので、&lt;code&gt;A&lt;/code&gt;を重複なしでソートしたときの順番を圧縮したものとして扱うことにします。&lt;br /&gt;
これにより、&lt;code&gt;数値の種類数-数値を圧縮した時の順番&lt;/code&gt;がその数値よりも大きな数の種類数を求めることができます。&lt;br /&gt;
そして、全ての&lt;code&gt;A&lt;/code&gt;においてその種類数を数え上げることで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var (map, _) = Compress(A);
    var count = A.Distinct().Count();
    var answer = new int[N];
    foreach (var a in A)
    {
        answer[count - (map[a] + 1)]++;
    }

    Console.WriteLine(string.Join(Environment.NewLine, answer));
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }

    return (map, remap);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc273/submissions/35759579"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行と列の移動はそれぞれ独立しているので、行を移動するときの列、列を移動するときの行ごとにブロックの座標を管理し、移動途中にブロックが存在するかを&lt;code&gt;LowerBound&lt;/code&gt;等で調べることで、クエリ当たり時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;下記のプログラムは考え方はあっていると思いますが、テストケースが4つ落ちています。どこがバグかわからないです...&lt;/del&gt;&lt;br /&gt;
修正しました。
番兵に指定した&lt;code&gt;rows&lt;/code&gt;と&lt;code&gt;cols&lt;/code&gt;、&lt;code&gt;cr&lt;/code&gt;と&lt;code&gt;cc&lt;/code&gt;の&lt;code&gt;H&lt;/code&gt;と&lt;code&gt;W&lt;/code&gt;が逆でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, cr, cc) = Scanner.Scan&amp;lt;int, int, long, long&amp;gt;();
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var rows = new Dictionary&amp;lt;long, List&amp;lt;long&amp;gt;&amp;gt;();
    var cols = new Dictionary&amp;lt;long, List&amp;lt;long&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (r, c) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        if (!rows.ContainsKey(r)) rows[r] = new List&amp;lt;long&amp;gt; { 0, (W + 1) };
        rows[r].Add(c);
        if (!cols.ContainsKey(c)) cols[c] = new List&amp;lt;long&amp;gt; { 0, (H + 1) };
        cols[c].Add(r);
    }

    foreach (var (_, v) in rows) v.Sort();
    foreach (var (_, v) in cols) v.Sort();

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (d, l) = Scanner.Scan&amp;lt;char, long&amp;gt;();

        if (d == 'L')
        {
            if (rows.ContainsKey(cr))
            {
                var lb = LowerBound(rows[cr], cc);
                cc = Math.Max(cc - l, rows[cr][lb - 1] + 1);
            }
            else
            {
                cc -= l;
            }
        }
        else if (d == 'R')
        {
            if (rows.ContainsKey(cr))
            {
                var ub = UpperBound(rows[cr], cc);
                cc = Math.Min(cc + l, rows[cr][ub] - 1);
            }
            else
            {
                cc += l;
            }
        }
        else if (d == 'U')
        {
            if (cols.ContainsKey(cc))
            {
                var lb = LowerBound(cols[cc], cr);
                cr = Math.Max(cr - l, cols[cc][lb - 1] + 1);
            }
            else
            {
                cr -= l;
            }
        }
        else if (d == 'D')
        {
            if (cols.ContainsKey(cc))
            {
                var ub = UpperBound(cols[cc], cr);
                cr = Math.Min(cr + l, cols[cc][ub] - 1);
            }
            else
            {
                cr += l;
            }
        }

        cr = Math.Min(Math.Max(cr, 1), H);
        cc = Math.Min(Math.Max(cc, 1), W);
        Console.WriteLine($&amp;quot;{cr} {cc}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 273の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221008abc272</id>
		<title>ABC272</title>
		<link href="https://blog.aconcavy.dev/posts/20221008abc272" />
		<updated>2022-10-08T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 272の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc272"&gt;https://atcoder.jp/contests/abc272&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35466353"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では&lt;code&gt;LINQ&lt;/code&gt;という&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;拡張メソッドを使うことで、整数型シーケンスの合計値を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = A.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35471787"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i(1&amp;lt;=i&amp;lt;=M)&lt;/code&gt;回目の講演会に&lt;code&gt;j(1&amp;lt;=j&amp;lt;=N)&lt;/code&gt;番目の人が参加しているかという2次元の表を構築し、全ての人&lt;code&gt;a&lt;/code&gt;と人&lt;code&gt;b&lt;/code&gt;の組み合わせ&lt;code&gt;(1&amp;lt;=a&amp;lt;b&amp;lt;=N)&lt;/code&gt;においてともに参加している講演会が1つでもあることを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var join = new bool[M, N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var X = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        for (var j = 1; j &amp;lt;= X[0]; j++)
        {
            join[i, X[j] - 1] = true;
        }
    }

    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var ok = false;
            for (var k = 0; k &amp;lt; M; k++)
            {
                ok |= join[k, i] &amp;amp;&amp;amp; join[k, j];
            }

            answer &amp;amp;= ok;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35474568"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;異なる2要素を全探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
2要素の和において偶数であることは、&lt;code&gt;偶数+偶数&lt;/code&gt;であること、または&lt;code&gt;奇数+奇数&lt;/code&gt;であることのみなので、&lt;code&gt;A&lt;/code&gt;を偶数と奇数にわけ、偶数が2個以上あればその最大値2つの和、奇数が2個以上あればその最大値2つの和のいずれかの最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    Array.Reverse(A);
    var even = new List&amp;lt;long&amp;gt;();
    var odd = new List&amp;lt;long&amp;gt;();
    foreach (var a in A)
    {
        if (a % 2 == 0) even.Add(a);
        else odd.Add(a);
    }

    var answer = -1L;
    if (even.Count &amp;gt;= 2) answer = Math.Max(answer, even[0] + even[1]);
    if (odd.Count &amp;gt;= 2) answer = Math.Max(answer, odd[0] + odd[1]);

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35503382"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;距離がちょうど&lt;code&gt;Sqrt(M)&lt;/code&gt;となる&lt;code&gt;(i,j)&lt;/code&gt;の差分をあらかじめ求めておき、&lt;code&gt;(1,1)&lt;/code&gt;から差分の幅優先探索をおこなうことで答えを求めることができます。
距離がちょうど&lt;code&gt;Sqrt(M)&lt;/code&gt;となるには、&lt;code&gt;(i-k)^2 + (j-i)^2 == M&lt;/code&gt;となる必要があり、&lt;code&gt;i=0,j=0&lt;/code&gt;としたときに&lt;code&gt;k&lt;/code&gt;または&lt;code&gt;l&lt;/code&gt;を固定することによって、&lt;code&gt;l&lt;/code&gt;または&lt;code&gt;k&lt;/code&gt;を求めることができます。
``&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();

    var root = new Dictionary&amp;lt;int, int&amp;gt;();
    for (var i = 0; i * i &amp;lt;= M; i++)
    {
        root[i * i] = i;
    }

    var delta = new HashSet&amp;lt;(int, int)&amp;gt;();

    void Add(int dh, int dw)
    {
        if (dh * dh + dw * dw == M &amp;amp;&amp;amp; !delta.Contains((dh, dw)))
        {
            delta.Add((dh, dw));
        }
    }

    // (i, j) = (0, 0)
    for (var k = 0; k &amp;lt; N; k++)
    {
        var dh = (0 - k);
        var dw2 = M - (dh * dh);
        if (dw2 &amp;lt; 0) break;
        if (root.ContainsKey(dw2))
        {
            var dw = root[dw2];
            // l = dw - j or j - dw
            Add(k, dw - 0);
            Add(k, 0 - dw);
            Add(dw - 0, k);
            Add(0 - dw, k);
        }
    }

    var dp = new long[N, N];
    const long inf = (long)1e18;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            dp[i, j] = inf;
        }
    }

    dp[0, 0] = 0;
    var queue = new Queue&amp;lt;(int, int)&amp;gt;();
    queue.Enqueue((0, 0));
    while (queue.Count &amp;gt; 0)
    {
        var (i, j) = queue.Dequeue();
        foreach (var (dh, dw) in delta)
        {
            var (k, l) = (i + dh, j + dw);
            if (0 &amp;lt;= k &amp;amp;&amp;amp; k &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= l &amp;amp;&amp;amp; l &amp;lt; N &amp;amp;&amp;amp; dp[k, l] == inf)
            {
                dp[k, l] = dp[i, j] + 1;
                queue.Enqueue((k, l));
            }
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (dp[i, j] == inf) dp[i, j] = -1;
        }
    }

    Printer.Print2D(dp, &amp;quot; &amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 272の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221001abc271</id>
		<title>ABC271</title>
		<link href="https://blog.aconcavy.dev/posts/20221001abc271" />
		<updated>2022-10-01T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 271の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271"&gt;https://atcoder.jp/contests/abc271&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35271548"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、整数を文字列に変換するときに、書式指定子&lt;code&gt;X&lt;/code&gt;を指定することで16進数文字列に変換することができ、書式指定子の後に数字を加えることで桁数を指定できます。
&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/standard-numeric-format-strings#hexadecimal-format-specifier-x"&gt;16 進書式指定子 (X)&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    Console.WriteLine(N.ToString(&amp;quot;X2&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35274115"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての配列を、配列の配列として保持しておき、&lt;code&gt;s&lt;/code&gt;番目の配列の、&lt;code&gt;t&lt;/code&gt;番目の値を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var line = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        A[i] = line[1..];
    }

    while (Q-- &amp;gt; 0)
    {
        var (s, t) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        s--;
        t--;
        Console.WriteLine(A[s][t]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35321236"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;巻まで読むことができるかという二部探索を行います。
判定式としては、持っている単行本のうち重複を除いた&lt;code&gt;x&lt;/code&gt;以下の巻数を&lt;code&gt;c1&lt;/code&gt;、&lt;code&gt;x&lt;/code&gt;より大きい巻数や重複した2冊目以降の数を&lt;code&gt;c2 (c2==N-c1)&lt;/code&gt;としたとき、足りない数の2倍が&lt;code&gt;c2&lt;/code&gt;以下であるか&lt;code&gt;(x-c1)*2&amp;lt;=c2&lt;/code&gt;を判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Distinct().ToArray();

    bool F(int x)
    {
        var c1 = A.Count(v =&amp;gt; v &amp;lt;= x);
        var c2 = N - c1;
        return (x - c1) * 2 &amp;lt;= c2;
    }

    var answer = BinarySearch((int)1e9, 0, F);
    Console.WriteLine(answer);
}

public static int BinarySearch(int ng, int ok, Func&amp;lt;int, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35302856"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i,j,k]:=i番目までのカードみたとき状態がk(表裏)のときにの合計がjが成り立つか&lt;/code&gt;という動的計画法をとき、&lt;code&gt;dp[N,S,0]&lt;/code&gt;か&lt;code&gt;dp[N,S,1]&lt;/code&gt;が成り立つかを判定し、成り立つときは経路復元を行います。
経路復元では、&lt;code&gt;dp[i,j,k]&lt;/code&gt;が成り立つときの&lt;code&gt;i-1&lt;/code&gt;番目の&lt;code&gt;jとk&lt;/code&gt;をメモしておきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, S) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new bool[N + 1, S + 1, 2];
    var prev = new (int, int)[N + 1, S + 1, 2];
    dp[0, 0, 0] = dp[0, 0, 1] = true;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        for (var j = 0; j &amp;lt;= S; j++)
        {
            if (j + a &amp;lt;= S)
            {
                for (var k = 0; k &amp;lt; 2; k++)
                {
                    if (dp[i, j, k])
                    {
                        dp[i + 1, j + a, 0] |= dp[i, j, k];
                        prev[i + 1, j + a, 0] = (j, k);
                    }
                }
            }

            if (j + b &amp;lt;= S)
            {
                for (var k = 0; k &amp;lt; 2; k++)
                {
                    if (dp[i, j, k])
                    {
                        dp[i + 1, j + b, 1] |= dp[i, j, k];
                        prev[i + 1, j + b, 1] = (j, k);
                    }
                }
            }
        }
    }

    if (dp[N, S, 0] || dp[N, S, 1])
    {
        var list = new List&amp;lt;int&amp;gt;();
        var curr = dp[N, S, 0] ? (S, 0) : (S, 1);
        for (var i = N; i &amp;gt; 0; i--)
        {
            list.Add(curr.Item2);
            curr = prev[i, curr.Item1, curr.Item2];
        }

        list.Reverse();
        var answer = string.Join(&amp;quot;&amp;quot;, list.Select(x =&amp;gt; x == 0 ? 'H' : 'T'));
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        Console.WriteLine(answer);
    }
    else
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35318996"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]:=Eのi番目までの道を使った時の都市jへの最小コスト&lt;/code&gt;とした動的計画法をときます。
良い経路は&lt;code&gt;E&lt;/code&gt;の部分列であり、&lt;code&gt;E[1]-&amp;gt;E[2]&lt;/code&gt;や&lt;code&gt;E[1]-&amp;gt;E[3]&lt;/code&gt;のようなことも可能であるため、&lt;code&gt;i&lt;/code&gt;ごとにコストを保持する必要はなく、一次元のみで求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    const long inf = (long)1e18;
    var Edges = new (int U, int V, long C)[M];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, c) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        G[a].Add((b, c));
        G[b].Add((a, c));
        Edges[i] = (a, b, c);
    }

    var E = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var dp = new long[N];
    Array.Fill(dp, inf);
    dp[0] = 0;

    for (var i = 0; i &amp;lt; K; i++)
    {
        var (a, b, c) = Edges[E[i]];
        if (dp[a] != inf)
        {
            dp[b] = Math.Min(dp[b], dp[a] + c);
            set.Add(b);
        }
    }

    var answer = dp[N - 1];
    if (answer == inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 271の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220924abc270</id>
		<title>ABC270</title>
		<link href="https://blog.aconcavy.dev/posts/20220924abc270" />
		<updated>2022-09-24T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 270の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270"&gt;https://atcoder.jp/contests/abc270&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35093269"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整数を2進数表記したとき、&lt;code&gt;2^0==1&lt;/code&gt;、&lt;code&gt;2^1==2&lt;/code&gt;、&lt;code&gt;2^2=4&lt;/code&gt;となり、入力&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の各ビットが立っているかをみることで、その問題に正解しているかどうかがわかります。
そのため、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の各ビットの論理和をとることで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = A | B;
    Console.WriteLine(C);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35103936"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc270/submissions/35139218"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;が負のとき、&lt;code&gt;X&lt;/code&gt;、&lt;code&gt;Y&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt;を反転させることで&lt;code&gt;X&lt;/code&gt;が正の時として考えることができます。&lt;br /&gt;
このとき、&lt;code&gt;X&amp;lt;Y&lt;/code&gt;または&lt;code&gt;Y&amp;lt;0&lt;/code&gt;であれば、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;X&lt;/code&gt;の間に壁はないので、答えは&lt;code&gt;X&lt;/code&gt;となります。
それ以外のとき、&lt;code&gt;Y&amp;lt;Z&lt;/code&gt;であれば、ハンマーを拾うことはできないので、答えは&lt;code&gt;-1&lt;/code&gt;となります。
それ以外のとき、ハンマーを拾ってから&lt;code&gt;X&lt;/code&gt;に向かうことができるので、答えは&lt;code&gt;Abs(Z)+Abs(X-Z)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, Z) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    if (X &amp;lt; 0)
    {
        X = -X;
        Y = -Y;
        Z = -Z;
    }

    if (X &amp;lt; Y || Y &amp;lt; 0)
    {
        Console.WriteLine(X);
    }
    else
    {
        if (Y &amp;lt; Z)
        {
            Console.WriteLine(-1);
        }
        else
        {
            Console.WriteLine(Math.Abs(Z) + Math.Abs(X - Z));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35106711"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;訪れた直前の頂点をメモしながら、始点である&lt;code&gt;X&lt;/code&gt;から幅優先探索を行い、終点の&lt;code&gt;Y&lt;/code&gt;から直前の頂点をたどることでパスを復元することができます。
復元した頂点は逆順であることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    X--; Y--;
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    var prev = new int[N];
    Array.Fill(prev, -1);
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(X);
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        foreach (var v in G[u])
        {
            if (prev[v] != -1) continue;
            prev[v] = u;
            queue.Enqueue(v);
        }
    }

    var route = new List&amp;lt;int&amp;gt;();
    var curr = Y;
    while (true)
    {
        route.Add(curr + 1);
        curr = prev[curr];
        if(curr == X) break;
    }

    route.Reverse();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, route));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35138376"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i]:=石がi個のときの先手が取れる石の最大個数&lt;/code&gt;とした動的計画法をときます。
遷移としては、石が&lt;code&gt;i-A[j]&lt;/code&gt;個のときの後手が取れる石の最大個数に&lt;code&gt;A[j]&lt;/code&gt;個足したものであることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dp = new int[N + 1];
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 0; j &amp;lt; K; j++)
        {
            if (i - A[j] &amp;gt;= 0)
            {
                dp[i] = Math.Max(dp[i], (i - A[j] - dp[i - A[j]]) + A[j]);
            }
        }
    }

    var answer = dp[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35124130"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直にシミュレーションしてしまうと実行時間制限に間に合いません。
現在のかごにあるりんごの最小値が&lt;code&gt;v&lt;/code&gt;、りんごが1個以上あるかごの数を&lt;code&gt;c&lt;/code&gt;のときには&lt;code&gt;Min(K/c,v)&lt;/code&gt;周することができ、りんごは&lt;code&gt;Min(K/c,v)周*c個&lt;/code&gt;食べることができます。
そして、食べられる&lt;code&gt;K&lt;/code&gt;が現在のりんごが1個以上あるかごの数未満になった場合は端数となるので、りんごが1個以上あるかごの番号が小さい順に数を減らすことで答えを求めることができます。
全体計算量はりんごの数をソートするための&lt;code&gt;O(NlogN)&lt;/code&gt;となり、実行時間制限に間に合います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var basket = N;
    var lap = 0L;
    foreach (var v in A.OrderBy(x =&amp;gt; x))
    {
        if (K &amp;lt; basket) break;
        var d = Math.Min(K / basket, v - lap);
        K -= d * basket;
        lap += d;
        basket--;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Math.Max(0, A[i] - lap);

        if (A[i] &amp;gt; 0 &amp;amp;&amp;amp; K &amp;gt; 0)
        {
            A[i]--;
            K--;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 270の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220917abc269</id>
		<title>ABC269</title>
		<link href="https://blog.aconcavy.dev/posts/20220917abc269" />
		<updated>2022-09-17T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 269の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc269"&gt;https://atcoder.jp/contests/abc269&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34918764"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入出力の問題です。
C#では、コンソールからの文字列の入力を&lt;code&gt;Console.ReadLine()&lt;/code&gt;メソッド、コンソールへの文字列の出力を&lt;code&gt;Console.WriteLine()&lt;/code&gt;メソッドで行うことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var values = Console.ReadLine().Split(' ');
    var (a, b, c, d) = (long.Parse(values[0]), long.Parse(values[1]), long.Parse(values[2]), long.Parse(values[3]));
    var answer = (a + b) * (c - d);
    Console.WriteLine(answer);
    Console.WriteLine(&amp;quot;Takahashi&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34925112"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(A,B)&lt;/code&gt;は&lt;code&gt;#&lt;/code&gt;が出現する最小の行と最大の行になり、&lt;code&gt;(C,D)&lt;/code&gt;は、&lt;code&gt;#&lt;/code&gt;が出現する最小の列と最大の列になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = 10;
    var G = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    const int inf = (int)1e9;
    var (a, b, c, d) = (inf, 0, inf, 0);
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (G[i][j] == '#')
            {
                a = Math.Min(a, i);
                b = Math.Max(b, i);
                c = Math.Min(c, j);
                d = Math.Max(d, j);
            }
        }
    }

    Console.WriteLine($&amp;quot;{a + 1} {b + 1}&amp;quot;);
    Console.WriteLine($&amp;quot;{c + 1} {d + 1}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34929182"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求めたい集合は、&lt;code&gt;|&lt;/code&gt;をビット論理和としたとき、&lt;code&gt;x | N == N&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;の集合です。
&lt;code&gt;N&lt;/code&gt;がとても大きいので、&lt;code&gt;x&lt;/code&gt;を全探索してしまうと実行時間制限に間に合いません。
そこで、&lt;code&gt;N&lt;/code&gt;のビットが立っている位置をビット全探索して論理和を求めることで、集合を求めることができます。
制約により&lt;code&gt;N&lt;/code&gt;のビットが立っている個数は最大でも&lt;code&gt;15&lt;/code&gt;なので、答えとなる個数は最大でも&lt;code&gt;2^15&lt;/code&gt;なので、実行時間制限に十分間に合います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();

    var list = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt;= 60; i++)
    {
        if ((N &amp;gt;&amp;gt; i &amp;amp; 1) == 1) list.Add(i);
    }

    var answer = new List&amp;lt;long&amp;gt;();
    var M = list.Count;
    for (var i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; M; i++)
    {
        var v = 0L;
        for (var j = 0; j &amp;lt; M; j++)
        {
            if ((i &amp;gt;&amp;gt; j &amp;amp; 1) == 1)
            {
                v |= 1L &amp;lt;&amp;lt; list[j];
            }
        }

        answer.Add(v);
    }

    answer.Sort();
    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34934356"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個のマスのペアが隣接する6マスにあるかを探索し、マスの番号を頂点とした&lt;code&gt;DisjointSetUnion (DSU, aka UnionFind)&lt;/code&gt;等を使って、連結成分の個数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var XY = new (int X, int Y)[N];
    var dict = new Dictionary&amp;lt;(int X, int Y), int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var p = Scanner.Scan&amp;lt;int, int&amp;gt;();
        XY[i] = p;
        dict[p] = i;
    }

    var D6 = new (int X, int Y)[6] { (-1, -1), (-1, 0), (0, -1), (0, 1), (1, 0), (1, 1) };
    var dsu = new DisjointSetUnion(N);
    for (var i = 0; i &amp;lt; N; i++)
    {
        foreach (var (dx, dy) in D6)
        {
            var np = (XY[i].X + dx, XY[i].Y + dy);
            if (dict.ContainsKey(np))
            {
                var j = dict[np];
                dsu.Merge(i, j);
            }
        }
    }

    var answer = dsu.GetGroups().Count();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34943393"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行と列はそれぞれ独立しているため、行と列を別に考えます。&lt;br /&gt;
ある行&lt;code&gt;m&lt;/code&gt;までに含まれるルークの数を質問したとき(&lt;code&gt;! 1 m 1 N&lt;/code&gt;)、質問への答えが&lt;code&gt;m&lt;/code&gt;の場合、&lt;code&gt;1&lt;/code&gt;行から&lt;code&gt;m&lt;/code&gt;行までには既にルークが全て置かれており、&lt;code&gt;m+1&lt;/code&gt;行目から&lt;code&gt;N&lt;/code&gt;行目までに答えとなる行が存在することがわかり、&lt;code&gt;m&lt;/code&gt;以外の場合は&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;m&lt;/code&gt;行までの中に答えとなる行が存在することがわかります。
また、制約が&lt;code&gt;2&amp;lt;=N&amp;lt;=1000&lt;/code&gt;であり、&lt;code&gt;N&amp;lt;=2^10&lt;/code&gt;であることから、答えとなる行&lt;code&gt;m&lt;/code&gt;の二部探索を行うことで、10回程度の質問で答えとなる行&lt;code&gt;m&lt;/code&gt;を求められることがわかります。&lt;br /&gt;
同様に列に対しても二部探索で答えを求めることで、行と列合わせて20回程度の質問で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();

    bool AskI(long m)
    {
        Console.WriteLine($&amp;quot;? 1 {m} 1 {N}&amp;quot;);
        var c = Scanner.Scan&amp;lt;int&amp;gt;();
        return c != m;
    }

    bool AskJ(long m)
    {
        Console.WriteLine($&amp;quot;? 1 {N} 1 {m}&amp;quot;);
        var c = Scanner.Scan&amp;lt;int&amp;gt;();
        return c != m;
    }

    var i = BinarySearch(0, N, AskI);
    var j = BinarySearch(0, N, AskJ);
    Console.WriteLine($&amp;quot;! {i} {j}&amp;quot;);
}

public static long BinarySearch(long l, long r, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(r - l) &amp;gt; 1)
    {
        var m = (r + l) / 2;
        if (func(m)) r = m;
        else l = m;
    }

    return r;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 269の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>