<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title>acon.log</title>
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2024 AconCavy</rights>
	<updated>2024-01-06T14:39:15Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240106abc335</id>
		<title>ABC335</title>
		<link href="https://blog.aconcavy.dev/posts/20240106abc335" />
		<updated>2024-01-06T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 335の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc335"&gt;https://atcoder.jp/contests/abc335&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc335/tasks/abc335_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC335/submissions/49060379"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;を&lt;code&gt;char&lt;/code&gt;型の配列とし、&lt;code&gt;|S|-1&lt;/code&gt;番目の値を&lt;code&gt;4&lt;/code&gt;にしたものを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    S[^1] = '4';
    Console.WriteLine(new string(S));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc335/tasks/abc335_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC335/submissions/49066081"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x,y,z&lt;/code&gt;の3種が取りうる組み合わせは高々&lt;code&gt;21^3==9261&lt;/code&gt;なので、全探索して&lt;code&gt;x+y+z&amp;lt;=N&lt;/code&gt;が成り立つかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var x = 0; x &amp;lt;= N; x++)
    {
        for (var y = 0; y &amp;lt;= N; y++)
        {
            for (var z = 0; z &amp;lt;= N; z++)
            {
                var s = x + y + z;
                if (s &amp;lt;= N)
                {
                    Console.WriteLine($&amp;quot;{x} {y} {z}&amp;quot;);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc335/tasks/abc335_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC335/submissions/49116652"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリ2を考えます。&lt;br /&gt;
&lt;code&gt;p&lt;/code&gt;の位置は、それまでに移動した回数が&lt;code&gt;q&lt;/code&gt;回である場合、パーツ&lt;code&gt;1&lt;/code&gt;が移動した回数が&lt;code&gt;q-p+1&lt;/code&gt;回目の位置になります。&lt;br /&gt;
&lt;code&gt;q-p+1&amp;lt;0&lt;/code&gt;であるとき、&lt;code&gt;(1-(p-q+1),0)&lt;/code&gt;の位置になります。&lt;br /&gt;
よって、クエリ1のときに&lt;code&gt;q&lt;/code&gt;回目の移動回数のときのパーツ&lt;code&gt;1&lt;/code&gt;の位置を記録し、クエリ2のときに上記の位置を求めることで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = new (int X, int Y)[Q + 1];
    P[0] = (1, 0);
    var q = 0;

    for (var i = 1; i &amp;lt;= Q; i++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
        if (query[0] == &amp;quot;1&amp;quot;)
        {
            var (cx, cy) = P[q];
            q++;
            var (dx, dy) = (0, 0);
            switch (query[1])
            {
                case &amp;quot;R&amp;quot;: dx++; break;
                case &amp;quot;L&amp;quot;: dx--; break;
                case &amp;quot;U&amp;quot;: dy++; break;
                case &amp;quot;D&amp;quot;: dy--; break;
                default: break;
            }

            P[q] = (cx + dx, cy + dy);
        }
        else
        {
            var p = int.Parse(query[1]);
            var d = q - p + 1;
            if (d &amp;gt;= 0)
            {
                var (x, y) = P[d];
                Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
            }
            else
            {
                var (x, y) = (1 - d, 0);
                Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc335/tasks/abc335_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC335/submissions/49091092"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;左上から時計回りに外周をたどることを考えます。&lt;br /&gt;
グリッド&lt;code&gt;G&lt;/code&gt;の&lt;code&gt;ch&lt;/code&gt;行&lt;code&gt;cw&lt;/code&gt;列を&lt;code&gt;G[ch][cw]&lt;/code&gt;とし、そのマスの値を&lt;code&gt;v&lt;/code&gt;、進行方向を&lt;code&gt;d (4方向)&lt;/code&gt;とします。&lt;br /&gt;
進行方向&lt;code&gt;d&lt;/code&gt;の差分を&lt;code&gt;dh&lt;/code&gt;行&lt;code&gt;dw&lt;/code&gt;列とすると、&lt;code&gt;v+1&lt;/code&gt;になるマスは&lt;code&gt;nh=ch+dh&lt;/code&gt;行&lt;code&gt;nw=cw+dw&lt;/code&gt;列になります。&lt;br /&gt;
&lt;code&gt;G[nh][nw]&lt;/code&gt;がグリッドの外あるいは既に値が埋められていた場合、進行方向を時計回りに&lt;code&gt;90&lt;/code&gt;度回転させます。&lt;br /&gt;
この処理を&lt;code&gt;v==N*N-1&lt;/code&gt;まで行い、中央のマスを&lt;code&gt;T&lt;/code&gt;にしたものを出力することで、答えを求めることができます。&lt;/p&gt;
&lt;p&gt;進行方向の差分を&lt;code&gt;D4={(0,1), (1,0), (0,-1), (-1,0)}&lt;/code&gt;の4つ管理しておき、進行方向を時計回りに&lt;code&gt;90&lt;/code&gt;度回転させる処理を&lt;code&gt;d=(d+1)%4&lt;/code&gt;とすることで、&lt;code&gt;d&lt;/code&gt;のときの進行方向の差分&lt;code&gt;D4[d]&lt;/code&gt;として取得することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new int[N, N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            G[i, j] = -1;
        }
    }

    var D4 = new[] { (0, 1), (1, 0), (0, -1), (-1, 0) };

    void Fill(int ch, int cw, int v, int d)
    {
        if (v == N * N) return;
        G[ch, cw] = v;
        var (dh, dw) = D4[d];
        var (nh, nw) = (ch + dh, cw + dw);
        if (nh &amp;lt; 0 || N &amp;lt;= nh || nw &amp;lt; 0 || N &amp;lt;= nw || G[nh, nw] != -1)
        {
            d++;
            d %= 4;
            (dh, dw) = D4[d];
            (nh, nw) = (ch + dh, cw + dw);
        }

        Fill(nh, nw, v + 1, d);
    }

    Fill(0, 0, 1, 0);
    var answer = new string[N, N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            answer[i, j] = G[i, j].ToString();
            if (answer[i, j] == &amp;quot;-1&amp;quot;) answer[i, j] = &amp;quot;T&amp;quot;;
        }
    }

    Printer.Print2D(answer, &amp;quot; &amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc335/tasks/abc335_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC335/submissions/49123545"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M&lt;/code&gt;個の辺のうち、&lt;code&gt;A[u|v]&amp;lt;A[1]||A[N]&amp;lt;A[u|v]&lt;/code&gt;の場合は、その辺は考える必要はありません。&lt;br /&gt;
また、&lt;code&gt;A[u]==A[v]&lt;/code&gt;の場合は、&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を同一頂点としてみなすことができ、これは&lt;code&gt;DisjointSetUnion&lt;/code&gt;などで管理することができます。&lt;br /&gt;
そして、&lt;code&gt;A[u]&amp;lt;A[v]&lt;/code&gt;の場合は、&lt;code&gt;u&lt;/code&gt;から&lt;code&gt;v&lt;/code&gt;への辺のみ考えればよく、&lt;code&gt;A[v]&amp;gt;A[u]&lt;/code&gt;の場合は、&lt;code&gt;v&lt;/code&gt;から&lt;code&gt;u&lt;/code&gt;への辺のみを考えれば十分です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[x]&lt;/code&gt;を頂点&lt;code&gt;x&lt;/code&gt;のの最大得点とします。&lt;br /&gt;
頂点&lt;code&gt;x&lt;/code&gt;の同一頂点を&lt;code&gt;L(x)&lt;/code&gt;としたとき、&lt;code&gt;dp[L(1)]=1&lt;/code&gt;、それ以外は&lt;code&gt;-Inf&lt;/code&gt;で初期化します。
頂点&lt;code&gt;u&lt;/code&gt;から頂点&lt;code&gt;v&lt;/code&gt;への辺があるとき、&lt;code&gt;A[u]&lt;/code&gt;の小さい順から&lt;code&gt;dp[L(v)]=Max(dp[L(v)], dp[L(u)]+1)&lt;/code&gt;として更新していき、&lt;code&gt;Max(0, dp[L(N)])&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var dsu = new DisjointSetUnion(N);
    var E = new Dictionary&amp;lt;int, List&amp;lt;(int U, int V)&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        if (A[u] &amp;lt; A[0] || A[u] &amp;gt; A[^1]) continue;
        if (A[v] &amp;lt; A[0] || A[v] &amp;gt; A[^1]) continue;
        if (A[u] &amp;gt; A[v]) (u, v) = (v, u);
        if (A[u] == A[v])
        {
            dsu.Merge(u, v);
        }
        else
        {
            if (A[u] &amp;gt; A[v]) (u, v) = (v, u);
            var a = A[u];
            if (!E.ContainsKey(a)) E[a] = new List&amp;lt;(int U, int V)&amp;gt;();
            E[a].Add((u, v));
        }
    }

    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var dp = new int[N];
    Array.Fill(dp, -Inf);
    dp[dsu.LeaderOf(0)] = 1;
    foreach (var (a, edges) in E.OrderBy(x =&amp;gt; x.Key))
    {
        foreach (var (u, v) in edges)
        {
            var (lu, lv) = (dsu.LeaderOf(u), dsu.LeaderOf(v));
            dp[lv] = Math.Max(dp[lv], dp[lu] + 1);
        }
    }

    var answer = Math.Max(0, dp[dsu.LeaderOf(N - 1)]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 335の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231223abc334</id>
		<title>ABC334</title>
		<link href="https://blog.aconcavy.dev/posts/20231223abc334" />
		<updated>2023-12-23T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 334の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc334"&gt;https://atcoder.jp/contests/abc334&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc334/tasks/abc334_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC334/submissions/48733376"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;B&amp;gt;G&lt;/code&gt;ならば&lt;code&gt;Bat&lt;/code&gt;、それ以外ならば&lt;code&gt;Glove&lt;/code&gt;が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (B, G) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = B &amp;gt; G ? &amp;quot;Bat&amp;quot; : &amp;quot;Glove&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc334/tasks/abc334_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC334/submissions/48800963"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;L&lt;/code&gt;を原点として考えると、&lt;code&gt;R-=L,A-=L,L-=L(0)&lt;/code&gt;になります。&lt;br /&gt;
また、&lt;code&gt;A&lt;/code&gt;から&lt;code&gt;M&lt;/code&gt;ごとにツリーがあることから、&lt;code&gt;0&lt;/code&gt;以上で最小のツリーの位置&lt;code&gt;B&lt;/code&gt;は&lt;code&gt;(A%M+M)%M&lt;/code&gt;になります。&lt;br /&gt;
これにより、&lt;code&gt;L(0)&amp;lt;=R&lt;/code&gt;かつ&lt;code&gt;L(0)&amp;lt;=B&lt;/code&gt;とすることができます。&lt;br /&gt;
よって、&lt;code&gt;R&amp;lt;B&lt;/code&gt;のときはツリーはありません。&lt;br /&gt;
一方、&lt;code&gt;B&amp;lt;=R&lt;/code&gt;のときは&lt;code&gt;B&lt;/code&gt;を原点としたときの&lt;code&gt;R&lt;/code&gt;までにあるツリーの数になるので、&lt;code&gt;(R-B)/M+1&lt;/code&gt;になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, M, L, R) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();
    R -= L;
    A -= L;
    var B = (A % M + M) % M;
    var answer = R &amp;lt; B ? 0 : (R - B) / M + 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc334/tasks/abc334_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC334/submissions/48803672"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;偶数のとき、&lt;code&gt;A&lt;/code&gt;のうち奇数番目と偶数番目をペアとした&lt;code&gt;K/2&lt;/code&gt;組を作ることが最適です。&lt;br /&gt;
これは、&lt;code&gt;i,j&lt;/code&gt;をなくした色、なくしていない色を&lt;code&gt;k&lt;/code&gt;とし、&lt;code&gt;x=|i-k|,y=|j-k|,z=|i-j|,w=|k-k|&lt;/code&gt;すると、三角不等式より&lt;code&gt;|z|+|w|=|z|&amp;lt;|x|+|y|&lt;/code&gt;になることから、なくした色のみ考えればいいからです。&lt;br /&gt;
奇数のとき、&lt;code&gt;K&lt;/code&gt;個のうちの一つを除外して&lt;code&gt;(K-1)/2&lt;/code&gt;組を作ることが最適になります。&lt;br /&gt;
よって、除外するものを固定したとき、それより左側にあるペアの累積和と右側にあるペアの累積和の総和の最小が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var D = new long[K - 1];
    for (var i = 0; i + 1 &amp;lt; K; i++)
    {
        D[i] = A[i + 1] - A[i];
    }

    var M = K / 2;
    var cumL = new long[M + 1];
    var cumR = new long[M + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        cumL[i + 1] = cumL[i] + D[i * 2];
    }

    Array.Reverse(D);
    for (var i = 0; i &amp;lt; M; i++)
    {
        cumR[i + 1] = cumR[i] + D[i * 2];
    }

    Array.Reverse(cumR);

    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var answer = Inf;
    for (var i = 0; i &amp;lt;= M; i++)
    {
        answer = Math.Min(answer, cumL[i] + cumR[i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc334/tasks/abc334_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC334/submissions/48771637"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;匹以下で引くことができるソリを&lt;code&gt;R&lt;/code&gt;が小さい方から順に選択することが、&lt;code&gt;X&lt;/code&gt;匹以下で引くことができる最大のソリの数になります。&lt;br /&gt;
あらかじめ&lt;code&gt;R&lt;/code&gt;を昇順に並べ替えたものの累積和を計算しておき、クエリごとに累積和の&lt;code&gt;X&lt;/code&gt;以下となるソリの数を二部探索することで、全体時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var R = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(R);
    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + R[i];
    }

    while (Q-- &amp;gt; 0)
    {
        var X = Scanner.Scan&amp;lt;long&amp;gt;();
        var answer = UpperBound(cum, X) - 1;
        Console.WriteLine(answer);
    }
}

public static int UpperBound&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; source, T key, IComparer&amp;lt;T&amp;gt;? comparer = null)
    =&amp;gt; UpperBound(System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source), key, comparer);

public static int UpperBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key, IComparer&amp;lt;T&amp;gt;? comparer = null)
{
    comparer ??= Comparer&amp;lt;T&amp;gt;.Default;
    var (lo, hi) = (-1, source.Length);
    while (hi - lo &amp;gt; 1)
    {
        var mi = lo + ((hi - lo) &amp;gt;&amp;gt; 1);
        if (comparer.Compare(source[mi], key) &amp;gt; 0) hi = mi;
        else lo = mi;
    }

    return hi;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc334/tasks/abc334_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC334/submissions/48795030"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各赤色のマスごとに塗り替えた後の連結成分数の総和を、赤色のマスの数で割ったものが期待値になります。&lt;br /&gt;
初期状態の連結成分数を&lt;code&gt;x&lt;/code&gt;とします。&lt;br /&gt;
ある赤色のマスから上下左右にある緑色のマス含む連結成分数を&lt;code&gt;y&lt;/code&gt;としたとき、その赤色のマスを緑色に塗り替えた後の連結成分数は&lt;code&gt;x-y+1&lt;/code&gt;になります。&lt;br /&gt;
よって、初期状態の連結成分数をあらかじめ計算し、赤マスごとにの上下左右にある緑マスを含む連結成分数を求めていくことで、時間計算量&lt;code&gt;O(HW)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var dsu = new DisjointSetUnion(H * W);
    int F(int h, int w) =&amp;gt; h * W + w;
    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };
    var red = 0;
    for (var ch = 0; ch &amp;lt; H; ch++)
    {
        for (var cw = 0; cw &amp;lt; W; cw++)
        {
            if (G[ch][cw] == '.')
            {
                red++;
                continue;
            }

            foreach (var (dh, dw) in D4)
            {
                var (nh, nw) = (ch + dh, cw + dw);
                if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
                if (G[nh][nw] == '#')
                {
                    dsu.Merge(F(ch, cw), F(nh, nw));
                }
            }
        }
    }

    var max = dsu.GetGroups().Count() - red;
    var buffer = new List&amp;lt;int&amp;gt;(4);
    var used = new bool[4];
    mint answer = 0;
    for (var ch = 0; ch &amp;lt; H; ch++)
    {
        for (var cw = 0; cw &amp;lt; W; cw++)
        {
            if (G[ch][cw] == '#') continue;

            buffer.Clear();
            Array.Fill(used, false);
            foreach (var (dh, dw) in D4)
            {
                var (nh, nw) = (ch + dh, cw + dw);
                if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
                if (G[nh][nw] == '#') buffer.Add(F(nh, nw));
            }

            var c = 0;
            for (var i = 0; i &amp;lt; buffer.Count; i++)
            {
                if (used[i]) continue;

                c++;
                for (var j = i + 1; j &amp;lt; buffer.Count; j++)
                {
                    if (dsu.IsSame(buffer[i], buffer[j]))
                    {
                        used[j] = true;
                    }
                }
            }

            answer += max - c + 1;
        }
    }

    answer /= red;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 334の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231216abc333</id>
		<title>ABC333</title>
		<link href="https://blog.aconcavy.dev/posts/20231216abc333" />
		<updated>2023-12-16T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 333の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc333"&gt;https://atcoder.jp/contests/abc333&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc333/tasks/abc333_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC333/submissions/48534167"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;code&gt;string&lt;/code&gt;のコンストラクタに文字と長さを与えると、与えられた文字を与えられた長さ繰り返した文字列を生成することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = new string((char)(N + '0'), N);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc333/tasks/abc333_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC333/submissions/48542641"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある線分の長さが等しいとき、&lt;code&gt;A-B-C-D-E-A&lt;/code&gt;として長さ1の辺で連結しているときの、時計回りで辿る頂点間の距離と反時計回りで辿る頂点間の距離のうち小さい方を頂点間の距離としたとき、頂点間の距離も等しくなります。&lt;br /&gt;
&lt;code&gt;A,B,C,D,E&lt;/code&gt;を&lt;code&gt;0,1,2,3,4&lt;/code&gt;、&lt;code&gt;S[0]&amp;lt;S[1]&lt;/code&gt;、&lt;code&gt;T[0]&amp;lt;T[1]&lt;/code&gt;とします。&lt;br /&gt;
反時計回りで辿ったときの頂点間の距離は&lt;code&gt;S[1]-S[0]&lt;/code&gt;になり、&lt;code&gt;E-A&lt;/code&gt;をまたぐことを1周したとして&lt;code&gt;S[0]&lt;/code&gt;の値を&lt;code&gt;+5&lt;/code&gt;して考えると、時計回りで辿ったときの頂点間の距離は&lt;code&gt;S[0]+5-S[1]&lt;/code&gt;になり、これらのうち小さい方がその頂点間の距離になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - 'A').ToArray();
    var T = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - 'A').ToArray();
    Array.Sort(S);
    Array.Sort(T);
    var d1 = Math.Min(S[1] - S[0], S[0] + 5 - S[1]);
    var d2 = Math.Min(T[1] - T[0], T[0] + 5 - T[1]);
    var answer = d1 == d2;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc333/tasks/abc333_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC333/submissions/48549647"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あり得る数を全列挙し、&lt;code&gt;N&lt;/code&gt;番目の数を求めます。&lt;br /&gt;
&lt;code&gt;i&lt;/code&gt;番目のレピュニット数&lt;code&gt;R[i]&lt;/code&gt;は、&lt;code&gt;R[1]=1&lt;/code&gt;、&lt;code&gt;R[i]=R[i-1]*10+1&lt;/code&gt;になります。&lt;br /&gt;
入出力例から&lt;code&gt;333&lt;/code&gt;番目は13桁あればいいので、13桁のレピュニット数を3つ選ぶ方法を全探索し、重複を削除したものの&lt;code&gt;N&lt;/code&gt;番目が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var M = 13;
    var A = new long[M];
    A[0] = 1;
    for (var i = 1; i &amp;lt; M; i++)
    {
        A[i] = A[i - 1] * 10 + 1;
    }

    var set = new HashSet&amp;lt;long&amp;gt; { 0 };
    for (var i = 0; i &amp;lt; M; i++)
    {
        for (var j = 0; j &amp;lt; M; j++)
        {
            for (var k = 0; k &amp;lt; M; k++)
            {
                set.Add(A[i] + A[j] + A[k]);
            }
        }
    }

    var array = set.Order().ToArray();
    var answer = array[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc333/tasks/abc333_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC333/submissions/48558726"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;1&lt;/code&gt;を葉にするには、頂点&lt;code&gt;1&lt;/code&gt;に連結している&lt;code&gt;M&lt;/code&gt;個の部分木のうち、&lt;code&gt;M-1&lt;/code&gt;個の部分木を削除することで達成できます。&lt;br /&gt;
よって、&lt;code&gt;M&lt;/code&gt;個の部分木の大きさをそれぞれ数え上げ、その中で一番大きな部分木以外の部分木を削除し、最後に頂点&lt;code&gt;1&lt;/code&gt;を削除することが最小の操作回数となります。&lt;br /&gt;
また、部分木の大きさは深さ優先探索で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        G[a].Add(b);
        G[b].Add(a);
    }

    int Dfs(int u, int p)
    {
        var result = 0;
        foreach (var v in G[u])
        {
            if (v == p) continue;
            result += Dfs(v, u);
        }

        return result + 1;
    }

    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var counts = new int[G[0].Count];
    for (var i = 0; i &amp;lt; G[0].Count; i++)
    {
        counts[i] = Dfs(G[0][i], 0);
    }

    var answer = counts.Sum() - counts.Max() + 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc333/tasks/abc333_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC333/submissions/48572832"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出来事を後ろから見ていくことで、その時点で必要なポーションの個数を計算することができます。&lt;br /&gt;
&lt;code&gt;x&lt;/code&gt;番目のモンスターに必要なポーションの個数を&lt;code&gt;P[x]&lt;/code&gt;、必要なポーションの個数の合計を&lt;code&gt;k&lt;/code&gt;とします。&lt;br /&gt;
出来事を後ろから見ていったとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t==1&lt;/code&gt;のとき、
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;P[x]==0&lt;/code&gt;ならば、この出来事の後には&lt;code&gt;x&lt;/code&gt;のポーションが必要なモンスターは出てこないため、そのポーションを拾う必要はありません。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P[x]&amp;gt;0&lt;/code&gt;ならば、この出来事の後には&lt;code&gt;x&lt;/code&gt;のポーションが必要なモンスターが出てくるため、そのポーションを拾う必要があります。
また、&lt;code&gt;P[x]-=1,k-=1&lt;/code&gt;になります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t==2&lt;/code&gt;のとき、&lt;code&gt;x&lt;/code&gt;のポーションが必要なモンスターが出てくるため、&lt;code&gt;P[x]+=1&lt;/code&gt;になります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして、全ての出来事を見たとき、&lt;code&gt;k&amp;gt;0&lt;/code&gt;ならば、必要なポーションが足りていないので答えは&lt;code&gt;-1&lt;/code&gt;になり、&lt;code&gt;k==0&lt;/code&gt;ならば、全ての出来事の間の&lt;code&gt;k&lt;/code&gt;の最大値が&lt;code&gt;Kmin&lt;/code&gt;になり、&lt;code&gt;t==1 &amp;amp;&amp;amp; P[x]&amp;gt;0&lt;/code&gt;のときの出来事のポーションを拾うことが答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Q = new Query[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (t, x) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        Q[i] = new Query(t, x - 1);
    }

    var answers = new List&amp;lt;int&amp;gt;();
    var P = new int[N];
    var k = 0;
    var minK = 0;
    for (var i = N - 1; i &amp;gt;= 0; i--)
    {
        var (t, x) = Q[i];
        if (t == 1)
        {
            if (P[x] == 0)
            {
                answers.Add(0);
            }
            else
            {
                answers.Add(1);
                minK = Math.Max(minK, k);
                P[x]--;
                k--;
            }
        }
        else
        {
            P[x]++;
            k++;
        }
    }

    if (k &amp;gt; 0)
    {
        Console.WriteLine(-1);
    }
    else
    {
        answers.Reverse();
        Console.WriteLine(minK);
        Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
    }
}

public readonly record struct Query(int T, int X);
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 333の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231210abc332</id>
		<title>ABC332</title>
		<link href="https://blog.aconcavy.dev/posts/20231210abc332" />
		<updated>2023-12-10T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 332の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc332"&gt;https://atcoder.jp/contests/abc332&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc332/tasks/abc332_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc332/submissions/48363459"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P[i]*Q[i]&lt;/code&gt;の総和を求め、総和が&lt;code&gt;S&lt;/code&gt;未満であれば送料の&lt;code&gt;K&lt;/code&gt;を足したものが答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, S, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (P, Q) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        answer += P * Q;
    }

    if (answer &amp;lt; S) answer += K;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc332/tasks/abc332_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc332/submissions/48367804"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;手順を愚直にシミュレートします。&lt;br /&gt;
現在のグラスの水の量を&lt;code&gt;cg&lt;/code&gt;、現在のマグカップの水の量を&lt;code&gt;cm&lt;/code&gt;としたとき、&lt;code&gt;cg==G&lt;/code&gt;ならば&lt;code&gt;cg=0&lt;/code&gt;、そうでなく&lt;code&gt;cm==0&lt;/code&gt;ならば&lt;code&gt;cm=M&lt;/code&gt;、それ以外のとき&lt;code&gt;d=Min(G-cg,cm)&lt;/code&gt;としたとき、&lt;code&gt;cg+=d&lt;/code&gt;かつ&lt;code&gt;cm-=d&lt;/code&gt;になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (K, G, M) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    long cg = 0;
    long cm = 0;
    while (K-- &amp;gt; 0)
    {
        if (cg == G) cg = 0;
        else if (cm == 0) cm = M;
        else
        {
            var d = Math.Min(G - cg, cm);
            cg += d;
            cm -= d;
        }
    }

    Console.WriteLine($&amp;quot;{cg} {cm}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc332/tasks/abc332_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc332/submissions/48379127"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような小問題を定義したとき、新しく購入するTシャツの数&lt;code&gt;x&lt;/code&gt;を二部探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;x枚のロゴ入りのTシャツを買うことでN日間過ごすことができるか。
無地のTシャツの枚数をa、ロゴ入りのTシャツの枚数をbとする。
初期値a=M、b=xとする。
各iについて次を判定する。

- S[i]が0のとき、a=M、b=xにする。
- S[i]が1のとき、a&amp;gt;0ならばa-=1する。そうでないとき、b&amp;gt;0ならばb-=1する。それ以外のときはTシャツがないので、x枚ではN日間過ごすことができない。
- S[i]が2のとき、b&amp;gt;0ならばb-=1する。それ以外のときはTシャツがないので、x枚ではN日間過ごすことができない。

1&amp;lt;=i&amp;lt;=Nにおいてa&amp;gt;=0かつb&amp;gt;=0を満たすことができれば、x枚でN日間過ごすことができる。
&lt;/code&gt;&lt;/pre&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    bool F(int x)
    {
        var a = M;
        var b = x;

        for (var i = 0; i &amp;lt; N; i++)
        {
            if (S[i] == '0')
            {
                a = M;
                b = x;
            }
            else if (S[i] == '1')
            {
                if (a &amp;gt; 0) a--;
                else if (b &amp;gt; 0) b--;
                else return false;
            }
            else
            {
                if (b &amp;gt; 0) b--;
                else return false;
            }
        }

        return true;
    }

    var answer = BinarySearch&amp;lt;int&amp;gt;(-1, N, F);
    Console.WriteLine(answer);
}

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f) where T : INumber&amp;lt;T&amp;gt; =&amp;gt; BinarySearch(ng, ok, f, T.One);

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f, T eps) where T : INumber&amp;lt;T&amp;gt;
{
    var one = T.One;
    var two = one + one;
    while (T.Abs(ok - ng) &amp;gt; eps)
    {
        var m = ng + (ok - ng) / two;
        if (f(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc332/tasks/abc332_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc332/submissions/48406663"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行&lt;code&gt;x&lt;/code&gt;と行&lt;code&gt;y&lt;/code&gt;を入れ替えたとき、各列における要素の順番が変わるだけで、要素の集合が変わることはありません。&lt;br /&gt;
同様に、列&lt;code&gt;x&lt;/code&gt;と列&lt;code&gt;y&lt;/code&gt;を入れ替えたとき、各行における要素の順番が変わるだけで、要素の集合が変わることはありません。&lt;br /&gt;
このことから、行を入れ替える操作と列を入れ替える操作は、それぞれ独立していることがわかります。&lt;br /&gt;
よって、&lt;code&gt;A&lt;/code&gt;の行を並べ替える順列と、&lt;code&gt;A&lt;/code&gt;の列の並べ替えの順列を全探索し、行と列を並べ替えたものが&lt;code&gt;B&lt;/code&gt;と一致しているかを判定します。&lt;br /&gt;
ある数列をバブルソートしたとき、隣り合う2項の交換回数はその数列の転倒数と一致するので、&lt;code&gt;B&lt;/code&gt;と一致するような&lt;code&gt;A&lt;/code&gt;の行番号の順列の転倒数と、列番号の順列の転倒数の和が、その並べ替えにおける&lt;code&gt;A&lt;/code&gt;を&lt;code&gt;B&lt;/code&gt;に一致させる交換回数になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[H][].Select(_ =&amp;gt; Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray()).ToArray();
    var B = new int[H][].Select(_ =&amp;gt; Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray()).ToArray();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var answer = Inf;
    foreach (var oAH in Permutation.Generate(H))
    {
        foreach (var oAW in Permutation.Generate(W))
        {
            var ok = true;
            for (var i = 0; i &amp;lt; H &amp;amp;&amp;amp; ok; i++)
            {
                for (var j = 0; j &amp;lt; W &amp;amp;&amp;amp; ok; j++)
                {
                    ok &amp;amp;= A[oAH[i]][oAW[j]] == B[i][j];
                }
            }

            if (!ok) continue;

            var inv = 0;
            var ftH = new FenwickTree&amp;lt;int&amp;gt;(H);
            var ftW = new FenwickTree&amp;lt;int&amp;gt;(W);
            for (var i = 0; i &amp;lt; H; i++)
            {
                inv += i - ftH.Sum(oAH[i] + 1);
                ftH.Add(oAH[i], 1);
            }

            for (var j = 0; j &amp;lt; W; j++)
            {
                inv += j - ftW.Sum(oAW[j] + 1);
                ftW.Add(oAW[j], 1);
            }

            answer = Math.Min(answer, inv);
        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}

public class FenwickTree&amp;lt;T&amp;gt;
    where T : struct, IAdditionOperators&amp;lt;T, T, T&amp;gt;, ISubtractionOperators&amp;lt;T, T, T&amp;gt;, IComparisonOperators&amp;lt;T, T, bool&amp;gt;
{
    public int Length { get; }
    private readonly T[] _data;

    public FenwickTree(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _data = new T[length];
    }

    public void Add(int index, T value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index++;
        while (index &amp;lt;= Length)
        {
            _data[index - 1] += value;
            index += index &amp;amp; -index;
        }
    }

    public T Sum(int length)
    {
        if (length &amp;lt; 0 || Length &amp;lt; length) throw new ArgumentOutOfRangeException(nameof(length));
        T s = default;
        while (length &amp;gt; 0)
        {
            s += _data[length - 1];
            length -= length &amp;amp; -length;
        }

        return s;
    }

    public T Sum(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        return Sum(right) - Sum(left);
    }

    public int LowerBound(T value) =&amp;gt; Bound(value, (x, y) =&amp;gt; x &amp;lt;= y);
    public int UpperBound(T value) =&amp;gt; Bound(value, (x, y) =&amp;gt; x &amp;lt; y);

    private int Bound(T value, Func&amp;lt;T, T, bool&amp;gt; compare)
    {
        if (Length == 0 || compare(value, _data[0])) return 0;
        var x = 0;
        var r = 1;
        while (r &amp;lt; Length) r &amp;lt;&amp;lt;= 1;
        for (var k = r; k &amp;gt; 0; k &amp;gt;&amp;gt;= 1)
        {
            if (x + k - 1 &amp;gt;= Length || compare(value, _data[x + k - 1])) continue;
            value -= _data[x + k - 1];
            x += k;
        }

        return x;
    }
}

public static class Permutation
{
    public static bool NextPermutation(Span&amp;lt;int&amp;gt; indices)
    {
        var n = indices.Length;
        var (i, j) = (n - 2, n - 1);
        while (i &amp;gt;= 0 &amp;amp;&amp;amp; indices[i] &amp;gt;= indices[i + 1]) i--;
        if (i == -1) return false;
        while (j &amp;gt; i &amp;amp;&amp;amp; indices[j] &amp;lt;= indices[i]) j--;
        (indices[i], indices[j]) = (indices[j], indices[i]);
        indices[(i + 1)..].Reverse();
        return true;
    }

    public static bool PreviousPermutation(Span&amp;lt;int&amp;gt; indices)
    {
        var n = indices.Length;
        var (i, j) = (n - 2, n - 1);
        while (i &amp;gt;= 0 &amp;amp;&amp;amp; indices[i] &amp;lt;= indices[i + 1]) i--;
        if (i == -1) return false;
        indices[(i + 1)..].Reverse();
        while (j &amp;gt; i &amp;amp;&amp;amp; indices[j - 1] &amp;lt; indices[i]) j--;
        (indices[i], indices[j]) = (indices[j], indices[i]);
        return true;
    }

    public static IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Generate(int n)
    {
        return Inner();

        IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Inner()
        {
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++) indices[i] = i;
            do { yield return indices; } while (NextPermutation(indices));
        }
    }

    public static IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; GenerateDescending(int n)
    {
        return Inner();

        IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Inner()
        {
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++) indices[i] = n - 1 - i;
            do { yield return indices; } while (PreviousPermutation(indices));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 332の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231202abc331</id>
		<title>ABC331</title>
		<link href="https://blog.aconcavy.dev/posts/20231202abc331" />
		<updated>2023-12-02T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 331の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc331"&gt;https://atcoder.jp/contests/abc331&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc331/tasks/abc331_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC331/submissions/48105656"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次の日を求めるので、&lt;code&gt;d&lt;/code&gt;を&lt;code&gt;+1&lt;/code&gt;します。&lt;br /&gt;
このとき、&lt;code&gt;d&amp;gt;D&lt;/code&gt;ならば、次の月になるので、&lt;code&gt;m&lt;/code&gt;を&lt;code&gt;+1&lt;/code&gt;して&lt;code&gt;d&lt;/code&gt;が&lt;code&gt;1&lt;/code&gt;になります。&lt;br /&gt;
このとき、&lt;code&gt;m&amp;gt;M&lt;/code&gt;ならば、次の年になるので、&lt;code&gt;y&lt;/code&gt;を&lt;code&gt;+1&lt;/code&gt;して&lt;code&gt;m&lt;/code&gt;が&lt;code&gt;1&lt;/code&gt;になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (M, D) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var (y, m, d) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    d++;

    if (d &amp;gt; D)
    {
        d = 1;
        m++;
    }

    if (m &amp;gt; M)
    {
        m = 1;
        y++;
    }

    Console.WriteLine($&amp;quot;{y} {m} {d}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc331/tasks/abc331_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC331/submissions/48102993"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;サイズごとの卵のパックを全探索します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, S, M, L) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    const long Inf = 1 &amp;lt;&amp;lt; 60;
    var answer = Inf;

    for (var s = 0; s &amp;lt;= (100 + 5) / 6; s++)
    {
        for (var m = 0; m &amp;lt;= (100 + 7) / 8; m++)
        {
            for (var l = 0; l &amp;lt;= (100 + 11) / 12; l++)
            {
                if (s * 6 + m * 8 + l * 12 &amp;gt;= N)
                {
                    answer = Math.Min(answer, s * S + m * M + l * L);
                }
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;次のような動的計画法で解くこともできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i] := i個の卵を買うときの最小の金額
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i+6] = Min(dp[i+6], dp[i]+S);
dp[i+8] = Min(dp[i+8], dp[i]+M);
dp[i+12] = Min(dp[i+12], dp[i]+L);
&lt;/code&gt;&lt;/pre&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, S, M, L) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var dp = new long[N + 1];
    Array.Fill(dp, Inf);
    dp[0] = 0;
    var X = new (int, long)[] { (6, S), (8, M), (12, L) };
    for (var i = 0; i &amp;lt; N; i++)
    {
        foreach (var (c, v) in X)
        {
            var nc = Math.Min(N, i + c);
            dp[nc] = Math.Min(dp[nc], dp[i] + v);
        }
    }

    var answer = dp[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc331/tasks/abc331_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC331/submissions/48110811"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;A[i]&lt;/code&gt;について&lt;code&gt;A[i]&lt;/code&gt;より大きな要素全ての和を愚直に探索してしまうと、&lt;code&gt;A[i]&lt;/code&gt;ごとに時間計算量&lt;code&gt;O(N)&lt;/code&gt;、全体で時間計算量&lt;code&gt;O(N^2)&lt;/code&gt;になり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、各&lt;code&gt;A[i]&lt;/code&gt;に対して高速に答えを求められるようにする必要があります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;を昇順ソートしたものを&lt;code&gt;B&lt;/code&gt;、数列&lt;code&gt;B&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目までの累積和を&lt;code&gt;cum[i]&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;における&lt;code&gt;A[i]&lt;/code&gt;が出現する最も右側の位置を&lt;code&gt;pos[A[i]]&lt;/code&gt;とします。&lt;br /&gt;
&lt;code&gt;A[i]&lt;/code&gt;より大きい要素全ての和は、&lt;code&gt;数列全体の和-A[i]以下の要素全ての和&lt;/code&gt;で求めることができることから、&lt;code&gt;cum[N]-cum[pos[A[i]]]&lt;/code&gt;で求めることができるようになります。&lt;br /&gt;
あらかじめ&lt;code&gt;cum[i]&lt;/code&gt;を時間計算量&lt;code&gt;O(N)&lt;/code&gt;で求めておくことで、以降各&lt;code&gt;i&lt;/code&gt;に対して時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができるようにします。&lt;br /&gt;
また、辞書などのデータ構造や&lt;code&gt;B&lt;/code&gt;に対する二部探索を行うことで、&lt;code&gt;pos[A[i]]&lt;/code&gt;を時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができるようにします。&lt;br /&gt;
そして、各&lt;code&gt;A[i]&lt;/code&gt;に対して&lt;code&gt;cum[N]-cum[pos[A[i]]]&lt;/code&gt;を求めていくことで、全体時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = A.ToArray();
    Array.Sort(B);
    var pos = new Dictionary&amp;lt;long, int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        pos[B[i]] = i;
    }

    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + B[i];
    }

    var answers = new long[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answers[i] = cum[N] - cum[pos[A[i]] + 1];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc331/tasks/abc331_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC331/submissions/48136966"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N*N&lt;/code&gt;マスのパターンを&lt;code&gt;P&lt;/code&gt;とします。&lt;br /&gt;
&lt;code&gt;P&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目までのにおける黒の個数を二次元累積和を&lt;code&gt;S[i][j]&lt;/code&gt;は次のように求められます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + (P[i][j]が黒?1:0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;S[i][j]&lt;/code&gt;を時間計算量&lt;code&gt;O(N^2)&lt;/code&gt;で求めておき、各クエリ当たり時間計算量&lt;code&gt;O(1)&lt;/code&gt;で答えられるようにしておきます。&lt;/p&gt;
&lt;p&gt;クエリ&lt;code&gt;a,b,c,d&lt;/code&gt;は閉区間&lt;code&gt;H:[a,c], W:[b,d]&lt;/code&gt;ですが、計算の都合として半開区間&lt;code&gt;H:[a,c), W:[b,d)&lt;/code&gt;とします。&lt;br /&gt;
また、&lt;code&gt;a,b,c,d&lt;/code&gt;を&lt;code&gt;N&lt;/code&gt;で割った余りを&lt;code&gt;am,bm,cm,dm&lt;/code&gt;とします。&lt;br /&gt;
クエリの長方形領域を&lt;code&gt;3*3&lt;/code&gt;の領域に分割すると、領域の{左上|右上|左下|右下}は&lt;code&gt;P&lt;/code&gt;の一部を覆い、{左中|右中}は&lt;code&gt;P&lt;/code&gt;の行の全てと列の一部を覆い、{上中|下中}は&lt;code&gt;P&lt;/code&gt;の行の一部と列の全てを覆い、真中が&lt;code&gt;P&lt;/code&gt;の行と列の全てを覆います。&lt;/p&gt;
&lt;p&gt;また、｛左|右|上|下|真｝中の領域は、0以上個の&lt;code&gt;P&lt;/code&gt;を繰り返します。&lt;br /&gt;
行を全て使うものは、縦に&lt;code&gt;hc=((c-a)-(N-am+cm))/N&lt;/code&gt;個の&lt;code&gt;P&lt;/code&gt;を並べます。&lt;br /&gt;
同様に、列を全て使うものは、横に&lt;code&gt;wc=((d-b)-(N-bm+dm))/N&lt;/code&gt;個の&lt;code&gt;P&lt;/code&gt;を並べます。&lt;br /&gt;
よって、各領域は次の範囲を覆います。&lt;/p&gt;
&lt;div class="table-responsive"&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;領域&lt;/th&gt;
&lt;th style="text-align: right;"&gt;行&lt;/th&gt;
&lt;th style="text-align: right;"&gt;列&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Pの個数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;左上&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[am,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[bm,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;右上&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[am,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,dm)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;左下&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,bm)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[cm,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;右下&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,0)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[cm,dm)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;左中&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[bm,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;hc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;右中&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,dm)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;hc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;上中&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[am,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;wc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;下中&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,cm)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;wc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;真中&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;[0,N)&lt;/td&gt;
&lt;td style="text-align: right;"&gt;hc*wc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;よって、各領域の&lt;code&gt;P&lt;/code&gt;を覆う範囲にある黒の個数に繰り返す&lt;code&gt;P&lt;/code&gt;の個数を掛けたものの総和が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = new char[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        P[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var cum = new CumulativeSum2D&amp;lt;long&amp;gt;(N + 10, N + 10);
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (P[i][j] == 'B')
            {
                cum.Add(i, j, 1);
            }
        }
    }

    while (Q-- &amp;gt; 0)
    {
        var (a, b, c, d) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
        c++; d++;

        long answer = 0;
        var (am, bm, cm, dm) = (a % N, b % N, c % N, d % N);
        long hc = ((c - a) - (N - am + cm)) / N;
        long wc = ((d - b) - (N - bm + dm)) / N;

        answer += cum.Sum(am, bm, N, N); // 左上
        answer += cum.Sum(am, 0, N, dm); // 右上
        answer += cum.Sum(0, bm, cm, N); // 左下
        answer += cum.Sum(0, 0, cm, dm); // 右下

        answer += cum.Sum(0, bm, N, N) * hc; // 左中
        answer += cum.Sum(0, 0, N, dm) * hc; // 右中
        answer += cum.Sum(am, 0, N, N) * wc; // 上中
        answer += cum.Sum(0, 0, cm, N) * wc; // 下中

        answer += cum.Sum(N, N) * (hc * wc); // 中中

        Console.WriteLine(answer);
    }
}

public class CumulativeSum2D&amp;lt;T&amp;gt; where T : INumber&amp;lt;T&amp;gt;
{
    public int Height { get; }
    public int Width { get; }
    private readonly T[] _data;
    private readonly T[] _sum;
    private bool _isUpdated;

    public CumulativeSum2D(int height, int width)
    {
        if (height &amp;lt;= 0) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt;= 0) throw new ArgumentOutOfRangeException(nameof(width));
        Height = height;
        Width = width;
        _data = new T[height * width];
        _sum = new T[(height + 1) * (width + 1)];
    }

    public void Add(int height, int width, T value)
    {
        ThrowIfNegative(height);
        ThrowIfGreaterThanOrEqual(height, Height);
        ThrowIfNegative(width);
        ThrowIfGreaterThanOrEqual(width, Width);
        _isUpdated = false;
        _data[height * Width + width] += value;
    }

    public void Set(int height, int width, T value)
    {
        ThrowIfNegative(height);
        ThrowIfGreaterThanOrEqual(height, Height);
        ThrowIfNegative(width);
        ThrowIfGreaterThanOrEqual(width, Width);
        _isUpdated = false;
        _data[height * Width + width] = value;
    }

    public T Get(int height, int width)
    {
        ThrowIfNegative(height);
        ThrowIfGreaterThanOrEqual(height, Height);
        ThrowIfNegative(width);
        ThrowIfGreaterThanOrEqual(width, Width);
        return _data[height * Width + width];
    }

    /// &amp;lt;summary&amp;gt;
    /// Calculate a two-dimensional cumulative sum of [0, height), [0, width).
    /// &amp;lt;/summary&amp;gt;
    public T Sum(int height, int width)
    {
        ThrowIfNegative(height);
        ThrowIfGreaterThan(height, Height);
        ThrowIfNegative(width);
        ThrowIfGreaterThan(width, Width);
        if (!_isUpdated) Build();
        return _sum[height * (Width + 1) + width];
    }

    /// &amp;lt;summary&amp;gt;
    /// Calculate a two-dimensional cumulative sum of [height1, height2), [width1, width2).
    /// &amp;lt;/summary&amp;gt;
    public T Sum(int height1, int width1, int height2, int width2)
    {
        ThrowIfGreaterThan(height1, height2);
        ThrowIfGreaterThan(width1, width2);
        return Sum(height1, width1) + Sum(height2, width2) - Sum(height2, width1) - Sum(height1, width2);
    }

    private void Build()
    {
        _isUpdated = true;
        var w1 = Width + 1;
        _sum[0] = _sum[w1] = _sum[1] = T.Zero;
        for (var i = 1; i &amp;lt;= Height; i++)
        {
            for (var j = 1; j &amp;lt;= Width; j++)
            {
                _sum[i * w1 + j] =
                    _sum[i * w1 + (j - 1)]
                    + _sum[(i - 1) * w1 + j]
                    - _sum[(i - 1) * w1 + (j - 1)]
                    + _data[(i - 1) * Width + (j - 1)];
            }
        }
    }

    private static void ThrowIfNegative(int value)
    {
        if (value &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(value));
    }

    private static void ThrowIfGreaterThan(int value, int other)
    {
        if (value &amp;gt; other) throw new ArgumentOutOfRangeException(nameof(value));
    }

    private static void ThrowIfGreaterThanOrEqual(int value, int other)
    {
        if (value &amp;gt;= other) throw new ArgumentOutOfRangeException(nameof(value));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc331/tasks/abc331_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC331/submissions/48133625"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主菜のを固定したとき、その主菜との食べ合わせが悪くない最も価格の高い副菜が、その主菜に対する最も価格が高い定食の組み合わせになります。&lt;br /&gt;
その主菜との食べ合わせが悪くない副菜のうち、最も価格が高い副菜以外を組み合わせたところで、最も高い副菜との組み合わせのほうが定食価格が高いので、最も高い副菜以外の走査を打ち切ることができます。&lt;br /&gt;
これにより、&lt;code&gt;N&lt;/code&gt;種類の主菜と、食べ合わせが悪い&lt;code&gt;L&lt;/code&gt;種類の食べ合わせを判定することで答えを求めることができます。&lt;br /&gt;
したがって、食べ合わせが悪い主菜と副菜の組み合わせのペアを集合で管理し、&lt;code&gt;B&lt;/code&gt;の価格と番号をペアにしたものを、価格の降順に並べ替え、各&lt;code&gt;A&lt;/code&gt;に対して食べ合わせの判定を行うことで、時間計算量&lt;code&gt;O(MlogM+N+L)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, L) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var set = new HashSet&amp;lt;(int C, int D)&amp;gt;();
    for (var i = 0; i &amp;lt; L; i++)
    {
        var (c, d) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        c--; d--;
        set.Add((c, d));
    }

    var C = B.Select((x, i) =&amp;gt; (V: x, I: i)).OrderByDescending(x =&amp;gt; x.V).ToArray();
    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, ai) = (A[i], i);
        for (var j = 0; j &amp;lt; M; j++)
        {
            var (b, bi) = C[j];
            if (set.Contains((ai, bi))) continue;
            answer = Math.Max(answer, a + b);
            break;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 331の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231125abc330</id>
		<title>ABC330</title>
		<link href="https://blog.aconcavy.dev/posts/20231125abc330" />
		<updated>2023-11-25T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 330の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc330"&gt;https://atcoder.jp/contests/abc330&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc330/tasks/abc330_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC330/submissions/47889596"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;内の条件を満たす個数を数え上げます。&lt;br /&gt;
また、&lt;code&gt;C#&lt;/code&gt;では&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;を実装するシーケンスに対して、&lt;code&gt;Count()&lt;/code&gt;の引数に条件判定を行うラムダ式を渡すことで、シーケンス内で与えられた条件を満たすものの個数を得ることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, L) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = A.Count(x =&amp;gt; x &amp;gt;= L);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc330/tasks/abc330_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC330/submissions/47919485"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC330/submissions/47943949"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;L&amp;lt;=x&amp;lt;=R&lt;/code&gt;のうち、&lt;code&gt;A[i]&lt;/code&gt;に最も近い&lt;code&gt;x&lt;/code&gt;を求めます。&lt;br /&gt;
&lt;code&gt;L&amp;lt;=A[i]&amp;lt;=R&lt;/code&gt;であるとき、&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;A[i]&lt;/code&gt;です。&lt;br /&gt;
&lt;code&gt;A[i]&amp;lt;L&lt;/code&gt;であるとき、&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;L&lt;/code&gt;です。&lt;br /&gt;
&lt;code&gt;A[i]&amp;gt;R&lt;/code&gt;であるとき、&lt;code&gt;x&lt;/code&gt;は&lt;code&gt;R&lt;/code&gt;です。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, L, R) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var answers = A.Select(x =&amp;gt; Math.Min(Math.Max(L, x), R));
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc330/tasks/abc330_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC330/submissions/47918184"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;を固定して考えると、&lt;code&gt;x&lt;/code&gt;が取りうる範囲は&lt;code&gt;0&amp;lt;=x&amp;lt;=Sqrt(D)&lt;/code&gt;になります。&lt;br /&gt;
これにより、&lt;code&gt;x^2-D&lt;/code&gt;を&lt;code&gt;c&lt;/code&gt;とすると、&lt;code&gt;c&amp;gt;=0&lt;/code&gt;のとき&lt;code&gt;y==0&lt;/code&gt;で最小値を取り、&lt;code&gt;c&amp;lt;0&lt;/code&gt;のとき、&lt;code&gt;y==Floor(Sqrt(-c))&lt;/code&gt;または&lt;code&gt;y==Ceil(Sqrt(-c))&lt;/code&gt;で最小値を取ります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var D = Scanner.Scan&amp;lt;long&amp;gt;();
    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var answer = Inf;
    for (long x = 0; x * x &amp;lt;= D; x++)
    {
        var xx = x * x;
        var c = xx - D;
        var y = c &amp;gt;= 0 ? 0 : (long)Math.Sqrt(-c);
        for (var k = 0; k &amp;lt; 2; k++)
        {
            var yy = (y + k) * (y + k);
            var v = Math.Abs(xx + yy - D);
            answer = Math.Min(answer, v);
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc330/tasks/abc330_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC330/submissions/47931077"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;行目の&lt;code&gt;o&lt;/code&gt;の個数を&lt;code&gt;cH[i]&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;行目の&lt;code&gt;o&lt;/code&gt;の個数を&lt;code&gt;cW[j]&lt;/code&gt;とします。&lt;br /&gt;
&lt;code&gt;i&lt;/code&gt;行目&lt;code&gt;j&lt;/code&gt;列のマスが&lt;code&gt;o&lt;/code&gt;のとき、そのマスと同じ行にある&lt;code&gt;o&lt;/code&gt;のマスを選ぶ組み合わせは&lt;code&gt;ch[i]-1&lt;/code&gt;個、そのマスと同じ列にある&lt;code&gt;o&lt;/code&gt;のマスを選ぶ組み合わせは&lt;code&gt;cw[j]-1&lt;/code&gt;個なので、このマスを3マスのうちの1つとしたとき、このマスを含む組み合わせは&lt;code&gt;(ch[i]-1)*(cw[j]-1)&lt;/code&gt;個になります。&lt;br /&gt;
よって、すべての&lt;code&gt;o&lt;/code&gt;のマスを固定したときの組み合わせの総和が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new char[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var cH = new long[N + 1];
    var cW = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (G[i][j] == 'x') continue;
            cH[i]++;
            cW[j]++;
        }
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (G[i][j] == 'x') continue;
            answer += (cH[i] - 1) * (cW[j] - 1);
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc330/tasks/abc330_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC330/submissions/47936346"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長さ&lt;code&gt;N&lt;/code&gt;の数列において取りうる&lt;code&gt;mex&lt;/code&gt;の値は、&lt;code&gt;0&amp;lt;=mex&amp;lt;=N&lt;/code&gt;になります。&lt;br /&gt;
よって、&lt;code&gt;A[i]&lt;/code&gt;が&lt;code&gt;N&lt;/code&gt;より大きい場合は、その値に対する処理を無視することができます。
また、数列&lt;code&gt;X&lt;/code&gt;において、&lt;code&gt;A[i]&lt;/code&gt;に存在する値は&lt;code&gt;X[A[i]]=inf&lt;/code&gt;、存在しない値は&lt;code&gt;X[i]=i&lt;/code&gt;とすることで、&lt;code&gt;X&lt;/code&gt;における最小値を&lt;code&gt;mex&lt;/code&gt;として求めることができます。&lt;br /&gt;
よって、&lt;code&gt;N&lt;/code&gt;以下の値がそれぞれ何個あるかを管理しながら、&lt;code&gt;SegmentTree&lt;/code&gt;などのデータ構造を使い区間内における最小値を高速で求められるようにすることで、クエリ当たり時間計算量&lt;code&gt;O(logN)&lt;/code&gt;、全体時間計算量&lt;code&gt;O(QlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var count = new int[N + 1];
    var st = new SegmentTree&amp;lt;int&amp;gt;(N + 1, new Oracle());
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        st.Set(i, i);
    }

    foreach (var a in A)
    {
        if (a &amp;lt;= N)
        {
            count[a]++;
            st.Set(a, Inf);
        }
    }

    for (var q = 0; q &amp;lt; Q; q++)
    {
        var (i, x) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        i--;
        if (A[i] &amp;lt;= N)
        {
            count[A[i]]--;
            if (count[A[i]] == 0) st.Set(A[i], A[i]);
        }

        A[i] = x;

        if (x &amp;lt;= N)
        {
            count[x]++;
            st.Set(x, Inf);
        }

        var mex = Math.Min(st.QueryToAll(), N);
        Console.WriteLine(mex);
    }
}

public class Oracle : IOracle&amp;lt;int&amp;gt;
{
    public int IdentityElement =&amp;gt; 1 &amp;lt;&amp;lt; 30;

    public int Operate(int a, int b)
    {
        return Math.Min(a, b);
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid IdentityElement { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public class SegmentTree&amp;lt;TMonoid&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly int _log;
    private readonly int _dataSize;

    public SegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid&amp;gt; oracle) : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public SegmentTree(int length, IOracle&amp;lt;TMonoid&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, oracle.IdentityElement);
    }

    public void Set(int index, TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        return _data[index + _dataSize];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        var (sml, smr) = (_oracle.IdentityElement, _oracle.IdentityElement);
        left += _dataSize;
        right += _dataSize;
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 330の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231118abc329</id>
		<title>ABC329</title>
		<link href="https://blog.aconcavy.dev/posts/20231118abc329" />
		<updated>2023-11-19T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 329の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329"&gt;https://atcoder.jp/contests/abc329&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47673253"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C#&lt;/code&gt;では、&lt;code&gt;string.Join&lt;/code&gt;メソッドを使うと、指定した区切り文字で与えられたシーケンスを文字列として結合することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, S.ToArray()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47677331"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;から重複をなくしたものをソートし、2番目に大きいものが答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = A.Distinct().ToArray();
    Array.Sort(B);
    Array.Reverse(B);
    var answer = B[1];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47683874"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1種類の文字からなる長さが&lt;code&gt;L&lt;/code&gt;の連続部分列が存在するとき、長さが&lt;code&gt;L-1&lt;/code&gt;の連続部分列も存在します。&lt;br /&gt;
よって、ある文字のみからなる連続部分列の最大長が、その文字のからなる連続部分列の種類の個数になります。&lt;br /&gt;
このことから、全ての文字ごとのその文字のみからなる連続部分列の最大長の和が答えとなります。&lt;br /&gt;
連続部分列の長さは、尺取り法を行うことで時間計算量&lt;code&gt;O(N)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - 'a').ToArray();
    var maxLengths = new int[26];
    var l = 0;
    var r = 0;
    while (l &amp;lt; N)
    {
        while (r &amp;lt; N &amp;amp;&amp;amp; S[r] == S[l]) r++;
        maxLengths[S[l]] = Math.Max(maxLengths[S[l]], r - l);
        l = r;
    }

    var answer = maxLengths.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47694536"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;count[x]&lt;/code&gt;を候補者&lt;code&gt;x&lt;/code&gt;の得票数、&lt;code&gt;i-1&lt;/code&gt;票目に当選した候補者を&lt;code&gt;y&lt;/code&gt;とします。
&lt;code&gt;i&lt;/code&gt;票目の投票により、候補者&lt;code&gt;A[i]&lt;/code&gt;の票が&lt;code&gt;+1&lt;/code&gt;されます。&lt;br /&gt;
このとき、&lt;code&gt;count[A[i]]&amp;gt;count[y]&lt;/code&gt;の場合、&lt;code&gt;A[i]&lt;/code&gt;の得票数が最多となるので、&lt;code&gt;A[i]&lt;/code&gt;が答えになります。
&lt;code&gt;count[A[i]]==count[y]&lt;/code&gt;の場合、&lt;code&gt;A[i]&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;は得票数が最多の候補者が複数いることになるので、&lt;code&gt;Min(A[i],y)&lt;/code&gt;が答えとなります。
&lt;code&gt;count[A[i]]&amp;lt;count[y]&lt;/code&gt;の場合、変わらず&lt;code&gt;y&lt;/code&gt;の得票数が最多なので、&lt;code&gt;y&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var count = new int[N + 1];
    var answer = 0;
    foreach (var a in A)
    {
        count[a]++;
        if (count[answer] &amp;lt; count[a])
        {
            answer = a;
        }
        else if (count[answer] == count[a])
        {
            answer = Math.Min(answer, a);
        }

        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47736738"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;元の操作に対して、逆の操作を考えます。&lt;br /&gt;
これは、&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;文字目から長さ&lt;code&gt;M&lt;/code&gt;の連続する部分文字列に対して、全ての&lt;code&gt;j&lt;/code&gt;において&lt;code&gt;S[i+j]=='#'&lt;/code&gt;または&lt;code&gt;S[i+j]==T[j]&lt;/code&gt;であるとき、その部分文字列を全て&lt;code&gt;#&lt;/code&gt;にするという操作になります。&lt;br /&gt;
この操作を繰り返し、全ての文字が&lt;code&gt;#&lt;/code&gt;になっている場合、答えは&lt;code&gt;Yes&lt;/code&gt;になります。&lt;/p&gt;
&lt;p&gt;この操作を&lt;code&gt;i&lt;/code&gt;番目に対しての操作としたとき、&lt;code&gt;i&lt;/code&gt;番目に対して複数回操作を行う必要はないので、&lt;code&gt;i&lt;/code&gt;番目に対して既に操作を行ったことがあるかを管理しながら、&lt;code&gt;i&lt;/code&gt;番目の前後&lt;code&gt;M-1&lt;/code&gt;箇所に対して判定を行っていくことで、時間計算量&lt;code&gt;O(NM^2)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();

    var X = S.ToCharArray();
    var used = new bool[N - (M - 1)];
    var queue = new Queue&amp;lt;int&amp;gt;();

    void F(int idx)
    {
        if (used[idx]) return;

        var ok = true;
        for (var i = 0; i &amp;lt; M &amp;amp;&amp;amp; ok; i++)
        {
            ok &amp;amp;= (X[idx + i] == '#' || X[idx + i] == T[i]);
        }

        if (ok)
        {
            used[idx] = true;
            queue.Enqueue(idx);
        }
    }

    for (var i = 0; i &amp;lt; N - (M - 1); i++)
    {
        F(i);
    }

    while (queue.Count &amp;gt; 0)
    {
        var idx = queue.Dequeue();
        X.AsSpan(idx, M).Fill('#');

        for (var i = Math.Max(0, idx - (M - 1)); i &amp;lt;= Math.Min(N - M, idx + (M - 1)); i++)
        {
            F(i);
        }
    }

    var answer = new string(X) == new string('#', N);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc329/tasks/abc329_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc329/submissions/47702938"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;番目の箱に入っているボールの色の集合とします。&lt;br /&gt;
各クエリにおいて、&lt;code&gt;S[a]&lt;/code&gt;から&lt;code&gt;S[b]&lt;/code&gt;にボールを移動し、&lt;code&gt;S[a]&lt;/code&gt;を空にするという操作を行います。&lt;br /&gt;
このとき、&lt;code&gt;|S[a]|&amp;gt;|S[b]|&lt;/code&gt;の場合、&lt;code&gt;S[a]&lt;/code&gt;から&lt;code&gt;S[b]&lt;/code&gt;にボールを移動する代わりに、&lt;code&gt;S[a]&lt;/code&gt;と&lt;code&gt;S[b]&lt;/code&gt;を入れ替えてから&lt;code&gt;S[a]&lt;/code&gt;から&lt;code&gt;S[b]&lt;/code&gt;にボールを移動させることで、ボールの移動回数を減らすことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var set = C.Select(c =&amp;gt; new HashSet&amp;lt;int&amp;gt; { c }).ToArray();
    while (Q-- &amp;gt; 0)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        if (set[b].Count &amp;lt; set[a].Count) (set[a], set[b]) = (set[b], set[a]);
        set[b].UnionWith(set[a]);
        set[a].Clear();
        Console.WriteLine(set[b].Count);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 329の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231111abc328</id>
		<title>ABC328</title>
		<link href="https://blog.aconcavy.dev/posts/20231111abc328" />
		<updated>2023-11-25T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 328の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc328"&gt;https://atcoder.jp/contests/abc328&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47452227"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;のうち、&lt;code&gt;X&lt;/code&gt;以下の値の総和を求めます。&lt;br /&gt;
C#では、配列などの&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;に対して&lt;code&gt;LINQ&lt;/code&gt;を使って例のように書くことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = S.Where(x =&amp;gt; x &amp;lt;= X).Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47464933"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ぞろ目であるには、月と日の数字がすべて同じである必要があるため、各数字が&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;のいずれかである必要があります。&lt;br /&gt;
そのため、ぞろ目にする数字&lt;code&gt;x&lt;/code&gt;を全探索し、&lt;code&gt;N&lt;/code&gt;以下の&lt;code&gt;x&lt;/code&gt;を並べてできた値の月&lt;code&gt;m&lt;/code&gt;のうち、&lt;code&gt;D[m]&lt;/code&gt;以下の&lt;code&gt;x&lt;/code&gt;を並べてできた値の日&lt;code&gt;d&lt;/code&gt;の数を数え上げます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = 0;
    for (var b = 1; b &amp;lt; 10; b++)
    {
        var m = b;
        while (m &amp;lt;= N)
        {
            var d = b;
            while (d &amp;lt;= D[m - 1])
            {
                answer++;
                d *= 10;
                d += b;
            }

            m *= 10;
            m += b;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47472269"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[l..r]&lt;/code&gt;を全探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になってしまいます。&lt;br /&gt;
そこで、あらかじめ&lt;code&gt;x&lt;/code&gt;文字までに文字が隣り合う回数を累積和&lt;code&gt;cum[x]&lt;/code&gt;として時間計算量&lt;code&gt;O(N)&lt;/code&gt;で計算しておき、クエリごとに&lt;code&gt;cum[r]-cum[l-1]&lt;/code&gt;を計算することで、&lt;code&gt;S[l..r]&lt;/code&gt;の文字が隣り合う回数を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求められるようになります。&lt;br /&gt;
ただし、&lt;code&gt;S[l]==S[l-1]&lt;/code&gt;である場合、&lt;code&gt;S[l-1]&lt;/code&gt;は範囲外であるため、答えを&lt;code&gt;-1&lt;/code&gt;する必要がある点に注意が必要です。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var cum = new int[N + 1];
    for (var i = 1; i &amp;lt; N; i++)
    {
        cum[i + 1] += cum[i];
        if (S[i] == S[i - 1]) cum[i + 1]++;
    }

    while (Q-- &amp;gt; 0)
    {
        var (l, r) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        l--;
        var answer = cum[r] - cum[l];
        if (l &amp;gt; 0 &amp;amp;&amp;amp; S[l - 1] == S[l]) answer--;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47476394"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;T&lt;/code&gt;の&lt;code&gt;m&lt;/code&gt;文字目までの文字が決まっているとしたとき、3文字を削除することは&lt;code&gt;m&lt;/code&gt;を&lt;code&gt;-3&lt;/code&gt;することと同じ意味になります。&lt;br /&gt;
よって、はじめに&lt;code&gt;T&lt;/code&gt;を空文字、&lt;code&gt;m=0&lt;/code&gt;として、&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目の文字を順に追加していき、&lt;code&gt;T&lt;/code&gt;の長さが3文字以上かつ末尾が&lt;code&gt;ABC&lt;/code&gt;となる場合は&lt;code&gt;ABC&lt;/code&gt;を削除しながら&lt;code&gt;m&lt;/code&gt;を更新していくことで、最終的にできた文字列が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var T = new char[N];
    var m = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        T[m] = S[i];
        while (m &amp;gt;= 2 &amp;amp;&amp;amp; T[m - 2] == 'A' &amp;amp;&amp;amp; T[m - 1] == 'B' &amp;amp;&amp;amp; T[m] == 'C')
        {
            m -= 3;
        }

        m++;
    }

    var answer = new string(T[..m]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47497743"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;頂点のグラフの全域木には、&lt;code&gt;N-1&lt;/code&gt;本の辺が必要となります。&lt;br /&gt;
よって、&lt;code&gt;M&lt;/code&gt;本の辺から&lt;code&gt;N-1&lt;/code&gt;本を選ぶ組み合わせを全探索し、その&lt;code&gt;N-1&lt;/code&gt;本の辺の組み合わせが全域木になる場合のコストの最小値が答えとなります
&lt;code&gt;N-1&lt;/code&gt;本の辺の組み合わせが全域木になるかは、&lt;code&gt;DSU&lt;/code&gt;などのデータ構造を使ってグラフの連結成分が1つであることを示すことで判定することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var E = new (int U, int V, long W)[M];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v, w) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        u--; v--;
        E[i] = (u, v, w);
    }

    var answer = K;
    foreach (var order in Combine(Enumerable.Range(0, M), N - 1))
    {
        long cost = 0;
        var dsu = new DisjointSetUnion(N);
        foreach (var (u, v, w) in order.Select(x =&amp;gt; E[x]))
        {
            dsu.Merge(u, v);
            cost += w;
            cost %= K;
        }

        if (dsu.SizeOf(0) == N)
        {
            answer = Math.Min(answer, cost);
        }
    }

    Console.WriteLine(answer);
}

public static IEnumerable&amp;lt;TSource[]&amp;gt; Combine&amp;lt;TSource&amp;gt;(IEnumerable&amp;lt;TSource&amp;gt;? source, int count)
{
    if (source is null) throw new ArgumentNullException(nameof(source));

    IEnumerable&amp;lt;TSource[]&amp;gt; Inner()
    {
        var items = source.ToArray();
        if (count &amp;lt;= 0 || items.Length &amp;lt; count) throw new ArgumentOutOfRangeException(nameof(count));
        var n = items.Length;
        var indices = new int[n];
        for (var i = 0; i &amp;lt; indices.Length; i++)
        {
            indices[i] = i;
        }

        TSource[] Result()
        {
            var result = new TSource[count];
            for (var i = 0; i &amp;lt; count; i++)
            {
                result[i] = items[indices[i]];
            }

            return result;
        }

        yield return Result();
        while (true)
        {
            var done = true;
            var idx = 0;
            for (var i = count - 1; i &amp;gt;= 0; i--)
            {
                if (indices[i] == i + n - count) continue;
                idx = i;
                done = false;
                break;
            }

            if (done) yield break;
            indices[idx]++;
            for (var i = idx; i + 1 &amp;lt; count; i++)
            {
                indices[i + 1] = indices[i] + 1;
            }

            yield return Result();
        }
    }

    return Inner();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc328/tasks/abc328_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC328/submissions/47506380"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の頂点があり、各頂点の値が&lt;code&gt;X[i]&lt;/code&gt;であるものを考えます。
部分集合&lt;code&gt;S&lt;/code&gt;が良い集合であるということは、部分集合&lt;code&gt;S&lt;/code&gt;に含まれる全てのクエリ&lt;code&gt;(a,b,d)&lt;/code&gt;において、&lt;code&gt;X[a]-X[b]==d&lt;/code&gt;であり、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;間は同じ連結成分であると考えることができます。&lt;br /&gt;
よって、各クエリ&lt;code&gt;(a,b,d)&lt;/code&gt;を順に見ていったとき、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;が同じ連結成分である場合は、&lt;code&gt;X[a]-X[b]==d&lt;/code&gt;が成り立つ場合にのみクエリを&lt;code&gt;S&lt;/code&gt;に追加できます。&lt;br /&gt;
一方、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;が異なる連結成分である場合は、&lt;code&gt;X[a]-X[b]==d&lt;/code&gt;となるように片方の連結集合の全ての&lt;code&gt;X&lt;/code&gt;の値を変更することで、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;を同じ連結成分にできるため、クエリを&lt;code&gt;S&lt;/code&gt;に追加することができます。&lt;br /&gt;
この操作をマージとしたとき、連結成分の小さい方から大きい方へマージすることで、高速にマージすることができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new List&amp;lt;int&amp;gt;();
    var X = new long[N];
    var dsu = new DisjointSetUnion(N);
    var nodes = new List&amp;lt;int&amp;gt;[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        nodes[i] = new List&amp;lt;int&amp;gt; { i };
    }

    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (a, b, d) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        if (dsu.IsSame(a, b))
        {
            if (X[a] - X[b] == d)
            {
                S.Add(i);
            }
        }
        else
        {
            var (u, v) = (dsu.LeaderOf(a), dsu.LeaderOf(b));
            d -= X[a] - X[b];
            if (nodes[u].Count &amp;lt; nodes[v].Count)
            {
                (u, v) = (v, u);
                d *= -1;
            }

            for (var j = 0; j &amp;lt; nodes[v].Count; j++)
            {
                nodes[u].Add(nodes[v][j]);
                X[nodes[v][j]] -= d;
            }

            dsu.Merge(a, b);
            S.Add(i);
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, S.Select(x =&amp;gt; x + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 328の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231104abc327</id>
		<title>ABC327</title>
		<link href="https://blog.aconcavy.dev/posts/20231104abc327" />
		<updated>2023-11-04T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 327の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc327"&gt;https://atcoder.jp/contests/abc327&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47207464"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;が隣接するということは、&lt;code&gt;S[i]&lt;/code&gt;が&lt;code&gt;a&lt;/code&gt;かつ&lt;code&gt;S[i+1]&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;となる箇所がある、または、&lt;code&gt;S[i]&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;かつ&lt;code&gt;S[i+1]&lt;/code&gt;が&lt;code&gt;a&lt;/code&gt;となる箇所がある必要があるため、そのような&lt;code&gt;i&lt;/code&gt;を全探索します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = false;
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        answer |= S[i] == 'a' &amp;amp;&amp;amp; S[i + 1] == 'b';
        answer |= S[i] == 'b' &amp;amp;&amp;amp; S[i + 1] == 'a';
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47215008"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;を全探索します。&lt;br /&gt;
符号なし64bit整数型で表現できる最大の数は、&lt;code&gt;2^64==2^(4*16)==2^4*2^16==16^16&lt;/code&gt;であり、これは&lt;code&gt;B&lt;/code&gt;の上限となる&lt;code&gt;10^18&lt;/code&gt;未満となります。&lt;br /&gt;
よって&lt;code&gt;A&lt;/code&gt;の上限を&lt;code&gt;15&lt;/code&gt;として探索することで、オーバーフローを考えずに答えを求めることができます。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;x^x&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;に&lt;code&gt;x&lt;/code&gt;を&lt;code&gt;x&lt;/code&gt;回掛けることで求めることができ、&lt;code&gt;x&lt;/code&gt;を&lt;code&gt;x&lt;/code&gt;回掛けるまでに&lt;code&gt;B&lt;/code&gt;を超える場合は、その&lt;code&gt;x&lt;/code&gt;以上の数値は&lt;code&gt;B&lt;/code&gt;を超えるため答えが存在しません。&lt;br /&gt;
つまり、&lt;code&gt;x^y&amp;lt;=B (0&amp;lt;=y&amp;lt;x)&lt;/code&gt;のとき、&lt;code&gt;x^(y+1)&amp;lt;=B&lt;/code&gt;であるためには、&lt;code&gt;x^y&amp;lt;=B/x&lt;/code&gt;である必要があります。&lt;br /&gt;
よって、&lt;code&gt;x^y&amp;gt;B/x&lt;/code&gt;の場合は、&lt;code&gt;x&lt;/code&gt;以上の値には&lt;code&gt;x^x==B&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;は存在しないことが分かります。&lt;br /&gt;
このことから、探索の上限が思いつかなくても、計算途中で&lt;code&gt;B&lt;/code&gt;を超える場合に探索を打ち切ることで、符号付き64bit整数型を使った探索を行ったとしてもオーバーフローを起こさずに答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var B = Scanner.Scan&amp;lt;long&amp;gt;();
    for (long i = 1; i &amp;lt;= 20; i++)
    {
        long v = 1;
        for (var j = 0; j &amp;lt; i; j++)
        {
            if (v &amp;lt;= B / i)
            {
                v *= i;
            }
            else
            {
                Console.WriteLine(-1);
                return;
            }
        }

        if (v == B)
        {
            Console.WriteLine(i);
            return;
        }
    }

    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47225443"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に3つの条件を判定します。&lt;br /&gt;
&lt;code&gt;3*3&lt;/code&gt;のマス目の判定は、&lt;code&gt;a*3+i&lt;/code&gt;行&lt;code&gt;b*3+j&lt;/code&gt;列(&lt;code&gt;0&amp;lt;=a,b&amp;lt;3&lt;/code&gt;、&lt;code&gt;0&amp;lt;=i,j&amp;lt;3&lt;/code&gt;)とすることで、&lt;code&gt;3*3&lt;/code&gt;のマス目を1つの大きなマス目としたとき、&lt;code&gt;a&lt;/code&gt;行&lt;code&gt;b&lt;/code&gt;列の大きなマス目とし、大きなマス目の中の&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列の小さなマス目として見ることができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int N = 9;
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    }

    var answer = true;
    var mask = (1 &amp;lt;&amp;lt; 9) - 1; // マス目の数字の存在判定をbit maskで管理

    for (var i = 0; i &amp;lt; N; i++)
    {
        var v = 0;
        for (var j = 0; j &amp;lt; N; j++)
        {
            v |= 1 &amp;lt;&amp;lt; A[i][j];
        }

        answer &amp;amp;= v == mask;
    }

    for (var j = 0; j &amp;lt; N; j++)
    {
        var v = 0;
        for (var i = 0; i &amp;lt; N; i++)
        {
            v |= 1 &amp;lt;&amp;lt; A[i][j];
        }

        answer &amp;amp;= v == mask;
    }

    for (var a = 0; a &amp;lt; 3; a++)
    {
        for (var b = 0; b &amp;lt; 3; b++)
        {
            var v = 0;
            for (var i = 0; i &amp;lt; 3; i++)
            {
                for (var j = 0; j &amp;lt; 3; j++)
                {
                    v |= 1 &amp;lt;&amp;lt; A[a * 3 + i][b * 3 + j];
                }
            }

            answer &amp;amp;= v == mask;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47236945"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長さ&lt;code&gt;N&lt;/code&gt;の数列&lt;code&gt;X&lt;/code&gt;を、頂点&lt;code&gt;A[i]&lt;/code&gt;と頂点&lt;code&gt;B[i]&lt;/code&gt;間に辺がある&lt;code&gt;N&lt;/code&gt;頂点&lt;code&gt;M&lt;/code&gt;辺のグラフとして考えます。&lt;br /&gt;
このとき、数列&lt;code&gt;X&lt;/code&gt;が良い数列の組であるためには、全ての&lt;code&gt;i&lt;/code&gt;について&lt;code&gt;X[A[i]]!=X[B[i]]&lt;/code&gt;が成立する必要があります。&lt;br /&gt;
よって、隣り合う頂点には異なる数字を割り当てる必要があることから、このグラフが二部グラフであることが良い数列である条件であることがわかります。&lt;br /&gt;
したがって、全ての連結成分において二部グラフが成り立つかを判定することで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var G = new HashSet&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new HashSet&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        G[A[i]].Add(B[i]);
        G[B[i]].Add(A[i]);
    }

    var colors = new int[N];
    Array.Fill(colors, -1);
    var queue = new Queue&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (colors[i] != -1) continue;
        colors[i] = 0;
        queue.Enqueue(i);
        while (queue.TryDequeue(out var u))
        {
            foreach (var v in G[u])
            {
                if (colors[u] == colors[v])
                {
                    Console.WriteLine(&amp;quot;No&amp;quot;);
                    return;
                }

                if (colors[v] != -1) continue;
                colors[v] = colors[u] ^ 1;
                queue.Enqueue(v);
            }
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc327/tasks/abc327_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC327/submissions/47256767"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;選んだコンテストによる変動する、&lt;code&gt;Sum((0.9)^(k-i)*Q[i])&lt;/code&gt;の部分について、次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][j] := i個目のコンテストまで見たとき、参加したコンテストがj個のときの最大値。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;あるコンテストが&lt;code&gt;x&lt;/code&gt;個目の選んだコンテストであった場合のパフォーマンスの重みを&lt;code&gt;w[x]&lt;/code&gt;とします。
また、&lt;code&gt;P&lt;/code&gt;を逆順にすることで、逆順にした&lt;code&gt;P&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目のコンテストのパフォーマンス重みを&lt;code&gt;w[j] (j&amp;lt;=i)&lt;/code&gt;とすることができます。
このとき、遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;// i番目のコンテストを選ばないとき、
dp[i+1][j] = Max(dp[i+1][j], dp[i][j])

// i番目のコンテストを選ぶとき、
dp[i+1][j+1] = Max(dp[i+1][j+1], dp[i][j]+w[j+1]*P[i])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cumW[x]&lt;/code&gt;を選んだコンテストの数が&lt;code&gt;x&lt;/code&gt;個の時の重みの累積和とします。
&lt;code&gt;N&lt;/code&gt;番目のコンテストまで見たとき、&lt;code&gt;dp[N][j]/cumW[j] - 1200/sqrt[j]&lt;/code&gt;の最大値が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var sqrt = new double[N + 1];
    var w = new double[N + 1];
    var cumW = new double[N + 1];
    sqrt[1] = w[1] = cumW[1] = 1;
    for (var i = 2; i &amp;lt;= N; i++)
    {
        sqrt[i] = Math.Sqrt(i);
        w[i] = w[i - 1] * 0.9;
        cumW[i] = cumW[i - 1] + w[i];
    }

    Array.Reverse(P);
    var dp = new double[N + 1, N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            // i番目のコンテストを選ばないとき
            dp[i + 1, j] = Math.Max(dp[i + 1, j], dp[i, j]);
            // i番目のコンテストを選ぶとき
            dp[i + 1, j + 1] = Math.Max(dp[i + 1, j + 1], dp[i, j] + w[j + 1] * P[i]);
        }
    }

    const double Inf = 1e18;
    var answer = -Inf;
    for (var j = 1; j &amp;lt;= N; j++)
    {
        var r = dp[N, j] / cumW[j] - 1200 / sqrt[j];
        answer = Math.Max(answer, r);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 327の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20231028abc326</id>
		<title>ABC326</title>
		<link href="https://blog.aconcavy.dev/posts/20231028abc326" />
		<updated>2023-10-28T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 326の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc326"&gt;https://atcoder.jp/contests/abc326&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/46992128"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;階層の差が&lt;code&gt;d&lt;/code&gt;階のとき、下に3階分は&lt;code&gt;-3&amp;lt;=d&lt;/code&gt;、上に2階分は&lt;code&gt;d&amp;lt;=2&lt;/code&gt;となるので、&lt;code&gt;-3&amp;lt;=d&amp;lt;=2&lt;/code&gt;の場合に答えは&lt;code&gt;Yes&lt;/code&gt;になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var d = Y - X;
    var answer = -3 &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= 2;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/46996643"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;以上の整数&lt;code&gt;x&lt;/code&gt;を全探索し、&lt;code&gt;x&lt;/code&gt;の百の位を&lt;code&gt;a&lt;/code&gt;、十の位を&lt;code&gt;b&lt;/code&gt;、一の位を&lt;code&gt;c&lt;/code&gt;としたとき、&lt;code&gt;a*b==c&lt;/code&gt;になるかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var x = N; x &amp;lt;= 999; x++)
    {
        var a = x / 100;
        var b = x / 10 % 10;
        var c = x % 10;
        if (a * b == c)
        {
            Console.WriteLine(x);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/47002900"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;をソートし、&lt;code&gt;l&lt;/code&gt;を固定したとき、&lt;code&gt;A[r]&amp;gt;=A[l]+M&lt;/code&gt;となる&lt;code&gt;r&lt;/code&gt;を求めることで、座標&lt;code&gt;A[l]&lt;/code&gt;を半開区間の左端としたときに&lt;code&gt;r-l&lt;/code&gt;個のプレゼントを選ぶことができるようになります。
&lt;code&gt;A&lt;/code&gt;のソートに時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;、&lt;code&gt;r&lt;/code&gt;を尺取り法で求めることで時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    Array.Sort(A);
    var answer = 0;
    var r = 0;
    for (var l = 0; l &amp;lt; N; l++)
    {
        while (r &amp;lt; N &amp;amp;&amp;amp; A[r] &amp;lt; A[l] + M) r++;
        answer = Math.Max(answer, r - l);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/47046457"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;条件1から、&lt;code&gt;A&lt;/code&gt;が各行/各列にちょうど1つのみ含まれるパターンは&lt;code&gt;5!&lt;/code&gt;通りであり、同様に&lt;code&gt;B&lt;/code&gt;と&lt;code&gt;C&lt;/code&gt;も&lt;code&gt;5!&lt;/code&gt;通りになります。
&lt;code&gt;5!^3&lt;/code&gt;通りパターンを全探索し、条件の2と3を満たすかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var R = Scanner.Scan&amp;lt;string&amp;gt;();
    var C = Scanner.Scan&amp;lt;string&amp;gt;();

    var G = new char[N, N];

    bool CheckR()
    {
        var result = true;
        for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; result; i++)
        {
            for (var j = 0; j &amp;lt; N &amp;amp;&amp;amp; result; j++)
            {
                if (G[i, j] != '.')
                {
                    result &amp;amp;= G[i, j] == R[i];
                    break;
                }
            }
        }

        return result;
    }

    bool CheckC()
    {
        var result = true;
        for (var j = 0; j &amp;lt; N &amp;amp;&amp;amp; result; j++)
        {
            for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; result; i++)
            {
                if (G[i, j] != '.')
                {
                    result &amp;amp;= G[i, j] == C[j];
                    break;
                }
            }
        }

        return result;
    }

    foreach (var AI in Permutation.GeneratePermutation(N))
    {
        foreach (var BI in Permutation.GeneratePermutation(N))
        {
            foreach (var CI in Permutation.GeneratePermutation(N))
            {
                var ok = true;
                for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; ok; i++)
                {
                    ok &amp;amp;= AI[i] != BI[i];
                    ok &amp;amp;= AI[i] != CI[i];
                    ok &amp;amp;= BI[i] != CI[i];
                }

                if (!ok) continue;

                for (var i = 0; i &amp;lt; N; i++)
                {
                    for (var j = 0; j &amp;lt; N; j++)
                    {
                        G[i, j] = '.';
                    }
                }

                for (var i = 0; i &amp;lt; N; i++)
                {
                    G[AI[i], i] = 'A';
                    G[BI[i], i] = 'B';
                    G[CI[i], i] = 'C';
                }

                if (CheckR() &amp;amp;&amp;amp; CheckC())
                {
                    Console.WriteLine(&amp;quot;Yes&amp;quot;);
                    Printer.Print2D(G);
                    return;
                }
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc326/tasks/abc326_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC326/submissions/47043979"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;が支給される確率を&lt;code&gt;P[i]&lt;/code&gt;、期待値を&lt;code&gt;E[i]&lt;/code&gt;としたとき、&lt;code&gt;E[i]=A[i]*P[i]&lt;/code&gt;となります。&lt;br /&gt;
ある&lt;code&gt;y&lt;/code&gt;について&lt;code&gt;P[y]&lt;/code&gt;の確率は、&lt;code&gt;x&amp;lt;y&lt;/code&gt;となる&lt;code&gt;P[x]&lt;/code&gt;から&lt;code&gt;1/N&lt;/code&gt;の確率で推移することから、&lt;code&gt;cumP[y-1]=P[0]+P[1]+...+P[y-1]&lt;/code&gt;としたとき、&lt;code&gt;P[y]=cumP[y-1]/N&lt;/code&gt;として求めることができます。&lt;br /&gt;
よって、各&lt;code&gt;i&lt;/code&gt;について累積の確率を管理しながら期待値を求めることで、時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var iN = mint.Inverse(N);
    var E = new mint[N + 1];
    var P = new mint[N + 1];
    var cumP = new mint[N + 1];
    P[0] = cumP[0] = 1;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        P[i] = cumP[i - 1] * iN;
        E[i] = A[i - 1] * P[i];
        cumP[i] = cumP[i - 1] + P[i];
    }

    mint answer = 0;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer += E[i];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 326の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>