<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title />
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2022 AconCavy</rights>
	<updated>2022-10-15T14:39:14Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221015abc273</id>
		<title>ABC273</title>
		<link href="https://blog.aconcavy.dev/posts/20221015abc273" />
		<updated>2022-10-15T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 273の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc273"&gt;https://atcoder.jp/contests/abc273&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC273/submissions/35661854"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;制約が&lt;code&gt;N&amp;lt;=10&lt;/code&gt;と小さいので、下のような関数で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;long F(x) =&amp;gt; x == 0 ? 1 : x * F(x - 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;しかし、何度も同じ関数が呼ばれてしまい、&lt;code&gt;F(10)&lt;/code&gt;のときには&lt;code&gt;10!&lt;/code&gt;回もの関数が呼ばれてしまいます。
そこで、あらかじめ&lt;code&gt;F(1), F(2), F(...)&lt;/code&gt;の計算結果をメモしながら次の値を求めていくことで、計算量を大幅に削減することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var dp = new long[N + 1];
    dp[0] = 1;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        dp[i] = dp[i - 1] * i;
    }

    var answer = dp[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC273/submissions/35670133"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四捨五入する桁(&lt;code&gt;10^k&lt;/code&gt;の桁)の値を&lt;code&gt;v&lt;/code&gt;としたとき、&lt;code&gt;v = X / 10^k % 10&lt;/code&gt;で求めることができます。&lt;br /&gt;
そして、&lt;code&gt;v&lt;/code&gt;が&lt;code&gt;4以下&lt;/code&gt;のとき&lt;code&gt;X&lt;/code&gt;の&lt;code&gt;10^k&lt;/code&gt;の桁を&lt;code&gt;0&lt;/code&gt;にします。&lt;br /&gt;
あるいは、&lt;code&gt;v&lt;/code&gt;が&lt;code&gt;5以上&lt;/code&gt;のとき&lt;code&gt;X&lt;/code&gt;の&lt;code&gt;10^k&lt;/code&gt;の桁を&lt;code&gt;0&lt;/code&gt;にし、&lt;code&gt;10^(k+1)&lt;/code&gt;の桁を&lt;code&gt;+1&lt;/code&gt;します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, K) = Scanner.Scan&amp;lt;long, int&amp;gt;();
    var pow10 = 1L;
    for (var i = 0; i &amp;lt; K; i++)
    {
        var v = X / pow10 % 10;
        X -= v * pow10;
        if (v &amp;gt;= 5) X += pow10 * 10;
        pow10 *= 10;
    }

    Console.WriteLine(X);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC273/submissions/35675303"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の値はとても大きなものもありますが、求められるものは大小関係なので、&lt;code&gt;A&lt;/code&gt;を重複なしでソートしたときの順番を圧縮したものとして扱うことにします。&lt;br /&gt;
これにより、&lt;code&gt;数値の種類数-数値を圧縮した時の順番&lt;/code&gt;がその数値よりも大きな数の種類数を求めることができます。&lt;br /&gt;
そして、全ての&lt;code&gt;A&lt;/code&gt;においてその種類数を数え上げることで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var (map, _) = Compress(A);
    var count = A.Distinct().Count();
    var answer = new int[N];
    foreach (var a in A)
    {
        answer[count - (map[a] + 1)]++;
    }

    Console.WriteLine(string.Join(Environment.NewLine, answer));
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }

    return (map, remap);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc273/tasks/abc273_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;行と列の移動はそれぞれ独立しているので、行を移動するときの列、列を移動するときの行ごとにブロックの座標を管理し、移動途中にブロックが存在するかを&lt;code&gt;LowerBound&lt;/code&gt;等で調べることで、クエリ当たり時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;p&gt;下記のプログラムは考え方はあっていると思いますが、テストケースが4つ落ちています。どこがバグかわからないです...&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, cr, cc) = Scanner.Scan&amp;lt;int, int, long, long&amp;gt;();
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var rows = new Dictionary&amp;lt;long, List&amp;lt;long&amp;gt;&amp;gt;();
    var cols = new Dictionary&amp;lt;long, List&amp;lt;long&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (r, c) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        if (!rows.ContainsKey(r)) rows[r] = new List&amp;lt;long&amp;gt; { 0, (H + 1) };
        rows[r].Add(c);
        if (!cols.ContainsKey(c)) cols[c] = new List&amp;lt;long&amp;gt; { 0, (W + 1) };
        cols[c].Add(r);
    }

    foreach (var (_, v) in rows) v.Sort();
    foreach (var (_, v) in cols) v.Sort();

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (d, l) = Scanner.Scan&amp;lt;char, long&amp;gt;();

        if (d == 'L')
        {
            if (rows.ContainsKey(cr))
            {
                var lb = LowerBound(rows[cr], cc);
                cc = Math.Max(cc - l, rows[cr][lb - 1] + 1);
            }
            else
            {
                cc -= l;
            }
        }
        else if (d == 'R')
        {
            if (rows.ContainsKey(cr))
            {
                var ub = UpperBound(rows[cr], cc);
                cc = Math.Min(cc + l, rows[cr][ub] - 1);
            }
            else
            {
                cc += l;
            }
        }
        else if (d == 'U')
        {
            if (cols.ContainsKey(cc))
            {
                var lb = LowerBound(cols[cc], cr);
                cr = Math.Max(cr - l, cols[cc][lb - 1] + 1);
            }
            else
            {
                cr -= l;
            }
        }
        else if (d == 'D')
        {
            if (cols.ContainsKey(cc))
            {
                var ub = UpperBound(cols[cc], cr);
                cr = Math.Min(cr + l, cols[cc][ub] - 1);
            }
            else
            {
                cr += l;
            }
        }

        cr = Math.Min(Math.Max(cr, 1), W);
        cc = Math.Min(Math.Max(cc, 1), H);
        Console.WriteLine($&amp;quot;{cr} {cc}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 273の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221008abc272</id>
		<title>ABC272</title>
		<link href="https://blog.aconcavy.dev/posts/20221008abc272" />
		<updated>2022-10-08T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 272の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc272"&gt;https://atcoder.jp/contests/abc272&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35466353"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では&lt;code&gt;LINQ&lt;/code&gt;という&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;拡張メソッドを使うことで、整数型シーケンスの合計値を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = A.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35471787"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i(1&amp;lt;=i&amp;lt;=M)&lt;/code&gt;回目の講演会に&lt;code&gt;j(1&amp;lt;=j&amp;lt;=N)&lt;/code&gt;番目の人が参加しているかという2次元の表を構築し、全ての人&lt;code&gt;a&lt;/code&gt;と人&lt;code&gt;b&lt;/code&gt;の組み合わせ&lt;code&gt;(1&amp;lt;=a&amp;lt;b&amp;lt;=N)&lt;/code&gt;においてともに参加している講演会が1つでもあることを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var join = new bool[M, N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var X = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        for (var j = 1; j &amp;lt;= X[0]; j++)
        {
            join[i, X[j] - 1] = true;
        }
    }

    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var ok = false;
            for (var k = 0; k &amp;lt; M; k++)
            {
                ok |= join[k, i] &amp;amp;&amp;amp; join[k, j];
            }

            answer &amp;amp;= ok;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35474568"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;異なる2要素を全探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
2要素の和において偶数であることは、&lt;code&gt;偶数+偶数&lt;/code&gt;であること、または&lt;code&gt;奇数+奇数&lt;/code&gt;であることのみなので、&lt;code&gt;A&lt;/code&gt;を偶数と奇数にわけ、偶数が2個以上あればその最大値2つの和、奇数が2個以上あればその最大値2つの和のいずれかの最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    Array.Reverse(A);
    var even = new List&amp;lt;long&amp;gt;();
    var odd = new List&amp;lt;long&amp;gt;();
    foreach (var a in A)
    {
        if (a % 2 == 0) even.Add(a);
        else odd.Add(a);
    }

    var answer = -1L;
    if (even.Count &amp;gt;= 2) answer = Math.Max(answer, even[0] + even[1]);
    if (odd.Count &amp;gt;= 2) answer = Math.Max(answer, odd[0] + odd[1]);

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc272/tasks/abc272_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC272/submissions/35503382"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;距離がちょうど&lt;code&gt;Sqrt(M)&lt;/code&gt;となる&lt;code&gt;(i,j)&lt;/code&gt;の差分をあらかじめ求めておき、&lt;code&gt;(1,1)&lt;/code&gt;から差分の幅優先探索をおこなうことで答えを求めることができます。
距離がちょうど&lt;code&gt;Sqrt(M)&lt;/code&gt;となるには、&lt;code&gt;(i-k)^2 + (j-i)^2 == M&lt;/code&gt;となる必要があり、&lt;code&gt;i=0,j=0&lt;/code&gt;としたときに&lt;code&gt;k&lt;/code&gt;または&lt;code&gt;l&lt;/code&gt;を固定することによって、&lt;code&gt;l&lt;/code&gt;または&lt;code&gt;k&lt;/code&gt;を求めることができます。
``&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();

    var root = new Dictionary&amp;lt;int, int&amp;gt;();
    for (var i = 0; i * i &amp;lt;= M; i++)
    {
        root[i * i] = i;
    }

    var delta = new HashSet&amp;lt;(int, int)&amp;gt;();

    void Add(int dh, int dw)
    {
        if (dh * dh + dw * dw == M &amp;amp;&amp;amp; !delta.Contains((dh, dw)))
        {
            delta.Add((dh, dw));
        }
    }

    // (i, j) = (0, 0)
    for (var k = 0; k &amp;lt; N; k++)
    {
        var dh = (0 - k);
        var dw2 = M - (dh * dh);
        if (dw2 &amp;lt; 0) break;
        if (root.ContainsKey(dw2))
        {
            var dw = root[dw2];
            // l = dw - j or j - dw
            Add(k, dw - 0);
            Add(k, 0 - dw);
            Add(dw - 0, k);
            Add(0 - dw, k);
        }
    }

    var dp = new long[N, N];
    const long inf = (long)1e18;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            dp[i, j] = inf;
        }
    }

    dp[0, 0] = 0;
    var queue = new Queue&amp;lt;(int, int)&amp;gt;();
    queue.Enqueue((0, 0));
    while (queue.Count &amp;gt; 0)
    {
        var (i, j) = queue.Dequeue();
        foreach (var (dh, dw) in delta)
        {
            var (k, l) = (i + dh, j + dw);
            if (0 &amp;lt;= k &amp;amp;&amp;amp; k &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= l &amp;amp;&amp;amp; l &amp;lt; N &amp;amp;&amp;amp; dp[k, l] == inf)
            {
                dp[k, l] = dp[i, j] + 1;
                queue.Enqueue((k, l));
            }
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (dp[i, j] == inf) dp[i, j] = -1;
        }
    }

    Printer.Print2D(dp, &amp;quot; &amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 272の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20221001abc271</id>
		<title>ABC271</title>
		<link href="https://blog.aconcavy.dev/posts/20221001abc271" />
		<updated>2022-10-01T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 271の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271"&gt;https://atcoder.jp/contests/abc271&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35271548"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、整数を文字列に変換するときに、書式指定子&lt;code&gt;X&lt;/code&gt;を指定することで16進数文字列に変換することができ、書式指定子の後に数字を加えることで桁数を指定できます。
&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/standard-numeric-format-strings#hexadecimal-format-specifier-x"&gt;16 進書式指定子 (X)&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    Console.WriteLine(N.ToString(&amp;quot;X2&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35274115"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての配列を、配列の配列として保持しておき、&lt;code&gt;s&lt;/code&gt;番目の配列の、&lt;code&gt;t&lt;/code&gt;番目の値を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var line = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        A[i] = line[1..];
    }

    while (Q-- &amp;gt; 0)
    {
        var (s, t) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        s--;
        t--;
        Console.WriteLine(A[s][t]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35321236"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;巻まで読むことができるかという二部探索を行います。
判定式としては、持っている単行本のうち重複を除いた&lt;code&gt;x&lt;/code&gt;以下の巻数を&lt;code&gt;c1&lt;/code&gt;、&lt;code&gt;x&lt;/code&gt;より大きい巻数や重複した2冊目以降の数を&lt;code&gt;c2 (c2==N-c1)&lt;/code&gt;としたとき、足りない数の2倍が&lt;code&gt;c2&lt;/code&gt;以下であるか&lt;code&gt;(x-c1)*2&amp;lt;=c2&lt;/code&gt;を判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Distinct().ToArray();

    bool F(int x)
    {
        var c1 = A.Count(v =&amp;gt; v &amp;lt;= x);
        var c2 = N - c1;
        return (x - c1) * 2 &amp;lt;= c2;
    }

    var answer = BinarySearch((int)1e9, 0, F);
    Console.WriteLine(answer);
}

public static int BinarySearch(int ng, int ok, Func&amp;lt;int, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35302856"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i,j,k]:=i番目までのカードみたとき状態がk(表裏)のときにの合計がjが成り立つか&lt;/code&gt;という動的計画法をとき、&lt;code&gt;dp[N,S,0]&lt;/code&gt;か&lt;code&gt;dp[N,S,1]&lt;/code&gt;が成り立つかを判定し、成り立つときは経路復元を行います。
経路復元では、&lt;code&gt;dp[i,j,k]&lt;/code&gt;が成り立つときの&lt;code&gt;i-1&lt;/code&gt;番目の&lt;code&gt;jとk&lt;/code&gt;をメモしておきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, S) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new bool[N + 1, S + 1, 2];
    var prev = new (int, int)[N + 1, S + 1, 2];
    dp[0, 0, 0] = dp[0, 0, 1] = true;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        for (var j = 0; j &amp;lt;= S; j++)
        {
            if (j + a &amp;lt;= S)
            {
                for (var k = 0; k &amp;lt; 2; k++)
                {
                    if (dp[i, j, k])
                    {
                        dp[i + 1, j + a, 0] |= dp[i, j, k];
                        prev[i + 1, j + a, 0] = (j, k);
                    }
                }
            }

            if (j + b &amp;lt;= S)
            {
                for (var k = 0; k &amp;lt; 2; k++)
                {
                    if (dp[i, j, k])
                    {
                        dp[i + 1, j + b, 1] |= dp[i, j, k];
                        prev[i + 1, j + b, 1] = (j, k);
                    }
                }
            }
        }
    }

    if (dp[N, S, 0] || dp[N, S, 1])
    {
        var list = new List&amp;lt;int&amp;gt;();
        var curr = dp[N, S, 0] ? (S, 0) : (S, 1);
        for (var i = N; i &amp;gt; 0; i--)
        {
            list.Add(curr.Item2);
            curr = prev[i, curr.Item1, curr.Item2];
        }

        list.Reverse();
        var answer = string.Join(&amp;quot;&amp;quot;, list.Select(x =&amp;gt; x == 0 ? 'H' : 'T'));
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        Console.WriteLine(answer);
    }
    else
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc271/tasks/abc271_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc271/submissions/35318996"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]:=Eのi番目までの道を使った時の都市jへの最小コスト&lt;/code&gt;とした動的計画法をときます。
良い経路は&lt;code&gt;E&lt;/code&gt;の部分列であり、&lt;code&gt;E[1]-&amp;gt;E[2]&lt;/code&gt;や&lt;code&gt;E[1]-&amp;gt;E[3]&lt;/code&gt;のようなことも可能であるため、&lt;code&gt;i&lt;/code&gt;ごとにコストを保持する必要はなく、一次元のみで求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    const long inf = (long)1e18;
    var Edges = new (int U, int V, long C)[M];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, c) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        G[a].Add((b, c));
        G[b].Add((a, c));
        Edges[i] = (a, b, c);
    }

    var E = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var dp = new long[N];
    Array.Fill(dp, inf);
    dp[0] = 0;

    for (var i = 0; i &amp;lt; K; i++)
    {
        var (a, b, c) = Edges[E[i]];
        if (dp[a] != inf)
        {
            dp[b] = Math.Min(dp[b], dp[a] + c);
            set.Add(b);
        }
    }

    var answer = dp[N - 1];
    if (answer == inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 271の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220924abc270</id>
		<title>ABC270</title>
		<link href="https://blog.aconcavy.dev/posts/20220924abc270" />
		<updated>2022-09-24T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 270の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270"&gt;https://atcoder.jp/contests/abc270&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35093269"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整数を2進数表記したとき、&lt;code&gt;2^0==1&lt;/code&gt;、&lt;code&gt;2^1==2&lt;/code&gt;、&lt;code&gt;2^2=4&lt;/code&gt;となり、入力&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の各ビットが立っているかをみることで、その問題に正解しているかどうかがわかります。
そのため、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の各ビットの論理和をとることで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = A | B;
    Console.WriteLine(C);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35103936"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc270/submissions/35139218"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;が負のとき、&lt;code&gt;X&lt;/code&gt;、&lt;code&gt;Y&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt;を反転させることで&lt;code&gt;X&lt;/code&gt;が正の時として考えることができます。&lt;br /&gt;
このとき、&lt;code&gt;X&amp;lt;Y&lt;/code&gt;または&lt;code&gt;Y&amp;lt;0&lt;/code&gt;であれば、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;X&lt;/code&gt;の間に壁はないので、答えは&lt;code&gt;X&lt;/code&gt;となります。
それ以外のとき、&lt;code&gt;Y&amp;lt;Z&lt;/code&gt;であれば、ハンマーを拾うことはできないので、答えは&lt;code&gt;-1&lt;/code&gt;となります。
それ以外のとき、ハンマーを拾ってから&lt;code&gt;X&lt;/code&gt;に向かうことができるので、答えは&lt;code&gt;Abs(Z)+Abs(X-Z)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, Z) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    if (X &amp;lt; 0)
    {
        X = -X;
        Y = -Y;
        Z = -Z;
    }

    if (X &amp;lt; Y || Y &amp;lt; 0)
    {
        Console.WriteLine(X);
    }
    else
    {
        if (Y &amp;lt; Z)
        {
            Console.WriteLine(-1);
        }
        else
        {
            Console.WriteLine(Math.Abs(Z) + Math.Abs(X - Z));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35106711"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;訪れた直前の頂点をメモしながら、始点である&lt;code&gt;X&lt;/code&gt;から幅優先探索を行い、終点の&lt;code&gt;Y&lt;/code&gt;から直前の頂点をたどることでパスを復元することができます。
復元した頂点は逆順であることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    X--; Y--;
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    var prev = new int[N];
    Array.Fill(prev, -1);
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(X);
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        foreach (var v in G[u])
        {
            if (prev[v] != -1) continue;
            prev[v] = u;
            queue.Enqueue(v);
        }
    }

    var route = new List&amp;lt;int&amp;gt;();
    var curr = Y;
    while (true)
    {
        route.Add(curr + 1);
        curr = prev[curr];
        if(curr == X) break;
    }

    route.Reverse();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, route));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35138376"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i]:=石がi個のときの先手が取れる石の最大個数&lt;/code&gt;とした動的計画法をときます。
遷移としては、石が&lt;code&gt;i-A[j]&lt;/code&gt;個のときの後手が取れる石の最大個数に&lt;code&gt;A[j]&lt;/code&gt;個足したものであることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dp = new int[N + 1];
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 0; j &amp;lt; K; j++)
        {
            if (i - A[j] &amp;gt;= 0)
            {
                dp[i] = Math.Max(dp[i], (i - A[j] - dp[i - A[j]]) + A[j]);
            }
        }
    }

    var answer = dp[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc270/tasks/abc270_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc270/submissions/35124130"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直にシミュレーションしてしまうと実行時間制限に間に合いません。
現在のかごにあるりんごの最小値が&lt;code&gt;v&lt;/code&gt;、りんごが1個以上あるかごの数を&lt;code&gt;c&lt;/code&gt;のときには&lt;code&gt;Min(K/c,v)&lt;/code&gt;周することができ、りんごは&lt;code&gt;Min(K/c,v)周*c個&lt;/code&gt;食べることができます。
そして、食べられる&lt;code&gt;K&lt;/code&gt;が現在のりんごが1個以上あるかごの数未満になった場合は端数となるので、りんごが1個以上あるかごの番号が小さい順に数を減らすことで答えを求めることができます。
全体計算量はりんごの数をソートするための&lt;code&gt;O(NlogN)&lt;/code&gt;となり、実行時間制限に間に合います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var basket = N;
    var lap = 0L;
    foreach (var v in A.OrderBy(x =&amp;gt; x))
    {
        if (K &amp;lt; basket) break;
        var d = Math.Min(K / basket, v - lap);
        K -= d * basket;
        lap += d;
        basket--;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Math.Max(0, A[i] - lap);

        if (A[i] &amp;gt; 0 &amp;amp;&amp;amp; K &amp;gt; 0)
        {
            A[i]--;
            K--;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 270の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220917abc269</id>
		<title>ABC269</title>
		<link href="https://blog.aconcavy.dev/posts/20220917abc269" />
		<updated>2022-09-17T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 269の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc269"&gt;https://atcoder.jp/contests/abc269&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34918764"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入出力の問題です。
C#では、コンソールからの文字列の入力を&lt;code&gt;Console.ReadLine()&lt;/code&gt;メソッド、コンソールへの文字列の出力を&lt;code&gt;Console.WriteLine()&lt;/code&gt;メソッドで行うことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var values = Console.ReadLine().Split(' ');
    var (a, b, c, d) = (long.Parse(values[0]), long.Parse(values[1]), long.Parse(values[2]), long.Parse(values[3]));
    var answer = (a + b) * (c - d);
    Console.WriteLine(answer);
    Console.WriteLine(&amp;quot;Takahashi&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34925112"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(A,B)&lt;/code&gt;は&lt;code&gt;#&lt;/code&gt;が出現する最小の行と最大の行になり、&lt;code&gt;(C,D)&lt;/code&gt;は、&lt;code&gt;#&lt;/code&gt;が出現する最小の列と最大の列になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = 10;
    var G = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    const int inf = (int)1e9;
    var (a, b, c, d) = (inf, 0, inf, 0);
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (G[i][j] == '#')
            {
                a = Math.Min(a, i);
                b = Math.Max(b, i);
                c = Math.Min(c, j);
                d = Math.Max(d, j);
            }
        }
    }

    Console.WriteLine($&amp;quot;{a + 1} {b + 1}&amp;quot;);
    Console.WriteLine($&amp;quot;{c + 1} {d + 1}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34929182"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;求めたい集合は、&lt;code&gt;|&lt;/code&gt;をビット論理和としたとき、&lt;code&gt;x | N == N&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;の集合です。
&lt;code&gt;N&lt;/code&gt;がとても大きいので、&lt;code&gt;x&lt;/code&gt;を全探索してしまうと実行時間制限に間に合いません。
そこで、&lt;code&gt;N&lt;/code&gt;のビットが立っている位置をビット全探索して論理和を求めることで、集合を求めることができます。
制約により&lt;code&gt;N&lt;/code&gt;のビットが立っている個数は最大でも&lt;code&gt;15&lt;/code&gt;なので、答えとなる個数は最大でも&lt;code&gt;2^15&lt;/code&gt;なので、実行時間制限に十分間に合います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();

    var list = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt;= 60; i++)
    {
        if ((N &amp;gt;&amp;gt; i &amp;amp; 1) == 1) list.Add(i);
    }

    var answer = new List&amp;lt;long&amp;gt;();
    var M = list.Count;
    for (var i = 0; i &amp;lt; 1 &amp;lt;&amp;lt; M; i++)
    {
        var v = 0L;
        for (var j = 0; j &amp;lt; M; j++)
        {
            if ((i &amp;gt;&amp;gt; j &amp;amp; 1) == 1)
            {
                v |= 1L &amp;lt;&amp;lt; list[j];
            }
        }

        answer.Add(v);
    }

    answer.Sort();
    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34934356"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個のマスのペアが隣接する6マスにあるかを探索し、マスの番号を頂点とした&lt;code&gt;DisjointSetUnion (DSU, aka UnionFind)&lt;/code&gt;等を使って、連結成分の個数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var XY = new (int X, int Y)[N];
    var dict = new Dictionary&amp;lt;(int X, int Y), int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var p = Scanner.Scan&amp;lt;int, int&amp;gt;();
        XY[i] = p;
        dict[p] = i;
    }

    var D6 = new (int X, int Y)[6] { (-1, -1), (-1, 0), (0, -1), (0, 1), (1, 0), (1, 1) };
    var dsu = new DisjointSetUnion(N);
    for (var i = 0; i &amp;lt; N; i++)
    {
        foreach (var (dx, dy) in D6)
        {
            var np = (XY[i].X + dx, XY[i].Y + dy);
            if (dict.ContainsKey(np))
            {
                var j = dict[np];
                dsu.Merge(i, j);
            }
        }
    }

    var answer = dsu.GetGroups().Count();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc269/tasks/abc269_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC269/submissions/34943393"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行と列はそれぞれ独立しているため、行と列を別に考えます。&lt;br /&gt;
ある行&lt;code&gt;m&lt;/code&gt;までに含まれるルークの数を質問したとき(&lt;code&gt;! 1 m 1 N&lt;/code&gt;)、質問への答えが&lt;code&gt;m&lt;/code&gt;の場合、&lt;code&gt;1&lt;/code&gt;行から&lt;code&gt;m&lt;/code&gt;行までには既にルークが全て置かれており、&lt;code&gt;m+1&lt;/code&gt;行目から&lt;code&gt;N&lt;/code&gt;行目までに答えとなる行が存在することがわかり、&lt;code&gt;m&lt;/code&gt;以外の場合は&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;m&lt;/code&gt;行までの中に答えとなる行が存在することがわかります。
また、制約が&lt;code&gt;2&amp;lt;=N&amp;lt;=1000&lt;/code&gt;であり、&lt;code&gt;N&amp;lt;=2^10&lt;/code&gt;であることから、答えとなる行&lt;code&gt;m&lt;/code&gt;の二部探索を行うことで、10回程度の質問で答えとなる行&lt;code&gt;m&lt;/code&gt;を求められることがわかります。&lt;br /&gt;
同様に列に対しても二部探索で答えを求めることで、行と列合わせて20回程度の質問で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();

    bool AskI(long m)
    {
        Console.WriteLine($&amp;quot;? 1 {m} 1 {N}&amp;quot;);
        var c = Scanner.Scan&amp;lt;int&amp;gt;();
        return c != m;
    }

    bool AskJ(long m)
    {
        Console.WriteLine($&amp;quot;? 1 {N} 1 {m}&amp;quot;);
        var c = Scanner.Scan&amp;lt;int&amp;gt;();
        return c != m;
    }

    var i = BinarySearch(0, N, AskI);
    var j = BinarySearch(0, N, AskJ);
    Console.WriteLine($&amp;quot;! {i} {j}&amp;quot;);
}

public static long BinarySearch(long l, long r, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(r - l) &amp;gt; 1)
    {
        var m = (r + l) / 2;
        if (func(m)) r = m;
        else l = m;
    }

    return r;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 269の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220910abc268</id>
		<title>ABC268</title>
		<link href="https://blog.aconcavy.dev/posts/20220910abc268" />
		<updated>2022-09-10T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 268の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc268"&gt;https://atcoder.jp/contests/abc268&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc268/tasks/abc268_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC268/submissions/34724829"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;100&lt;/code&gt;までの長さ&lt;code&gt;101&lt;/code&gt;の&lt;code&gt;bool&lt;/code&gt;配列を用意して、与えられた整数の位置を&lt;code&gt;true&lt;/code&gt;にし、その&lt;code&gt;true&lt;/code&gt;の数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var exists = new bool[101];
    for (var i = 0; i &amp;lt; 5; i++)
    {
        exists[A[i]] = true;
    }
    var answer = exists.Count(x =&amp;gt; x);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc268/tasks/abc268_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC268/submissions/34727479"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sの長さ&amp;gt;Tの長さ&lt;/code&gt;の場合は&lt;code&gt;false&lt;/code&gt;であり、それ以外の時に&lt;code&gt;S&lt;/code&gt;の長さの範囲で文字がすべて一致するかを判断します。&lt;br /&gt;
C#では、&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.string.startswith?view=net-6.0"&gt;&lt;code&gt;String.StartWith&lt;/code&gt;&lt;/a&gt;メソッドで引数に与えられた文字列で文字列が始まっているかを判断できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = T.StartsWith(S);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc268/tasks/abc268_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC268/submissions/34738844"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;始点を全探索して全ての値が&lt;code&gt;i-1&lt;/code&gt;、&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;i+1&lt;/code&gt;のいずれかの目の前にあるかを探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり実行時間制限に間に合いません。
そこで、人&lt;code&gt;i&lt;/code&gt;と料理&lt;code&gt;P[i]&lt;/code&gt;の距離&lt;code&gt;(P[i]-i)%N&lt;/code&gt;の個数に変換することで、距離&lt;code&gt;d-1&lt;/code&gt;、&lt;code&gt;d&lt;/code&gt;、&lt;code&gt;d+1&lt;/code&gt;にある個数の和の最大値を求める問題に変換することで、時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    var count = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        count[(P[i] - i + N) % N]++;
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = 0;
        for (var j = 0; j &amp;lt; 3; j++)
        {
            c += count[(i + j) % N];
        }

        answer = Math.Max(answer, c);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc268/tasks/abc268_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC268/submissions/34762121"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の文字列の順列として並べ替えたものの間に1以上の任意の数の&lt;code&gt;_&lt;/code&gt;を追加した文字列を全て列挙し、&lt;code&gt;M&lt;/code&gt;個の文字列に存在しない文字列があるかどうかを判定します。
&lt;code&gt;_&lt;/code&gt;を追加する文字列を生成する方法として、現在の&lt;code&gt;_&lt;/code&gt;の個数、現在&lt;code&gt;_&lt;/code&gt;を追加しようとしてる位置、残りの追加できる&lt;code&gt;_&lt;/code&gt;の数を管理しながら深さ優先探索を行うことができます。
また、&lt;code&gt;N=1&lt;/code&gt;の時がコーナーケースで、&lt;code&gt;3&lt;/code&gt;文字以上&lt;code&gt;16&lt;/code&gt;文字以下であることの確認が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    var remains = 16 - (N - 1);
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
        remains -= S[i].Length;
    }

    var T = new HashSet&amp;lt;string&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        T.Add(s);
    }

    if (N == 1)
    {
        Console.WriteLine(!T.Contains(S[0]) &amp;amp;&amp;amp; 3 &amp;lt;= S[0].Length &amp;amp;&amp;amp; S[0].Length &amp;lt;= 16 ? S[0] : &amp;quot;-1&amp;quot;);
        return;
    }

    var set = new HashSet&amp;lt;string&amp;gt;();
    var count = new int[N - 1];
    Array.Fill(count, 1);
    foreach (var perm in Enumerable.Range(0, N).Permute(N))
    {
        void Dfs(int curr, int rem)
        {
            if (rem &amp;lt; 0) return;
            if (curr &amp;gt;= N - 1)
            {
                var builder = new StringBuilder();
                for (var i = 0; i &amp;lt; N; i++)
                {
                    builder.Append(S[perm[i]]);
                    if (i &amp;lt; N - 1) builder.Append('_', count[i]);
                }

                var x = builder.ToString();
                set.Add(x);
                return;
            }

            for (var k = 0; k &amp;lt;= rem; k++)
            {
                count[curr] += k;
                Dfs(curr + 1, rem - k);
                count[curr] -= k;
            }
        }

        Dfs(0, remains);
    }

    foreach (var x in set)
    {
        if (!T.Contains(x))
        {
            Console.WriteLine(x);
            return;
        }
    }

    Console.WriteLine(&amp;quot;-1&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下のような順列を列挙するメソッドを使用しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static partial class EnumerableExtension
{
    public static IEnumerable&amp;lt;TSource[]&amp;gt; Permute&amp;lt;TSource&amp;gt;(this IEnumerable&amp;lt;TSource&amp;gt; source, int count)
    {
        if (source is null) throw new ArgumentNullException(nameof(source));
        IEnumerable&amp;lt;TSource[]&amp;gt; Inner()
        {
            var items = source.ToArray();
            if (count &amp;lt;= 0 || items.Length &amp;lt; count) throw new ArgumentOutOfRangeException(nameof(count));
            var n = items.Length;
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++)
            {
                indices[i] = i;
            }
            var cycles = new int[count];
            for (var i = 0; i &amp;lt; cycles.Length; i++)
            {
                cycles[i] = n - i;
            }
            TSource[] Result()
            {
                var result = new TSource[count];
                for (var i = 0; i &amp;lt; count; i++)
                {
                    result[i] = items[indices[i]];
                }
                return result;
            }
            yield return Result();
            while (true)
            {
                var done = true;
                for (var i = count - 1; i &amp;gt;= 0; i--)
                {
                    cycles[i]--;
                    if (cycles[i] == 0)
                    {
                        for (var j = i; j + 1 &amp;lt; indices.Length; j++)
                        {
                            (indices[j], indices[j + 1]) = (indices[j + 1], indices[j]);
                        }
                        cycles[i] = n - i;
                    }
                    else
                    {
                        (indices[i], indices[^cycles[i]]) = (indices[^cycles[i]], indices[i]);
                        yield return Result();
                        done = false;
                        break;
                    }
                }
                if (done) yield break;
            }
        }
        return Inner();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 268の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220903abc267</id>
		<title>ABC267</title>
		<link href="https://blog.aconcavy.dev/posts/20220903abc267" />
		<updated>2022-09-03T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 267の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267"&gt;https://atcoder.jp/contests/abc267&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34533809"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与えられる文字列は5通りしかないため、それぞれに対しての答えを求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = 0;
    if (S == &amp;quot;Monday&amp;quot;) answer = 5;
    if (S == &amp;quot;Tuesday&amp;quot;) answer = 4;
    if (S == &amp;quot;Wednesday&amp;quot;) answer = 3;
    if (S == &amp;quot;Thursday&amp;quot;) answer = 2;
    if (S == &amp;quot;Friday&amp;quot;) answer = 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34560503"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;列ごとの処理を行うため、あらかじめ列ごとにピンが1本でも立っているかを&lt;code&gt;bool&lt;/code&gt;で管理できるようにします。
1番ピンが&lt;code&gt;false&lt;/code&gt;かつ、列&lt;code&gt;L&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;かつと列&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;かつ、列&lt;code&gt;L&lt;/code&gt;と列&lt;code&gt;R&lt;/code&gt;の間の列&lt;code&gt;M&lt;/code&gt;が&lt;code&gt;false&lt;/code&gt;であるときにスプリットになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = new bool[11];
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        T[i + 1] = S[i] == '1';
    }

    var col = new bool[7];
    col[0] |= T[7];
    col[1] |= T[4];
    col[2] |= T[8] || T[2];
    col[3] |= T[5] || T[1];
    col[4] |= T[9] || T[3];
    col[5] |= T[6];
    col[6] |= T[10];

    if (!T[1])
    {
        for (var l = 0; l &amp;lt; col.Length; l++)
        {
            for (var r = l + 2; r &amp;lt; col.Length; r++)
            {
                for (var m = l + 1; m &amp;lt; r; m++)
                {
                    if (col[l] &amp;amp;&amp;amp; col[r] &amp;amp;&amp;amp; !col[m])
                    {
                        Console.WriteLine(&amp;quot;Yes&amp;quot;);
                        return;
                    }
                }
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34548091"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長さ&lt;code&gt;M&lt;/code&gt;の連続部分列の右側の位置&lt;code&gt;R&lt;/code&gt;から位置&lt;code&gt;R+1&lt;/code&gt;にずれたとき、求める総和は&lt;code&gt;A[R-M+1..R]&lt;/code&gt;の区間和が引かれて&lt;code&gt;A[R]*M&lt;/code&gt;が足されます。
そのため、位置をずらして総和を更新していったときの最大値が答えとなります。
累積和を用いることで時間計算量&lt;code&gt;O(1)&lt;/code&gt;で区間和を求めることができ、全体の計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    var sum = 0L;
    for (var i = 0; i &amp;lt; M; i++)
    {
        sum += (i + 1) * A[i];
    }

    var answer = sum;
    for (var i = 1; i + M &amp;lt;= N; i++)
    {
        sum -= cum[i + M - 1] - cum[i - 1];
        sum += M * A[i + M - 1];
        answer = Math.Max(answer, sum);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34568995"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]:=i番目までみたときにBの要素をj個決めたときの求める和の最大値&lt;/code&gt;とした動的計画法を解きます。&lt;br /&gt;
これは、&lt;code&gt;i&lt;/code&gt;番目の要素を選ばなかったときは&lt;code&gt;Max(dp[i+1][j], dp[i][j])&lt;/code&gt;であり、選んだ時は&lt;code&gt;Max(dp[i+1][j+1], dp[i][j]+A[i]*(j+1))&lt;/code&gt;の遷移が成り立ちます。
総和が負になることもあるため、&lt;code&gt;dp&lt;/code&gt;テーブルを&lt;code&gt;-inf&lt;/code&gt;のような値で初期化する必要があることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    const long inf = (long)1e18;
    var dp = new long[N + 1, M + 1];
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 0; j &amp;lt;= M; j++)
        {
            dp[i, j] = -inf;
        }
    }

    dp[0, 0] = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= M; j++)
        {
            dp[i + 1, j] = Math.Max(dp[i + 1, j], dp[i, j]);
            if (j + 1 &amp;lt;= M) dp[i + 1, j + 1] = Math.Max(dp[i + 1, j + 1], dp[i, j] + A[i] * (j + 1));
        }
    }

    var answer = dp[N, M];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34578204"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある時点で頂点&lt;code&gt;u&lt;/code&gt;を消すと、頂点&lt;code&gt;u&lt;/code&gt;に接続している頂点&lt;code&gt;v&lt;/code&gt;のコストは&lt;code&gt;A[u]&lt;/code&gt;減ることになり、その時点での頂点&lt;code&gt;v&lt;/code&gt;とコストのペアを&lt;code&gt;PriorityQueue&lt;/code&gt;に追加していくことで、頂点&lt;code&gt;x&lt;/code&gt;を消すときに必要なコストの最小値を求めることができ、全ての頂点におけるコストの最小値の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var costs = new long[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        costs[u] += A[v];
        costs[v] += A[u];
        G[u].Add(v);
        G[v].Add(u);
    }

    var answer = 0L;
    var queue = new PriorityQueue&amp;lt;(int U, long C)&amp;gt;((x, y) =&amp;gt; x.C.CompareTo(y.C));
    for (var i = 0; i &amp;lt; N; i++)
    {
        queue.Enqueue((i, costs[i]));
    }

    var used = new bool[N];
    while (queue.Count &amp;gt; 0)
    {
        var (u, c) = queue.Dequeue();
        if (used[u]) continue;
        used[u] = true;
        answer = Math.Max(answer, c);
        foreach (var v in G[u])
        {
            if (used[v]) continue;
            costs[v] -= A[u];
            queue.Enqueue((v, costs[v]));
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 267の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220827abc266</id>
		<title>ABC266</title>
		<link href="https://blog.aconcavy.dev/posts/20220827abc266" />
		<updated>2022-08-27T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 266の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc266"&gt;https://atcoder.jp/contests/abc266&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34367371"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;の長さが奇数なので、&lt;code&gt;S&lt;/code&gt;のインデックス&lt;code&gt;Floor(Sの長さ/2)&lt;/code&gt;の文字が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    Console.WriteLine(S[N / 2]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34371987"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N-x&lt;/code&gt;が&lt;code&gt;998244353&lt;/code&gt;の倍数であるということは、&lt;code&gt;N&lt;/code&gt;を&lt;code&gt;998244353&lt;/code&gt;で割ったときの余りが&lt;code&gt;x&lt;/code&gt;になることがわかります。&lt;br /&gt;
また、言語によって負の数に対する余りの計算は異なり、余りが負の値になる場合があります。
&lt;code&gt;a&lt;/code&gt;を&lt;code&gt;b(!=0)&lt;/code&gt;で割ったときの余りが&lt;code&gt;c&lt;/code&gt;のとき、&lt;code&gt;a+b&lt;/code&gt;や&lt;code&gt;a-b&lt;/code&gt;を&lt;code&gt;b&lt;/code&gt;で割ったときの余りも&lt;code&gt;c&lt;/code&gt;になることから、&lt;code&gt;x&lt;/code&gt;が負の値のときは&lt;code&gt;998244353&lt;/code&gt;を足すことで、&lt;code&gt;0&amp;lt;=x&amp;lt;=998244353&lt;/code&gt;にすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    const long M = 998244353;
    var x = N % M;
    if (x &amp;lt; 0) x += M;
    Console.WriteLine(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34400444"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34409358"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての角が180度未満であるかを外積を用いて判定します。
角&lt;code&gt;abc&lt;/code&gt;の外積は&lt;code&gt;cross=(c.X-b.X)*(a.Y-b.Y)-(a.X-b.X)*(c.Y-b.Y)&lt;/code&gt;で計算でき、&lt;code&gt;abc&lt;/code&gt;が反時計回りなら&lt;code&gt;cross&amp;gt;=0&lt;/code&gt;の場合角&lt;code&gt;abc&lt;/code&gt;の角は&lt;code&gt;180&lt;/code&gt;度未満になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = 4;
    var P = new Point[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        P[i] = new Point(x, y);
    }

    long Cross(Point a, Point b, Point c)
    {
        var (dx1, dy1) = (c.X - b.X, c.Y - b.Y);
        var (dx2, dy2) = (a.X - b.X, a.Y - b.Y);
        return dx1 * dy2 - dx2 * dy1;
    }

    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var a = P[i];
        var b = P[(i + 1) % N];
        var c = P[(i + 2) % N];
        answer &amp;amp;= Cross(a, b, c) &amp;gt;= 0;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}

public readonly struct Point
{
    public readonly long X;
    public readonly long Y;
    public Point(long x, long y) =&amp;gt; (X, Y) = (x, y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34392662"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34408822"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[t][x]:=時刻tの座標xにおける既に捕まえた大きさの最大値&lt;/code&gt;とした動的計画法を解きます。
これは、時刻&lt;code&gt;t&lt;/code&gt;の座標&lt;code&gt;x&lt;/code&gt;における大きさを&lt;code&gt;A[t][x]&lt;/code&gt;としたとき、&lt;code&gt;dp[t][x] = Max(dp[t-1][x-1], dp[t-1][x], dp[t-1][x+1]) + A[t][x]&lt;/code&gt;の遷移で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new long[(int)1e5 + 1, 5];
    var T = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (t, x, a) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        A[t, x] = a;
        T = t;
    }

    const long inf = (long)1e18;
    var dp = new long[T + 1, 5];
    for (var i = 0; i &amp;lt;= T; i++)
    {
        for (var j = 0; j &amp;lt; 5; j++)
        {
            dp[i, j] = -inf;
        }
    }

    dp[0, 0] = 0;

    for (var t = 1; t &amp;lt;= T; t++)
    {
        for (var x = 0; x &amp;lt; 5; x++)
        {
            for (var p = x - 1; p &amp;lt;= x + 1; p++)
            {
                if (0 &amp;lt;= p &amp;amp;&amp;amp; p &amp;lt; 5) dp[t, x] = Math.Max(dp[t, x], dp[t - 1, p] + A[t, x]);
            }
        }
    }

    var answer = 0L;
    for (var i = 0; i &amp;lt; 5; i++)
    {
        answer = Math.Max(answer, dp[T, i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34405481"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt;回目の期待値は、&lt;code&gt;n-1&lt;/code&gt;回目の期待値と出目を比較して大きいほうを選んだときの&lt;code&gt;1-6&lt;/code&gt;の出目の総和になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = 0.0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var exp = 0.0;
        for (var x = 1; x &amp;lt;= 6; x++)
        {
            exp += Math.Max(x, answer) / 6.0;
        }

        answer = Math.Max(answer, exp);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 266の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220821abc265</id>
		<title>ABC265</title>
		<link href="https://blog.aconcavy.dev/posts/20220821abc265" />
		<updated>2022-08-21T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 265の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265"&gt;https://atcoder.jp/contests/abc265&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34200512"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3個のりんごを&lt;code&gt;b&lt;/code&gt;セット買ったとき、1個のりんごを&lt;code&gt;a=N-b*3&lt;/code&gt;セット買うことができます。
この&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を全探索し、&lt;code&gt;a*X+b*Y&lt;/code&gt;の最小を求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    const int inf = (int)1e9;
    var answer = inf;
    for (var b = 0; b * 3 &amp;lt;= N; b++)
    {
        var a = (N - b * 3);
        var v = a * X + b * Y;
        answer = Math.Min(answer, v);
    }
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;X*3&amp;gt;Y&lt;/code&gt;で場合分けをして、時間計算量&lt;code&gt;O(1)&lt;/code&gt;で解くこともできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var answer = X * 3 &amp;gt; Y ? (N / 3) * Y + N % 3 * X : X * N;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34206744"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直にシミュレーションを行い、&lt;code&gt;現在の持ち時間-A[i]&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;以下になれば、答えは&lt;code&gt;No&lt;/code&gt;となります。
1回の移動あたりのボーナスを全て探索してしまうと、全体の時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;かかってしまうので、あらかじめ配列として&lt;code&gt;bonus[x]&lt;/code&gt;をもっておくことで、1回の移動あたりのボーナスの値を&lt;code&gt;O(1)&lt;/code&gt;で取得することができ、全体計算量&lt;code&gt;O(N)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, T) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var bonus = new long[N + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        bonus[x] = y;
    }

    var curr = T;
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        curr += bonus[i + 1];
        if (curr &amp;gt; A[i])
        {
            curr -= A[i];
        }
        else
        {
            Console.WriteLine(&amp;quot;No&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34212489"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在いるマスに書かれている文字にそって愚直にシミュレーションを行います。
あるマス&lt;code&gt;(i,j)&lt;/code&gt;からマスの外に出ようとした場合には、答えはマス&lt;code&gt;(i,j)&lt;/code&gt;となります。
無限に移動し続ける場合の判定として、既に訪れたマスをフラグ管理なのでメモしておき、移動先のマスが既に訪れているマスの場合には答えは&lt;code&gt;-1&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var used = new bool[H, W];
    used[0, 0] = true;
    var queue = new Queue&amp;lt;(int, int)&amp;gt;();
    queue.Enqueue((0, 0));
    while (queue.Count &amp;gt; 0)
    {
        var (ch, cw) = queue.Dequeue();
        var (nh, nw) = G[ch][cw] switch
        {
            'U' =&amp;gt; (ch - 1, cw),
            'D' =&amp;gt; (ch + 1, cw),
            'L' =&amp;gt; (ch, cw - 1),
            'R' =&amp;gt; (ch, cw + 1),
            _ =&amp;gt; (0, 0),
        };

        if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw)
        {
            Console.WriteLine($&amp;quot;{ch + 1} {cw + 1}&amp;quot;);
            return;
        }

        if (used[nh, nw])
        {
            Console.WriteLine(-1);
            return;
        }

        used[nh, nw] = true;
        queue.Enqueue((nh, nw));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34217740"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;累積和をあらかじめ求めておくことで、区間和を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。
また、尺取り法で区間和&lt;code&gt;Cum[w]-Cum[x]==P+Q+R&lt;/code&gt;となる区間を求めることで、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;が時間計算量&lt;code&gt;O(N)&lt;/code&gt;でわかります。
この&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;間で&lt;code&gt;Cum[y]-Cum[x]==P&lt;/code&gt;、&lt;code&gt;Cum[z]-Cum[y]==Q&lt;/code&gt;、&lt;code&gt;Cum[w]-Cum[z]==R&lt;/code&gt;となる&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;z&lt;/code&gt;が存在すれば、答えは&lt;code&gt;Yes&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P, Q, R) = Scanner.Scan&amp;lt;int, long, long, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    var PQR = P + Q + R;
    var w = 0;
    for (var x = 0; x &amp;lt; N; x++)
    {
        while (x &amp;lt; N &amp;amp;&amp;amp; cum[w] - cum[x] &amp;lt; PQR) w++;
        if (cum[w] - cum[x] != PQR) continue;
        
        var y = l;
        while (y &amp;lt; w &amp;amp;&amp;amp; cum[y] - cum[x] &amp;lt; P) y++;
        if (cum[y] - cum[x] != P) continue;

        var z = y;
        while (z &amp;lt; w &amp;amp;&amp;amp; cum[z] - cum[y] &amp;lt; Q) z++;
        if (cum[z] - cum[y] != Q) continue;

        if (cum[w] - cum[z] != R) continue;

        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34223689"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][x][y] := i回目の移動で(x,y)に至る移動経路の個数&lt;/code&gt;とする動的計画法を解きます。
ここで、&lt;code&gt;(x,y)&lt;/code&gt;の取りうる値は疎であることから、全ての&lt;code&gt;(x,y)&lt;/code&gt;を管理せずに移動しうる&lt;code&gt;(x,y)&lt;/code&gt;をキーとした辞書などを使って管理することで、時間計算量&lt;code&gt;O(N^3logN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var (A, B, C, D, E, F) = Scanner.Scan&amp;lt;long, long, long, long, long, long&amp;gt;();
    var delta = new (long, long)[] { (A, B), (C, D), (E, F) };
    var obstacles = new HashSet&amp;lt;Point&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        obstacles.Add(new Point(x, y));
    }

    var dp0 = new Dictionary&amp;lt;Point, mint&amp;gt;();
    dp0[new Point(0, 0)] = 1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var dp1 = new Dictionary&amp;lt;Point, mint&amp;gt;();
        foreach (var (p, v) in dp0)
        {
            foreach (var (dx, dy) in delta)
            {
                var np = new Point(p.X + dx, p.Y + dy);
                if (obstacles.Contains(np)) continue;
                if (!dp1.ContainsKey(np)) dp1[np] = 0;
                dp1[np] += v;
            }
        }

        dp0 = dp1;
    }

    mint answer = 0;
    foreach (var (_, v) in dp0)
    {
        answer += v;
    }

    Console.WriteLine(answer);
}

public readonly struct Point : IEquatable&amp;lt;Point&amp;gt;
{
    public readonly long X;
    public readonly long Y;
    public Point(long x, long y) =&amp;gt; (X, Y) = (x, y);
    public bool Equals(Point other) =&amp;gt; X == other.X &amp;amp;&amp;amp; Y == other.Y;
    public override int GetHashCode() =&amp;gt; HashCode.Combine(X, Y);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 265の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20220813abc264</id>
		<title>ABC264</title>
		<link href="https://blog.aconcavy.dev/posts/20220813abc264" />
		<updated>2022-08-13T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 264の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264"&gt;https://atcoder.jp/contests/abc264&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33984910"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.string.substring?view=net-6.0"&gt;&lt;code&gt;SubString&lt;/code&gt;メソッド&lt;/a&gt;に始点と長さを指定することで、部分文字列を取得することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L, R) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    L--;
    const string atcoder = &amp;quot;atcoder&amp;quot;;
    var answer = atcoder.SubString(L, R - L);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、文字列スライスを使うことで&lt;code&gt;[L,R)&lt;/code&gt;区間の部分文字列を取得することもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L, R) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    L--;
    const string atcoder = &amp;quot;atcoder&amp;quot;;
    var answer = atcoder[L..R];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33988441"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中心(8行目8列目)からの行の距離と列の距離の最大値の偶奇によって色分けされているので、それを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (R, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var mid = 8;
    var r = Math.Abs(mid - R);
    var c = Math.Abs(mid - C);
    var answer = Math.Max(r, c) % 2 == 0 ? &amp;quot;white&amp;quot; : &amp;quot;black&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33998636"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行列&lt;code&gt;A&lt;/code&gt;のうち、どの行と列を使うかの組み合わせを全探索してます。
これは、bit全探索(2のn乗のビットが立っていれば、そのn行目またはn列目を使う)を行うことで簡潔に書くことができます。
時間計算量は、最大でも&lt;code&gt;(2^10)*(2^10)≒10^6&lt;/code&gt;なので、余裕で間に合います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H1, W1) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[H1][];
    for (var i = 0; i &amp;lt; H1; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var (H2, W2) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var B = new int[H2][];
    for (var i = 0; i &amp;lt; H2; i++)
    {
        B[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    for (var H = 0; H &amp;lt; 1 &amp;lt;&amp;lt; H1; H++)
    {
        var hc = 0;
        for (var k = 0; k &amp;lt; H1; k++)
        {
            if ((H &amp;gt;&amp;gt; k &amp;amp; 1) == 1) hc++;
        }

        if (hc != H2) continue;

        for (var W = 0; W &amp;lt; 1 &amp;lt;&amp;lt; W1; W++)
        {
            var wc = 0;
            for (var k = 0; k &amp;lt; W1; k++)
            {
                if ((W &amp;gt;&amp;gt; k &amp;amp; 1) == 1) wc++;
            }

            if (wc != W2) continue;

            var G = new List&amp;lt;List&amp;lt;int&amp;gt;&amp;gt;();
            for (var i = 0; i &amp;lt; H1; i++)
            {
                if ((H &amp;gt;&amp;gt; i &amp;amp; 1) == 1) G.Add(new List&amp;lt;int&amp;gt;());
                else continue;

                for (var j = 0; j &amp;lt; W1; j++)
                {
                    if ((W &amp;gt;&amp;gt; j &amp;amp; 1) == 1) G[^1].Add(A[i][j]);
                }
            }

            var ok = true;
            for (var i = 0; i &amp;lt; H2; i++)
            {
                for (var j = 0; j &amp;lt; W2; j++)
                {
                    ok &amp;amp;= G[i][j] == B[i][j];
                }
            }

            if (ok)
            {
                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33993322"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数列をソートするための最小の操作回数は転倒数と一致するため、文字が&lt;code&gt;atcoder&lt;/code&gt;の何番目に値するかに変換した数列の転倒数を求めることで、時間計算量&lt;code&gt;O(|S|log|S|)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int N = 7;
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    int F(char c)
    {
        return c switch
        {
            'a' =&amp;gt; 0,
            't' =&amp;gt; 1,
            'c' =&amp;gt; 2,
            'o' =&amp;gt; 3,
            'd' =&amp;gt; 4,
            'e' =&amp;gt; 5,
            'r' =&amp;gt; 6,
            _ =&amp;gt; 7,
        };
    }

    var T = S.Select(x =&amp;gt; F(x)).ToArray();
    var ft = new FenwickTree(10);
    var answer = 0L;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = T[i];
        answer += i - ft.Sum(c + 1);
        ft.Add(c, 1);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文字列を頂点として、隣接する文字を入れ替えていく幅優先探索でも、時間計算量&lt;code&gt;O(|S|!)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/34003277"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての発電所から電線がつながっている都市をクエリごとに計算してしまうと、連結成分の判定に&lt;code&gt;Disjoint Set Union (DSU)&lt;/code&gt;を使ったとしても、&lt;code&gt;DSU&lt;/code&gt;の構成に時間計算量&lt;code&gt;O(α(N+M)) (α:アッカーマンの逆関数、非常に小さな定数)&lt;/code&gt;、全ての発電所の連結成分の個数の数え上げに時間計算量&lt;code&gt;O(M)&lt;/code&gt;となってしまい、全体で&lt;code&gt;O(Q(α(N+M)+M))&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、使わない電線をあらかじめ繋いでおき、そこにクエリの逆順で電線を繋いでいくという問題に言い換えると、クエリごとに毎回&lt;code&gt;DSU&lt;/code&gt;を構築しなおす必要がなくなり、クエリ当たりの時間計算量が、全ての発電所の連結成分の個数の数え上げの&lt;code&gt;O(M)&lt;/code&gt;のみになります。&lt;br /&gt;
さらに、全ての発電所の連結成分の数え上げを、ある一つの発電所に連結成分をまとめ、その発電所のみ調べることで、時間計算量を&lt;code&gt;O(1)&lt;/code&gt;にすることができます。&lt;br /&gt;
このことから、クエリの先読み逆順処理と発電所のまとめあげをおこなうことで、全体の時間計算量を&lt;code&gt;O(α(N+M)+Q)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, E) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var Edges = new (int U, int V)[E];
    for (var i = 0; i &amp;lt; E; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        Edges[i] = (u, v);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var X = new int[Q];
    var removes = new bool[E];
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var x = Scanner.Scan&amp;lt;int&amp;gt;() - 1;
        X[i] = x;
        removes[x] = true;
    }

    var s = 0;
    var dsu = new DisjointSetUnion(N + M + 1);
    for (var u = N + 1; u &amp;lt;= N + M; u++)
    {
        dsu.Merge(s, u);
    }

    for (var i = 0; i &amp;lt; E; i++)
    {
        if (!removes[i])
        {
            var (u, v) = Edges[i];
            dsu.Merge(u, v);
        }
    }

    var answer = new int[Q];
    for (var i = Q - 1; i &amp;gt;= 0; i--)
    {
        answer[i] = dsu.SizeOf(s) - (M + 1);
        var (u, v) = Edges[X[i]];
        dsu.Merge(u, v);
    }

    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 264の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>