<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://blog.aconcavy.dev/</id>
	<title>acon.log</title>
	<link rel="self" href="https://blog.aconcavy.dev/" />
	<rights>Copyright © 2020-2024 AconCavy</rights>
	<updated>2024-04-20T14:17:19Z</updated>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240420abc350</id>
		<title>ABC350</title>
		<link href="https://blog.aconcavy.dev/posts/20240420abc350" />
		<updated>2024-04-20T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 350の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc350"&gt;https://atcoder.jp/contests/abc350&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc350/tasks/abc350_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC350/submissions/52543658"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1以上350未満かつ316以外のコンテストが対象となるコンテストになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var n = int.Parse(S[3..]);
    var answer = 1 &amp;lt;= n &amp;amp;&amp;amp; n &amp;lt; 350 &amp;amp;&amp;amp; n != 316;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc350/tasks/abc350_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC350/submissions/52549788"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;p&gt;&lt;code&gt;E[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;番目の歯が生えているかをboolとして持ちます。
&lt;code&gt;E[T[i]]&lt;/code&gt;を順番に反転させ、最終的に&lt;code&gt;E&lt;/code&gt;の&lt;code&gt;true&lt;/code&gt;の数が答えになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var T = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var E = new bool[N];
    Array.Fill(E, true);
    foreach (var t in T)
    {
        E[t] = !E[t];
    }

    var answer = E.Count(x =&amp;gt; x);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc350/tasks/abc350_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC350/submissions/52581134"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index[x]&lt;/code&gt;を&lt;code&gt;A&lt;/code&gt;における&lt;code&gt;x&lt;/code&gt;の位置とします。&lt;br /&gt;
あらかじめ各&lt;code&gt;index[A[i]]&lt;/code&gt;を求めておき、左から順番に&lt;code&gt;A[i]==i&lt;/code&gt;であるかを判定していきます。&lt;br /&gt;
&lt;code&gt;A[i]!=i&lt;/code&gt;のとき、&lt;code&gt;i&lt;/code&gt;の値は&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;j=index[i]&lt;/code&gt;番目にあるので、&lt;code&gt;A[i]&lt;/code&gt;と&lt;code&gt;A[j]&lt;/code&gt;を入れ替えます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var index = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        index[A[i]] = i;
    }

    var answers = new List&amp;lt;(int A, int B)&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A[i] == i) continue;
        var j = index[i];
        (index[A[i]], index[A[j]]) = (index[A[j]], index[A[i]]);
        (A[i], A[j]) = (A[j], A[i]);
        answers.Add((i + 1, j + 1));
    }

    Console.WriteLine(answers.Count);
    Console.WriteLine(string.Join(Environment.NewLine, answers.Select(x =&amp;gt; $&amp;quot;{x.A} {x.B}&amp;quot;)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc350/tasks/abc350_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC350/submissions/52577949"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各連結成分ごとに2組のユーザの組み合わせを数え上げ、既に友達になっている&lt;code&gt;M&lt;/code&gt;組を引いたものが答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dsu = new DisjointSetUnion(N);
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        dsu.Merge(a, b);
    }

    long answer = 0;
    foreach (var group in dsu.GetGroups())
    {
        var c = (long)group.Count;
        answer += c * (c - 1) / 2;
    }

    answer -= M;
    Console.WriteLine(answer);
}

public class DisjointSetUnion
{
    public int Length { get; }
    private readonly int[] _parentOrSize;
    public DisjointSetUnion(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _parentOrSize = new int[Length];
        Array.Fill(_parentOrSize, -1);
    }
    public int Merge(int u, int v)
    {
        if (u &amp;lt; 0 || Length &amp;lt;= u) throw new ArgumentOutOfRangeException(nameof(u));
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        var (x, y) = (LeaderOf(u), LeaderOf(v));
        if (x == y) return x;
        if (-_parentOrSize[x] &amp;lt; -_parentOrSize[y]) (x, y) = (y, x);
        _parentOrSize[x] += _parentOrSize[y];
        _parentOrSize[y] = x;
        return x;
    }
    public bool IsSame(int u, int v)
    {
        if (u &amp;lt; 0 || Length &amp;lt;= u) throw new ArgumentOutOfRangeException(nameof(u));
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        return LeaderOf(u) == LeaderOf(v);
    }
    public int LeaderOf(int v)
    {
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        if (_parentOrSize[v] &amp;lt; 0) return v;
        return _parentOrSize[v] = LeaderOf(_parentOrSize[v]);
    }
    public int SizeOf(int v)
    {
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        return -_parentOrSize[LeaderOf(v)];
    }
    public IEnumerable&amp;lt;IReadOnlyCollection&amp;lt;int&amp;gt;&amp;gt; GetGroups()
    {
        var result = new List&amp;lt;int&amp;gt;[Length].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
        for (var i = 0; i &amp;lt; Length; i++) result[LeaderOf(i)].Add(i);
        return result.Where(x =&amp;gt; x.Count &amp;gt; 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 350の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240413abc349</id>
		<title>ABC349</title>
		<link href="https://blog.aconcavy.dev/posts/20240413abc349" />
		<updated>2024-04-13T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 349の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc349"&gt;https://atcoder.jp/contests/abc349&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc349/tasks/abc349_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC349/submissions/52293336"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;総和は&lt;code&gt;0&lt;/code&gt;になるので、&lt;code&gt;0-Aの総和&lt;/code&gt;が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = -A.Sum();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc349/tasks/abc349_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC349/submissions/52298832"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字ごとに出現数を数え上げ、全ての出現数において、その種類数が&lt;code&gt;0&lt;/code&gt;か&lt;code&gt;2&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var count = new int[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    var dict = new Dictionary&amp;lt;int, int&amp;gt;();
    for (var i = 0; i &amp;lt; 26; i++)
    {
        if (count[i] == 0) continue;
        if (!dict.ContainsKey(count[i])) dict[count[i]] = 0;
        dict[count[i]]++;
    }

    var answer = dict.Values.All(x =&amp;gt; x == 0 || x == 2);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc349/tasks/abc349_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC349/submissions/52306540"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を左から順にみて、&lt;code&gt;T&lt;/code&gt;の&lt;code&gt;k&lt;/code&gt;番目の小文字が出現したかを判定します。
&lt;code&gt;S&lt;/code&gt;の末尾に&lt;code&gt;x&lt;/code&gt;を追加したものを&lt;code&gt;S&lt;/code&gt;として考えることで、末尾に&lt;code&gt;X&lt;/code&gt;を追加したものを判定することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;() + &amp;quot;x&amp;quot;;
    var T = Scanner.Scan&amp;lt;string&amp;gt;().ToLower();
    var k = 0;
    foreach (var c in S)
    {
        if (k &amp;gt;= 3) break;
        if (T[k] == c) k++;
    }

    var answer = k == 3;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc349/tasks/abc349_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC349/submissions/52337055"&gt;コンテスト提出&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/ABC349/submissions/52362230"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r%b==0&lt;/code&gt;かつ&lt;code&gt;l=(r/b-1)*b&amp;gt;=L&lt;/code&gt;となる最大の&lt;code&gt;2&lt;/code&gt;のべき乗&lt;code&gt;b&lt;/code&gt;を&lt;code&gt;r&lt;/code&gt;の大きい順に求めることで達成できます。
各数列において、&lt;code&gt;b&lt;/code&gt;は最大60回程度で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L, R) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answers = new List&amp;lt;(long L, long R)&amp;gt;();
    while (R &amp;gt; L)
    {
        long b = 1L &amp;lt;&amp;lt; 60;
        var l = (R / b - 1) * b;
        while (R % b != 0 || l &amp;lt; L)
        {
            b &amp;gt;&amp;gt;= 1;
            l = (R / b - 1) * b;
        }
        answers.Add((l, R));
        R = l;
    }

    Console.WriteLine(answers.Count);
    answers.Reverse();
    foreach (var (l, r) in answers)
    {
        Console.WriteLine($&amp;quot;{l} {r}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 349の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240406abc348</id>
		<title>ABC348</title>
		<link href="https://blog.aconcavy.dev/posts/20240406abc348" />
		<updated>2024-04-06T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 348の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc348"&gt;https://atcoder.jp/contests/abc348&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc348/tasks/abc348_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC348/submissions/52059334"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の文字を&lt;code&gt;i&lt;/code&gt;が3の倍数なら&lt;code&gt;x&lt;/code&gt;、それ以外なら&lt;code&gt;o&lt;/code&gt;にした文字列を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;
public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = new string(Enumerable.Range(1, N).Select(x =&amp;gt; x % 3 == 0 ? 'x' : 'o').ToArray());
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc348/tasks/abc348_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC348/submissions/52068262"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;i&lt;/code&gt;について、距離が最大となる&lt;code&gt;j&lt;/code&gt;を全探索します。&lt;br /&gt;
距離の2乗を計算することで、整数で計算することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = new Point[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        P[i] = new Point(x, y);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x1, y1) = P[i];
        var answer = 0;
        var max = 0;
        for (var j = 0; j &amp;lt; N; j++)
        {
            var (x2, y2) = P[j];
            var dx = x1 - x2;
            var dy = y1 - y2;
            var d = dx * dx + dy * dy;
            if (d &amp;gt; max)
            {
                max = d;
                answer = j + 1;
            }
        }

        Console.WriteLine(answer);
    }
}

public readonly record struct Point(int X, int Y);
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc348/tasks/abc348_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC348/submissions/52072763"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書などのデータ構造を使って色に対して美味しさが最も小さい値を管理し、その最大値が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, int&amp;gt;();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, c) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (!dict.ContainsKey(c)) dict[c] = Inf;
        dict[c] = Math.Min(dict[c], a);
    }

    var answer = dict.Values.Max();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc348/tasks/abc348_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC348/submissions/52080246"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在の場所を&lt;code&gt;(ch,cw)&lt;/code&gt;とエネルギー量を&lt;code&gt;ce&lt;/code&gt;したとき、&lt;code&gt;(ch,cw)&lt;/code&gt;に薬(エネルギー&lt;code&gt;E&lt;/code&gt;)がある場合は、&lt;code&gt;ce&lt;/code&gt;の値を&lt;code&gt;Max(ce,E)&lt;/code&gt;に更新しながら、&lt;code&gt;Dijkstra&lt;/code&gt;法で探索を行います。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new char[H][];
    var (sh, sw) = (-1, -1);
    var (th, tw) = (-1, -1);
    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (A[i][j] == 'S')
            {
                (sh, sw) = (i, j);
            }

            if (A[i][j] == 'T')
            {
                (th, tw) = (i, j);
            }
        }
    }

    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var E = new Dictionary&amp;lt;(int, int), int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (r, c, e) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        E[(r - 1, c - 1)] = e;
    }

    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var dp = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        dp[i] = new int[W];
        Array.Fill(dp[i], -Inf);
    }

    dp[sh][sw] = 0;
    var queue = new PriorityQueue&amp;lt;(int H, int W, int E), long&amp;gt;();
    queue.Enqueue((sh, sw, 0), 0);
    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };
    while (queue.TryDequeue(out var top, out _))
    {
        var (ch, cw, ce) = top;
        if (dp[ch][cw] &amp;gt; ce) continue;
        if (E.ContainsKey((ch, cw)))
        {
            ce = Math.Max(ce, E[(ch, cw)]);
        }

        if (ce == 0) continue;
        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            if (A[nh][nw] == '#') continue;
            var ne = ce - 1;
            if (dp[nh][nw] &amp;gt;= ne) continue;
            dp[nh][nw] = ne;
            queue.Enqueue((nh, nw, ne), -ne);
        }
    }

    var answer = dp[th][tw] &amp;gt;= 0;
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc348/tasks/abc348_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC348/submissions/52114743"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある木の&lt;code&gt;f&lt;/code&gt;の値を求めるには、その部分木&lt;code&gt;f&lt;/code&gt;の和と、その部分木の重みの和を足したものになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;(long F, long W) Dfs(int u, int p)
{
    long f = 0;
    long w = 0;
    foreach(var v in T[u])
    {
        if (v == p) continue;
        var (cf, cw) = Dfs(v, u);
        f += cf;
        w += cw;
    }

    return (f + w, w + C[u]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;しかし、各&lt;code&gt;i&lt;/code&gt;について愚直に計算してしまうと時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまうので、部分木の和と部分木の重みの和を保持しながら全方位木DPを行うことで時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var E = new (int A, int B)[N - 1];
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        E[i] = (a, b);
    }

    var C = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var dp = new ReRooting&amp;lt;Data&amp;gt;(N, new Operation(C));
    foreach (var (a, b) in E)
    {
        dp.AddEdge(a, b);
    }

    var result = dp.Calculate();
    var answer = result.Select(x =&amp;gt; x.S).Min();
    Console.WriteLine(answer);
}

public class Operation : ReRooting&amp;lt;Data&amp;gt;.IOperation
{
    public Data Identity =&amp;gt; new Data(0, 0);

    private readonly long[] C;
    public Operation(long[] c) =&amp;gt; C = c;

    public Data AddRoot(int i, Data value)
    {
        return new Data(value.S + value.C, value.C + C[i]);
    }

    public Data Merge(Data left, Data right)
    {
        return new Data(left.S + right.S, left.C + right.C);
    }
}

public readonly record struct Data(long S, long C);

public class ReRooting&amp;lt;T&amp;gt;
{
    public int Size { get; init; }
    private readonly List&amp;lt;int&amp;gt;[] _edges;
    private readonly IOperation _operation;

    public ReRooting(int size, IOperation operation)
    {
        Size = size;
        _operation = operation;
        _edges = new List&amp;lt;int&amp;gt;[Size];
        for (var i = 0; i &amp;lt; Size; i++) _edges[i] = new List&amp;lt;int&amp;gt;();
    }

    public void AddEdge(int u, int v)
    {
        _edges[u].Add(v);
        _edges[v].Add(u);
    }

    public T[] Calculate()
    {
        var result = new T[Size];
        Array.Fill(result, _operation.Identity);
        var dp = new T[Size][];
        Dfs(0);
        Bfs(0, _operation.Identity);
        return result;

        T Dfs(int u, int p = -1)
        {
            dp[u] = new T[_edges[u].Count];
            var cum = _operation.Identity;
            for (var i = 0; i &amp;lt; _edges[u].Count; i++)
            {
                var v = _edges[u][i];
                if (v == p) continue;
                dp[u][i] = Dfs(v, u);
                cum = _operation.Merge(cum, dp[u][i]);
            }

            return _operation.AddRoot(u, cum);
        }

        void Bfs(int u, T value, int p = -1)
        {
            var n = _edges[u].Count;
            for (var i = 0; i &amp;lt; n; i++)
            {
                if (_edges[u][i] == p) dp[u][i] = value;
            }

            var cumL = new T[n + 1];
            var cumR = new T[n + 1];
            Array.Fill(cumL, _operation.Identity);
            Array.Fill(cumR, _operation.Identity);
            for (var i = 0; i &amp;lt; n; i++)
            {
                var j = n - 1 - i;
                cumL[i + 1] = _operation.Merge(cumL[i], dp[u][i]);
                cumR[j] = _operation.Merge(cumR[j + 1], dp[u][j]);
            }

            result[u] = _operation.AddRoot(u, cumL[n]);
            for (var i = 0; i &amp;lt; n; i++)
            {
                var v = _edges[u][i];
                if (v != p) Bfs(v, _operation.AddRoot(u, _operation.Merge(cumL[i], cumR[i + 1])), u);
            }
        }
    }

    public interface IOperation
    {
        public T Identity { get; }
        public T Merge(T left, T right);
        public T AddRoot(int i, T value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 348の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240330abc347</id>
		<title>ABC347</title>
		<link href="https://blog.aconcavy.dev/posts/20240330abc347" />
		<updated>2024-03-30T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 347の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc347"&gt;https://atcoder.jp/contests/abc347&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc347/tasks/abc347_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC347/submissions/51800657"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;A[i]&lt;/code&gt;について、&lt;code&gt;A[i]%K==0&lt;/code&gt;ならば&lt;code&gt;A[i]/K&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answers = A.Where(x =&amp;gt; x % K == 0).Select(x =&amp;gt; x / K).ToArray();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc347/tasks/abc347_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC347/submissions/51804646"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連続する部分文字列は、&lt;code&gt;0&amp;lt;i&amp;lt;j&amp;lt;|S|&lt;/code&gt;となる&lt;code&gt;S[i]&lt;/code&gt;から&lt;code&gt;S[j]&lt;/code&gt;までの文字列となり、&lt;code&gt;|S|&lt;/code&gt;は最大でも&lt;code&gt;100&lt;/code&gt;なので、&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;の組み合わせを全探索し、その部分文字列&lt;code&gt;S[i..j]&lt;/code&gt;を集合などで管理して、最終的な集合の大きさを求めます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var set = new HashSet&amp;lt;string&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt;= N; j++)
        {
            set.Add(S[i..j]);
        }
    }

    Console.WriteLine(set.Count);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc347/tasks/abc347_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC347/submissions/51883124"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1週間でループするので、各&lt;code&gt;D[i]&lt;/code&gt;を&lt;code&gt;A+B&lt;/code&gt;で割った余りの重複を省いてソートしたものを&lt;code&gt;E&lt;/code&gt;とし、&lt;code&gt;E&lt;/code&gt;の長さを&lt;code&gt;M&lt;/code&gt;とします。&lt;br /&gt;
&lt;code&gt;E[0]&lt;/code&gt;日目を1週間の1日目としたとき、全て休日である条件は、&lt;code&gt;E[M-1]&lt;/code&gt;が休日であることなので、&lt;code&gt;E[M-1]-E[0]+1&amp;lt;=A&lt;/code&gt;が条件となります。&lt;br /&gt;
また、1週間でループするので、&lt;code&gt;E[i+M]&lt;/code&gt;を&lt;code&gt;E[i]+A+B&lt;/code&gt;とし、各&lt;code&gt;E[i] (i&amp;lt;M)&lt;/code&gt;について同様の条件を判定することで、各&lt;code&gt;E[i]&lt;/code&gt;日目を1週間の1日目としたときの判定を行うことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var C = A + B;
    var D = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().Select(x =&amp;gt; x % C).Distinct().Order().ToArray();
    var M = D.Length;
    var E = new long[M * 2];
    for (var i = 0; i &amp;lt; M; i++)
    {
        E[i] = D[i];
        E[i + M] = D[i] + C;
    }

    for (var i = 0; i &amp;lt; M; i++)
    {
        if (E[i + M - 1] - E[i] &amp;lt; A)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc347/tasks/abc347_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC347/submissions/51881963"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次の動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,a,b] := i番目のビットまでみたとき、Xのビットが1の数がa、Yのビットの数がbの時のXの値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;-1を存在しない値とする。

i==0のとき、
Cの0番目のビットが0のとき、
dp[0,0,0] = 0
dp[0,0,1] = -1
dp[0,1,0] = -1
dp[0,1,1] = 1
Cの0番目のビットが1のとき、
dp[0,0,0] = -1
dp[0,0,1] = 0
dp[0,1,0] = 1
dp[0,1,1] = -1

i&amp;gt;0のときかつdp[i-1,a,b]!=-1のとき、
Cのi番目のビットが0のとき、
dp[i,a,b] = dp[i-1,a,b]
dp[i,a+1,b+1] = dp[i-1,a,b] | (1&amp;lt;&amp;lt;i)

Cのi番目のビットが1のとき、
dp[i,a+1,b] = dp[i-1,a,b] | (1L&amp;lt;&amp;lt;i)
dp[i,a,b+1] = dp[i-1,a,b]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最終的に&lt;code&gt;X=dp[N,A,B]&lt;/code&gt;となり、&lt;code&gt;Y=C^X&lt;/code&gt;となります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, C) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var N = 60;
    var dp = new long[N + 1, A + 2, B + 2];
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var a = 0; a &amp;lt;= A; a++)
        {
            for (var b = 0; b &amp;lt;= B; b++)
            {
                dp[i, a, b] = -1;
            }
        }
    }

    if ((C &amp;amp; 1) == 0)
    {
        dp[0, 0, 0] = 0;
        dp[0, 1, 1] = 1;
    }
    else
    {
        dp[0, 1, 0] = 1;
        dp[0, 0, 1] = 0;
    }

    for (var i = 1; i &amp;lt;= N; i++)
    {
        for (var a = 0; a &amp;lt;= A; a++)
        {
            for (var b = 0; b &amp;lt;= B; b++)
            {
                if (dp[i - 1, a, b] == -1) continue;
                var bit = (C &amp;gt;&amp;gt; i) &amp;amp; 1;
                if (bit == 0)
                {
                    dp[i, a, b] = dp[i - 1, a, b];
                    dp[i, a + 1, b + 1] = dp[i - 1, a, b] | (1L &amp;lt;&amp;lt; i);
                }
                else
                {
                    dp[i, a + 1, b] = dp[i - 1, a, b] | (1L &amp;lt;&amp;lt; i);
                    dp[i, a, b + 1] = dp[i - 1, a, b];
                }
            }
        }
    }

    if (dp[N, A, B] &amp;gt;= 0)
    {
        var x = dp[N, A, B];
        var y = C ^ x;
        Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
        return;
    }

    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc347/tasks/abc347_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC347/submissions/51877156"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最終的な&lt;code&gt;A&lt;/code&gt;の各値は、&lt;code&gt;S&lt;/code&gt;に&lt;code&gt;x&lt;/code&gt;が追加してから、&lt;code&gt;S&lt;/code&gt;から&lt;code&gt;x&lt;/code&gt;が削除されるまでの集合の大きさの和となります。&lt;br /&gt;
このことから、各クエリごとに&lt;code&gt;x&lt;/code&gt;が&lt;code&gt;S&lt;/code&gt;に追加されたときのクエリ番号と、そのクエリまでの集合の大きさの累積和を管理し、&lt;code&gt;x&lt;/code&gt;が&lt;code&gt;S&lt;/code&gt;から削除されるときに&lt;code&gt;x&lt;/code&gt;を追加したクエリ番号からの累積和を&lt;code&gt;A[x]&lt;/code&gt;に足すという処理を行います。&lt;br /&gt;
全てのクエリが終わったあとに、&lt;code&gt;S&lt;/code&gt;に残った要素についても同様の処理を行うことで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var A = new long[N];
    var S = new Dictionary&amp;lt;int, int&amp;gt;();
    var cum = new long[Q + 1];
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var x = X[i];
        if (S.ContainsKey(x))
        {
            A[x - 1] += cum[i] - cum[S[x]];
            S.Remove(x);
        }
        else
        {
            S[x] = i;
        }

        cum[i + 1] = cum[i] + S.Count;
    }

    foreach (var (x, i) in S)
    {
        A[x - 1] += cum[Q] - cum[i];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 347の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240323abc346</id>
		<title>ABC346</title>
		<link href="https://blog.aconcavy.dev/posts/20240323abc346" />
		<updated>2024-03-23T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 346の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc346"&gt;https://atcoder.jp/contests/abc346&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51542851"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文通り、&lt;code&gt;B[i]=A[i]*A[i+1]&lt;/code&gt;となる&lt;code&gt;B&lt;/code&gt;を求め、それを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = new long[N - 1];
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        B[i] = A[i] * A[i + 1];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51551415"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;wbwbwwbwbwbw&lt;/code&gt;を十分な長さ連結した文字列を&lt;code&gt;S&lt;/code&gt;とします。&lt;br /&gt;
&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;w&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;についての累積和をそれぞれ計算しておき、長さ&lt;code&gt;w+b&lt;/code&gt;の区間の&lt;code&gt;w&lt;/code&gt;の個数と&lt;code&gt;b&lt;/code&gt;の個数が、それぞれ&lt;code&gt;w&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;であるかを判定することで答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (W, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = &amp;quot;wbwbwwbwbwbw&amp;quot;;
    while (S.Length &amp;lt; 300)
    {
        S += S;
    }

    var cumW = new int[S.Length + 1];
    var cumB = new int[S.Length + 1];
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        cumW[i + 1] += cumW[i];
        cumB[i + 1] += cumB[i];
        if (S[i] == 'w') cumW[i + 1]++;
        else cumB[i + 1]++;
    }

    var L = W + B;
    for (var i = 0; i + L &amp;lt;= S.Length; i++)
    {
        if (cumW[i + L] - cumW[i] == W &amp;amp;&amp;amp; cumB[i + L] - cumB[i] == B)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51553756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;K&lt;/code&gt;までの総和&lt;code&gt;S&lt;/code&gt;は&lt;code&gt;K*(K+1)/2&lt;/code&gt;で求めることができ、&lt;code&gt;K&lt;/code&gt;以下の重複を除いた&lt;code&gt;A&lt;/code&gt;の値を&lt;code&gt;S&lt;/code&gt;から引いたものが答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var S = K * (K + 1) / 2;
    foreach (var a in A.Distinct().Where(x =&amp;gt; x &amp;lt;= K))
    {
        S -= a;
    }

    Console.WriteLine(S);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51571688"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,j,k] := i番目の文字がj(0|1)であるかつ、良い文字列であるk(0|1)ときのコストの最小値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;a = S[i], b = S[i]^1 とする。

i番目で良い文字列になるパターン
dp[i+1,a,1] = Min(dp[i+1,a,1], dp[i,a,0]);
dp[i+1,b,1] = Min(dp[i+1,b,1], dp[i,b,0] + C[i]);

i番目では良い文字列ではないパターン
dp[i+1,a,0] = Min(dp[i+1,a,0], dp[i,b,0]);
dp[i+1,b,0] = Min(dp[i+1,b,0], dp[i,a,0] + C[i]);

i番目までに既に良い文字列であるパターン
dp[i+1,a,1] = Min(dp[i+1,a,1], dp[i,b,1]);
dp[i+1,b,1] = Min(dp[i+1,b,1], dp[i,a,1] + C[i]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Min(dp[N,0,1], dp[N,1,1])&lt;/code&gt;が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
    var C = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var dp = new long[N + 1, 2, 2];
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 0; j &amp;lt; 2; j++)
        {
            for (var k = 0; k &amp;lt; 2; k++)
            {
                dp[i, j, k] = Inf;
            }
        }
    }

    dp[1, S[0], 0] = 0;
    dp[1, S[0] ^ 1, 0] = C[0];
    for (var i = 1; i &amp;lt; N; i++)
    {
        var a = S[i];
        var b = S[i] ^ 1;

        dp[i + 1, a, 1] = Math.Min(dp[i + 1, a, 1], dp[i, a, 0]);
        dp[i + 1, b, 1] = Math.Min(dp[i + 1, b, 1], dp[i, b, 0] + C[i]);

        dp[i + 1, a, 0] = Math.Min(dp[i + 1, a, 0], dp[i, b, 0]);
        dp[i + 1, b, 0] = Math.Min(dp[i + 1, b, 0], dp[i, a, 0] + C[i]);

        dp[i + 1, a, 1] = Math.Min(dp[i + 1, a, 1], dp[i, b, 1]);
        dp[i + 1, b, 1] = Math.Min(dp[i + 1, b, 1], dp[i, a, 1] + C[i]);
    }

    var answer = Math.Min(dp[N, 0, 1], dp[N, 1, 1]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51584285"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最終的なマスの色は、マスに対する最後のクエリの操作によって上書きされるので、クエリを逆順で処理することを考えます。&lt;br /&gt;
1番目のクエリでは、&lt;code&gt;A&lt;/code&gt;行目に対してまだ操作が行われていないとき、&lt;code&gt;A&lt;/code&gt;行目のうちそれまでに塗りつぶした列以外のマスを塗りつぶすという操作になります。&lt;br /&gt;
同様に、2番目のクエリでは、&lt;code&gt;A&lt;/code&gt;列目に対してまだ操作が行われていないとき、&lt;code&gt;A&lt;/code&gt;列目のうちそれまでに塗りつぶした行以外のマスを塗りつぶすという操作になります。&lt;br /&gt;
このことから、塗りつぶしていない行とその数、塗りつぶしていない列とその数を管理しながらクエリを適用していくことで、すべてのクエリを適用した状態の色の数を数え上げることができます。&lt;br /&gt;
また、操作が行われなかったマスの数は&lt;code&gt;H*W-操作が行われたマスの数&lt;/code&gt;で求めることができ、この値を初期状態の色&lt;code&gt;0&lt;/code&gt;の個数に加える必要があります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, M) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    var query = new (int T, int A, int X)[M];
    for (var i = 0; i &amp;lt; M; i++)
    {
        query[i] = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    }

    Array.Reverse(query);
    var row = new int[H];
    var col = new int[W];
    Array.Fill(row, -1);
    Array.Fill(col, -1);
    var remH = H;
    var remW = W;
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (t, a, x) = query[i];
        a--;
        if (t == 1)
        {
            if (row[a] != -1) continue;
            row[a] = x;
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x] += remW;
            remH--;
        }
        else
        {
            if (col[a] != -1) continue;
            col[a] = x;
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x] += remH;
            remW--;
        }
    }

    var sum = dict.Values.Sum();
    var zero = (long)H * W - sum;
    if (!dict.ContainsKey(0)) dict[0] = 0;
    dict[0] += zero;

    Console.WriteLine(dict.Where(x =&amp;gt; x.Value &amp;gt; 0).Count());
    foreach (var (k, v) in dict.Where(x =&amp;gt; x.Value &amp;gt; 0).OrderBy(x =&amp;gt; x.Key))
    {
        Console.WriteLine($&amp;quot;{k} {v}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 346の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240317abc345</id>
		<title>ABC345</title>
		<link href="https://blog.aconcavy.dev/posts/20240317abc345" />
		<updated>2024-03-17T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 345の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc345"&gt;https://atcoder.jp/contests/abc345&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51274575"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;の先頭が&lt;code&gt;&amp;lt;&lt;/code&gt;、末尾が&lt;code&gt;&amp;gt;&lt;/code&gt;、それ以外が&lt;code&gt;=&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S[0] == '&amp;lt;' &amp;amp;&amp;amp; S[^1] == '&amp;gt;';
    for (var i = 1; i &amp;lt; S.Length - 1; i++)
    {
        answer &amp;amp;= S[i] == '=';
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51278782"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;が正の整数である場合は、&lt;code&gt;(X+10-1)/10&lt;/code&gt;を計算することで、切り上げた値を得ることができます。&lt;br /&gt;
一方、&lt;code&gt;X&lt;/code&gt;が負の整数である場合は、切り上げは&lt;code&gt;0&lt;/code&gt;に近づける処理になるので、符号を正にした値を切り捨てた値の符号を負にすればいいので、&lt;code&gt;-(-X/10)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var X = Scanner.Scan&amp;lt;long&amp;gt;();
    var answer = X &amp;gt; 0 ? (X + 9) / 10 : -(-X / 10);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51306807"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字ごとに出現数を数え上げ、&lt;code&gt;count[c]&lt;/code&gt;を現在見ている箇所より右側に出現する文字&lt;code&gt;c&lt;/code&gt;の数とします。&lt;br /&gt;
同じ文字が複数出現する場合は、それらの位置を入れ替えたものは元の文字から変わらないので、答えを&lt;code&gt;+1&lt;/code&gt;します。
&lt;code&gt;i&lt;/code&gt;番目の文字と&lt;code&gt;i&amp;lt;j&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;番目の文字を入れ替えたとき、元の文字列とは異なる文字列になる組み合わせは、&lt;code&gt;i&lt;/code&gt;番目の文字列と異なる文字の数になります。&lt;br /&gt;
これは、&lt;code&gt;i&lt;/code&gt;を&lt;code&gt;0-indexed&lt;/code&gt;にすると、&lt;code&gt;N-i-count[c]&lt;/code&gt;通りになり、&lt;code&gt;count[c]&lt;/code&gt;を1減らすという操作を全ての&lt;code&gt;i&lt;/code&gt;において計算することで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var count = new long[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    long answer = 0;
    if (count.Any(x =&amp;gt; x &amp;gt; 1)) answer++;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i] - 'a';
        answer += N - i - count[c];
        count[c]--;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51371503"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あり得る配置数を枝刈りを工夫して全探索を行います。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, H, W) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var T = new (int A, int B)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        T[i] = (a, b);
    }

    var G = new bool[H, W];

    bool Dfs((int A, int B)[] tiles, int k)
    {
        var result = true;
        for (var i = 0; i &amp;lt; H &amp;amp;&amp;amp; result; i++)
        {
            for (var j = 0; j &amp;lt; W &amp;amp;&amp;amp; result; j++)
            {
                result &amp;amp;= G[i, j];
            }
        }

        if (k &amp;gt;= N || result) return result;

        if (Dfs(tiles, k + 1)) return true;

        var (a, b) = tiles[k];
        for (var t = 0; t &amp;lt; 2; t++)
        {
            var end = false;
            for (var h = 0; h + a &amp;lt;= H &amp;amp;&amp;amp; !end; h++)
            {
                for (var w = 0; w + b &amp;lt;= W &amp;amp;&amp;amp; !end; w++)
                {
                    if (G[h, w]) continue;

                    var ok = true;
                    for (var i = 0; i &amp;lt; a &amp;amp;&amp;amp; ok; i++)
                    {
                        for (var j = 0; j &amp;lt; b &amp;amp;&amp;amp; ok; j++)
                        {
                            ok &amp;amp;= !G[h + i, w + j];
                        }
                    }

                    if (!ok) continue;

                    for (var i = 0; i &amp;lt; a; i++)
                    {
                        for (var j = 0; j &amp;lt; b; j++)
                        {
                            G[h + i, w + j] = true;
                        }
                    }

                    if (Dfs(tiles, k + 1)) return true;

                    for (var i = 0; i &amp;lt; a; i++)
                    {
                        for (var j = 0; j &amp;lt; b; j++)
                        {
                            G[h + i, w + j] = false;
                        }
                    }

                    end = true;
                }
            }

            if (a == b) break;
            (a, b) = (b, a);
        }

        return false;
    }

    var tiles = new (int A, int B)[N];
    foreach (var order in Permutation.Generate(N))
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            tiles[i] = T[order[i]];
        }

        if (Dfs(tiles, 0))
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}

public static class Permutation
{
    public static bool NextPermutation(Span&amp;lt;int&amp;gt; indices)
    {
        var n = indices.Length;
        var (i, j) = (n - 2, n - 1);
        while (i &amp;gt;= 0 &amp;amp;&amp;amp; indices[i] &amp;gt;= indices[i + 1]) i--;
        if (i == -1) return false;
        while (j &amp;gt; i &amp;amp;&amp;amp; indices[j] &amp;lt;= indices[i]) j--;
        (indices[i], indices[j]) = (indices[j], indices[i]);
        indices[(i + 1)..].Reverse();
        return true;
    }

    public static bool PreviousPermutation(Span&amp;lt;int&amp;gt; indices)
    {
        var n = indices.Length;
        var (i, j) = (n - 2, n - 1);
        while (i &amp;gt;= 0 &amp;amp;&amp;amp; indices[i] &amp;lt;= indices[i + 1]) i--;
        if (i == -1) return false;
        indices[(i + 1)..].Reverse();
        while (j &amp;gt; i &amp;amp;&amp;amp; indices[j - 1] &amp;lt; indices[i]) j--;
        (indices[i], indices[j]) = (indices[j], indices[i]);
        return true;
    }

    public static IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Generate(int n)
    {
        return Inner();

        IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Inner()
        {
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++) indices[i] = i;
            do { yield return indices; } while (NextPermutation(indices));
        }
    }

    public static IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; GenerateDescending(int n)
    {
        return Inner();

        IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Inner()
        {
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++) indices[i] = n - 1 - i;
            do { yield return indices; } while (PreviousPermutation(indices));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 345の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240309abc344</id>
		<title>ABC344</title>
		<link href="https://blog.aconcavy.dev/posts/20240309abc344" />
		<updated>2024-03-09T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 344の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc344"&gt;https://atcoder.jp/contests/abc344&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51023473"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を&lt;code&gt;|&lt;/code&gt;で分けたものの、1番目と3番目の文字列を結合したものが答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Split('|');
    var answer = S[0] + S[2];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51028592"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;が入力されるまで入力された値をリストに保持するを繰り返し、リストを反転させたものを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var list = new List&amp;lt;int&amp;gt;();
    while (true)
    {
        var v = Scanner.Scan&amp;lt;int&amp;gt;();
        list.Add(v);
        if (v == 0) break;
    }

    list.Reverse();
    Console.WriteLine(string.Join(Environment.NewLine, list));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51035730"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初期状態を&lt;code&gt;0&lt;/code&gt;のみの集合として、前回の集合の要素と今回の集合の要素の組み合わせの合計値の集合を次の集合にするという操作を3回行います。&lt;br /&gt;
3回操作を行った集合に&lt;code&gt;X&lt;/code&gt;の各要素が含まれているかを判定します。&lt;br /&gt;
全体の時間計算量は&lt;code&gt;O(N*M*L)&lt;/code&gt;になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var dp = new HashSet&amp;lt;long&amp;gt;();
    dp.Add(0);
    for (var i = 0; i &amp;lt; 3; i++)
    {
        var N = Scanner.Scan&amp;lt;int&amp;gt;();
        var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().Distinct().ToArray();
        var ndp = new HashSet&amp;lt;long&amp;gt;();
        foreach (var v in dp)
        {
            foreach (var a in A)
            {
                ndp.Add(v + a);
            }
        }

        dp = ndp;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    foreach (var x in X)
    {
        var answer = dp.Contains(x);
        Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51046772"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 文字がsとなるときの操作回数の最小値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初期状態&lt;code&gt;dp[&amp;quot;&amp;quot;]=0&lt;/code&gt;として、それまでの文字列&lt;code&gt;P[k]&lt;/code&gt;に&lt;code&gt;S[j]&lt;/code&gt;を末尾に加えた文字列&lt;code&gt;X&lt;/code&gt;が&lt;code&gt;T&lt;/code&gt;に前方一致する場合、&lt;code&gt;dp[X]=Min(dp[X],dp[P[k]]+1)&lt;/code&gt;で更新していき、最終的な&lt;code&gt;dp[T]&lt;/code&gt;の値が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dp = new Dictionary&amp;lt;string, int&amp;gt;();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    dp[&amp;quot;&amp;quot;] = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var line = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
        var a = int.Parse(line[0]);
        var ndp = new Dictionary&amp;lt;string, int&amp;gt;(dp);
        foreach (var (s, c) in dp)
        {
            foreach (var t in line[1..])
            {
                if (s.Length + t.Length &amp;gt; T.Length) continue;
                var ok = true;
                for (var j = 0; j &amp;lt; t.Length &amp;amp;&amp;amp; ok; j++)
                {
                    ok &amp;amp;= t[j] == T[s.Length + j];
                }

                if (ok)
                {
                    var x = s + t;
                    if (!ndp.ContainsKey(x)) ndp[x] = Inf;
                    ndp[x] = Math.Min(ndp[x], c + 1);
                }
            }
        }

        dp = ndp;
    }

    var answer = dp.ContainsKey(T) ? dp[T] : -1;
    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51057943"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;値&lt;code&gt;x&lt;/code&gt;に対して直前の値&lt;code&gt;prev[x]&lt;/code&gt;と直後の値&lt;code&gt;prev[x]&lt;/code&gt;を管理します。&lt;br /&gt;
1番目のクエリでは、&lt;code&gt;a=x, b=y, c=next[x]&lt;/code&gt;としたとき、&lt;code&gt;next[a]=b, next[b]=c, prev[b]=a, prev[c]=b&lt;/code&gt;として更新します。&lt;br /&gt;
2番目のクエリでは、&lt;code&gt;a=prev[x], c=next[x]&lt;/code&gt;としたとき、&lt;code&gt;next[a]=c, prev[c]=a&lt;/code&gt;として更新します。&lt;br /&gt;
全てのクエリを処理した後、先頭から順に値を列挙したものが答えとなります。&lt;br /&gt;
あらかじめ、最初の値の直前の値と、最後の値の直後の値に番兵を設定することで、最初と最後を意識することなく処理することができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var prev = new Dictionary&amp;lt;int, int&amp;gt;();
    var next = new Dictionary&amp;lt;int, int&amp;gt;();
    next[A[^1]] = -1;
    prev[-1] = A[^1];
    prev[A[0]] = -2;
    next[-2] = A[0];
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        var u = A[i];
        var v = A[i + 1];
        next[u] = v;
        prev[v] = u;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var q = 1; q &amp;lt;= Q; q++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var (x, y) = (query[1], query[2]);
            var a = x;
            var b = y;
            var c = next[x];
            next[a] = b;
            next[b] = c;
            prev[b] = a;
            prev[c] = b;
        }
        else
        {
            var x = query[1];
            var a = prev[x];
            var b = x;
            var c = next[x];
            next[a] = c;
            prev[c] = a;
        }
    }

    var curr = next[-2];
    var answer = new List&amp;lt;int&amp;gt;();
    while (curr &amp;gt;= 0)
    {
        answer.Add(curr);
        curr = next[curr];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 344の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240302abc343</id>
		<title>ABC343</title>
		<link href="https://blog.aconcavy.dev/posts/20240302abc343" />
		<updated>2024-03-02T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 343の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343"&gt;https://atcoder.jp/contests/abc343&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50767994"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C=A+B&lt;/code&gt;とし、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の間でfor文を回して&lt;code&gt;C&lt;/code&gt;以外の値であればそれを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = A + B;
    for (var i = 0; i &amp;lt; 10; i++)
    {
        if (i != C)
        {
            Console.WriteLine(i);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50775147"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;行目の出力は、&lt;code&gt;A[i][j]==1&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;を全て出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var list = new List&amp;lt;int&amp;gt;();
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (A[i][j] == 1)
            {
                list.Add(j + 1);
            }
        }

        Console.WriteLine(string.Join(&amp;quot; &amp;quot;, list));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50793087"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x*x*x=k&amp;lt;=N&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;を走査し、その&lt;code&gt;k&lt;/code&gt;を文字列としてみたときに回文であるかを判定し、回文であるときの最大の&lt;code&gt;k&lt;/code&gt;を求めます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();

    bool F(long x)
    {
        var s = x.ToString();
        var m = s.Length;
        for (int i = 0, j = m - 1; i &amp;lt;= j; i++, j--)
        {
            if (s[i] != s[j]) return false;
        }

        return true;
    }

    long answer = 0;
    for (long x = 1; x * x * x &amp;lt;= N; x++)
    {
        var k = x * x * x;
        if (k &amp;lt;= N &amp;amp;&amp;amp; F(k))
        {
            answer = k;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50799830"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;得点をKeyとした選手の番号の集合をもつ辞書などを使って現在の状態を管理します。&lt;br /&gt;
現在の&lt;code&gt;A&lt;/code&gt;の得点が&lt;code&gt;x&lt;/code&gt;であるとき、&lt;code&gt;y=x+B&lt;/code&gt;となる得点&lt;code&gt;y&lt;/code&gt;の集合に&lt;code&gt;A&lt;/code&gt;を追加し、得点&lt;code&gt;x&lt;/code&gt;の集合から&lt;code&gt;A&lt;/code&gt;を削除する操作を行います。&lt;br /&gt;
このとき、得点&lt;code&gt;x&lt;/code&gt;が空集合であれば、&lt;code&gt;x&lt;/code&gt;のキーを削除し、辞書に存在するキーの数が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new Dictionary&amp;lt;long, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    dp[0] = Enumerable.Range(0, N).ToHashSet();
    var P = new long[N];
    for (var i = 0; i &amp;lt; T; i++)
    {
        var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        A--;
        var curr = P[A];
        var next = curr + B;
        if (!dp.ContainsKey(next)) dp[next] = new HashSet&amp;lt;int&amp;gt;();
        dp[next].Add(A);
        dp[curr].Remove(A);
        P[A] = next;
        if (dp[curr].Count == 0) dp.Remove(curr);
        Console.WriteLine(dp.Count);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けていません。&lt;/p&gt;
&lt;!-- 
[コンテスト提出]()  
[復習提出]()

&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;

```csharp
```

&lt;/details&gt;
 --&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50824854"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1番目に大きい値を&lt;code&gt;X1&lt;/code&gt;、&lt;code&gt;X1&lt;/code&gt;の個数を&lt;code&gt;C1&lt;/code&gt;、2番目に大きい値を&lt;code&gt;X2&lt;/code&gt;、&lt;code&gt;X2&lt;/code&gt;の個数を&lt;code&gt;C2&lt;/code&gt;とし、&lt;code&gt;i&lt;/code&gt;番目に&lt;code&gt;X1=A[i], C1=1, X2=0, C2=0&lt;/code&gt;の要素をもつ&lt;code&gt;SegmentTree&lt;/code&gt;を用意します。&lt;br /&gt;
&lt;code&gt;SegmentTree&lt;/code&gt;において、ある値&lt;code&gt;x&lt;/code&gt;とその個数&lt;code&gt;c&lt;/code&gt;があるとき、次のような演算をおこないます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;- X1&amp;lt;xならば、X1=x, C1=c, X2=X1, C2=C1
- それ以外かつX1==xならば、C1+=c,
- それ以外かつX2&amp;lt;xならば、X2=x, C2=c
- それ以外かつX2==xならば、C2+=c,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1番目のクエリでは、&lt;code&gt;SegmentTree&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目の要素を&lt;code&gt;X1=p, C1=1, X2=0, C2=0&lt;/code&gt;で更新します。&lt;br /&gt;
2番目のクエリでは、&lt;code&gt;SegmentTree&lt;/code&gt;の&lt;code&gt;l&lt;/code&gt;から&lt;code&gt;r&lt;/code&gt;について、上記の演算を行うことで、時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var st = new SegmentTree&amp;lt;Data&amp;gt;(N, new Oracle());
    for (var i = 0; i &amp;lt; N; i++)
    {
        st.Set(i, new Data(A[i], 1, 0, 0));
    }

    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var p = query[1] - 1;
            var x = query[2];
            var next = new Data(x, 1, 0, 0);
            st.Set(p, next);
        }
        else
        {
            var l = query[1] - 1;
            var r = query[2];
            var x = st.Query(l, r);
            Console.WriteLine(x.C2);
        }
    }
}

public readonly record struct Data(int X1, int C1, int X2, int C2);

public class Oracle : IOracle&amp;lt;Data&amp;gt;
{
    public Data IdentityElement =&amp;gt; new Data(0, 0, 0, 0);

    public Data Operate(Data a, Data b)
    {
        var x1 = 0;
        var c1 = 0;
        var x2 = 0;
        var c2 = 0;

        void F(int x, int c)
        {
            if (x1 &amp;lt; x)
            {
                x2 = x1;
                c2 = c1;
                x1 = x;
                c1 = c;
            }
            else if (x1 == x)
            {
                c1 += c;
            }
            else if (x2 &amp;lt; x)
            {
                x2 = x;
                c2 = c;
            }
            else if (x2 == x)
            {
                c2 += c;
            }
        }

        F(a.X1, a.C1);
        F(a.X2, a.C2);
        F(b.X1, b.C1);
        F(b.X2, b.C2);
        return new Data(x1, c1, x2, c2);
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid IdentityElement { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public class SegmentTree&amp;lt;TMonoid&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly int _log;
    private readonly int _dataSize;

    public SegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid&amp;gt; oracle) : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public SegmentTree(int length, IOracle&amp;lt;TMonoid&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, oracle.IdentityElement);
    }

    public void Set(int index, TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        return _data[index + _dataSize];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        var (sml, smr) = (_oracle.IdentityElement, _oracle.IdentityElement);
        left += _dataSize;
        right += _dataSize;
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 343の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240224abc342</id>
		<title>ABC342</title>
		<link href="https://blog.aconcavy.dev/posts/20240224abc342" />
		<updated>2024-02-24T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 342の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc342"&gt;https://atcoder.jp/contests/abc342&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50558948"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字を数え上げ、出現数が1の文字の出現位置を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;
public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var count = new int[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    for (var i = 0; i &amp;lt; 26; i++)
    {
        if (count[i] == 1)
        {
            var answer = S.IndexOf((char)(i + 'a')) + 1;
            Console.WriteLine(answer);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50561667"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あらかじめ&lt;code&gt;P[i]&lt;/code&gt;の位置&lt;code&gt;pos[P[i]]&lt;/code&gt;を求めておき、&lt;code&gt;pos[A] &amp;lt; pos[B]&lt;/code&gt;なら&lt;code&gt;A&lt;/code&gt;を、それ以外ならば&lt;code&gt;B&lt;/code&gt;の値を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var pos = new int[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        pos[P[i]] = i;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (pos[a] &amp;lt; pos[b])
        {
            Console.WriteLine(a);
        }
        else
        {
            Console.WriteLine(b);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50581747"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;変換後の文字&lt;code&gt;d&lt;/code&gt;になる文字を集合として管理しながら、クエリごとに&lt;code&gt;c&lt;/code&gt;の集合を&lt;code&gt;d&lt;/code&gt;の集合にマージし、&lt;code&gt;c&lt;/code&gt;の集合を空にするという操作を行います。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; 26; i++)
    {
        dict[i] = new HashSet&amp;lt;int&amp;gt; { i };
    }

    while (Q-- &amp;gt; 0)
    {
        var (c, d) = Scanner.Scan&amp;lt;char, char&amp;gt;();
        if (c == d) continue;
        c -= 'a';
        d -= 'a';
        dict[d].UnionWith(dict[c]);
        dict[c].Clear();
    }

    var to = new int[26];
    for (var i = 0; i &amp;lt; 26; i++)
    {
        foreach (var c in dict[i])
        {
            to[c] = i;
        }
    }

    var answer = new char[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer[i] = (char)(to[S[i] - 'a'] + 'a');
    }

    Console.WriteLine(new string(answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50616552"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    const int M = (int)2e5 + 1;
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = (int)Math.Sqrt(A[i]); j * j &amp;gt; 0; j--)
        {
            var sq = j * j;
            if (A[i] % sq == 0) A[i] /= sq;
        }
    }

    var count = new long[M];
    foreach (var a in A)
    {
        count[a]++;
    }

    var answer = count[0] * (count[0] - 1) / 2 + count[0] * (N - count[0]);
    for (var i = 1; i &amp;lt; M; i++)
    {
        answer += count[i] * (count[i] - 1) / 2;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50614877"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;駅を頂点、&lt;code&gt;l,d,k,c&lt;/code&gt;の情報を辺をもつ有向グラフとしたとき、頂点&lt;code&gt;N&lt;/code&gt;につながる頂点&lt;code&gt;x&lt;/code&gt;の&lt;code&gt;F(x)&lt;/code&gt;は、&lt;code&gt;F(x)=Max(F(x), l+(k-1)*d)&lt;/code&gt;として求めることができ、この頂点&lt;code&gt;x&lt;/code&gt;を始点とした最短経路問題としてDjikstra法で解くことができます。&lt;br /&gt;
頂点&lt;code&gt;u&lt;/code&gt;の&lt;code&gt;F(u)&lt;/code&gt;が決まっていて、頂点&lt;code&gt;u&lt;/code&gt;に繋がる頂点&lt;code&gt;v&lt;/code&gt;および情報&lt;code&gt;l,d,k,c&lt;/code&gt;があるとき、&lt;code&gt;F(u)-c&amp;lt;l&lt;/code&gt;であれば頂点&lt;code&gt;u&lt;/code&gt;から頂点&lt;code&gt;v&lt;/code&gt;に遷移することができ、&lt;code&gt;F(v)=l+Min(K-1,(F(u)-c-l)/d)*d&lt;/code&gt;として求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;Data&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;Data&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (l, d, k, c, A, B) = Scanner.Scan&amp;lt;int, int, int, int, int, int&amp;gt;();
        A--;
        B--;
        G[B].Add(new Data(A, l, d, k, c));
    }

    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var dp = new long[N];
    Array.Fill(dp, -Inf);
    var queue = new PriorityQueue&amp;lt;(int U, long C), long&amp;gt;();
    foreach (var (v, l, d, k, c) in G[N - 1])
    {
        var vc = l + (k - 1) * d;
        if (dp[v] &amp;lt; vc)
        {
            dp[v] = vc;
            queue.Enqueue((v, dp[v]), -dp[v]);
        }
    }

    while (queue.TryDequeue(out var top, out _))
    {
        var (u, uc) = top;
        if (dp[u] &amp;gt; uc) continue;
        foreach (var (v, l, d, k, c) in G[u])
        {
            if (dp[u] - c &amp;lt; l) continue;
            var vk = Math.Min(k - 1, (dp[u] - c - l) / d);
            var vc = l + vk * d;
            if (dp[v] &amp;gt;= vc) continue;
            dp[v] = vc;
            queue.Enqueue((v, dp[v]), -dp[v]);
        }
    }

    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var answer = dp[i] &amp;gt;= 0 ? dp[i].ToString() : &amp;quot;Unreachable&amp;quot;;
        Console.WriteLine(answer);
    }
}

public readonly record struct Data(int To, long L, long D, long K, long C);
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 342の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://blog.aconcavy.dev/posts/20240217abc341</id>
		<title>ABC341</title>
		<link href="https://blog.aconcavy.dev/posts/20240217abc341" />
		<updated>2024-02-17T00:00:00Z</updated>
		<content>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 341の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc341"&gt;https://atcoder.jp/contests/abc341&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50329620"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最初に&lt;code&gt;1&lt;/code&gt;から始めて、&lt;code&gt;N&lt;/code&gt;個の&lt;code&gt;01&lt;/code&gt;を繋げた文字列が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var builder = new StringBuilder();
    builder.Append('1');
    for (var i = 0; i &amp;lt; N; i++)
    {
        builder.Append(&amp;quot;01&amp;quot;);
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50336089"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;が小さい順に&lt;code&gt;S[i]&lt;/code&gt;を&lt;code&gt;T[i]&lt;/code&gt;にする行動を可能な限り行い、最終的な&lt;code&gt;N&lt;/code&gt;の通貨の単位が答えになります。&lt;br /&gt;
つまり、&lt;code&gt;N&lt;/code&gt;未満の各&lt;code&gt;i&lt;/code&gt;において、&lt;code&gt;i+1&lt;/code&gt;の通貨を&lt;code&gt;A[i]/S*T&lt;/code&gt;増やすという作業を順に行うことで達成できます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (s, t) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        A[i + 1] += t * (A[i] / s);
    }

    var answer = A[^1];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50345688"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての陸の座標から移動を行い、文字列が示す順に移動を行い、経路上が全て陸の経路の数を数え上げます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    (int dh, int dw) Delta(char d)
    {
        return d switch
        {
            'L' =&amp;gt; (0, -1),
            'R' =&amp;gt; (0, 1),
            'U' =&amp;gt; (-1, 0),
            'D' =&amp;gt; (1, 0),
            _ =&amp;gt; (0, 0)
        };
    }

    (int h, int w) F(int ch, int cw)
    {
        foreach (var d in T)
        {
            var (dh, dw) = Delta(d);
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) return (-1, -1);
            if (G[nh][nw] == '#') return (-1, -1);
            ch = nh;
            cw = nw;
        }

        return (ch, cw);
    }

    var ok = new bool[H, W];
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == '#') continue;
            var (ch, cw) = F(i, j);
            if (ch &amp;lt; 0 || cw &amp;lt; 0) continue;
            ok[ch, cw] = true;
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (ok[i, j]) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50370958"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;以下の&lt;code&gt;N&lt;/code&gt;の倍数または&lt;code&gt;M&lt;/code&gt;の倍数の個数は、&lt;code&gt;N&lt;/code&gt;の倍数の個数と&lt;code&gt;M&lt;/code&gt;の倍数の個数から&lt;code&gt;LCM(N,M)&lt;/code&gt;の倍数の個数を引いたものとなります。&lt;br /&gt;
また、ちょうど一方のみで割り切れる数は、&lt;code&gt;x&lt;/code&gt;以下の&lt;code&gt;N&lt;/code&gt;の倍数または&lt;code&gt;M&lt;/code&gt;の倍数の個数からさらに&lt;code&gt;LCM(N,M)&lt;/code&gt;の倍数の個数を引いたものとなります。&lt;br /&gt;
よって、&lt;code&gt;x/N + x/M - x/LCM(N,M)*2 &amp;gt;= K&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;を二部探索することで答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
    var lcm = Lcm(N, M);

    bool F(long x)
    {
        return (x / N) + (x / M) - ((x / lcm) * 2) &amp;gt;= K;
    }

    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var answer = BinarySearch(0, Inf, F);
    Console.WriteLine(answer);
}

public static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
public static long Lcm(long a, long b) =&amp;gt; a / Gcd(a, b) * b;

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f) where T : INumber&amp;lt;T&amp;gt; =&amp;gt; BinarySearch(ng, ok, f, T.One);

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f, T eps) where T : INumber&amp;lt;T&amp;gt;
{
    var one = T.One;
    var two = one + one;
    while (T.Abs(ok - ng) &amp;gt; eps)
    {
        var m = ng + (ok - ng) / two;
        if (f(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50390978"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;隣り合う数字の変化量に注目します。&lt;br /&gt;
隣り合う数字が異なる場合、その変化量を&lt;code&gt;1&lt;/code&gt;とすると、&lt;code&gt;L&lt;/code&gt;文字目から&lt;code&gt;R&lt;/code&gt;文字目が良い文字列になる条件は、&lt;code&gt;L&lt;/code&gt;文字目から&lt;code&gt;R&lt;/code&gt;文字目までの変化量の総和がその文字列の長さ&lt;code&gt;-1&lt;/code&gt;であることになります。&lt;br /&gt;
例えば、&lt;code&gt;6&lt;/code&gt;文字の良い文字列の&lt;code&gt;010101&lt;/code&gt;の変化量は&lt;code&gt;5&lt;/code&gt;となり、&lt;code&gt;6&lt;/code&gt;文字の良い文字列ではない&lt;code&gt;011010&lt;/code&gt;の変化量は&lt;code&gt;4&lt;/code&gt;となります。&lt;br /&gt;
ある範囲を反転させるということは、&lt;code&gt;L-1&lt;/code&gt;文字目と&lt;code&gt;L&lt;/code&gt;文字目の変化量が&lt;code&gt;1-元の変化量&lt;/code&gt;になり、&lt;code&gt;L&lt;/code&gt;文字目から&lt;code&gt;R&lt;/code&gt;文字目の変化量は変わらず、&lt;code&gt;R&lt;/code&gt;文字目から&lt;code&gt;R+1&lt;/code&gt;文字目の変化量が&lt;code&gt;1-元の変化量&lt;/code&gt;になります。&lt;br /&gt;
よって、一点更新区間和の&lt;code&gt;SegmentTree&lt;/code&gt;を使って変化量を管理することで、クエリ当たり時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToArray();
    var A = new int[N - 1];

    var st = new SegmentTree&amp;lt;int&amp;gt;(N + 1, new Oracle());
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        st.Set(i + 1, S[i] == S[i + 1] ? 0 : 1);
    }

    while (Q-- &amp;gt; 0)
    {
        var (t, l, r) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        if (t == 1)
        {
            st.Set(l - 1, 1 - st.Get(l - 1));
            st.Set(r, 1 - st.Get(r));
        }
        else
        {
            var answer = st.Query(l, r) == r - l;
            Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
        }
    }
}

public class Oracle : IOracle&amp;lt;int&amp;gt;
{
    public int IdentityElement =&amp;gt; 0;

    public int Operate(int a, int b)
    {
        return a + b;
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid IdentityElement { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public class SegmentTree&amp;lt;TMonoid&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly int _log;
    private readonly int _dataSize;

    public SegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid&amp;gt; oracle) : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public SegmentTree(int length, IOracle&amp;lt;TMonoid&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, oracle.IdentityElement);
    }

    public void Set(int index, TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        return _data[index + _dataSize];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        var (sml, smr) = (_oracle.IdentityElement, _oracle.IdentityElement);
        left += _dataSize;
        right += _dataSize;
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 341の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>