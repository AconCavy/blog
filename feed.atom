<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>https://aconcavy.github.io/blog</id>
	<title />
	<link rel="self" href="https://aconcavy.github.io/blog" />
	<rights>Copyright © 2020-2022 AconCavy</rights>
	<updated>2022-03-07T01:49:29Z</updated>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220305abc242</id>
		<title>ABC242</title>
		<link href="https://aconcavy.github.io/blog/posts/20220305abc242" />
		<updated>2022-03-06T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 242の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc242"&gt;https://atcoder.jp/contests/abc242&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29883827"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;それぞれどの条件に当てはまるかで確率を求めます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X &amp;lt;= A&lt;/code&gt;ならば確率は&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A+1 &amp;lt;= X &amp;lt;= B&lt;/code&gt; ならば確率は&lt;code&gt;C/(B-A)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B &amp;lt; X&lt;/code&gt;ならば確率は&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (A, B, C, X) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
var answer = 0d;
if (X &amp;lt;= A) answer = 1d;
if (A + 1 &amp;lt;= X &amp;amp;&amp;amp; X &amp;lt;= B) answer = (double)C / (B - A);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29869226"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書順最小となる文字列は、文字列&lt;code&gt;S&lt;/code&gt;を構成する文字のうち、小さいものを左から順に並べたものになります。
そのため、文字列&lt;code&gt;S&lt;/code&gt;をソートした文字列が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
Array.Sort(S);
var answer = new string(S);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29875962"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;動的計画法で答えとなる個数を数え上げます。
初期値として、1桁目は&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;である個数をそれぞれ&lt;code&gt;1&lt;/code&gt;とします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;桁目の数値が&lt;code&gt;j&lt;/code&gt;のとき、&lt;code&gt;i+1&lt;/code&gt;桁目には、&lt;code&gt;j-1&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;j+1&lt;/code&gt;に遷移することができます。
&lt;code&gt;N&lt;/code&gt;桁目まで確定したときの、&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;までの個数の和が答えとなります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数え上げのときに&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;10&lt;/code&gt;に遷移できるスペースを確保しておくと、&lt;code&gt;j=0&lt;/code&gt;の時の&lt;code&gt;j-1&lt;/code&gt;の遷移と&lt;code&gt;j=9&lt;/code&gt;のときの&lt;code&gt;j+1&lt;/code&gt;で&lt;code&gt;if&lt;/code&gt;文が不要になります。
&lt;code&gt;mint&lt;/code&gt;は、&lt;code&gt;Mod&lt;/code&gt;として指定した数値で余りをとった整数をもつ構造体です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var dp = new mint[N + 1, 11];
for (var i = 1; i &amp;lt; 10; i++)
{
    dp[1, i] = 1;
}

for (var i = 1; i &amp;lt; N; i++)
{
    for (var j = 1; j &amp;lt; 10; j++)
    {
        dp[i + 1, j - 1] += dp[i, j];
        dp[i + 1, j] += dp[i, j];
        dp[i + 1, j + 1] += dp[i, j];
    }
}

mint answer = 0;
for (var i = 1; i &amp;lt; 10; i++)
{
    answer += dp[N, i];
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29901915"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t=0&lt;/code&gt;ならば、&lt;code&gt;S[k]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k=0&lt;/code&gt;ならば、&lt;code&gt;S[0]+t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&amp;gt;60&lt;/code&gt;ならば、&lt;code&gt;S[0]&lt;/code&gt;から派生したところになりそう。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&amp;gt;0&lt;/code&gt;かつ&lt;code&gt;k&amp;gt;0&lt;/code&gt;のときの周期は?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説では、&lt;code&gt;F(t,k)&lt;/code&gt;となる文字は、再帰的に求めることができるそうです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t=0&lt;/code&gt;ならば、&lt;code&gt;F(t,k)=S[k]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k=0&lt;/code&gt;ならば、&lt;code&gt;F(t,k)=S[0]+t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;それ以外ならば、&lt;code&gt;F(t,k)&lt;/code&gt;=&lt;code&gt;F(t-1,k/2)+k%2+1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;F&lt;/code&gt;は&lt;code&gt;O(logk)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();
var N = S.Length;
var Q = Scanner.Scan&amp;lt;int&amp;gt;();
while (Q-- &amp;gt; 0)
{
    var (t, k) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answer = F(t, k - 1);
    Console.WriteLine(answer);
}

char G(char c, long d)
{
    return (char)((c - 'A' + d) % 3 + 'A');
}

char F(long t, long k)
{
    if (t == 0) return S[(int)k];
    if (k == 0) return G(S[0], t);
    return G(F(t - 1, k / 2), k % 2 + 1);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc242/tasks/abc242_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC242/submissions/29902510"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書順で文字列&lt;code&gt;S&lt;/code&gt;以下の文字列を考えます。
回文のため、文字列&lt;code&gt;S&lt;/code&gt;の前半分の文字列&lt;code&gt;S'&lt;/code&gt;において、&lt;code&gt;S'&lt;/code&gt;未満の個数を数え上げを行います。
この数え上げは、&lt;code&gt;S'&lt;/code&gt;の文字をそれぞれ&lt;code&gt;0-25&lt;/code&gt;の26進数としたときの個数として数え上げることができます。
また、文字列&lt;code&gt;S&lt;/code&gt;の前半分を回文にした文字列を&lt;code&gt;T&lt;/code&gt;としたとき、&lt;code&gt;S&lt;/code&gt;以下ならば、答えを1増やします。&lt;/p&gt;
&lt;p&gt;例えば、&lt;code&gt;S=ABCDE&lt;/code&gt;ならば、&lt;code&gt;S'=ABC&lt;/code&gt;なので、前半の数え上げは&lt;code&gt;26^2*0 + 26^1*1 + 26^0*2 = 28&lt;/code&gt;となり、&lt;code&gt;T=ABCBA&amp;lt;=S&lt;/code&gt;なので答えは&lt;code&gt;29&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var Q = Scanner.Scan&amp;lt;int&amp;gt;();
while (Q-- &amp;gt; 0)
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = S.ToCharArray();

    for (var i = 0; i &amp;lt; (N + 1) / 2; i++)
    {
        T[N - 1 - i] = T[i];
    }

    mint answer = 0;
    for (var i = 0; i &amp;lt; (N + 1) / 2; i++)
    {
        answer *= 26;
        answer += T[i] - 'A';
    }

    if (new string(T).CompareTo(S) &amp;lt;= 0) answer++;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 242の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220226abc241</id>
		<title>ABC241</title>
		<link href="https://aconcavy.github.io/blog/posts/20220226abc241" />
		<updated>2022-02-27T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 241の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241"&gt;https://atcoder.jp/contests/abc241&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29662070"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在の値を&lt;code&gt;curr&lt;/code&gt;とし、現在の値を&lt;code&gt;A[curr]&lt;/code&gt;で更新します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var curr = 0;
for (var i = 0; i &amp;lt; 3; i++)
{
    curr = A[curr];
}

Console.WriteLine(curr);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29664697"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あらかじめ麵の長さ&lt;code&gt;A&lt;/code&gt;の個数を辞書に持ち、&lt;code&gt;B&lt;/code&gt;を順番に見たときに、1個以上ある場合は辞書の&lt;code&gt;B&lt;/code&gt;の値をデクリメントし、0個または辞書に存在しない場合は答えは&lt;code&gt;No&lt;/code&gt;になります。最終的にすべてを見ることができれば、答えは&lt;code&gt;Yes&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;int, int&amp;gt;();
foreach (var a in A)
{
    if (!dict.ContainsKey(a))
    {
        dict[a] = 0;
    }

    dict[a]++;
}

foreach (var b in B)
{
    if (!dict.ContainsKey(b) || dict[b] == 0)
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
        return;
    }

    dict[b]--;
}

Console.WriteLine(&amp;quot;Yes&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29675472"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;マスを順にみて、端を&lt;code&gt;(i,j)&lt;/code&gt;に固定したときに連続した区間のうち4つ以上&lt;code&gt;#&lt;/code&gt;が存在すれば、答えは&lt;code&gt;Yes&lt;/code&gt;となります。
縦の場合は&lt;code&gt;(i,j)&lt;/code&gt;から&lt;code&gt;(i+5,j)&lt;/code&gt;まで、横の場合は&lt;code&gt;(i,j)&lt;/code&gt;から&lt;code&gt;(i,j+5)&lt;/code&gt;まで、斜めの場合は&lt;code&gt;(i,j)&lt;/code&gt;から&lt;code&gt;(i+5,j+5)&lt;/code&gt;と&lt;code&gt;(i+5,j-5)&lt;/code&gt;を確かめます。
検査時に範囲外に出ないように注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var G = new string[N];
for (var i = 0; i &amp;lt; N; i++)
{
    G[i] = Scanner.ScanLine();
}

for (var i = 0; i &amp;lt; N; i++)
{
    for (var j = 0; j &amp;lt; N; j++)
    {
        var ok = false;
        if (i + 5 &amp;lt; N)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i + k][j] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (j + 5 &amp;lt; N)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i][j + k] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (i + 5 &amp;lt; N &amp;amp;&amp;amp; j + 5 &amp;lt; N)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i + k][j + k] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (i + 5 &amp;lt; N &amp;amp;&amp;amp; j - 5 &amp;gt;= 0)
        {
            var count = 0;
            for (var k = 0; k &amp;lt;= 5; k++)
            {
                if (G[i + k][j - k] == '#') count++;
            }

            ok |= count &amp;gt;= 4;
        }

        if (ok)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }

    }
}

Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29715030"&gt;復習提出 (FenwickTree)&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/abc241/submissions/29716771"&gt;復習提出 (平衡二分探索木)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FenwickTree&lt;/code&gt;を使った場合の解き方です。
&lt;code&gt;x&lt;/code&gt;の値が大きいので、あらかじめクエリを先読みし、出現する座標を圧縮します。
圧縮した&lt;code&gt;x&lt;/code&gt;の値を&lt;code&gt;cx&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が1であれば、&lt;code&gt;FenwickTree&lt;/code&gt;の&lt;code&gt;cx&lt;/code&gt;に1を追加します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が2であれば、&lt;code&gt;FenwickTree&lt;/code&gt;の区間&lt;code&gt;[idx, cx]&lt;/code&gt;の値が&lt;code&gt;k&lt;/code&gt;以上の場所を二部探索し、存在するならばその時の&lt;code&gt;idx&lt;/code&gt;の対応する値が答えとなります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が2であれば、&lt;code&gt;FenwickTree&lt;/code&gt;の区間&lt;code&gt;[cx, idx]&lt;/code&gt;の値が&lt;code&gt;k&lt;/code&gt;以上の場所を二部探索し、存在するならばその時の&lt;code&gt;idx&lt;/code&gt;の対応する値が答えとなります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var Q = Scanner.Scan&amp;lt;int&amp;gt;();
var query = new (int, long, int)[Q];
var set = new HashSet&amp;lt;long&amp;gt;();
for (var i = 0; i &amp;lt; Q; i++)
{
    var line = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var (t, x) = ((int)line[0], line[1]);
    var k = t == 1 ? -1 : (int)line[2];
    query[i] = (t, x, k);
    set.Add(x);
}
 
var (map, remap) = Compress(set);
var N = map.Count;
var ft = new FenwickTree(N);
foreach (var (t, x, k) in query)
{
    if (t == 1)
    {
        ft.Add(map[x], 1);
    }
    else if (t == 2)
    {
        bool F(int idx) =&amp;gt; ft.Sum(idx, map[x] + 1) &amp;gt;= k;
        var idx = BinarySearch(map[x] + 1, 0, F);
        var answer = F(idx) ? remap[idx] : -1;
        Console.WriteLine(answer);
    }
    else
    {
        bool F(int idx) =&amp;gt; ft.Sum(map[x], idx + 1) &amp;gt;= k;
        var idx = BinarySearch(map[x] - 1, N - 1, F);
        var answer = F(idx) ? remap[idx] : -1;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static int BinarySearch(int ng, int ok, Func&amp;lt;int, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }

    return ok;
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }

    return (map, remap);
}

public class FenwickTree
{
    private readonly long[] _data;
    private readonly int _length;

    public FenwickTree(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        _length = length;
        _data = new long[length];
    }

    public void Add(int index, long item)
    {
        if (index &amp;lt; 0 || _length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index++;
        while (index &amp;lt;= _length)
        {
            _data[index - 1] += item;
            index += index &amp;amp; -index;
        }
    }

    public long Sum(int length)
    {
        if (length &amp;lt; 0 || _length &amp;lt; length) throw new ArgumentOutOfRangeException(nameof(length));
        var s = 0L;
        while (length &amp;gt; 0)
        {
            s += _data[length - 1];
            length -= length &amp;amp; -length;
        }

        return s;
    }

    public long Sum(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || _length &amp;lt; right) throw new ArgumentOutOfRangeException();
        return Sum(right) - Sum(left);
    }

    public int LowerBound(long item) =&amp;gt; CommonBound(item, LessThanOrEqual);
    public int UpperBound(long item) =&amp;gt; CommonBound(item, LessThan);

    private int CommonBound(long item, Func&amp;lt;long, long, bool&amp;gt; compare)
    {
        if (compare(item, _data[0])) return 0;
        var x = 0;
        var r = 1;
        while (r &amp;lt; _length) r &amp;lt;&amp;lt;= 1;
        for (var k = r; k &amp;gt; 0; k &amp;gt;&amp;gt;= 1)
        {
            if (x + k - 1 &amp;gt;= _length || compare(item, _data[x + k - 1])) continue;
            item -= _data[x + k - 1];
            x += k;
        }

        return x;
    }

    private static bool LessThanOrEqual(long x, long y) =&amp;gt; x &amp;lt;= y;
    private static bool LessThan(long x, long y) =&amp;gt; x &amp;lt; y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;平衡二分探索木を使った時の解き方です。
C#では&lt;code&gt;MultiSet&lt;/code&gt;が存在しないので、平衡二分探索木を自作する必要があります。
降順、昇順の平衡二分探索木を用意し、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が1であれば、両方の平衡二分探索木に&lt;code&gt;x&lt;/code&gt;を追加します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が2であれば、降順の平衡二分探索木において&lt;code&gt;x&lt;/code&gt;以上になるインデックス&lt;code&gt;(idx)&lt;/code&gt;を取得し、&lt;code&gt;idx+k-1&lt;/code&gt;となる値が存在するならば、その値が答えとなります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;の値が3であれば、昇順の平衡二分探索木において、&lt;code&gt;x&lt;/code&gt;以下になるインデックス&lt;code&gt;(idx)&lt;/code&gt;を取得し、&lt;code&gt;idx+k-1&lt;/code&gt;となる値が存在するならば、その値が答えとなります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var Q = Scanner.Scan&amp;lt;int&amp;gt;();
var asc = new RandomizedBinarySearchTree&amp;lt;long&amp;gt;();
var desc = new RandomizedBinarySearchTree&amp;lt;long&amp;gt;((x, y) =&amp;gt; y.CompareTo(x));

while (Q-- &amp;gt; 0)
{
    var line = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var (t, x) = (line[0], line[1]);
    if (t == 1)
    {
        asc.Insert(x);
        desc.Insert(x);
    }
    else
    {
        var k = (int)line[2] - 1;
        var set = t == 2 ? desc : asc;
        if (set.Count() == 0)
        {
            Console.WriteLine(-1);
            continue;
        }
        var lb = set.LowerBound(x);
        var answer = lb + k &amp;lt; set.Count() ? set.ElementAt(lb + k) : -1;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次のような平衡二分探索木を使用しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class RandomizedBinarySearchTree&amp;lt;T&amp;gt; : IEnumerable&amp;lt;T&amp;gt;
{
    private readonly Comparison&amp;lt;T&amp;gt; _comparison;
    private readonly Compare _lowerBound;
    private readonly Compare _upperBound;
    private readonly Random _random;

    private Node _root;
    private int _count;

    public RandomizedBinarySearchTree(int seed = 0) : this(comparer: null, seed) { }

    public RandomizedBinarySearchTree(Comparer&amp;lt;T&amp;gt; comparer, int seed = 0) : this(
        (comparer ?? Comparer&amp;lt;T&amp;gt;.Default).Compare, seed)
    {
    }

    public RandomizedBinarySearchTree(Comparison&amp;lt;T&amp;gt; comparison, int seed = 0)
    {
        _comparison = comparison;
        _lowerBound = (x, y) =&amp;gt; _comparison(x, y) &amp;gt;= 0;
        _upperBound = (x, y) =&amp;gt; _comparison(x, y) &amp;gt; 0;
        _random = new Random(seed);
    }

    public delegate bool Compare(T x, T y);

    public void Insert(T value)
    {
        if (_root is null) _root = new Node(value);
        else InsertAt(LowerBound(value), value);
    }

    public void InsertAt(int index, T value)
    {
        var (l, r) = Split(_root, index);
        _root = Merge(Merge(l, new Node(value)), r);
    }

    public void Erase(T value)
    {
        EraseAt(LowerBound(value));
    }

    public void EraseAt(int index)
    {
        var (l, r1) = Split(_root, index);
        var (_, r2) = Split(r1, 1);
        _root = Merge(l, r2);
    }

    public T ElementAt(int index)
    {
        if (index &amp;lt; 0 || Count(_root) &amp;lt;= index) throw new ArgumentNullException(nameof(index));
        var node = _root;
        var idx = Count(node) - Count(node.R) - 1;
        while (node is { })
        {
            if (idx == index) return node.Value;
            if (idx &amp;gt; index)
            {
                node = node.L;
                idx -= Count(node?.R) + 1;
            }
            else
            {
                node = node.R;
                idx += Count(node?.L) + 1;
            }
        }

        throw new ArgumentOutOfRangeException(nameof(index));
    }

    public bool Contains(T value)
    {
        return Find(value) is { };
    }

    public int Count() =&amp;gt; Count(_root);

    public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; Enumerate(_root).GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();

    public int UpperBound(T value) =&amp;gt; CommonBound(value, _upperBound);
    public int LowerBound(T value) =&amp;gt; CommonBound(value, _lowerBound);

    public int CommonBound(T value, Compare compare)
    {
        var node = _root;
        if (node is null) return -1;
        var bound = Count(node);
        var idx = bound - Count(node.R) - 1;
        while (node is { })
        {
            if (compare(node.Value, value))
            {
                node = node.L;
                bound = Math.Min(bound, idx);
                idx -= Count(node?.R) + 1;
            }
            else
            {
                node = node.R;
                idx += Count(node?.L) + 1;
            }
        }

        return bound;
    }

    private double GetProbability() =&amp;gt; _random.NextDouble();

    private Node Merge(Node l, Node r)
    {
        if (l is null || r is null) return l ?? r;
        var (n, m) = (Count(l), Count(r));
        if ((double)n / (n + m) &amp;gt; GetProbability())
        {
            l.R = Merge(l.R, r);
            return l;
        }
        else
        {
            r.L = Merge(l, r.L);
            return r;
        }
    }

    private (Node, Node) Split(Node node, int k)
    {
        if (node is null) return (null, null);

        if (k &amp;lt;= Count(node.L))
        {
            var (l, r) = Split(node.L, k);
            node.L = r;
            return (l, node);
        }
        else
        {
            var (l, r) = Split(node.R, k - Count(node.L) - 1);
            node.R = l;
            return (node, r);
        }
    }

    private Node Find(T value)
    {
        var node = _root;
        while (node is { })
        {
            var cmp = _comparison(node.Value, value);
            if (cmp &amp;gt; 0) node = node.L;
            else if (cmp &amp;lt; 0) node = node.R;
            else break;
        }

        return node;
    }

    private static int Count(Node node) =&amp;gt; node?.Count ?? 0;

    private static IEnumerable&amp;lt;T&amp;gt; Enumerate(Node node = null)
    {
        if (node is null) yield break;
        foreach (var value in Enumerate(node.L)) yield return value;
        yield return node.Value;
        foreach (var value in Enumerate(node.R)) yield return value;
    }

    private class Node
    {
        public T Value { get; }

        public Node L
        {
            get =&amp;gt; _l;
            set
            {
                _l = value;
                UpdateCount();
            }
        }

        public Node R
        {
            get =&amp;gt; _r;
            set
            {
                _r = value;
                UpdateCount();
            }
        }

        public int Count { get; private set; }

        private Node _l;
        private Node _r;

        public Node(T value)
        {
            Value = value;
            Count = 1;
        }

        private void UpdateCount()
        {
            Count = (L?.Count ?? 0) + (R?.Count ?? 0) + 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc241/tasks/abc241_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc241/submissions/29701801"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mod&lt;/code&gt;の性質上、最大でも&lt;code&gt;N&lt;/code&gt;回でループすることがわかります。
そのため、答えは&lt;code&gt;(1回のループ中の和 * ループ回数) + (ループに入るまでの和 + ループの端数の和)&lt;/code&gt;で求めることができます。
実装としては、&lt;code&gt;idx&lt;/code&gt;のときの合計値と、&lt;code&gt;idx&lt;/code&gt;の時に&lt;code&gt;A&lt;/code&gt;の値を参照したことを保持しながら順にみていきます。
一度見たことがある&lt;code&gt;A&lt;/code&gt;を参照する場合、&lt;code&gt;現在の合計値 - 1度目のidxの合計値&lt;/code&gt;から1回のループ中の和がわかり、&lt;code&gt;2度目のidx - 1度目のidx&lt;/code&gt;からループの長さが求まり、&lt;code&gt;(K - 1度目のidx) / ループの長さ&lt;/code&gt;でループの回数がわかるので、&lt;code&gt;(1回のループ中の和 * ループ回数)&lt;/code&gt;を求めることができます。
また、&lt;code&gt;(K - 1度目のidx) % ループの長さ&lt;/code&gt;でループの端数となる残りの&lt;code&gt;idx&lt;/code&gt;を求めることができ、&lt;code&gt;一度目のidx + 残りのidx&lt;/code&gt;のときの合計値をみることで、&lt;code&gt;(ループに入るまでの和 + ループの端数の和)&lt;/code&gt;を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;int, int&amp;gt;();
var steps = new List&amp;lt;long&amp;gt;();

int F(long x) =&amp;gt; (int)(x % N);
var current = 0L;
for (var i = 0; i &amp;lt; K; i++)
{
    var x = F(current);
    if (dict.ContainsKey(x))
    {
        var noloop = dict[x];
        var loop = i - dict[x];
        var div = (K - noloop) / loop;
        current = (current - steps[noloop]) * div;
        var mod = (int)((K - noloop) % loop);
        if (mod &amp;lt; 0) mod += loop;
        current += steps[noloop + mod];
        break;
    }

    dict[x] = i;
    steps.Add(current);
    current += A[x];
}

Console.WriteLine(current);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 241の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220220abc240</id>
		<title>ABC240</title>
		<link href="https://aconcavy.github.io/blog/posts/20220220abc240" />
		<updated>2022-02-20T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 240の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240"&gt;https://atcoder.jp/contests/abc240&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29503598"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10で割ったときのあまりの値を比較することで、ループを再現することができます。
また、隣り合っていることは差が1であればいいので、それを確かめます。
例えば、&lt;code&gt;a=2, b=3&lt;/code&gt;のときは、&lt;code&gt;2+1==3&lt;/code&gt;となり、&lt;code&gt;a=1,b=10&lt;/code&gt;の時は&lt;code&gt;1==0+1&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var answer = (A + 1) % 10 == B % 10 || (B + 1) % 10 == A % 10;
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29506402"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重複を削除したときの個数が答えとなります。
C#のLINQには、&lt;code&gt;Distinct&lt;/code&gt;というシーケンス内の重複を除いたシーケンスを返すメソッドがあるため、それを使い個数を数えます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var answer = A.Distinct().Count();
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29511865"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;動的計画法で答えを求めます。
&lt;code&gt;i&lt;/code&gt;番目のジャンプを座標&lt;code&gt;j(0&amp;lt;=j&amp;lt;=X)&lt;/code&gt;から行うと、&lt;code&gt;i+1&lt;/code&gt;番目では、&lt;code&gt;j+a&lt;/code&gt;または&lt;code&gt;j+b&lt;/code&gt;に存在することができます。初期状態の&lt;code&gt;0&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;としたとき、そこからの遷移を計算し、&lt;code&gt;N&lt;/code&gt;回ジャンプ後の&lt;code&gt;X&lt;/code&gt;の値が&lt;code&gt;true&lt;/code&gt;ならば存在することができると表現できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var dp = new bool[N + 1, X + 1];
dp[0, 0] = true;
for (var i = 0; i &amp;lt; N; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    for (var j = 0; j &amp;lt;= X; j++)
    {
        if (j + a &amp;lt;= X) dp[i + 1, j + a] |= dp[i, j];
        if (j + b &amp;lt;= X) dp[i + 1, j + b] |= dp[i, j];
    }
}

var answer = dp[N, X];
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29521922"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スタックに順番にボールを追加していき、同じ数字がK個連続した場合は削除する操作を行います。このとき一つの数字につき1つの値を入れていると、計算量は&lt;code&gt;O(N^2)&lt;/code&gt;になってしまうので、連続した値は値と個数の一つのオブジェクトとしてまとめ、スタックに入っているボールの個数を管理することで、計算量を&lt;code&gt;O(N)&lt;/code&gt;に抑えることができます。
具体的には、もしスタックが空またはスタックのトップと異なる値の場合は、値と個数1をタプルとしてまとめてスタックに追加し、もしスタックのトップと同じ値の場合は、スタックのトップの個数を更新します。その後、スタックのトップを順にみていき、値と個数が同じ場合はスタックから取り除き、現在の個数も減少させます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var curr = 0;
var stack = new Stack&amp;lt;(int V, int C)&amp;gt;();
foreach (var a in A)
{
    curr++;
    if (stack.Count == 0)
    {
        stack.Push((a, 1));
        Console.WriteLine(curr);
        continue;
    }

    var (v, c) = stack.Pop();

    if (a == v)
    {
        c++;
        stack.Push((v, c));
    }
    else
    {
        stack.Push((v, c));
        stack.Push((a, 1));
    }

    while (stack.Count &amp;gt; 0)
    {
        (v, c) = stack.Peek();
        if (v == c)
        {
            stack.Pop();
            curr -= c;
        }
        else
        {
            break;
        }
    }

    Console.WriteLine(curr);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc240/tasks/abc240_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc240/submissions/29533033"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文の根付き木について、子を持たない頂点に対してそれぞれ異なる値を与えたときに、部分木&lt;code&gt;i&lt;/code&gt;が持つ値群の最小値と最大値をそれぞれ&lt;code&gt;Li&lt;/code&gt;と&lt;code&gt;Ri&lt;/code&gt;としたとき、頂点&lt;code&gt;i&lt;/code&gt;は区間&lt;code&gt;[Li, Ri]&lt;/code&gt;を持つと解釈することができます。
そのため、深さ優先探索を行い、子を持たない頂点の場合はそれまでに出現していない値を&lt;code&gt;Li&lt;/code&gt;と&lt;code&gt;Ri&lt;/code&gt;に設定し、子を持つ頂点は、子の&lt;code&gt;Li&lt;/code&gt;と&lt;code&gt;Ri&lt;/code&gt;の中でそれぞれ最小、最大となるものを選択することで、答えとなる区間を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; N - 1; i++)
{
    var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    u--; v--;
    G[u].Add(v);
    G[v].Add(u);
}

const int inf = (int)1e9;
var L = new int[N];
var R = new int[N];
var curr = 1;
(int L, int R) Dfs(int u, int p)
{
    var l = inf;
    var r = -inf;
    foreach (var v in G[u])
    {
        if (v == p) continue;
        var (ll, rr) = Dfs(v, u);
        l = Math.Min(l, ll);
        r = Math.Max(r, rr);
    }

    if (l == inf)
    {
        L[u] = curr;
        R[u] = curr;
        curr++;
    }
    else
    {
        L[u] = l;
        R[u] = r;
    }

    return (L[u], R[u]);
}

Dfs(0, -1);

foreach (var (l, r) in L.Zip(R))
{
    Console.WriteLine($&amp;quot;{l} {r}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 240の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220219abc239</id>
		<title>ABC239</title>
		<link href="https://aconcavy.github.io/blog/posts/20220219abc239" />
		<updated>2022-02-20T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 239の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc239"&gt;https://atcoder.jp/contests/abc239&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc239/tasks/abc239_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC239/submissions/29426523"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与えられた計算式に入力のHを与えたときの答えを求めます。
&lt;code&gt;int&lt;/code&gt;だと&lt;code&gt;x * (12800000 + x)&lt;/code&gt;の計算でオーバーフローしてしまうので、&lt;code&gt;long&lt;/code&gt;で取ることに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var H = Scanner.Scan&amp;lt;long&amp;gt;();
double F(long x) =&amp;gt; Math.Sqrt(x * (12800000 + x));
Console.WriteLine(F(H));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc239/tasks/abc239_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC239/submissions/29432159"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&amp;gt;=0&lt;/code&gt;のときはそのまま&lt;code&gt;X/10&lt;/code&gt;で切り捨てを求め、&lt;code&gt;X&amp;lt;0&lt;/code&gt;のときは&lt;code&gt;-X/10&lt;/code&gt;の切り上げた数の&lt;code&gt;-&lt;/code&gt;を考えればいいです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var X = Scanner.Scan&amp;lt;long&amp;gt;();
var answer = X &amp;gt;= 0 ? X / 10 : -(-X + 9) / 10;
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc239/tasks/abc239_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC239/submissions/29441499"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一つの点に対して、&lt;code&gt;abs(dx)+abs(dy)==3&lt;/code&gt;となる格子点は8つのみであり、それぞれの点の組み合わせのうち、一致する点があるかを全探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (x1, y1, x2, y2) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();

var D = new[] { (-2, 1), (-2, -1), (-1, 2), (-1, -2), (1, 2), (1, -2), (2, 1), (2, -1) };
var answer = false;
foreach (var (dx1, dy1) in D)
{
    var (xx1, yy1) = (x1 + dx1, y1 + dy1);
    foreach (var (dx2, dy2) in D)
    {
        var (xx2, yy2) = (x2 + dx2, y2 + dy2);
        answer |= xx1 == xx2 &amp;amp;&amp;amp; yy1 == yy2;
    }
}

Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc239/tasks/abc239_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC239/submissions/29446892"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;200までの素数を作ることができるかを考えると、&lt;code&gt;{200以下の任意の素数}-{高橋君の選んだ素数}&lt;/code&gt;となる整数を青木君は選ぶことで素数を作ることができます。そのため、高橋君の整数を固定し、200以下の素数をすべて見たときに青木君が選ぶことのできる整数が存在するかを判定します。もし青木君が素数を作るための整数を1つでも選ぶことができなければ、高橋君の勝利となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (A, B, C, D) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
var P = Prime.Sieve(200);
var answer = false;
for (var i = A; i &amp;lt;= B; i++)
{
    var exist = false;
    foreach (var p in P)
    {
        var j = p - i;
        exist |= C &amp;lt;= j &amp;amp;&amp;amp; j &amp;lt;= D;
    }

    answer |= !exist;
}
Console.WriteLine(answer ? &amp;quot;Takahashi&amp;quot; : &amp;quot;Aoki&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Prime.Sieve(200)&lt;/code&gt;は、与えられた数以下の素数群を返す関数です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Prime
{
    public static IEnumerable&amp;lt;int&amp;gt; Sieve(int value)
    {
        if (value &amp;lt; 2) yield break;
        yield return 2;
        var sieve = new bool[(value + 1) / 2];
        for (var i = 1; i &amp;lt; sieve.Length; i++)
        {
            if (sieve[i]) continue;
            yield return i * 2 + 1;
            for (var j = i; j &amp;lt; sieve.Length; j += i * 2 + 1) sieve[j] = true;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc239/tasks/abc239_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC239/submissions/29456696"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに部分木を計算すると、計算量が&lt;code&gt;O(N^2)&lt;/code&gt;でになってしまうので、あらかじめ部分木のうちで対象となりうる要素を保持しておくことを考えます。
しかし、部分木のすべての数を保持してしまうと、全体で最悪&lt;code&gt;N*(N-1)/2&lt;/code&gt;個の要素が存在し、ソートも考えると計算量が&lt;code&gt;O(N^2log(N^2))&lt;/code&gt;でTLEになってしまうので、保持する要素を制限することを考えます。制約の、&lt;code&gt;1 &amp;lt;= Ki &amp;lt;= 20&lt;/code&gt;から、各頂点で対象となる数は、最大でも20個ということがわかります。また、木Bが木Aの部分木のとき、木Bの大きいほうから21番目以降の要素は、木Aにおいても21番目以降であるため、21番目以降の要素は無視することができます。このことから、深さ優先探索を行って部分木を見たときに、部分木の要素のうち、降順で最大20個ずつ保持して行くことで、計算量を&lt;code&gt;O(Nlog(N))&lt;/code&gt;に抑えることができ、各クエリ当たり&lt;code&gt;O(1)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var X = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; N - 1; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--; b--;
    G[a].Add(b);
    G[b].Add(a);
}

var list = new List&amp;lt;int&amp;gt;[N].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();

void Dfs(int u, int p)
{
    foreach (var v in G[u])
    {
        if (v == p) continue;
        Dfs(v, u);
        foreach (var x in list[v])
        {
            list[u].Add(x);
        }
    }

    list[u].Add(X[u]);
    list[u].Sort();
    list[u].Reverse();
    list[u] = list[u].Take(20).ToList();
}

Dfs(0, -1);

for (var i = 0; i &amp;lt; Q; i++)
{
    var (v, k) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    v--; k--;
    Console.WriteLine(list[v][k]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc239/tasks/abc239_f"&gt;問題F&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC239/submissions/29479750"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;N-1&lt;/code&gt;本の高速道路なら、Dの合計が&lt;code&gt;(N-1)*2&lt;/code&gt;以外は&lt;code&gt;-1&lt;/code&gt;になりそう。&lt;/li&gt;
&lt;li&gt;連結じゃないところを優先して繋げる?&lt;/li&gt;
&lt;li&gt;連結成分ごとの&lt;code&gt;D&lt;/code&gt;の合計が多いところを優先して繋げる?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説でも同様の考え方でした。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;連結させた場合に&lt;code&gt;D&lt;/code&gt;が変化するから&lt;code&gt;PriorityQueue&lt;/code&gt;で&lt;code&gt;D&lt;/code&gt;の合計が多い物を優先する。&lt;/li&gt;
&lt;li&gt;連結したものは一つの&lt;code&gt;queue&lt;/code&gt;にまとめる。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var D = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
if (D.Sum() != (N - 1) * 2)
{
    Console.WriteLine(-1);
    return;
}

var dsu = new DisjointSetUnion(N);
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--;
    b--;
    G[a].Add(b);
    G[b].Add(a);
    dsu.Merge(a, b);
    D[a]--;
    D[b]--;
}

var answers = new List&amp;lt;(int, int)&amp;gt;();
var queue = new PriorityQueue&amp;lt;(Queue&amp;lt;int&amp;gt; U, long M)&amp;gt;((x, y) =&amp;gt; y.M.CompareTo(x.M));
foreach (var group in dsu.GetGroups())
{
    var q = new Queue&amp;lt;int&amp;gt;(group.Where(x =&amp;gt; D[x] &amp;gt; 0));
    var s = group.Sum(x =&amp;gt; D[x]);
    if (q.Count == 0)
    {
        Console.WriteLine(-1);
        return;
    }

    queue.Enqueue((q, s));
}

while (queue.Count &amp;gt;= 2)
{
    var (uq, us) = queue.Dequeue();
    var (vq, vs) = queue.Dequeue();
    var u = uq.Dequeue();
    var v = vq.Dequeue();
    D[u]--;
    D[v]--;
    us--;
    vs--;
    dsu.Merge(u, v);
    answers.Add((u + 1, v + 1));
    if (D[u] &amp;gt; 0) uq.Enqueue(u);
    if (D[v] &amp;gt; 0) vq.Enqueue(v);

    if (us &amp;gt;= vs)
    {
        while (vq.Count &amp;gt; 0) uq.Enqueue(vq.Dequeue());
        us += vs;
        queue.Enqueue((uq, us));
    }
    else
    {
        while (uq.Count &amp;gt; 0) vq.Enqueue(uq.Dequeue());
        vs += us;
        queue.Enqueue((vq, vs));
    }
}

for (var i = 0; i &amp;lt; N; i++)
{
    for (var j = i + 1; j &amp;lt; N; j++)
    {
        if (D[i] == 0) break;
        if (D[j] == 0) continue;
        D[i]--;
        D[j]--;
        answers.Add((i + 1, j + 1));
    }
}

if (D.Any(x =&amp;gt; x != 0))
{
    Console.WriteLine(-1);
    return;
}

foreach (var (u, v) in answers)
{
    Console.WriteLine($&amp;quot;{u} {v}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 239の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220205abc238</id>
		<title>ABC238</title>
		<link href="https://aconcavy.github.io/blog/posts/20220205abc238" />
		<updated>2022-02-06T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 238の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC238"&gt;https://atcoder.jp/contests/ABC238&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/ABC238/tasks/ABC238_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC238/submissions/29069118"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;が1または5以上の時、答えは&lt;code&gt;Yes&lt;/code&gt;になります。
また、2の&lt;code&gt;N&lt;/code&gt;乗を計算可能な大きさに丸めてから、実際に計算することでも求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
N = Math.Min(60, N);
var answer = (1L &amp;lt;&amp;lt; N) &amp;gt; N * N;
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/ABC238/tasks/ABC238_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC238/submissions/29078455"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在のナイフの角度を持ちながら、それぞれの切れ込みの角度を計算します。360度を超える場合はx+360度と同じ角度なので、360で余りを取ります。すべての切れ込みをソートし、各切れ込みの差分の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var list = new List&amp;lt;int&amp;gt; { 0 };
var curr = 0;
foreach (var a in A)
{
    list.Add((curr + a) % 360);
    curr += a;
    curr %= 360;
}
list.Add(360);
list.Sort();
var answer = 0;
for (var i = 0; i + 1 &amp;lt; list.Count; i++)
{
    answer = Math.Max(answer, list[i + 1] - list[i]);
}
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/ABC238/tasks/ABC238_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC238/submissions/29087110"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;f(x)&lt;/code&gt;を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができても、Nまで愚直に数え上げると時間計算量&lt;code&gt;O(N)&lt;/code&gt;かかり、制約に間に合いません。
それぞれの桁数の時の個数の和を求めます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1からnまでの総和は&lt;code&gt;n * (n+1) / 2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;桁の数字個数は&lt;code&gt;10^d - 10^(d-1)&lt;/code&gt;個存在する。(2桁の場合は、&lt;code&gt;10^2 - 10^1&lt;/code&gt;で90個)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt;と同じ桁の場合は&lt;code&gt;N - 10^(d-1) + 1&lt;/code&gt;個存在する。(16の場合は、&lt;code&gt;16 - 10^(2-1) + 1&lt;/code&gt;で7個)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上を踏まえて、&lt;code&gt;N&lt;/code&gt;と同じ桁数まで数え上げることで、時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
mint answer = 0;
mint i2 = mint.Inverse(2);
mint F(long x) =&amp;gt; (mint)x * (x + 1) * i2;
var curr = 1L;
for (var l = 1; l &amp;lt;= 18 &amp;amp;&amp;amp; curr &amp;lt;= N; l++)
{
    curr *= 10;
    if (curr &amp;lt;= N)
    {
        var x = curr - curr / 10;
        answer += F(x);
    }
    else
    {
        var x = N - curr / 10 + 1;
        answer += F(x);
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/ABC238/tasks/ABC238_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC238/submissions/29094375"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ANDにより、&lt;code&gt;x &amp;gt;= a&lt;/code&gt;かつ&lt;code&gt;y &amp;gt;= a&lt;/code&gt;がわかり、&lt;code&gt;x &amp;lt;= y&lt;/code&gt;かつ&lt;code&gt;x = a&lt;/code&gt;としたとき、&lt;code&gt;y = a + b&lt;/code&gt;ということがわかります。
&lt;code&gt;s = x + y = a + a + b = 2a + b&lt;/code&gt;となり、&lt;code&gt;s - 2a = b&lt;/code&gt;が成り立つ&lt;code&gt;b&lt;/code&gt;の存在によって答えが求まります。
このとき、&lt;code&gt;y = a + b = a | b&lt;/code&gt;とすると、&lt;code&gt;b&lt;/code&gt;は&lt;code&gt;a&lt;/code&gt;の0のビットをいくつか1にしたものかつ&lt;code&gt;a&lt;/code&gt;の1のビットをすべて0にしたものになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var T = Scanner.Scan&amp;lt;int&amp;gt;();
while (T-- &amp;gt; 0)
{
    var (a, s) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var a2 = a + a;
    var answer = a2 &amp;lt;= s;
    var r = s - a2;
    if (r &amp;gt; 0)
    {
        for (var i = 0; i &amp;lt; 63; i++)
        {
            if ((r &amp;gt;&amp;gt; i &amp;amp; 1) == 1)
            {
                answer &amp;amp;= (a &amp;gt;&amp;gt; i &amp;amp; 1) == 0;
            }
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/ABC238/tasks/ABC238_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC238/submissions/29102881"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;すべてのAの走査回数が奇数? -&amp;gt; 例3で偽&lt;/li&gt;
&lt;li&gt;クエリを右増左減のソート後に区間最小が0の時に区間を1に更新して最後に区間すべてが1であれば正? -&amp;gt; 例1で偽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説では、累積和行列&lt;code&gt;B&lt;/code&gt;を考えたときに、クエリにより&lt;code&gt;l&lt;/code&gt;と&lt;code&gt;r&lt;/code&gt;が与えられた場合&lt;code&gt;B[r] - B[l]&lt;/code&gt;の値から&lt;code&gt;A[l]..A[r]&lt;/code&gt;の総和が求められるものとし、&lt;code&gt;l&lt;/code&gt;と&lt;code&gt;r&lt;/code&gt;をグラフの辺として考えたとき、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;まで連結であることを考えればいいようです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var dsu = new DisjointSetUnion(N + 1);
for (var i = 0; i &amp;lt; Q; i++)
{
    var (l, r) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    l--;
    dsu.Merge(l, r);
}
var answer = dsu.IsSame(0, N);
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 238の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220130abc237</id>
		<title>ABC237</title>
		<link href="https://aconcavy.github.io/blog/posts/20220130abc237" />
		<updated>2022-01-31T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 237の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237"&gt;https://atcoder.jp/contests/ABC237&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28899214"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#含めほとんどの言語では、&lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt;のようなビットシフト計算が備わっており、2の&lt;code&gt;x&lt;/code&gt;乗を表現することができます。
例えば、&lt;code&gt;1 &amp;lt;&amp;lt; 2&lt;/code&gt;は、1を2進数で表すと&lt;code&gt;1&lt;/code&gt;であり、2つ左にシフトすると&lt;code&gt;100&lt;/code&gt;になって、10進数では&lt;code&gt;4&lt;/code&gt;を表現します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
const long inf = 1L &amp;lt;&amp;lt; 31;
Console.WriteLine(-inf &amp;lt;= N &amp;amp;&amp;amp; N &amp;lt; inf ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28909504"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;転置行列は、&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目を&lt;code&gt;j&lt;/code&gt;行&lt;code&gt;i&lt;/code&gt;列目にしたものなので、そのまま添え字を入れ替えたものを結果として出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = new int[H, W];
for (var i = 0; i &amp;lt; H; i++)
{
    var AA = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var j = 0; j &amp;lt; W; j++)
    {
        A[i, j] = AA[j];
    }
}

var B = new int[W, H];
for (var i = 0; i &amp;lt; H; i++)
{
    for (var j = 0; j &amp;lt; W; j++)
    {
        B[j, i] = A[i, j];
    }
}

Printer.Print2D(B, &amp;quot; &amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28919221"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あらかじめ、文字列前方と後方の連続する&lt;code&gt;a&lt;/code&gt;を無視した文字列が回文であれば元の文が回文である可能性があります。
このとき、文字列前方の連続する&lt;code&gt;a&lt;/code&gt;の個数が文字列後方の連続する&lt;code&gt;a&lt;/code&gt;の個数以下場合は、足りない&lt;code&gt;a&lt;/code&gt;を前方に追加することで回文にすることができますが、それ以外(前方&amp;gt;後方)の場合は後方に&lt;code&gt;a&lt;/code&gt;を追加することはできないので、回文にすることはできません。
例えば、&lt;code&gt;aabcbaaa&lt;/code&gt;では、前方と後方の連続した&lt;code&gt;a&lt;/code&gt;を無視すると&lt;code&gt;bcb&lt;/code&gt;となり回文になり、前方(2)は後方(3)以下なので、回文にすることができます。一方で、
&lt;code&gt;aaabcbaa&lt;/code&gt;では、同様に無視すると&lt;code&gt;bcb&lt;/code&gt;となり回文になりますが、前方(3)は後方(2)より大きいため、回文にすることはできません。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.ScanLine();
var (l, r) = (0, S.Length - 1);
while (r &amp;gt;= 0 &amp;amp;&amp;amp; S[r] == 'a') r--;
while (l &amp;lt; r &amp;amp;&amp;amp; S[l] == 'a') l++;

var lc = l;
var rc = S.Length - r - 1;
if (lc &amp;gt; rc)
{
    Console.WriteLine(&amp;quot;No&amp;quot;);
    return;
}

var t = S[l..(r + 1)];
var answer = t == new string(t.Reverse().ToArray());
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28928816"&gt;コンテスト提出&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28958803"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数字をノードとしてみたときに、0をルートとするツリーを作成し、深さ優先探索の通りがかり順(左部分木-&amp;gt;自分-&amp;gt;右部分木)で見ていった結果が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var S = Scanner.ScanLine();
var nodes = new Node[N + 1];
for (var i = 0; i &amp;lt;= N; i++)
{
    nodes[i] = new Node();
}
 
foreach (var (c, i) in S.Select((x, i) =&amp;gt; (x, i)))
{
    if (c == 'L')
    {
        nodes[i].Left = i + 1;
    }
    else
    {
        nodes[i].Right = i + 1;
    }
}
 
var answer = new List&amp;lt;int&amp;gt;();
 
void Dfs(int curr)
{
    if (curr &amp;lt; 0) return;
    Dfs(nodes[curr].Left);
    answer.Add(curr);
    Dfs(nodes[curr].Right);
}
 
Dfs(0);
 
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Node&lt;/code&gt;は左側と右側を持つクラスです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class Node
{
    public int Left { get; set; } = -1;
    public int Right { get; set; } = -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Deque&lt;/code&gt;を使った場合は、文字列を逆順から見て、反対側に追加すればよいです。
C#には&lt;code&gt;Deque&lt;/code&gt;というクラスはありませんが、&lt;code&gt;LinkedList&amp;lt;T&amp;gt;&lt;/code&gt;という連結リストがあるため、それを使うことで代用することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var S = Scanner.ScanLine();
var deq = new Deque&amp;lt;int&amp;gt;();
deq.PushBack(N);
foreach (var (c, i) in S.Select((x, i) =&amp;gt; (x, i)).Reverse())
{
    if (c == 'L') deq.PushBack(i);
    else deq.PushFront(i);
}
 
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, deq));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28933145"&gt;コンテスト提出&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28962115"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;頂点&lt;code&gt;U&lt;/code&gt;と頂点&lt;code&gt;V&lt;/code&gt;をつなぐ辺にそれぞれ重みを付けてグラフを作成したときの、拡張ダイクストラ法で解くことを考えます。
楽しさの変化量を辺の重みとしてみたとき、&lt;code&gt;H&lt;/code&gt;を頂点の高さ、&lt;code&gt;d&lt;/code&gt;を高さの差の絶対値とすると、&lt;code&gt;H[U]&amp;lt;H[V]&lt;/code&gt;であれば&lt;code&gt;U-&amp;gt;V&lt;/code&gt;の辺は&lt;code&gt;d&lt;/code&gt;の重み、&lt;code&gt;H[U]&amp;gt;H[V}&lt;/code&gt;であれば&lt;code&gt;U-&amp;gt;V&lt;/code&gt;の辺は&lt;code&gt;-2d&lt;/code&gt;の重み、&lt;code&gt;H[U]=H[V]&lt;/code&gt;であれば&lt;code&gt;0&lt;/code&gt;の重みをそれぞれの辺につけます。&lt;br /&gt;
その重み付きグラフを用いて、頂点&lt;code&gt;0&lt;/code&gt;から優先度付きキューを用いて幅優先探索を行い、各頂点のコストを最大化したときの最大の値が答えとなります。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;嘘解放でした。この実装では、&lt;code&gt;after_contest&lt;/code&gt;でTLEになります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/kyopro_friends/status/1487807336202735617"&gt;競技プログラミングをするフレンズ E問題after_contest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;楽しさの減少を標高差のまま考えたとき、&lt;code&gt;U-&amp;gt;V&lt;/code&gt;に至る経路がどうであれ、楽しさは&lt;code&gt;H[U]-H[V]&lt;/code&gt;を得ることができます。楽しさの減少が標高差の2倍のときは、&lt;code&gt;U-&amp;gt;V&lt;/code&gt;に至る経路のうち&lt;code&gt;H[X]&amp;lt;H[Y]&lt;/code&gt;の移動を行ったときに、楽しさが&lt;code&gt;H[X]-H[Y]&lt;/code&gt;減少します。言い換えれば、減少分を辺のコストとしたときの単一始点最短経路問題として考えることができます。
そして、各頂点の得られる楽しさから最小化された頂点のコストを引くことで、頂点に対する楽しさの最大化を行うことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var H = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; M; i++)
{
    var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    u--; v--;
    G[u].Add((v, Math.Max(0, H[v] - H[u])));
    G[v].Add((u, Math.Max(0, H[u] - H[v])));
}

var costs = new long[N];
Array.Fill(costs, long.MaxValue);
costs[0] = 0;
var queue = new PriorityQueue&amp;lt;(int U, long Cost)&amp;gt;((x, y) =&amp;gt; x.Cost.CompareTo(y.Cost));
queue.Enqueue((0, 0));

while (queue.Count &amp;gt; 0)
{
    var (u, cu) = queue.Dequeue();
    if (costs[u] &amp;lt; cu) continue;
    foreach (var (v, cv) in G[u])
    {
        var c = costs[u] + cv;
        if (costs[v] &amp;lt;= c) continue;
        costs[v] = c;
        queue.Enqueue((v, c));
    }
}

var answer = 0L;
for (var i = 0; i &amp;lt; N; i++)
{
    answer = Math.Max(answer, H[0] - H[i] - costs[i]);
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2022年1月31日現在のAtCoderの&lt;code&gt;C#(.NET Core 3.1.201)&lt;/code&gt;では&lt;code&gt;PriorityQueue&lt;/code&gt;は標準ライブラリにないため、自作する必要があります。
&lt;code&gt;C#(.NET 6.0)&lt;/code&gt;以降であれば、&lt;code&gt;PriorityQueue&lt;/code&gt;が標準ライブラリに追加されるので、言語アップデートを待ちましょう。&lt;/p&gt;
&lt;h2 id="f"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_f"&gt;問題F&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28958599"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NMMMのdp?&lt;/li&gt;
&lt;li&gt;部分増加列&lt;code&gt;a1&lt;/code&gt;、&lt;code&gt;a2&lt;/code&gt;、&lt;code&gt;a3&lt;/code&gt;を固定したときの&lt;code&gt;a1&lt;/code&gt;と&lt;code&gt;a2&lt;/code&gt;の間の数、&lt;code&gt;a2&lt;/code&gt;と&lt;code&gt;a3&lt;/code&gt;の間の数、&lt;code&gt;a3&lt;/code&gt;以降の数の組み合わせの数え上げ?&lt;/li&gt;
&lt;li&gt;www(a1)xxx(a2)yyy(a3)zzzのような数列の時、www:1通り、xxx:長さc1、yyy:長さc2、zzz:長さc3で組み合わせ?&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var a1 = 1; a1 &amp;lt;= M; a1++)
for(var a2 = a1 + 1; a1 + a2 &amp;lt;= M; a2++)
for(var a3 = a2 + 1; a1 + a2 + a3 &amp;lt;= M; a3++)
for(var c1 = 0; c1 &amp;lt;= N; c1++)
for(var c2 = 0; c1 + c2 &amp;lt;= N; c2++)
{
    var c3 = N - 3 - c1 - c2;
    // 組み合わせ?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、部分増加列の最後尾として考えられる最小値の数列の状態数を求めるdpでした。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][a1][a2][a3]&lt;/code&gt; := 長さが&lt;code&gt;i&lt;/code&gt;で、長さ&lt;code&gt;j&lt;/code&gt;の部分増加列の最後尾として考えられる最小値が&lt;code&gt;aj&lt;/code&gt;であるような数列の状態数&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var dp = new mint[N + 1, M + 2, M + 2, M + 2];
dp[0, M + 1, M + 1, M + 1] = 1;
for (var i = 0; i &amp;lt; N; i++)
{
    for (var a1 = 0; a1 &amp;lt;= M + 1; a1++)
    {
        for (var a2 = 0; a2 &amp;lt;= M + 1; a2++)
        {
            for (var a3 = 0; a3 &amp;lt;= M + 1; a3++)
            {
                for (var x = 1; x &amp;lt;= M; x++)
                {
                    if (x &amp;lt;= a1) dp[i + 1, x, a2, a3] += dp[i, a1, a2, a3];
                    else if (x &amp;lt;= a2) dp[i + 1, a1, x, a3] += dp[i, a1, a2, a3];
                    else if (x &amp;lt;= a3) dp[i + 1, a1, a2, x] += dp[i, a1, a2, a3];
                }
            }
        }
    }
}

mint answer = 0;
for (var a1 = 1; a1 &amp;lt;= M; a1++)
{
    for (var a2 = a1 + 1; a2 &amp;lt;= M; a2++)
    {
        for (var a3 = a2 + 1; a3 &amp;lt;= M; a3++)
        {
            answer += dp[N, a1, a2, a3];
        }
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 237の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220123abc236</id>
		<title>ABC236</title>
		<link href="https://aconcavy.github.io/blog/posts/20220123abc236" />
		<updated>2022-01-24T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 236の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236"&gt;https://atcoder.jp/contests/abc236&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28718361"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列を文字の配列としてとり、指定されたインデックスの中身を入れ替えます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
A--; B--;
(S[A], S[B]) = (S[B], S[A]);
Console.WriteLine(string.Join(&amp;quot;&amp;quot;, S));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;タプルを使うことで、一時変数を使わずに値を入れ替えることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var tmp = a;
a = b;
b = a;

(a, b) = (b, a); // 上と同じ
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28722017"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;カードはすべて数値なので、&lt;code&gt;4N&lt;/code&gt;枚のカードの総和&lt;code&gt;(4 * N * (N+1) / 2)&lt;/code&gt;から渡されたカードの束Aの総和を引くことで、抜き取られたカードを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var answer = 4L * (N * (N + 1) / 2) - A.Sum();
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28725764"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列をキーとした辞書を作成し、急行列車が止まる駅をチェックします。時間計算量は&lt;code&gt;O(NlogN)&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var S = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var T = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;string, bool&amp;gt;();
foreach (var s in S)
{
    dict[s] = false;
}

foreach (var t in T)
{
    dict[t] = true;
}

foreach (var s in S)
{
    Console.WriteLine(dict[s] ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ほかにも、&lt;code&gt;T&lt;/code&gt;は&lt;code&gt;S&lt;/code&gt;の部分列であることが制約で保証されているため、&lt;code&gt;S&lt;/code&gt;を前から順に見ていったとき、次の&lt;code&gt;T&lt;/code&gt;と一致した場合には&lt;code&gt;Yes&lt;/code&gt;を表示し、&lt;code&gt;T&lt;/code&gt;を次に進めるといった方法でも、時間計算量&lt;code&gt;O(N)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var S = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var T = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var queue = new Queue&amp;lt;string&amp;gt;(T);
foreach (var s in S)
{
    if (queue.TryPeek(out var t) &amp;amp;&amp;amp; s == t)
    {
        queue.Dequeue();
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
    }
    else
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28749636"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今見ている人とスコアをもって深さ優先探索を行い、すべての人がペアを組み終わったときのスコアを最大値を求めます。遷移としては、既にペアを組んでいる場合は次の人に進み、組んでいない場合は今見ている人以降のまだペアを組んでいない人とペアを組みます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = new int[N * 2, N * 2];
for (var i = 0; i &amp;lt; N * 2 - 1; i++)
{
    var AA = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var j = 0; j &amp;lt; AA.Length; j++)
    {
        A[i, j + i + 1] = A[j + i + 1, i] = AA[j];
    }
}

var answer = 0;
var used = new bool[N * 2];

void Dfs(int curr, int xor)
{
    if (curr &amp;gt;= N * 2)
    {
        if (used.All(x =&amp;gt; x))
        {
            answer = Math.Max(answer, xor);
        }
        return;
    }

    if (!used[curr])
    {
        for (var next = curr + 1; next &amp;lt; N * 2; next++)
        {
            if (!used[next])
            {
                used[curr] = used[next] = true;
                Dfs(curr + 1, xor ^ A[curr, next]);
                used[curr] = used[next] = false;
            }
        }
    }
    else
    {
        Dfs(curr + 1, xor);
    }
}

Dfs(0, 0);

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28760550"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二部探索?&lt;/li&gt;
&lt;li&gt;最初に奇数番目と偶数番目をそれぞれ分けて、もし値が増えるならそれぞれ足していくことで平均値はでそう?&lt;/li&gt;
&lt;li&gt;上の方針では、&lt;code&gt;1 2 4 5 7 8&lt;/code&gt;のように番目をとるとダメになる可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説では、平均と中央値ともに二部探索でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

long DP(IEnumerable&amp;lt;long&amp;gt; source)
{
    var (x, y) = (0L, 0L);
    foreach (var v in source)
    {
        var z = Math.Max(x, y) + v;
        (x, y) = (y, z);
    }

    return Math.Max(x, y);
}

double Average()
{
    bool F(long k) =&amp;gt; DP(A.Select(x =&amp;gt; x * 1000 - k)) &amp;gt;= 0;
    return BinarySearch((long)1e12 + 1, 0, F) / 1000d;
}

long Median()
{
    bool F(long k) =&amp;gt; DP(A.Select(x =&amp;gt; x &amp;gt;= k ? 1L : -1L)) &amp;gt; 0;
    return BinarySearch((long)1e9 + 1, 0, F);
}

Console.WriteLine(Average());
Console.WriteLine(Median());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BinarySearch&lt;/code&gt;は&lt;code&gt;[ng, ok)&lt;/code&gt;の間で、&lt;code&gt;func&lt;/code&gt;の判定式を使って二部探索を行う関数です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 236の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220115abc235</id>
		<title>ABC235</title>
		<link href="https://aconcavy.github.io/blog/posts/20220115abc235" />
		<updated>2022-01-16T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 235の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235"&gt;https://atcoder.jp/contests/abc235&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28530777"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各桁を移動させて足します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var V = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
var answer = 0;
answer += V[0] * 100 + V[1] * 10 + V[2];
answer += V[1] * 100 + V[2] * 10 + V[0];
answer += V[2] * 100 + V[0] * 10 + V[1];

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28530905"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;順にみて前回より大きい場合は&lt;code&gt;curr&lt;/code&gt;を更新し、小さい場合は移動することができないため、&lt;code&gt;curr&lt;/code&gt;を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var H = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var curr = 0L;
for (var i = 0; i &amp;lt; N; i++)
{
    if (curr &amp;lt; H[i])
    {
        curr = H[i];
    }
    else
    {
        Console.WriteLine(curr);
        return;
    }
}

Console.WriteLine(curr);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28535489"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリのたびにすべてを走査すると&lt;code&gt;O(N*Q)&lt;/code&gt;となりTLEになるので、高速化する必要があります。
あらかじめ値をキーとした出現場所をもつ辞書を作成し、その値が何番目に出現するかを保持しておき、クエリによる&lt;code&gt;x&lt;/code&gt;の値が存在して、&lt;code&gt;k&lt;/code&gt;の値が辞書内に存在する&lt;code&gt;x&lt;/code&gt;の個数以内ならばその出現場所を表示し、それ以外の場合は&lt;code&gt;-1&lt;/code&gt;を表示することで、クエリ当たり&lt;code&gt;O(logN)&lt;/code&gt;で実行することができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    if (!dict.ContainsKey(A[i])) dict[A[i]] = new List&amp;lt;int&amp;gt;();
    dict[A[i]].Add(i + 1);
}

while (Q-- &amp;gt; 0)
{
    var (x, k) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    k--;
    if (dict.ContainsKey(x))
    {
        if (k &amp;lt; dict[x].Count)
        {
            Console.WriteLine(dict[x][k]);
        }
        else
        {
            Console.WriteLine(-1);
        }
    }
    else
    {
        Console.WriteLine(-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28546896"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各操作をBFSで走査することにより、各値の更新は高々1回のみで十分になります。&lt;br /&gt;
シフト操作によって、&lt;code&gt;N&lt;/code&gt;の値より大きい数から&lt;code&gt;N&lt;/code&gt;より小さい値に変化する可能性もあるので、Nを文字列としてみたときの長さより大きい場合は無視することに注意します。&lt;br /&gt;
&lt;code&gt;Shift&lt;/code&gt;メソッドは配列を与えられた値だけシフトする関数です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (A, N) = Scanner.Scan&amp;lt;long, long&amp;gt;();
var dp = new Dictionary&amp;lt;long, int&amp;gt;();
dp[1] = 0;

var queue = new Queue&amp;lt;long&amp;gt;();
queue.Enqueue(1);
const int inf = (int)1e7;

void Push(long curr, long next)
{
    if (next &amp;gt; inf) return;
    if (dp.ContainsKey(next)) return;
    dp[next] = dp[curr] + 1;
    queue.Enqueue(next);
}

while (queue.Count &amp;gt; 0)
{
    var u = queue.Dequeue();
    if (u &amp;gt;= 10 &amp;amp;&amp;amp; u % 10 != 0)
    {
        var v = long.Parse(Shift(u.ToString().AsSpan(), 1));
        Push(u, v);
    }
    Push(u, u * A);
}
 
if (dp.ContainsKey(N))
{
    Console.WriteLine(dp[N]);
}
else
{
    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28551552"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに最小全域木を求めると、ソートに&lt;code&gt;(MlogM)&lt;/code&gt;、クラスカル法で最小全域木を求めるために&lt;code&gt;O(Ea(V))&lt;/code&gt;となり、TLEになってしまいます。
クエリに対してグラフはそれぞれ独立なため、あらかじめクエリを先読みしてすべての辺をまとめてソートし、クラスカル法で辺を見てその辺が有効な場合、もしその辺がクエリの辺である場合はそのクエリは有効であり、そうではない場合は最小全域木としてマージしていくことで、計算量を抑えることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M, Q) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
var E1 = new Edge[M];
var E2 = new Edge[Q];
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b, c) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    a--; b--;
    E1[i] = new Edge(-1, a, b, c);
}

for (var i = 0; i &amp;lt; Q; i++)
{
    var (a, b, c) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    a--; b--;
    E2[i] = new Edge(i, a, b, c);
}

var answer = new bool[Q];
var dsu = new DisjointSetUnion(N);
foreach (var e in E1.Concat(E2).OrderBy(x =&amp;gt; x.Cost))
{
    if (dsu.IsSame(e.U, e.V)) continue;
    if (e.ID == -1)
    {
        dsu.Merge(e.U, e.V);
    }
    else
    {
        answer[e.ID] = true;
    }
}

Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer.Select(x =&amp;gt; x ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_f"&gt;問題F&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28569936"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;桁dp?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&amp;lt;&amp;lt;10&lt;/code&gt;(1024)通りの場合分け?&lt;/li&gt;
&lt;li&gt;総和の数え方がわからない...&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var dp = new mint[N + 1, 1 &amp;lt;&amp;lt; 10];
for(var i = 0; i &amp;lt; S.Length; i++)
{
    for(var j = 0; j &amp;lt; 1 &amp;lt;&amp;lt; 10; j++)
    {
        for(var k = 0; k &amp;lt; 10; k++)
        {
            // dp[i + 1, j | (1 &amp;lt;&amp;lt; k)] = ?;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、総和と個数をそれぞれ別に数え上げるそうです。
&lt;code&gt;mint&lt;/code&gt;は、あまりをとる整数型です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var V = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
var N = V.Length;
var M = Scanner.Scan&amp;lt;int&amp;gt;();
var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

var ok = 0;
foreach (var c in C)
{
    ok |= 1 &amp;lt;&amp;lt; c;
}

var max = 1 &amp;lt;&amp;lt; 10;
var count = new mint[2][] { new mint[max], new mint[max] };
var sum = new mint[2][] { new mint[max], new mint[max] };
mint curr = 0;
var digits = 0;

var t = 1;
for (var i = 0; i &amp;lt; N; i++)
{
    t ^= 1;
    var tt = t ^ 1;
    var c = V[i];
    Array.Fill(count[tt], 0);
    Array.Fill(sum[tt], 0);
    for (var j = 0; j &amp;lt; max; j++)
    {
        for (var d = 0; d &amp;lt; 10; d++)
        {
            var next = j | (1 &amp;lt;&amp;lt; d);
            count[tt][next] += count[t][j];
            sum[tt][next] += sum[t][j] * 10 + count[t][j] * d;
        }
    }

    if (i &amp;gt; 0)
    {
        for (var d = 1; d &amp;lt; 10; d++)
        {
            var next = 1 &amp;lt;&amp;lt; d;
            count[tt][next]++;
            sum[tt][next] += d;
        }
    }

    for (var d = 0; d &amp;lt; c; d++)
    {
        if (i == 0 &amp;amp;&amp;amp; d == 0) continue;
        var next = digits | (1 &amp;lt;&amp;lt; d);
        count[tt][next]++;
        sum[tt][next] += curr * 10 + d;
    }

    digits |= 1 &amp;lt;&amp;lt; c;
    curr = curr * 10 + c;
}

t ^= 1;
var answer = 0L;
for (var j = 0; j &amp;lt; max; j++)
{
    if ((j &amp;amp; ok) == ok)
    {
        answer += sum[t][j];
    }
}

if ((digits &amp;amp; ok) == ok)
{
    answer += curr;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 235の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20220108abc234</id>
		<title>ABC234</title>
		<link href="https://aconcavy.github.io/blog/posts/20220108abc234" />
		<updated>2022-01-08T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 234の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234"&gt;https://atcoder.jp/contests/abc234&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28380748"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F(x)&lt;/code&gt;を定義し、求める式を&lt;code&gt;G(x)&lt;/code&gt;とした時に、&lt;code&gt;G(T)&lt;/code&gt;の値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var T = Scanner.Scan&amp;lt;int&amp;gt;();
long F(long x) =&amp;gt; x * x + 2 * x + 3;
long G(long x) =&amp;gt; F(F(F(x) + x) + F(F(x)));
var answer = G(T);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28384115"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;すべての点の組み合わせを試すことで求めることができます。
最後に&lt;code&gt;Sqrt&lt;/code&gt;を取ることで誤差を回避しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var P = new (double X, double Y)[N];
for (var i = 0; i &amp;lt; N; i++)
{
    var (x, y) = Scanner.Scan&amp;lt;double, double&amp;gt;();
    P[i] = (x, y);
}

var answer = 0d;
foreach (var (x1, y1) in P)
{
    foreach (var (x2, y2) in P)
    {
        var (dx, dy) = (x2 - x1, y2 - y1);
        answer = Math.Max(answer, dx * dx + dy * dy);
    }
}

answer = Math.Sqrt(answer);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28387201"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt;を2進数表記したとき、&lt;code&gt;1&lt;/code&gt;の値を&lt;code&gt;2&lt;/code&gt;にしたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var K = Scanner.Scan&amp;lt;long&amp;gt;();
var list = new List&amp;lt;long&amp;gt;();
while (K &amp;gt; 0)
{
    list.Add(K &amp;amp; 1);
    K &amp;gt;&amp;gt;= 1;
}
list.Reverse();
var answer = string.Join(&amp;quot;&amp;quot;, list.Select(x =&amp;gt; x * 2));
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28404691"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc234/submissions/28418529"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;優先度付きキューを使い、キューのサイズが&lt;code&gt;K&lt;/code&gt;個の時の最小の値がそれぞれの状態の答えとなります。
最初は、先頭から&lt;code&gt;K&lt;/code&gt;個の値を入れたときの最小の値を表示し、それ以降は追加される値がキューの最小よりも小さい場合はK番目より小さいので無視し、大きい場合はキューを更新することで&lt;code&gt;K&lt;/code&gt;個を維持しつつ最小の値を管理できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var queue = new PriorityQueue&amp;lt;int&amp;gt;();
for (var i = 0; i &amp;lt; K; i++)
{
    queue.Enqueue(P[i]);
}

Console.WriteLine(queue.Peek());

for (var i = K; i &amp;lt; N; i++)
{
    if (queue.Peek() &amp;lt; P[i])
    {
        queue.Dequeue();
        queue.Enqueue(P[i]);
    }

    var answer = queue.Peek();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/284197124"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;答えとしてあり得る値を考えたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等差が&lt;code&gt;-9&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt; (19通り)&lt;/li&gt;
&lt;li&gt;最上位の桁が&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt; (10通り)&lt;/li&gt;
&lt;li&gt;桁数が17桁 (17通り)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;すべて合わせて&lt;code&gt;3230(19*10*17)&lt;/code&gt;通りのうち、各桁の値が&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の条件をもつ値すべてを全探索しすることで、&lt;code&gt;X&lt;/code&gt;以上を最小の値を求めることができる。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var X = Scanner.Scan&amp;lt;long&amp;gt;();
var hashset = new HashSet&amp;lt;long&amp;gt;(Enumerable.Range(0, 10).Select(x =&amp;gt; (long)x));
for (var d = -9; d &amp;lt;= 9; d++)
{
    for (var i = 0L; i &amp;lt;= 9; i++)
    {
        var x = i;
        for (var t = 1; t &amp;lt; 18; t++)
        {
            var mod = x % 10;
            if (mod + d &amp;lt; 0 || 10 &amp;lt;= mod + d) break;
            x *= 10;
            x += mod + d;
            hashset.Add(x);
        }
    }
}

var answer = hashset.Where(x =&amp;gt; x &amp;gt;= X).Min();
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;E問題を解こうとしてたはずなのにF問題やってたのでコンテスト中には解けませんでした。コンテスト後に気づいて解いてみたら解けてたので悔しいです。&lt;/del&gt;&lt;/p&gt;
&lt;h2 id="e-1"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_f"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28417399"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;制約が&lt;code&gt;N&amp;lt;=5000&lt;/code&gt;だからdpと組み合わせ?&lt;/li&gt;
&lt;li&gt;2^Nから重複を引く?&lt;/li&gt;
&lt;li&gt;重複組み合わせ?&lt;/li&gt;
&lt;li&gt;長さが&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;のそれぞれの時に数え上げ?&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var s = 1; s &amp;lt; S.Length; s++)
{
    var sum = 0;
    for(var i = 0; i &amp;lt; 26; i++)
    {
        sum = Math.Min(count[i], s);
    }

    // ToDo
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、&lt;code&gt;i&lt;/code&gt;番目までのアルファベットを使った時の文字列の合計が&lt;code&gt;j&lt;/code&gt;である時の組み合わせを数え上げる動的計画法でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();

var N = S.Length;
var fact = new mint[N + 1];
var ifact = new mint[N + 1];
fact[0] = ifact[0] = 1;
for (var i = 1; i &amp;lt;= N; i++)
{
    fact[i] = fact[i - 1] * i;
    ifact[i] = 1 / fact[i];
}

mint Combination(int n, int k)
{
    if (n &amp;lt; k || n &amp;lt; 0 || k &amp;lt; 0) return 0;
    return fact[n] * ifact[k] * ifact[n - k];
}

var count = new int[26];
foreach (var c in S)
{
    count[c - 'a']++;
}

var dp = new mint[27, N + 1];
dp[0, 0] = 1;

for (var i = 0; i &amp;lt; 26; i++)
{
    for (var j = 0; j &amp;lt;= N; j++)
    {
        for (var k = 0; k &amp;lt;= Math.Min(j, count[i]); k++)
        {
            dp[i + 1, j] += dp[i, j - k] * Combination(j, k);
        }
    }
}

mint answer = 0;
for (var i = 1; i &amp;lt;= N; i++)
{
    answer += dp[26, i];
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 234の復習記事です。&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>https://aconcavy.github.io/blog/posts/20211225abc233</id>
		<title>ABC233</title>
		<link href="https://aconcavy.github.io/blog/posts/20211225abc233" />
		<updated>2021-12-25T00:00:00Z</updated>
		<content>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 233の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233"&gt;https://atcoder.jp/contests/abc233&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28110738"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Y-X)&lt;/code&gt;を10で割ったときの切り上げの値が必要な切手の数となります。
&lt;code&gt;(Y-X)&lt;/code&gt;が負の場合は既に金額が足りているので、0と&lt;code&gt;Max&lt;/code&gt;を取ることで、&lt;code&gt;if&lt;/code&gt;文なくすことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (X, Y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var answer = Math.Max(0, ((Y - X) + 9) / 10);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28113146"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;code&gt;Array.Reverse&lt;/code&gt;メソッドを使うことで、配列の指定した範囲を逆順にすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (L, R) = Scanner.Scan&amp;lt;int, int&amp;gt;();
L--;
var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
Array.Reverse(S, L, R - L);
Console.WriteLine(string.Join(&amp;quot;&amp;quot;, S));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28122407"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;総積が&lt;code&gt;X&lt;/code&gt;になるためには、要素となる数が&lt;code&gt;X&lt;/code&gt;の倍数である必要があるため、それ以外を除いたものから、袋からそれぞれ1つずつ選んだ時の組み合わせの数となります。&lt;br /&gt;
再帰関数を使って&lt;code&gt;idx&lt;/code&gt;となる袋を順にみていくとき、ボールの値が現在の値&lt;code&gt;curr&lt;/code&gt;の倍数であり、&lt;code&gt;curr&lt;/code&gt;が0より大きい場合、次の袋に進むことができます。&lt;br /&gt;
もしすべての袋から1つずつ拾うことができて、&lt;code&gt;curr&lt;/code&gt;の値が1のときは、それまでに選んだボールの値の総積が&lt;code&gt;X&lt;/code&gt;となるので、その時の数を数え上げることで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, X) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = new long[N][];
for (var i = 0; i &amp;lt; N; i++)
{
    A[i] = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().Skip(1).Where(x =&amp;gt; X % x == 0).ToArray();
}

var answer = 0L;

void Dfs(int idx, long curr)
{
    if (idx == N)
    {
        if (curr == 1) answer++;
        return;
    }

    foreach (var a in A[idx])
    {
        if (curr % a == 0 &amp;amp;&amp;amp; curr / a != 0)
        {
            Dfs(idx + 1, curr / a);
        }
    }
}

Dfs(0, X);

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28148861"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;累積和で範囲を求められそう&lt;/li&gt;
&lt;li&gt;尺取り法は単調増加ではないから使えなさそう&lt;/li&gt;
&lt;li&gt;ディクショナリでまとめて数え上げられそう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;L&lt;/code&gt;を固定したときに&lt;code&gt;R&lt;/code&gt;の数を数え上げましたが、実装が間違っていたのかWAで時間切れとなりました。&lt;/p&gt;
&lt;p&gt;解説では&lt;code&gt;R&lt;/code&gt;を固定したときに&lt;code&gt;L&lt;/code&gt;の数を数え上げていました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var cum = new long[N + 1];
for (var i = 0; i &amp;lt; N; i++)
{
    cum[i + 1] = cum[i] + A[i];
}

var dict = new Dictionary&amp;lt;long, long&amp;gt;();
var answer = 0L;
for (var i = 1; i &amp;lt;= N; i++)
{
    if (!dict.ContainsKey(cum[i - 1]))
    {
        dict[cum[i - 1]] = 0;
    }
    dict[cum[i - 1]]++;
    if (dict.ContainsKey(cum[i] - K))
    {
        answer += dict[cum[i] - K];
    }
}
 
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28143437"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大きい桁から累積和を取ると、その桁に最終的に足される数を求めることができます。
累積和を小さい桁から見たとき、その桁の累積和の1の位の数が桁として確定し、累積和の1の位より大きい値は、その次の桁に繰り上げられるため、次の桁の累積和に足す必要があります。&lt;br /&gt;
出力では、一番大きい桁が0の場合は除外して表示する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var X = Scanner.Scan&amp;lt;string&amp;gt;();
var N = X.Length;
var cum = new int[N + 1];
for (var i = 0; i &amp;lt; N; i++)
{
    cum[i + 1] = cum[i] + X[i] - '0';
}

var answer = new int[X.Length + 1];
for (var i = N; i &amp;gt; 0; i--)
{
    answer[i] = cum[i] % 10;
    cum[i - 1] += cum[i] / 10;
}

answer[0] += cum[0];
if (answer[0] == 0)
{
    Console.WriteLine(string.Join(&amp;quot;&amp;quot;, answer.Skip(1)));
}
else
{
    Console.WriteLine(string.Join(&amp;quot;&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;AtCoder Beginner Contest 233の復習記事です。&lt;/p&gt;</summary>
	</entry>
</feed>