<!DOCTYPE html><html lang="ja"><head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline';
img-src 'self' * data: *.w3.org; 
child-src 'none';
frame-src 'self' *.twitter.com;
font-src 'self' *.fontawesome.com;
connect-src 'self' *.fontawesome.com *.typekit.net;
style-src 'self' 'unsafe-inline';
script-src 'self' 'unsafe-eval' *.twitter.com *.typekit.net;">

    <title>acon.log - ABC287</title>

    <link rel="icon" href="/assets/images/favicon.svg" type="text/svg+xml">
    <link href="/mirror/cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/style.css" type="text/css">
    <script src="/assets/vendor/adobe/adobe_fonts.js"></script>

    
<meta property="og:title" content="ABC287">
<meta property="og:description" content="">
<meta property="og:image" content="https://blog.aconcavy.dev/assets/images/icon.webp">
<meta property="og:url" content="https://blog.aconcavy.dev/posts/20230128abc287">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="acon.log">
<meta name="twitter:image" content="https://blog.aconcavy.dev/assets/images/icon.webp">


</head>

<body>

<nav class="navbar navbar-expand-lg navbar-dark fixed-top shadow-sm" id="navbar">
    <div class="container">
        <a class="navbar-brand l-navbar__brand" href="/">acon.log</a>
        <button class="navbar-toggler navbar-toggler-right l-navbar__toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon l-navbar__toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ms-auto">
    <li class="nav-item l-navbar__nav-item">
        <a class="nav-link l-navbar__nav-link" href="/posts">Posts</a>
    </li>
</ul>

        </div>
    </div>
</nav>



<header class="l-header">
    <div class="l-header__inner">
    </div>
</header>


<main class="l-main">
    <div class="container">
        <div class="row">
            <div id="content">
                    <article>
                        <div class="card shadow-sm c-post">
                            <div class="card-body p-md-5">
                                
<header>
    <div class="c-post-header mb-3">
        <h1 class="card-title c-post-header__title">ABC287</h1>

        <div class="card-text c-post-header__meta">
            Published on <time datetime="2023-01-28T00:00:00&amp;#x2B;00:00">Saturday, 28 January 2023</time>
        </div>
        <div class="card-text c-post-header__meta">
            Updated on <time datetime="2023-01-28T00:00:00&amp;#x2B;00:00">Saturday, 28 January 2023</time>
        </div>

            <div class="mt-3 mb-4">
                    <a href="/tags/atcoder" class="badge badge-light c-tag--light"> atcoder</a>
                    <a href="/tags/csharp" class="badge badge-light c-tag--light"> csharp</a>
            </div>

        <hr>
    </div>
</header>

                                <div class="c-post-body">
                                    <h2 id="section">はじめに</h2>
<p>AtCoder Beginner Contest 287の復習記事です。</p>
<p>記事における<code>Scanner</code>クラスは、自作の入力クラスです。</p>
<h2 id="section-1">コンテスト</h2>
<p><a href="https://atcoder.jp/contests/abc287">https://atcoder.jp/contests/abc287</a></p>
<h3 id="a"><a href="https://atcoder.jp/contests/abc287/tasks/abc287_a">問題A</a></h3>
<p><a href="https://atcoder.jp/contests/abc287/submissions/38375686">コンテスト提出</a></p>
<p>入力から<code>For</code>の個数を数え上げ、その個数の2倍が<code>N</code>より大きければ過半数が提案に賛成しています。</p>
<pre><code class="language-csharp line-numbers">public static void Solve()
{
    var N = Scanner.Scan&lt;int&gt;();
    var f = 0;
    for (var i = 0; i &lt; N; i++)
    {
        var S = Scanner.Scan&lt;string&gt;();
        if (S == &quot;For&quot;) f++;
    }

    var answer = f * 2 &gt; N ? &quot;Yes&quot; : &quot;No&quot;;
    Console.WriteLine(answer);
}
</code></pre>
<h3 id="b"><a href="https://atcoder.jp/contests/abc287/tasks/abc287_b">問題B</a></h3>
<p><a href="https://atcoder.jp/contests/abc287/submissions/38380732">コンテスト提出</a></p>
<p>各<code>S</code>の末尾3文字が<code>T</code>のいずれかと一致しているかを各<code>S</code>と各<code>T</code>の組み合わせを全探索することで、時間計算量<code>O(NM)</code>で答えを求めることができます。<br>
また、<code>T</code>の集合を<code>Set</code>や<code>HashSet</code>などのデータ構造で管理することで、時間計算量を<code>O(NlogM)</code>、<code>O(N)</code>にすることもできます。<br>
ほかにも、入力が数値のみであることから、大きさが<code>1000</code>以上の配列を用意して<code>T</code>を配列のインデックスとして存在判定し、<code>S%1000</code>でその配列にアクセスすることで、時間計算量<code>O(N+M)</code>で解くこともできます。</p>
<pre><code class="language-csharp line-numbers">public static void Solve()
{
    var (N, M) = Scanner.Scan&lt;int, int&gt;();
    var S = new string[N];
    for (var i = 0; i &lt; N; i++)
    {
        var s = Scanner.Scan&lt;string&gt;();
        S[i] = s[3..];
    }

    var T = new HashSet&lt;string&gt;();
    for (var i = 0; i &lt; M; i++)
    {
        var t = Scanner.Scan&lt;string&gt;();
        T.Add(t);
    }

    var answer = 0;
    foreach (var s in S)
    {
        if (T.Contains(s)) answer++;
    }

    Console.WriteLine(answer);
}
</code></pre>
<h3 id="c"><a href="https://atcoder.jp/contests/abc287/tasks/abc287_c">問題C</a></h3>
<p><a href="https://atcoder.jp/contests/abc287/submissions/38385675">コンテスト提出</a></p>
<p>直線になるようなグラフがパスグラフになります。
これは、グラフを構成する辺が<code>N-1</code>本であり、端点となる2つの頂点は次数が<code>1</code>、それ以外は次数が<code>2</code>であり、連結であるグラフです。
グラフが連結であるかどうかは幅/深さ優先探索や<code>DisjointSetUnion</code>で調べることができます。</p>
<pre><code class="language-csharp line-numbers">public static void Solve()
{
    var (N, M) = Scanner.Scan&lt;int, int&gt;();
    var G = new List&lt;int&gt;[N].Select(x =&gt; new List&lt;int&gt;()).ToArray();
    for (var i = 0; i &lt; M; i++)
    {
        var (u, v) = Scanner.Scan&lt;int, int&gt;();
        u--; v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    if (M != N - 1 || G.Any(x =&gt; x.Count &gt; 2))
    {
        Console.WriteLine(&quot;No&quot;);
        return;
    }

    var used = new bool[N];
    var queue = new Queue&lt;int&gt;();
    queue.Enqueue(0);
    used[0] = true;
    while (queue.Count &gt; 0)
    {
        var u = queue.Dequeue();
        foreach (var v in G[u].Where(x =&gt; !used[x]))
        {
            used[v] = true;
            queue.Enqueue(v);
        }
    }

    var answer = used.All(x =&gt; x);
    Console.WriteLine(answer ? &quot;Yes&quot; : &quot;No&quot;);
}
</code></pre>
<h3 id="d"><a href="https://atcoder.jp/contests/abc287/tasks/abc287_d">問題D</a></h3>
<p><a href="https://atcoder.jp/contests/abc287/submissions/38402756">コンテスト提出</a></p>
<p><code>S</code>と<code>T</code>の先頭から<code>i</code>文字が一致しているかを<code>first[i]</code>としたとき、</p>
<pre><code class="language-text line-numbers">i==0のとき、
first[0] = true

i&gt;=1のとき、
f1 = S[i] == T[i]
f2 = S[i] == '?'
f3 = T[i] == '?'
first[i] = first[i - 1] &amp;&amp; (f1 || f2 || f3)
</code></pre>
<p>同様に末尾から<code>i</code>文字が一致しているかを<code>last[i]</code>とすると、各<code>x</code>に対する答えを<code>f(x)</code>とすると次のようになります。</p>
<pre><code class="language-text line-numbers">f(x) == first[x] &amp;&amp; last[|T| - x]`
</code></pre>
<p>事前に<code>first</code>と<code>last</code>を時間計算量<code>O(|T|)</code>で求めておくことで、<code>f(x)</code>は時間計算量<code>O(1)</code>で求めることができ、全体計算量は<code>O(|T|)</code>となります。</p>
<pre><code class="language-csharp line-numbers">public static void Solve()
{
    var S = Scanner.Scan&lt;string&gt;();
    var T = Scanner.Scan&lt;string&gt;();
    var N = T.Length;
    var first = new bool[N + 1];
    var last = new bool[N + 1];
    first[0] = last[0] = true;
    for (var i = 0; i &lt; N; i++)
    {
        var sj = S.Length - 1 - i;
        var tj = T.Length - 1 - i;
        var ff = S[i] == '?' || T[i] == '?' || S[i] == T[i];
        var fl = S[sj] == '?' || T[tj] == '?' || S[sj] == T[tj];
        first[i + 1] = first[i] &amp;&amp; ff;
        last[i + 1] = last[i] &amp;&amp; fl;
    }

    for (var x = 0; x &lt;= N; x++)
    {
        var y = N - x;
        var answer = first[x] &amp;&amp; last[y];
        Console.WriteLine(answer ? &quot;Yes&quot; : &quot;No&quot;);
    }
}
</code></pre>
<h3 id="e"><a href="https://atcoder.jp/contests/abc287/tasks/abc287_e">問題E</a></h3>
<p><a href="https://atcoder.jp/contests/abc287/submissions/38399917">コンテスト提出</a></p>
<p>全ての文字列において、長さ<code>0&lt;=k&lt;=|S|</code>の連続部分文字列<code>T</code>となる個数をあらかじめ求めておき、各<code>i</code>における長さ<code>k</code>の<code>T</code>の個数が2個以上存在する場合、<code>LCP(i,?)==k</code>が成立するため、その<code>k</code>の最大が<code>i</code>に対する答えとなります。
連続部分文字列の管理に<code>RollingHash</code>などを使うことで、連続部分列の計算を時間計算量<code>O(1)</code>で求めることができ、全体時間計算量<code>O(NlogN)</code>で答えを求めることができます。</p>
<pre><code class="language-csharp line-numbers">public static void Solve()
{
    var N = Scanner.Scan&lt;int&gt;();
    var S = new string[N];
    var dict = new Dictionary&lt;ulong, Dictionary&lt;int, int&gt;&gt;();
    var rhs = new RollingHash[N];
    for (var i = 0; i &lt; N; i++)
    {
        var s = Scanner.Scan&lt;string&gt;();
        S[i] = s;
        var rh = new RollingHash(s);
        rhs[i] = rh;
        for (var j = 0; j &lt;= s.Length; j++)
        {
            var h = rh.SlicedHash(0, j);
            if (!dict.ContainsKey(h)) dict[h] = new Dictionary&lt;int, int&gt;();
            if (!dict[h].ContainsKey(j)) dict[h][j] = 0;
            dict[h][j]++;
        }
    }

    for (var i = 0; i &lt; N; i++)
    {
        var answer = 0;
        for (var j = 0; j &lt;= S[i].Length; j++)
        {
            var h = rhs[i].SlicedHash(0, j);
            if (dict[h].ContainsKey(j) &amp;&amp; dict[h][j] &gt;= 2) answer = j;
        }

        Console.WriteLine(answer);
    }
}
</code></pre>
<p><code>RollingHash</code>について、keymoonさんの<a href="https://qiita.com/keymoon/items/11fac5627672a6d6a9f6">安全で爆速なRollingHashの話</a>を参考にしました。</p>
<pre><code class="language-csharp line-numbers">public class RollingHash
{
    private const ulong Mask30 = (1UL &lt;&lt; 30) - 1;
    private const ulong Mask31 = (1UL &lt;&lt; 31) - 1;
    private const ulong Modulo = (1UL &lt;&lt; 61) - 1;
    private const ulong Positivizer = Modulo * ((1UL &lt;&lt; 3) - 1);
    public static readonly ulong Base;
    static RollingHash()
    {
        Base = (ulong)new Random().Next(1 &lt;&lt; 8, int.MaxValue);
    }
    private readonly ulong[] _powers;
    private readonly ulong[] _hash;
    public RollingHash(ReadOnlySpan&lt;char&gt; s)
    {
        _powers = new ulong[s.Length + 1];
        _powers[0] = 1;
        _hash = new ulong[s.Length + 1];
        for (var i = 0; i &lt; s.Length; i++)
        {
            _powers[i + 1] = CalcModulo(Multiply(_powers[i], Base));
            _hash[i + 1] = CalcModulo(Multiply(_hash[i], Base) + s[i]);
        }
    }
    public ulong SlicedHash(int start, int length)
    {
        return CalcModulo(_hash[start + length] + Positivizer - Multiply(_hash[start], _powers[length]));
    }
    private static ulong Multiply(ulong a, ulong b)
    {
        var au = a &gt;&gt; 31;
        var ad = a &amp; Mask31;
        var bu = b &gt;&gt; 31;
        var bd = b &amp; Mask31;
        var m = ad * bu + au * bd;
        var mu = m &gt;&gt; 30;
        var md = m &amp; Mask30;
        return ((au * bu) &lt;&lt; 1) + mu + (md &lt;&lt; 31) + ad * bd;
    }
    private static ulong CalcModulo(ulong v)
    {
        var vu = v &gt;&gt; 61;
        var vd = v &amp; Modulo;
        var x = vu + vd;
        return x &lt; Modulo ? x : x - Modulo;
    }
}
</code></pre>

                                </div>
                                <footer>
    <div class="c-post-footer mt-3">
        <div class="c-post-footer__share">
            <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" url="/posts/20230128abc287" data-size="large">
                Tweet
            </a>
        </div>

        <hr>

        <div class="row justify-content-center">
            <div class="col-md-4 mt-3">
                <img class="rounded-circle c-icon-self--sm c-post-footer__icon" src="/assets/images/icon.svg" alt="icon">
            </div>
            <div class="col-md-4 mt-3">
                <h5 class="card-text">AconCavy</h5>
                <div class="card-text">C#が好きなひきこもり</div>
                <a class="nav-link fab fa-twitter fa-2x c-icon-sns" href="https://twitter.com/AconCavy"></a>
                <a class="nav-link fab fa-github fa-2x c-icon-sns" href="https://github.com/AconCavy"></a>
            </div>
        </div>
    </div>

</footer>

                            </div>
                        </div>
                    </article>
            </div>
        </div>
    </div>
</main>

<footer class="l-footer">
    <div class="container">
        <div class="row">
            <div class="col-md-12 text-center">
                <p>Copyright &#xA9; 2020-2023 AconCavy</p>
                <ul class="list-inline text-center small">
                        <li class="list-inline-item">
                            <a href="/feed.rss"><i class="fa fa-rss l-footer__feed"></i> RSS Feed</a>
                        </li>
                        <li class="list-inline-item">
                            <a href="/feed.atom"><i class="fa fa-rss l-footer__feed"></i> Atom Feed</a>
                        </li>
                </ul>
            </div>
        </div>
    </div>
</footer>


<script src="/mirror/cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
<script src="/mirror/cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js"></script>
<script src="/mirror/kit.fontawesome.com/defa8b99ee.js"></script>

<script src="/assets/vendor/prism/prism.js"></script>

<script async="" src="/mirror/platform.twitter.com/widgets.js" charset="utf-8"></script>





</body></html>