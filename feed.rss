<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>acon.log</title>
		<link>https://blog.aconcavy.dev/</link>
		<description />
		<copyright>Copyright © 2020-2024 AconCavy</copyright>
		<pubDate>Sat, 23 Mar 2024 15:07:51 GMT</pubDate>
		<lastBuildDate>Sat, 23 Mar 2024 15:07:51 GMT</lastBuildDate>
		<item>
			<title>ABC346</title>
			<link>https://blog.aconcavy.dev/posts/20240323abc346</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 346の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240323abc346</guid>
			<pubDate>Sat, 23 Mar 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 346の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc346"&gt;https://atcoder.jp/contests/abc346&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51542851"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;問題文通り、&lt;code&gt;B[i]=A[i]*A[i+1]&lt;/code&gt;となる&lt;code&gt;B&lt;/code&gt;を求め、それを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = new long[N - 1];
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        B[i] = A[i] * A[i + 1];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51551415"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;wbwbwwbwbwbw&lt;/code&gt;を十分な長さ連結した文字列を&lt;code&gt;S&lt;/code&gt;とします。&lt;br /&gt;
&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;w&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;についての累積和をそれぞれ計算しておき、長さ&lt;code&gt;w+b&lt;/code&gt;の区間の&lt;code&gt;w&lt;/code&gt;の個数と&lt;code&gt;b&lt;/code&gt;の個数が、それぞれ&lt;code&gt;w&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;であるかを判定することで答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (W, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = &amp;quot;wbwbwwbwbwbw&amp;quot;;
    while (S.Length &amp;lt; 300)
    {
        S += S;
    }

    var cumW = new int[S.Length + 1];
    var cumB = new int[S.Length + 1];
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        cumW[i + 1] += cumW[i];
        cumB[i + 1] += cumB[i];
        if (S[i] == 'w') cumW[i + 1]++;
        else cumB[i + 1]++;
    }

    var L = W + B;
    for (var i = 0; i + L &amp;lt;= S.Length; i++)
    {
        if (cumW[i + L] - cumW[i] == W &amp;amp;&amp;amp; cumB[i + L] - cumB[i] == B)
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51553756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;K&lt;/code&gt;までの総和&lt;code&gt;S&lt;/code&gt;は&lt;code&gt;K*(K+1)/2&lt;/code&gt;で求めることができ、&lt;code&gt;K&lt;/code&gt;以下の重複を除いた&lt;code&gt;A&lt;/code&gt;の値を&lt;code&gt;S&lt;/code&gt;から引いたものが答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var S = K * (K + 1) / 2;
    foreach (var a in A.Distinct().Where(x =&amp;gt; x &amp;lt;= K))
    {
        S -= a;
    }

    Console.WriteLine(S);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51571688"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,j,k] := i番目の文字がj(0|1)であるかつ、良い文字列であるk(0|1)ときのコストの最小値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;a = S[i], b = S[i]^1 とする。

i番目で良い文字列になるパターン
dp[i+1,a,1] = Min(dp[i+1,a,1], dp[i,a,0]);
dp[i+1,b,1] = Min(dp[i+1,b,1], dp[i,b,0] + C[i]);

i番目では良い文字列ではないパターン
dp[i+1,a,0] = Min(dp[i+1,a,0], dp[i,b,0]);
dp[i+1,b,0] = Min(dp[i+1,b,0], dp[i,a,0] + C[i]);

i番目までに既に良い文字列であるパターン
dp[i+1,a,1] = Min(dp[i+1,a,1], dp[i,b,1]);
dp[i+1,b,1] = Min(dp[i+1,b,1], dp[i,a,1] + C[i]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Min(dp[N,0,1], dp[N,1,1])&lt;/code&gt;が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
    var C = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var dp = new long[N + 1, 2, 2];
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 0; j &amp;lt; 2; j++)
        {
            for (var k = 0; k &amp;lt; 2; k++)
            {
                dp[i, j, k] = Inf;
            }
        }
    }

    dp[1, S[0], 0] = 0;
    dp[1, S[0] ^ 1, 0] = C[0];
    for (var i = 1; i &amp;lt; N; i++)
    {
        var a = S[i];
        var b = S[i] ^ 1;

        dp[i + 1, a, 1] = Math.Min(dp[i + 1, a, 1], dp[i, a, 0]);
        dp[i + 1, b, 1] = Math.Min(dp[i + 1, b, 1], dp[i, b, 0] + C[i]);

        dp[i + 1, a, 0] = Math.Min(dp[i + 1, a, 0], dp[i, b, 0]);
        dp[i + 1, b, 0] = Math.Min(dp[i + 1, b, 0], dp[i, a, 0] + C[i]);

        dp[i + 1, a, 1] = Math.Min(dp[i + 1, a, 1], dp[i, b, 1]);
        dp[i + 1, b, 1] = Math.Min(dp[i + 1, b, 1], dp[i, a, 1] + C[i]);
    }

    var answer = Math.Min(dp[N, 0, 1], dp[N, 1, 1]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc346/tasks/abc346_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC346/submissions/51584285"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最終的なマスの色は、マスに対する最後のクエリの操作によって上書きされるので、クエリを逆順で処理することを考えます。&lt;br /&gt;
1番目のクエリでは、&lt;code&gt;A&lt;/code&gt;行目に対してまだ操作が行われていないとき、&lt;code&gt;A&lt;/code&gt;行目のうちそれまでに塗りつぶした列以外のマスを塗りつぶすという操作になります。&lt;br /&gt;
同様に、2番目のクエリでは、&lt;code&gt;A&lt;/code&gt;列目に対してまだ操作が行われていないとき、&lt;code&gt;A&lt;/code&gt;列目のうちそれまでに塗りつぶした行以外のマスを塗りつぶすという操作になります。&lt;br /&gt;
このことから、塗りつぶしていない行とその数、塗りつぶしていない列とその数を管理しながらクエリを適用していくことで、すべてのクエリを適用した状態の色の数を数え上げることができます。&lt;br /&gt;
また、操作が行われなかったマスの数は&lt;code&gt;H*W-操作が行われたマスの数&lt;/code&gt;で求めることができ、この値を初期状態の色&lt;code&gt;0&lt;/code&gt;の個数に加える必要があります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, M) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    var query = new (int T, int A, int X)[M];
    for (var i = 0; i &amp;lt; M; i++)
    {
        query[i] = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    }

    Array.Reverse(query);
    var row = new int[H];
    var col = new int[W];
    Array.Fill(row, -1);
    Array.Fill(col, -1);
    var remH = H;
    var remW = W;
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (t, a, x) = query[i];
        a--;
        if (t == 1)
        {
            if (row[a] != -1) continue;
            row[a] = x;
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x] += remW;
            remH--;
        }
        else
        {
            if (col[a] != -1) continue;
            col[a] = x;
            if (!dict.ContainsKey(x)) dict[x] = 0;
            dict[x] += remH;
            remW--;
        }
    }

    var sum = dict.Values.Sum();
    var zero = (long)H * W - sum;
    if (!dict.ContainsKey(0)) dict[0] = 0;
    dict[0] += zero;

    Console.WriteLine(dict.Where(x =&amp;gt; x.Value &amp;gt; 0).Count());
    foreach (var (k, v) in dict.Where(x =&amp;gt; x.Value &amp;gt; 0).OrderBy(x =&amp;gt; x.Key))
    {
        Console.WriteLine($&amp;quot;{k} {v}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC345</title>
			<link>https://blog.aconcavy.dev/posts/20240317abc345</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 345の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240317abc345</guid>
			<pubDate>Sun, 17 Mar 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 345の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc345"&gt;https://atcoder.jp/contests/abc345&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51274575"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;の先頭が&lt;code&gt;&amp;lt;&lt;/code&gt;、末尾が&lt;code&gt;&amp;gt;&lt;/code&gt;、それ以外が&lt;code&gt;=&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S[0] == '&amp;lt;' &amp;amp;&amp;amp; S[^1] == '&amp;gt;';
    for (var i = 1; i &amp;lt; S.Length - 1; i++)
    {
        answer &amp;amp;= S[i] == '=';
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51278782"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;が正の整数である場合は、&lt;code&gt;(X+10-1)/10&lt;/code&gt;を計算することで、切り上げた値を得ることができます。&lt;br /&gt;
一方、&lt;code&gt;X&lt;/code&gt;が負の整数である場合は、切り上げは&lt;code&gt;0&lt;/code&gt;に近づける処理になるので、符号を正にした値を切り捨てた値の符号を負にすればいいので、&lt;code&gt;-(-X/10)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var X = Scanner.Scan&amp;lt;long&amp;gt;();
    var answer = X &amp;gt; 0 ? (X + 9) / 10 : -(-X / 10);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51306807"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字ごとに出現数を数え上げ、&lt;code&gt;count[c]&lt;/code&gt;を現在見ている箇所より右側に出現する文字&lt;code&gt;c&lt;/code&gt;の数とします。&lt;br /&gt;
同じ文字が複数出現する場合は、それらの位置を入れ替えたものは元の文字から変わらないので、答えを&lt;code&gt;+1&lt;/code&gt;します。
&lt;code&gt;i&lt;/code&gt;番目の文字と&lt;code&gt;i&amp;lt;j&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;番目の文字を入れ替えたとき、元の文字列とは異なる文字列になる組み合わせは、&lt;code&gt;i&lt;/code&gt;番目の文字列と異なる文字の数になります。&lt;br /&gt;
これは、&lt;code&gt;i&lt;/code&gt;を&lt;code&gt;0-indexed&lt;/code&gt;にすると、&lt;code&gt;N-i-count[c]&lt;/code&gt;通りになり、&lt;code&gt;count[c]&lt;/code&gt;を1減らすという操作を全ての&lt;code&gt;i&lt;/code&gt;において計算することで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var count = new long[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    long answer = 0;
    if (count.Any(x =&amp;gt; x &amp;gt; 1)) answer++;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i] - 'a';
        answer += N - i - count[c];
        count[c]--;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc345/tasks/abc345_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC345/submissions/51371503"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あり得る配置数を枝刈りを工夫して全探索を行います。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, H, W) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var T = new (int A, int B)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        T[i] = (a, b);
    }

    var G = new bool[H, W];

    bool Dfs((int A, int B)[] tiles, int k)
    {
        var result = true;
        for (var i = 0; i &amp;lt; H &amp;amp;&amp;amp; result; i++)
        {
            for (var j = 0; j &amp;lt; W &amp;amp;&amp;amp; result; j++)
            {
                result &amp;amp;= G[i, j];
            }
        }

        if (k &amp;gt;= N || result) return result;

        if (Dfs(tiles, k + 1)) return true;

        var (a, b) = tiles[k];
        for (var t = 0; t &amp;lt; 2; t++)
        {
            var end = false;
            for (var h = 0; h + a &amp;lt;= H &amp;amp;&amp;amp; !end; h++)
            {
                for (var w = 0; w + b &amp;lt;= W &amp;amp;&amp;amp; !end; w++)
                {
                    if (G[h, w]) continue;

                    var ok = true;
                    for (var i = 0; i &amp;lt; a &amp;amp;&amp;amp; ok; i++)
                    {
                        for (var j = 0; j &amp;lt; b &amp;amp;&amp;amp; ok; j++)
                        {
                            ok &amp;amp;= !G[h + i, w + j];
                        }
                    }

                    if (!ok) continue;

                    for (var i = 0; i &amp;lt; a; i++)
                    {
                        for (var j = 0; j &amp;lt; b; j++)
                        {
                            G[h + i, w + j] = true;
                        }
                    }

                    if (Dfs(tiles, k + 1)) return true;

                    for (var i = 0; i &amp;lt; a; i++)
                    {
                        for (var j = 0; j &amp;lt; b; j++)
                        {
                            G[h + i, w + j] = false;
                        }
                    }

                    end = true;
                }
            }

            if (a == b) break;
            (a, b) = (b, a);
        }

        return false;
    }

    var tiles = new (int A, int B)[N];
    foreach (var order in Permutation.Generate(N))
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            tiles[i] = T[order[i]];
        }

        if (Dfs(tiles, 0))
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}

public static class Permutation
{
    public static bool NextPermutation(Span&amp;lt;int&amp;gt; indices)
    {
        var n = indices.Length;
        var (i, j) = (n - 2, n - 1);
        while (i &amp;gt;= 0 &amp;amp;&amp;amp; indices[i] &amp;gt;= indices[i + 1]) i--;
        if (i == -1) return false;
        while (j &amp;gt; i &amp;amp;&amp;amp; indices[j] &amp;lt;= indices[i]) j--;
        (indices[i], indices[j]) = (indices[j], indices[i]);
        indices[(i + 1)..].Reverse();
        return true;
    }

    public static bool PreviousPermutation(Span&amp;lt;int&amp;gt; indices)
    {
        var n = indices.Length;
        var (i, j) = (n - 2, n - 1);
        while (i &amp;gt;= 0 &amp;amp;&amp;amp; indices[i] &amp;lt;= indices[i + 1]) i--;
        if (i == -1) return false;
        indices[(i + 1)..].Reverse();
        while (j &amp;gt; i &amp;amp;&amp;amp; indices[j - 1] &amp;lt; indices[i]) j--;
        (indices[i], indices[j]) = (indices[j], indices[i]);
        return true;
    }

    public static IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Generate(int n)
    {
        return Inner();

        IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Inner()
        {
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++) indices[i] = i;
            do { yield return indices; } while (NextPermutation(indices));
        }
    }

    public static IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; GenerateDescending(int n)
    {
        return Inner();

        IEnumerable&amp;lt;IReadOnlyList&amp;lt;int&amp;gt;&amp;gt; Inner()
        {
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++) indices[i] = n - 1 - i;
            do { yield return indices; } while (PreviousPermutation(indices));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC344</title>
			<link>https://blog.aconcavy.dev/posts/20240309abc344</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 344の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240309abc344</guid>
			<pubDate>Sat, 09 Mar 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 344の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc344"&gt;https://atcoder.jp/contests/abc344&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51023473"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を&lt;code&gt;|&lt;/code&gt;で分けたものの、1番目と3番目の文字列を結合したものが答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Split('|');
    var answer = S[0] + S[2];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51028592"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;が入力されるまで入力された値をリストに保持するを繰り返し、リストを反転させたものを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var list = new List&amp;lt;int&amp;gt;();
    while (true)
    {
        var v = Scanner.Scan&amp;lt;int&amp;gt;();
        list.Add(v);
        if (v == 0) break;
    }

    list.Reverse();
    Console.WriteLine(string.Join(Environment.NewLine, list));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51035730"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初期状態を&lt;code&gt;0&lt;/code&gt;のみの集合として、前回の集合の要素と今回の集合の要素の組み合わせの合計値の集合を次の集合にするという操作を3回行います。&lt;br /&gt;
3回操作を行った集合に&lt;code&gt;X&lt;/code&gt;の各要素が含まれているかを判定します。&lt;br /&gt;
全体の時間計算量は&lt;code&gt;O(N*M*L)&lt;/code&gt;になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var dp = new HashSet&amp;lt;long&amp;gt;();
    dp.Add(0);
    for (var i = 0; i &amp;lt; 3; i++)
    {
        var N = Scanner.Scan&amp;lt;int&amp;gt;();
        var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().Distinct().ToArray();
        var ndp = new HashSet&amp;lt;long&amp;gt;();
        foreach (var v in dp)
        {
            foreach (var a in A)
            {
                ndp.Add(v + a);
            }
        }

        dp = ndp;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    foreach (var x in X)
    {
        var answer = dp.Contains(x);
        Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51046772"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 文字がsとなるときの操作回数の最小値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初期状態&lt;code&gt;dp[&amp;quot;&amp;quot;]=0&lt;/code&gt;として、それまでの文字列&lt;code&gt;P[k]&lt;/code&gt;に&lt;code&gt;S[j]&lt;/code&gt;を末尾に加えた文字列&lt;code&gt;X&lt;/code&gt;が&lt;code&gt;T&lt;/code&gt;に前方一致する場合、&lt;code&gt;dp[X]=Min(dp[X],dp[P[k]]+1)&lt;/code&gt;で更新していき、最終的な&lt;code&gt;dp[T]&lt;/code&gt;の値が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dp = new Dictionary&amp;lt;string, int&amp;gt;();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    dp[&amp;quot;&amp;quot;] = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        var line = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
        var a = int.Parse(line[0]);
        var ndp = new Dictionary&amp;lt;string, int&amp;gt;(dp);
        foreach (var (s, c) in dp)
        {
            foreach (var t in line[1..])
            {
                if (s.Length + t.Length &amp;gt; T.Length) continue;
                var ok = true;
                for (var j = 0; j &amp;lt; t.Length &amp;amp;&amp;amp; ok; j++)
                {
                    ok &amp;amp;= t[j] == T[s.Length + j];
                }

                if (ok)
                {
                    var x = s + t;
                    if (!ndp.ContainsKey(x)) ndp[x] = Inf;
                    ndp[x] = Math.Min(ndp[x], c + 1);
                }
            }
        }

        dp = ndp;
    }

    var answer = dp.ContainsKey(T) ? dp[T] : -1;
    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc344/tasks/abc344_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC344/submissions/51057943"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;値&lt;code&gt;x&lt;/code&gt;に対して直前の値&lt;code&gt;prev[x]&lt;/code&gt;と直後の値&lt;code&gt;prev[x]&lt;/code&gt;を管理します。&lt;br /&gt;
1番目のクエリでは、&lt;code&gt;a=x, b=y, c=next[x]&lt;/code&gt;としたとき、&lt;code&gt;next[a]=b, next[b]=c, prev[b]=a, prev[c]=b&lt;/code&gt;として更新します。&lt;br /&gt;
2番目のクエリでは、&lt;code&gt;a=prev[x], c=next[x]&lt;/code&gt;としたとき、&lt;code&gt;next[a]=c, prev[c]=a&lt;/code&gt;として更新します。&lt;br /&gt;
全てのクエリを処理した後、先頭から順に値を列挙したものが答えとなります。&lt;br /&gt;
あらかじめ、最初の値の直前の値と、最後の値の直後の値に番兵を設定することで、最初と最後を意識することなく処理することができるようになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var prev = new Dictionary&amp;lt;int, int&amp;gt;();
    var next = new Dictionary&amp;lt;int, int&amp;gt;();
    next[A[^1]] = -1;
    prev[-1] = A[^1];
    prev[A[0]] = -2;
    next[-2] = A[0];
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        var u = A[i];
        var v = A[i + 1];
        next[u] = v;
        prev[v] = u;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var q = 1; q &amp;lt;= Q; q++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var (x, y) = (query[1], query[2]);
            var a = x;
            var b = y;
            var c = next[x];
            next[a] = b;
            next[b] = c;
            prev[b] = a;
            prev[c] = b;
        }
        else
        {
            var x = query[1];
            var a = prev[x];
            var b = x;
            var c = next[x];
            next[a] = c;
            prev[c] = a;
        }
    }

    var curr = next[-2];
    var answer = new List&amp;lt;int&amp;gt;();
    while (curr &amp;gt;= 0)
    {
        answer.Add(curr);
        curr = next[curr];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC343</title>
			<link>https://blog.aconcavy.dev/posts/20240302abc343</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 343の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240302abc343</guid>
			<pubDate>Sat, 02 Mar 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 343の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343"&gt;https://atcoder.jp/contests/abc343&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50767994"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C=A+B&lt;/code&gt;とし、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の間でfor文を回して&lt;code&gt;C&lt;/code&gt;以外の値であればそれを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = A + B;
    for (var i = 0; i &amp;lt; 10; i++)
    {
        if (i != C)
        {
            Console.WriteLine(i);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50775147"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;行目の出力は、&lt;code&gt;A[i][j]==1&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;を全て出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var list = new List&amp;lt;int&amp;gt;();
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (A[i][j] == 1)
            {
                list.Add(j + 1);
            }
        }

        Console.WriteLine(string.Join(&amp;quot; &amp;quot;, list));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50793087"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x*x*x=k&amp;lt;=N&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;を走査し、その&lt;code&gt;k&lt;/code&gt;を文字列としてみたときに回文であるかを判定し、回文であるときの最大の&lt;code&gt;k&lt;/code&gt;を求めます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();

    bool F(long x)
    {
        var s = x.ToString();
        var m = s.Length;
        for (int i = 0, j = m - 1; i &amp;lt;= j; i++, j--)
        {
            if (s[i] != s[j]) return false;
        }

        return true;
    }

    long answer = 0;
    for (long x = 1; x * x * x &amp;lt;= N; x++)
    {
        var k = x * x * x;
        if (k &amp;lt;= N &amp;amp;&amp;amp; F(k))
        {
            answer = k;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50799830"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;得点をKeyとした選手の番号の集合をもつ辞書などを使って現在の状態を管理します。&lt;br /&gt;
現在の&lt;code&gt;A&lt;/code&gt;の得点が&lt;code&gt;x&lt;/code&gt;であるとき、&lt;code&gt;y=x+B&lt;/code&gt;となる得点&lt;code&gt;y&lt;/code&gt;の集合に&lt;code&gt;A&lt;/code&gt;を追加し、得点&lt;code&gt;x&lt;/code&gt;の集合から&lt;code&gt;A&lt;/code&gt;を削除する操作を行います。&lt;br /&gt;
このとき、得点&lt;code&gt;x&lt;/code&gt;が空集合であれば、&lt;code&gt;x&lt;/code&gt;のキーを削除し、辞書に存在するキーの数が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new Dictionary&amp;lt;long, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    dp[0] = Enumerable.Range(0, N).ToHashSet();
    var P = new long[N];
    for (var i = 0; i &amp;lt; T; i++)
    {
        var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        A--;
        var curr = P[A];
        var next = curr + B;
        if (!dp.ContainsKey(next)) dp[next] = new HashSet&amp;lt;int&amp;gt;();
        dp[next].Add(A);
        dp[curr].Remove(A);
        P[A] = next;
        if (dp[curr].Count == 0) dp.Remove(curr);
        Console.WriteLine(dp.Count);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けていません。&lt;/p&gt;
&lt;!-- 
[コンテスト提出]()  
[復習提出]()

&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;

```csharp
```

&lt;/details&gt;
 --&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc343/tasks/abc343_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc343/submissions/50824854"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1番目に大きい値を&lt;code&gt;X1&lt;/code&gt;、&lt;code&gt;X1&lt;/code&gt;の個数を&lt;code&gt;C1&lt;/code&gt;、2番目に大きい値を&lt;code&gt;X2&lt;/code&gt;、&lt;code&gt;X2&lt;/code&gt;の個数を&lt;code&gt;C2&lt;/code&gt;とし、&lt;code&gt;i&lt;/code&gt;番目に&lt;code&gt;X1=A[i], C1=1, X2=0, C2=0&lt;/code&gt;の要素をもつ&lt;code&gt;SegmentTree&lt;/code&gt;を用意します。&lt;br /&gt;
&lt;code&gt;SegmentTree&lt;/code&gt;において、ある値&lt;code&gt;x&lt;/code&gt;とその個数&lt;code&gt;c&lt;/code&gt;があるとき、次のような演算をおこないます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;- X1&amp;lt;xならば、X1=x, C1=c, X2=X1, C2=C1
- それ以外かつX1==xならば、C1+=c,
- それ以外かつX2&amp;lt;xならば、X2=x, C2=c
- それ以外かつX2==xならば、C2+=c,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1番目のクエリでは、&lt;code&gt;SegmentTree&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目の要素を&lt;code&gt;X1=p, C1=1, X2=0, C2=0&lt;/code&gt;で更新します。&lt;br /&gt;
2番目のクエリでは、&lt;code&gt;SegmentTree&lt;/code&gt;の&lt;code&gt;l&lt;/code&gt;から&lt;code&gt;r&lt;/code&gt;について、上記の演算を行うことで、時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var st = new SegmentTree&amp;lt;Data&amp;gt;(N, new Oracle());
    for (var i = 0; i &amp;lt; N; i++)
    {
        st.Set(i, new Data(A[i], 1, 0, 0));
    }

    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var p = query[1] - 1;
            var x = query[2];
            var next = new Data(x, 1, 0, 0);
            st.Set(p, next);
        }
        else
        {
            var l = query[1] - 1;
            var r = query[2];
            var x = st.Query(l, r);
            Console.WriteLine(x.C2);
        }
    }
}

public readonly record struct Data(int X1, int C1, int X2, int C2);

public class Oracle : IOracle&amp;lt;Data&amp;gt;
{
    public Data IdentityElement =&amp;gt; new Data(0, 0, 0, 0);

    public Data Operate(Data a, Data b)
    {
        var x1 = 0;
        var c1 = 0;
        var x2 = 0;
        var c2 = 0;

        void F(int x, int c)
        {
            if (x1 &amp;lt; x)
            {
                x2 = x1;
                c2 = c1;
                x1 = x;
                c1 = c;
            }
            else if (x1 == x)
            {
                c1 += c;
            }
            else if (x2 &amp;lt; x)
            {
                x2 = x;
                c2 = c;
            }
            else if (x2 == x)
            {
                c2 += c;
            }
        }

        F(a.X1, a.C1);
        F(a.X2, a.C2);
        F(b.X1, b.C1);
        F(b.X2, b.C2);
        return new Data(x1, c1, x2, c2);
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid IdentityElement { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public class SegmentTree&amp;lt;TMonoid&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly int _log;
    private readonly int _dataSize;

    public SegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid&amp;gt; oracle) : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public SegmentTree(int length, IOracle&amp;lt;TMonoid&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, oracle.IdentityElement);
    }

    public void Set(int index, TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        return _data[index + _dataSize];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        var (sml, smr) = (_oracle.IdentityElement, _oracle.IdentityElement);
        left += _dataSize;
        right += _dataSize;
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC342</title>
			<link>https://blog.aconcavy.dev/posts/20240224abc342</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 342の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240224abc342</guid>
			<pubDate>Sat, 24 Feb 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 342の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc342"&gt;https://atcoder.jp/contests/abc342&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50558948"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字を数え上げ、出現数が1の文字の出現位置を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;
public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var count = new int[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    for (var i = 0; i &amp;lt; 26; i++)
    {
        if (count[i] == 1)
        {
            var answer = S.IndexOf((char)(i + 'a')) + 1;
            Console.WriteLine(answer);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50561667"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あらかじめ&lt;code&gt;P[i]&lt;/code&gt;の位置&lt;code&gt;pos[P[i]]&lt;/code&gt;を求めておき、&lt;code&gt;pos[A] &amp;lt; pos[B]&lt;/code&gt;なら&lt;code&gt;A&lt;/code&gt;を、それ以外ならば&lt;code&gt;B&lt;/code&gt;の値を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var pos = new int[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        pos[P[i]] = i;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (pos[a] &amp;lt; pos[b])
        {
            Console.WriteLine(a);
        }
        else
        {
            Console.WriteLine(b);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50581747"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;変換後の文字&lt;code&gt;d&lt;/code&gt;になる文字を集合として管理しながら、クエリごとに&lt;code&gt;c&lt;/code&gt;の集合を&lt;code&gt;d&lt;/code&gt;の集合にマージし、&lt;code&gt;c&lt;/code&gt;の集合を空にするという操作を行います。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; 26; i++)
    {
        dict[i] = new HashSet&amp;lt;int&amp;gt; { i };
    }

    while (Q-- &amp;gt; 0)
    {
        var (c, d) = Scanner.Scan&amp;lt;char, char&amp;gt;();
        if (c == d) continue;
        c -= 'a';
        d -= 'a';
        dict[d].UnionWith(dict[c]);
        dict[c].Clear();
    }

    var to = new int[26];
    for (var i = 0; i &amp;lt; 26; i++)
    {
        foreach (var c in dict[i])
        {
            to[c] = i;
        }
    }

    var answer = new char[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer[i] = (char)(to[S[i] - 'a'] + 'a');
    }

    Console.WriteLine(new string(answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50616552"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    const int M = (int)2e5 + 1;
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = (int)Math.Sqrt(A[i]); j * j &amp;gt; 0; j--)
        {
            var sq = j * j;
            if (A[i] % sq == 0) A[i] /= sq;
        }
    }

    var count = new long[M];
    foreach (var a in A)
    {
        count[a]++;
    }

    var answer = count[0] * (count[0] - 1) / 2 + count[0] * (N - count[0]);
    for (var i = 1; i &amp;lt; M; i++)
    {
        answer += count[i] * (count[i] - 1) / 2;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc342/tasks/abc342_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC342/submissions/50614877"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;駅を頂点、&lt;code&gt;l,d,k,c&lt;/code&gt;の情報を辺をもつ有向グラフとしたとき、頂点&lt;code&gt;N&lt;/code&gt;につながる頂点&lt;code&gt;x&lt;/code&gt;の&lt;code&gt;F(x)&lt;/code&gt;は、&lt;code&gt;F(x)=Max(F(x), l+(k-1)*d)&lt;/code&gt;として求めることができ、この頂点&lt;code&gt;x&lt;/code&gt;を始点とした最短経路問題としてDjikstra法で解くことができます。&lt;br /&gt;
頂点&lt;code&gt;u&lt;/code&gt;の&lt;code&gt;F(u)&lt;/code&gt;が決まっていて、頂点&lt;code&gt;u&lt;/code&gt;に繋がる頂点&lt;code&gt;v&lt;/code&gt;および情報&lt;code&gt;l,d,k,c&lt;/code&gt;があるとき、&lt;code&gt;F(u)-c&amp;lt;l&lt;/code&gt;であれば頂点&lt;code&gt;u&lt;/code&gt;から頂点&lt;code&gt;v&lt;/code&gt;に遷移することができ、&lt;code&gt;F(v)=l+Min(K-1,(F(u)-c-l)/d)*d&lt;/code&gt;として求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;Data&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;Data&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (l, d, k, c, A, B) = Scanner.Scan&amp;lt;int, int, int, int, int, int&amp;gt;();
        A--;
        B--;
        G[B].Add(new Data(A, l, d, k, c));
    }

    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var dp = new long[N];
    Array.Fill(dp, -Inf);
    var queue = new PriorityQueue&amp;lt;(int U, long C), long&amp;gt;();
    foreach (var (v, l, d, k, c) in G[N - 1])
    {
        var vc = l + (k - 1) * d;
        if (dp[v] &amp;lt; vc)
        {
            dp[v] = vc;
            queue.Enqueue((v, dp[v]), -dp[v]);
        }
    }

    while (queue.TryDequeue(out var top, out _))
    {
        var (u, uc) = top;
        if (dp[u] &amp;gt; uc) continue;
        foreach (var (v, l, d, k, c) in G[u])
        {
            if (dp[u] - c &amp;lt; l) continue;
            var vk = Math.Min(k - 1, (dp[u] - c - l) / d);
            var vc = l + vk * d;
            if (dp[v] &amp;gt;= vc) continue;
            dp[v] = vc;
            queue.Enqueue((v, dp[v]), -dp[v]);
        }
    }

    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var answer = dp[i] &amp;gt;= 0 ? dp[i].ToString() : &amp;quot;Unreachable&amp;quot;;
        Console.WriteLine(answer);
    }
}

public readonly record struct Data(int To, long L, long D, long K, long C);
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC341</title>
			<link>https://blog.aconcavy.dev/posts/20240217abc341</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 341の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240217abc341</guid>
			<pubDate>Sat, 17 Feb 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 341の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc341"&gt;https://atcoder.jp/contests/abc341&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50329620"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最初に&lt;code&gt;1&lt;/code&gt;から始めて、&lt;code&gt;N&lt;/code&gt;個の&lt;code&gt;01&lt;/code&gt;を繋げた文字列が答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var builder = new StringBuilder();
    builder.Append('1');
    for (var i = 0; i &amp;lt; N; i++)
    {
        builder.Append(&amp;quot;01&amp;quot;);
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50336089"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;が小さい順に&lt;code&gt;S[i]&lt;/code&gt;を&lt;code&gt;T[i]&lt;/code&gt;にする行動を可能な限り行い、最終的な&lt;code&gt;N&lt;/code&gt;の通貨の単位が答えになります。&lt;br /&gt;
つまり、&lt;code&gt;N&lt;/code&gt;未満の各&lt;code&gt;i&lt;/code&gt;において、&lt;code&gt;i+1&lt;/code&gt;の通貨を&lt;code&gt;A[i]/S*T&lt;/code&gt;増やすという作業を順に行うことで達成できます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (s, t) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        A[i + 1] += t * (A[i] / s);
    }

    var answer = A[^1];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50345688"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての陸の座標から移動を行い、文字列が示す順に移動を行い、経路上が全て陸の経路の数を数え上げます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    (int dh, int dw) Delta(char d)
    {
        return d switch
        {
            'L' =&amp;gt; (0, -1),
            'R' =&amp;gt; (0, 1),
            'U' =&amp;gt; (-1, 0),
            'D' =&amp;gt; (1, 0),
            _ =&amp;gt; (0, 0)
        };
    }

    (int h, int w) F(int ch, int cw)
    {
        foreach (var d in T)
        {
            var (dh, dw) = Delta(d);
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) return (-1, -1);
            if (G[nh][nw] == '#') return (-1, -1);
            ch = nh;
            cw = nw;
        }

        return (ch, cw);
    }

    var ok = new bool[H, W];
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == '#') continue;
            var (ch, cw) = F(i, j);
            if (ch &amp;lt; 0 || cw &amp;lt; 0) continue;
            ok[ch, cw] = true;
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (ok[i, j]) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50370958"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;以下の&lt;code&gt;N&lt;/code&gt;の倍数または&lt;code&gt;M&lt;/code&gt;の倍数の個数は、&lt;code&gt;N&lt;/code&gt;の倍数の個数と&lt;code&gt;M&lt;/code&gt;の倍数の個数から&lt;code&gt;LCM(N,M)&lt;/code&gt;の倍数の個数を引いたものとなります。&lt;br /&gt;
また、ちょうど一方のみで割り切れる数は、&lt;code&gt;x&lt;/code&gt;以下の&lt;code&gt;N&lt;/code&gt;の倍数または&lt;code&gt;M&lt;/code&gt;の倍数の個数からさらに&lt;code&gt;LCM(N,M)&lt;/code&gt;の倍数の個数を引いたものとなります。&lt;br /&gt;
よって、&lt;code&gt;x/N + x/M - x/LCM(N,M)*2 &amp;gt;= K&lt;/code&gt;となる&lt;code&gt;x&lt;/code&gt;を二部探索することで答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
    var lcm = Lcm(N, M);

    bool F(long x)
    {
        return (x / N) + (x / M) - ((x / lcm) * 2) &amp;gt;= K;
    }

    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var answer = BinarySearch(0, Inf, F);
    Console.WriteLine(answer);
}

public static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
public static long Lcm(long a, long b) =&amp;gt; a / Gcd(a, b) * b;

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f) where T : INumber&amp;lt;T&amp;gt; =&amp;gt; BinarySearch(ng, ok, f, T.One);

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f, T eps) where T : INumber&amp;lt;T&amp;gt;
{
    var one = T.One;
    var two = one + one;
    while (T.Abs(ok - ng) &amp;gt; eps)
    {
        var m = ng + (ok - ng) / two;
        if (f(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc341/tasks/abc341_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC341/submissions/50390978"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;隣り合う数字の変化量に注目します。&lt;br /&gt;
隣り合う数字が異なる場合、その変化量を&lt;code&gt;1&lt;/code&gt;とすると、&lt;code&gt;L&lt;/code&gt;文字目から&lt;code&gt;R&lt;/code&gt;文字目が良い文字列になる条件は、&lt;code&gt;L&lt;/code&gt;文字目から&lt;code&gt;R&lt;/code&gt;文字目までの変化量の総和がその文字列の長さ&lt;code&gt;-1&lt;/code&gt;であることになります。&lt;br /&gt;
例えば、&lt;code&gt;6&lt;/code&gt;文字の良い文字列の&lt;code&gt;010101&lt;/code&gt;の変化量は&lt;code&gt;5&lt;/code&gt;となり、&lt;code&gt;6&lt;/code&gt;文字の良い文字列ではない&lt;code&gt;011010&lt;/code&gt;の変化量は&lt;code&gt;4&lt;/code&gt;となります。&lt;br /&gt;
ある範囲を反転させるということは、&lt;code&gt;L-1&lt;/code&gt;文字目と&lt;code&gt;L&lt;/code&gt;文字目の変化量が&lt;code&gt;1-元の変化量&lt;/code&gt;になり、&lt;code&gt;L&lt;/code&gt;文字目から&lt;code&gt;R&lt;/code&gt;文字目の変化量は変わらず、&lt;code&gt;R&lt;/code&gt;文字目から&lt;code&gt;R+1&lt;/code&gt;文字目の変化量が&lt;code&gt;1-元の変化量&lt;/code&gt;になります。&lt;br /&gt;
よって、一点更新区間和の&lt;code&gt;SegmentTree&lt;/code&gt;を使って変化量を管理することで、クエリ当たり時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToArray();
    var A = new int[N - 1];

    var st = new SegmentTree&amp;lt;int&amp;gt;(N + 1, new Oracle());
    for (var i = 0; i + 1 &amp;lt; N; i++)
    {
        st.Set(i + 1, S[i] == S[i + 1] ? 0 : 1);
    }

    while (Q-- &amp;gt; 0)
    {
        var (t, l, r) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        if (t == 1)
        {
            st.Set(l - 1, 1 - st.Get(l - 1));
            st.Set(r, 1 - st.Get(r));
        }
        else
        {
            var answer = st.Query(l, r) == r - l;
            Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
        }
    }
}

public class Oracle : IOracle&amp;lt;int&amp;gt;
{
    public int IdentityElement =&amp;gt; 0;

    public int Operate(int a, int b)
    {
        return a + b;
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid IdentityElement { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public class SegmentTree&amp;lt;TMonoid&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly int _log;
    private readonly int _dataSize;

    public SegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid&amp;gt; oracle) : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public SegmentTree(int length, IOracle&amp;lt;TMonoid&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, oracle.IdentityElement);
    }

    public void Set(int index, TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        return _data[index + _dataSize];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        var (sml, smr) = (_oracle.IdentityElement, _oracle.IdentityElement);
        left += _dataSize;
        right += _dataSize;
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC340</title>
			<link>https://blog.aconcavy.dev/posts/20240210abc340</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 340の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240210abc340</guid>
			<pubDate>Sat, 10 Feb 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 340の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc340"&gt;https://atcoder.jp/contests/abc340&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc340/tasks/abc340_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC340/submissions/50139538"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初期値を&lt;code&gt;x&lt;/code&gt;として、&lt;code&gt;x&amp;lt;B&lt;/code&gt;の間&lt;code&gt;x&lt;/code&gt;を答えのリストに追加し、&lt;code&gt;x&lt;/code&gt;を&lt;code&gt;x+D&lt;/code&gt;に更新するという操作を行い、そのリストを出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, D) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var answers = new List&amp;lt;int&amp;gt;();
    var x = A;
    while (x &amp;lt;= B)
    {
        answers.Add(x);
        x += D;
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc340/tasks/abc340_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC340/submissions/50143462"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1番目のクエリの場合は、リストの末尾に&lt;code&gt;x&lt;/code&gt;を追加し、2番目のクエリの場合は、リストの末尾から&lt;code&gt;x&lt;/code&gt;番目の値を出力します。&lt;br /&gt;
C#の場合、リストの末尾から&lt;code&gt;x&lt;/code&gt;番目は、&lt;code&gt;list[list.Count-x]&lt;/code&gt;または&lt;code&gt;list[^x]&lt;/code&gt;で値を取得することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var list = new List&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (t, x) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (t == 1)
        {
            list.Add(x);
        }
        else
        {
            var answer = list[list.Count - x];
            Console.WriteLine(answer);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc340/tasks/abc340_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC340/submissions/50150152"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;メモ化再帰を行います。&lt;br /&gt;
既に計算した値を辞書に保持しておくことで、同じ計算を何度もする必要がなくなり、高速化することができます。&lt;br /&gt;
時間計算量は&lt;code&gt;O(logN)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var dp = new Dictionary&amp;lt;long, long&amp;gt;();

    long F(long x)
    {
        if (x &amp;lt; 2) return 0;
        if (dp.ContainsKey(x)) return dp[x];
        return dp[x] = x + F(x / 2) + F((x + 2) / 2);
    }

    var answer = F(N);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc340/tasks/abc340_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC340/submissions/50155059"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;i&lt;/code&gt;から頂点&lt;code&gt;i+1&lt;/code&gt;へ距離&lt;code&gt;A&lt;/code&gt;の辺と、頂点&lt;code&gt;i&lt;/code&gt;から頂点&lt;code&gt;X&lt;/code&gt;へ距離&lt;code&gt;B&lt;/code&gt;の辺を張り、頂点&lt;code&gt;1&lt;/code&gt;から頂点&lt;code&gt;N&lt;/code&gt;までの最短経路を求める問題とすることができ、ダイクストラ法で時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new List&amp;lt;(int, long)&amp;gt;[N + 1].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    for (var i = 1; i &amp;lt; N; i++)
    {
        var (a, b, x) = Scanner.Scan&amp;lt;long, long, int&amp;gt;();
        G[i].Add((i + 1, a));
        G[i].Add((x, b));
    }

    var dp = new long[N + 1];
    const long Inf = 1L &amp;lt;&amp;lt; 60;
    Array.Fill(dp, Inf);
    dp[1] = 0;
    var queue = new PriorityQueue&amp;lt;(int U, long C), long&amp;gt;();
    queue.Enqueue((1, 0), 0);
    while (queue.TryDequeue(out var top, out _))
    {
        var (u, uc) = top;
        if (dp[u] &amp;lt; uc) continue;
        foreach (var (v, vc) in G[u])
        {
            var nc = dp[u] + vc;
            if (dp[v] &amp;lt;= nc) continue;
            dp[v] = nc;
            queue.Enqueue((v, nc), nc);
        }
    }

    var answer = dp[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc340/tasks/abc340_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC340/submissions/50163839"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある箱&lt;code&gt;i&lt;/code&gt;のボールの数が&lt;code&gt;x&lt;/code&gt;のとき、全ての箱に&lt;code&gt;x/N&lt;/code&gt;個配り、&lt;code&gt;i+1&lt;/code&gt;から順に&lt;code&gt;x%N&lt;/code&gt;個の箱に&lt;code&gt;1&lt;/code&gt;個配る操作になります。&lt;br /&gt;
&lt;code&gt;i+1&lt;/code&gt;から順に&lt;code&gt;x%N&lt;/code&gt;個の箱に配る操作は、&lt;code&gt;i&lt;/code&gt;から右の&lt;code&gt;r=Min(x%N, N-1-i)&lt;/code&gt;個の区間、一番左から&lt;code&gt;x%N-r&lt;/code&gt;個の区間に&lt;code&gt;1&lt;/code&gt;個配る操作となります。&lt;br /&gt;
これは、1点更新区間加算の&lt;code&gt;LazySegmentTree&lt;/code&gt;を使うことで、時間計算量&lt;code&gt;O(N+(MlogN))&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var lst = new LazySegmentTree&amp;lt;Monoid, long&amp;gt;(N, new Oracle());
    for (var i = 0; i &amp;lt; N; i++)
    {
        lst.Set(i, new Monoid(A[i], 1));
    }

    foreach (var b in B)
    {
        var x = lst.Get(b);
        lst.Set(b, new Monoid(0, 1));
        var div = x.V / N;
        var rem = x.V % N;
        lst.Apply(0, N, div);
        var r = (int)Math.Min(rem, N - 1 - b);
        if (r &amp;gt; 0) lst.Apply(b + 1, b + 1 + r, 1);
        var l = (int)(rem - r);
        if (l &amp;gt; 0) lst.Apply(0, l, 1);
    }

    var answers = new long[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answers[i] = lst.Get(i).V;
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}

public readonly record struct Monoid(long V, int S);

public class Oracle : IOracle&amp;lt;Monoid, long&amp;gt;
{
    public long IdentityMapping =&amp;gt; 0;

    public Monoid IdentityElement =&amp;gt; new(0, 1);

    public long Compose(long f, long g)
    {
        return f + g;
    }

    public Monoid Map(long f, Monoid x)
    {
        return new Monoid(x.V + f * x.S, x.S);
    }

    public Monoid Operate(Monoid a, Monoid b)
    {
        return new Monoid(a.V + b.V, a.S + b.S);
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid IdentityElement { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public interface IOracle&amp;lt;TMonoid, TMapping&amp;gt; : IOracle&amp;lt;TMonoid&amp;gt;
{
    TMapping IdentityMapping { get; }
    TMonoid Map(TMapping f, TMonoid x);
    TMapping Compose(TMapping f, TMapping g);
}

public class LazySegmentTree&amp;lt;TMonoid, TMapping&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid, TMapping&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly TMapping[] _lazy;
    private readonly int _log;
    private readonly int _dataSize;

    public LazySegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid, TMapping&amp;gt; oracle)
        : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public LazySegmentTree(int length, IOracle&amp;lt;TMonoid, TMapping&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, _oracle.IdentityElement);
        _lazy = new TMapping[_dataSize];
        Array.Fill(_lazy, _oracle.IdentityMapping);
    }

    public void Set(int index, in TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        for (var i = _log; i &amp;gt;= 1; i--) Push(index &amp;gt;&amp;gt; i);
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        for (var i = _log; i &amp;gt;= 1; i--) Push(index &amp;gt;&amp;gt; i);
        return _data[index];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        if (left == right) return _oracle.IdentityElement;
        left += _dataSize;
        right += _dataSize;
        for (var i = _log; i &amp;gt;= 1; i--)
        {
            if ((left &amp;gt;&amp;gt; i) &amp;lt;&amp;lt; i != left) Push(left &amp;gt;&amp;gt; i);
            if ((right &amp;gt;&amp;gt; i) &amp;lt;&amp;lt; i != right) Push((right - 1) &amp;gt;&amp;gt; i);
        }

        var (sml, smr) = (_oracle.IdentityElement, _oracle.IdentityElement);
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public void Apply(int index, TMapping mapping)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        for (var i = _log; i &amp;gt;= 1; i--) Push(index &amp;gt;&amp;gt; i);
        _data[index] = _oracle.Map(mapping, _data[index]);
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public void Apply(int left, int right, in TMapping mapping)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        if (left == right) return;
        left += _dataSize;
        right += _dataSize;
        for (var i = _log; i &amp;gt;= 1; i--)
        {
            if ((left &amp;gt;&amp;gt; i) &amp;lt;&amp;lt; i != left) Push(left &amp;gt;&amp;gt; i);
            if ((right &amp;gt;&amp;gt; i) &amp;lt;&amp;lt; i != right) Push((right - 1) &amp;gt;&amp;gt; i);
        }

        var (l, r) = (left, right);
        while (l &amp;lt; r)
        {
            if ((l &amp;amp; 1) == 1) ApplyToAll(l++, mapping);
            if ((r &amp;amp; 1) == 1) ApplyToAll(--r, mapping);
            l &amp;gt;&amp;gt;= 1;
            r &amp;gt;&amp;gt;= 1;
        }

        for (var i = 1; i &amp;lt;= _log; i++)
        {
            if ((left &amp;gt;&amp;gt; i) &amp;lt;&amp;lt; i != left) Update(left &amp;gt;&amp;gt; i);
            if ((right &amp;gt;&amp;gt; i) &amp;lt;&amp;lt; i != right) Update((right - 1) &amp;gt;&amp;gt; i);
        }
    }

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        for (var i = _log; i &amp;gt;= 1; i--) Push(left &amp;gt;&amp;gt; i);
        var sm = _oracle.IdentityElement;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    Push(left);
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        for (var i = _log; i &amp;gt;= 1; i--) Push((right - 1) &amp;gt;&amp;gt; i);
        var sm = _oracle.IdentityElement;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    Push(right);
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);

    private void ApplyToAll(int k, in TMapping mapping)
    {
        _data[k] = _oracle.Map(mapping, _data[k]);
        if (k &amp;lt; _dataSize) _lazy[k] = _oracle.Compose(mapping, _lazy[k]);
    }

    private void Push(int k)
    {
        ApplyToAll(k &amp;lt;&amp;lt; 1, _lazy[k]);
        ApplyToAll((k &amp;lt;&amp;lt; 1) + 1, _lazy[k]);
        _lazy[k] = _oracle.IdentityMapping;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc340/tasks/abc340_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC340/submissions/50177594"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三角形の面積は&lt;code&gt;|XB-YA|/2&lt;/code&gt;で求めることができ、&lt;code&gt;|XB-YA|==2&lt;/code&gt;となる&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;を見つける必要があります。&lt;br /&gt;
この&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;は、拡張ユークリッド互除法で求めることができ、&lt;code&gt;g==Xb+Ya&lt;/code&gt;が成り立つとき、&lt;code&gt;g*c==(Xb+Ya)*c==2&lt;/code&gt;となる&lt;code&gt;c=2/g&lt;/code&gt;が存在する、つまり&lt;code&gt;2&lt;/code&gt;が&lt;code&gt;g&lt;/code&gt;で割り切れるとき、&lt;code&gt;(a*c, b*c)&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var g = ExtGcd(X, -Y, out var b, out var a);
    if (2 % g != 0)
    {
        Console.WriteLine(-1);
        return;
    }

    var c = 2 / g;
    Console.WriteLine($&amp;quot;{a * c} {b * c}&amp;quot;);
}

public static long ExtGcd(long a, long b, out long x, out long y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }

    var d = ExtGcd(b, a % b, out y, out x);
    y -= a / b * x;
    return d;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC339</title>
			<link>https://blog.aconcavy.dev/posts/20240203abc339</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 339の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240203abc339</guid>
			<pubDate>Sat, 03 Feb 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 339の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc339"&gt;https://atcoder.jp/contests/abc339&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc339/tasks/abc339_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC339/submissions/49912559"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を末尾から見ていき、&lt;code&gt;.&lt;/code&gt;が出現した次の文字以降の文字列を出力します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var i = S.Length - 1;
    while (S[i] != '.') i--;
    var answer = S[(i + 1)..];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc339/tasks/abc339_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC339/submissions/49920492"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上下左右の移動方向の差分&lt;code&gt;(dh,dw)&lt;/code&gt;をそれぞれ&lt;code&gt;U=(-1,0), D=(1,0), R=(0,1), L=(0,-1)&lt;/code&gt;とし、現在位置に向いている方向の差分を足した位置に移動させます。&lt;br /&gt;
このとき、&lt;code&gt;URDL&lt;/code&gt;の順に配列として並べてインデックスで参照し、時計回りに90度の回転をインデックスを&lt;code&gt;+1&lt;/code&gt;する、反時計回りに90度の回転をインデックスを&lt;code&gt;-1&lt;/code&gt;することに対応づけることで、楽に管理することができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G = new char[H, W];
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            G[i, j] = '.';
        }
    }

    var (ch, cw) = (0, 0);
    var delta = new[] { (-1, 0), (0, 1), (1, 0), (0, -1) };
    var dir = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (G[ch, cw] == '.')
        {
            G[ch, cw] = '#';
            dir = (dir + 1) % 4;
        }
        else
        {
            G[ch, cw] = '.';
            dir = (dir - 1 + 4) % 4;
        }

        var (dh, dw) = delta[dir];
        (ch, cw) = ((ch + dh + H) % H, (cw + dw + W) % W);
    }

    Printer.Print2D(G);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc339/tasks/abc339_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC339/submissions/49922683"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;答えを二部探索します。&lt;br /&gt;
バスの乗客数&lt;code&gt;x&lt;/code&gt;が与えられた情報に矛盾しないかの判定は、&lt;code&gt;A[i]&lt;/code&gt;を逆順で&lt;code&gt;x&lt;/code&gt;から引いていき、一度も&lt;code&gt;x&amp;lt;0&lt;/code&gt;にならない場合は矛盾しない乗客数となります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    bool F(long x)
    {
        for (var i = N - 1; i &amp;gt;= 0; i--)
        {
            x -= A[i];
            if (x &amp;lt; 0) return false;
        }

        return true;
    }

    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var answer = BinarySearch(-1, Inf, F);
    Console.WriteLine(answer);
}

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f) where T : INumber&amp;lt;T&amp;gt; =&amp;gt; BinarySearch(ng, ok, f, T.One);

public static T BinarySearch&amp;lt;T&amp;gt;(T ng, T ok, Func&amp;lt;T, bool&amp;gt; f, T eps) where T : INumber&amp;lt;T&amp;gt;
{
    var one = T.One;
    var two = one + one;
    while (T.Abs(ok - ng) &amp;gt; eps)
    {
        var m = ng + (ok - ng) / two;
        if (f(m)) ok = m;
        else ng = m;
    }

    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc339/tasks/abc339_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC339/submissions/49961277"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[ch1][cw1][ch2][cw2] := プレイヤー1が(ch1,cw1)、プレイヤー1が(ch2,cw2)にいるときの最小移動回数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは、各プレイヤーの現在位置を幅優先探索で最小移動回数を計算することで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new char[N][];
    var p = new List&amp;lt;(int H, int W)&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; N; j++)
        {
            if (S[i][j] == 'P')
            {
                p.Add((i, j));
            }
        }
    }

    const int Inf = 1 &amp;lt;&amp;lt; 30;

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };
    var queue = new Queue&amp;lt;Data&amp;gt;();
    var first = new Data(p[0].H, p[0].W, p[1].H, p[1].W);
    queue.Enqueue(first);
    var dp = new int[N, N, N, N];
    for (var h1 = 0; h1 &amp;lt; N; h1++)
    {
        for (var w1 = 0; w1 &amp;lt; N; w1++)
        {
            for (var h2 = 0; h2 &amp;lt; N; h2++)
            {
                for (var w2 = 0; w2 &amp;lt; N; w2++)
                {
                    dp[h1, w1, h2, w2] = Inf;
                }
            }
        }
    }

    dp[p[0].H, p[0].W, p[1].H, p[1].W] = 0;

    bool CanMove(int ch, int cw, int nh, int nw)
    {
        return 0 &amp;lt;= nh &amp;amp;&amp;amp; nh &amp;lt; N &amp;amp;&amp;amp; 0 &amp;lt;= nw &amp;amp;&amp;amp; nw &amp;lt; N &amp;amp;&amp;amp; S[nh][nw] != '#';
    }

    var answer = Inf;
    while (queue.Count &amp;gt; 0)
    {
        var curr = queue.Dequeue();
        var (ch1, cw1, ch2, cw2) = curr;
        foreach (var (dh, dw) in D4)
        {
            var (nh1, nw1) = (ch1 + dh, cw1 + dw);
            var (nh2, nw2) = (ch2 + dh, cw2 + dw);
            if (!CanMove(ch1, cw1, nh1, nw1)) (nh1, nw1) = (ch1, cw1);
            if (!CanMove(ch2, cw2, nh2, nw2)) (nh2, nw2) = (ch2, cw2);
            var next = new Data(nh1, nw1, nh2, nw2);
            if (dp[ch1, cw1, ch2, cw2] + 1 &amp;lt; dp[nh1, nw1, nh2, nw2])
            {
                dp[nh1, nw1, nh2, nw2] = dp[ch1, cw1, ch2, cw2] + 1;
                if (nh1 == nh2 &amp;amp;&amp;amp; nw1 == nw2)
                {
                    answer = Math.Min(answer, dp[nh1, nw1, nh2, nw2]);
                }
                else
                {
                    queue.Enqueue(next);
                }
            }
        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}

public readonly record struct Data(int H1, int W1, int H2, int W2);
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc339/tasks/abc339_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC339/submissions/49952774"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;を末尾とするときの部分列の最大の長さは、部分列の末尾が&lt;code&gt;x (A[i]-D&amp;lt;=x&amp;lt;=A[i]+D)&lt;/code&gt;のときの部分列の最大の長さ+1で求めることができます。&lt;br /&gt;
これは、区間の最大を求めるのSegmentTreeで時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができ、全体計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var max = A.Max() + 10;
    var st = new SegmentTree&amp;lt;int&amp;gt;(max, new Oracle());
    for (var i = 0; i &amp;lt; N; i++)
    {
        var l = Math.Max(0, A[i] - D);
        var r = Math.Min(A[i] + D + 1, max);
        var v = st.Query(l, r);
        st.Set(A[i], v + 1);
    }

    var answer = st.QueryToAll();
    Console.WriteLine(answer);
}

public class Oracle : IOracle&amp;lt;int&amp;gt;
{
    public int IdentityElement =&amp;gt; 0;

    public int Operate(int a, int b)
    {
        return Math.Max(a, b);
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid IdentityElement { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public class SegmentTree&amp;lt;TMonoid&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly int _log;
    private readonly int _dataSize;

    public SegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid&amp;gt; oracle) : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public SegmentTree(int length, IOracle&amp;lt;TMonoid&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, oracle.IdentityElement);
    }

    public void Set(int index, TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        return _data[index + _dataSize];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        var (sml, smr) = (_oracle.IdentityElement, _oracle.IdentityElement);
        left += _dataSize;
        right += _dataSize;
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.IdentityElement)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        var sm = _oracle.IdentityElement;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC338</title>
			<link>https://blog.aconcavy.dev/posts/20240127abc338</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 338の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240127abc338</guid>
			<pubDate>Sat, 27 Jan 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 338の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc338"&gt;https://atcoder.jp/contests/abc338&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc338/tasks/abc338_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC338/submissions/49692017"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先頭のみ大文字で、それ以降は全て小文字であることを判定します。&lt;br /&gt;
C#では、&lt;code&gt;char.IsUpper()&lt;/code&gt;で文字が大文字であるかを判定でき、&lt;code&gt;char.IsLower()&lt;/code&gt;で文字が小文字であるかを判定できます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = char.IsUpper(S[0]);
    for (var i = 1; i &amp;lt; S.Length; i++)
    {
        answer &amp;amp;= char.IsLower(S[i]);
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc338/tasks/abc338_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC338/submissions/49695705"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字の出現数を数え上げ、最大出現数とその文字を管理しながら、26文字を全探索します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var count = new int[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    var answer = 'a';
    var max = 0;
    for (var i = 0; i &amp;lt; 26; i++)
    {
        if (count[i] &amp;gt; max)
        {
            answer = (char)(i + 'a');
            max = count[i];
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc338/tasks/abc338_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC338/submissions/49720390"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;料理&lt;code&gt;A&lt;/code&gt;の数の最大は&lt;code&gt;A[i]==0&lt;/code&gt;のときを除いた&lt;code&gt;Q[i]/A[i]&lt;/code&gt;の最小となり、料理&lt;code&gt;A&lt;/code&gt;を作る数を固定して考えます。&lt;br /&gt;
料理&lt;code&gt;A&lt;/code&gt;の数を&lt;code&gt;a&lt;/code&gt;としたとき、&lt;code&gt;i&lt;/code&gt;番目の材料の残りは&lt;code&gt;R[i]=Q[i]-a*A[i]&lt;/code&gt;であり、この時料理&lt;code&gt;B&lt;/code&gt;の最大は&lt;code&gt;B[i]==0&lt;/code&gt;のときを除いた&lt;code&gt;R[i]/B[i]&lt;/code&gt;の最小&lt;code&gt;b&lt;/code&gt;になります。&lt;br /&gt;
よって、この&lt;code&gt;a+b&lt;/code&gt;の最大値が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var Q = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    const long Inf = 1L &amp;lt;&amp;lt; 60;
    var maxA = Inf;

    for (var i = 0; i &amp;lt; N; i++)
    {
        maxA = Math.Min(maxA, A[i] == 0 ? Inf : (Q[i] / A[i]));
    }

    long answer = 0;
    for (var a = 0; a &amp;lt;= maxA; a++)
    {
        var b = Inf;
        for (var i = 0; i &amp;lt; N; i++)
        {
            var r = Q[i] - a * A[i];
            var maxB = B[i] == 0 ? Inf : (r / B[i]);
            b = Math.Min(b, maxB);
        }

        answer = Math.Max(answer, a + b);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc338/tasks/abc338_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けていません。&lt;/p&gt;
&lt;!-- [コンテスト提出]()  
[復習提出]()

&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;

```csharp
``` --&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc338/tasks/abc338_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC338/submissions/49743811"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;弦を&lt;code&gt;A[i]&lt;/code&gt;から&lt;code&gt;B[i]&lt;/code&gt;の辺、&lt;code&gt;B[i]-A[i]&amp;gt;N&lt;/code&gt;の場合は&lt;code&gt;B[i]&lt;/code&gt;から&lt;code&gt;A[i]&lt;/code&gt;の1周分先の頂点とした&lt;code&gt;A[i]+N*2&lt;/code&gt;への辺とします。&lt;br /&gt;
また、&lt;code&gt;A[i]+1==B[i]&lt;/code&gt;の場合は円周上の辺と同じなので無視します。&lt;br /&gt;
辺の右端を降順に管理する優先度付きキューを用意します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;頂点&lt;code&gt;a&lt;/code&gt;を辺の左端、頂点&lt;code&gt;a&lt;/code&gt;から辺でつながる頂点を&lt;code&gt;b&lt;/code&gt;とします。&lt;/li&gt;
&lt;li&gt;キューから&lt;code&gt;a&lt;/code&gt;以下の頂点を削除します。&lt;/li&gt;
&lt;li&gt;キューの最初の頂点&lt;code&gt;x&lt;/code&gt;が&lt;code&gt;a&amp;lt;x&amp;amp;&amp;amp;x&amp;lt;b&lt;/code&gt;の場合は、弦が交差します。&lt;/li&gt;
&lt;li&gt;それ以外のとき、キューに&lt;code&gt;b&lt;/code&gt;を追加します。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;この操作を繰り返し、弦が交差するかどうかを判定します。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var M = N * 2;
    var G = new List&amp;lt;int&amp;gt;[M].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        if (a &amp;gt; b) (a, b) = (b, a);
        if (b - a &amp;gt; N) (a, b) = (b, a + M);
        if (a + 1 != b) G[a].Add(b);
    }

    var queue = new PriorityQueue&amp;lt;int, int&amp;gt;();
    for (var a = 0; a &amp;lt; M; a++)
    {
        while (queue.Count &amp;gt; 0 &amp;amp;&amp;amp; queue.Peek() &amp;lt;= a) queue.Dequeue();

        foreach (var b in G[a])
        {
            if (queue.TryPeek(out var x, out _))
            {
                if (a &amp;lt; x &amp;amp;&amp;amp; x &amp;lt; b)
                {
                    Console.WriteLine(&amp;quot;Yes&amp;quot;);
                    return;
                }
            }
        }

        foreach (var v in G[a])
        {
            queue.Enqueue(v, v);
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC337</title>
			<link>https://blog.aconcavy.dev/posts/20240120abc337</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 337の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20240120abc337</guid>
			<pubDate>Sat, 20 Jan 2024 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 337の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc337"&gt;https://atcoder.jp/contests/abc337&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc337/tasks/abc337_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC337/submissions/49433631"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;チーム高橋の合計得点とチーム青木の合計得点を数え上げます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var a = 0;
    var b = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a += x;
        b += y;
    }

    var answer = &amp;quot;Draw&amp;quot;;
    if (a &amp;gt; b) answer = &amp;quot;Takahashi&amp;quot;;
    if (b &amp;gt; a) answer = &amp;quot;Aoki&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc337/tasks/abc337_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC337/submissions/49460354"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;をそれぞれ&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;としたとき、&lt;code&gt;S[i]-S[i-1]&lt;/code&gt;が全ての&lt;code&gt;i (1&amp;lt;=i&amp;lt;N)&lt;/code&gt;において&lt;code&gt;0&lt;/code&gt;以上であることが拡張ABC文字列であることの条件になります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    for (var i = 1; i &amp;lt; S.Length; i++)
    {
        if (S[i] - S[i - 1] &amp;lt; 0)
        {
            Console.WriteLine(&amp;quot;No&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc337/tasks/abc337_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC337/submissions/49453358"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]==-1&lt;/code&gt;の場合は&lt;code&gt;curr=i&lt;/code&gt;とし、それ以外の場合は&lt;code&gt;next[A[i]]=i&lt;/code&gt;とすると、&lt;code&gt;i&lt;/code&gt;番目の人は&lt;code&gt;curr&lt;/code&gt;であり、その次の人は&lt;code&gt;curr=next[curr]&lt;/code&gt;になり、これを&lt;code&gt;N&lt;/code&gt;人分求めることで、答えを求めることができます。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var next = new int[N];
    var curr = -1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A[i] == -1) curr = i;
        else next[A[i] - 1] = i;
    }

    var answer = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer[i] = curr;
        curr = next[curr];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Select(x =&amp;gt; x + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc337/tasks/abc337_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC337/submissions/49494907"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;横に&lt;code&gt;K&lt;/code&gt;個のマスを全て&lt;code&gt;o&lt;/code&gt;にできるかを考えます。
これは、各行ごとに&lt;code&gt;o&lt;/code&gt;の数の累積和&lt;code&gt;cumO&lt;/code&gt;を求めておくことで、連続する&lt;code&gt;K&lt;/code&gt;列の区間にある&lt;code&gt;o&lt;/code&gt;の数を&lt;code&gt;cumO[i+K]-cumO[i]&lt;/code&gt;で求めることができ、&lt;code&gt;o&lt;/code&gt;の数を&lt;code&gt;c&lt;/code&gt;としたとき、&lt;code&gt;K-c&lt;/code&gt;が&lt;code&gt;.&lt;/code&gt;または&lt;code&gt;x&lt;/code&gt;の数になります。&lt;br /&gt;
そのため、&lt;code&gt;x&lt;/code&gt;の累積和&lt;code&gt;cumX&lt;/code&gt;を同様に求め、同じ区間の&lt;code&gt;x&lt;/code&gt;の数が&lt;code&gt;0&lt;/code&gt;の場合、その区間の&lt;code&gt;.&lt;/code&gt;の数は&lt;code&gt;K-c&lt;/code&gt;個となり、&lt;code&gt;K-c&lt;/code&gt;個を&lt;code&gt;o&lt;/code&gt;にすることで連続した&lt;code&gt;K&lt;/code&gt;列を&lt;code&gt;o&lt;/code&gt;にすることができます。
同様に縦の場合も考え、全ての連続する&lt;code&gt;K&lt;/code&gt;列または&lt;code&gt;K&lt;/code&gt;行のうち、その区間に&lt;code&gt;x&lt;/code&gt;が存在しない場合の&lt;code&gt;k-c&lt;/code&gt;の最小値が答えとなります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var S = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var oX = new long[H, W + 1];
    var oY = new long[H + 1, W];
    var xX = new long[H, W + 1];
    var xY = new long[H + 1, W];

    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            oX[i, j + 1] += oX[i, j];
            oY[i + 1, j] += oY[i, j];
            xX[i, j + 1] += xX[i, j];
            xY[i + 1, j] += xY[i, j];

            if (S[i][j] == 'o')
            {
                oX[i, j + 1] += 1;
                oY[i + 1, j] += 1;
            }
            else if (S[i][j] == 'x')
            {
                xX[i, j + 1] += 1;
                xY[i + 1, j] += 1;
            }
        }
    }

    const long Inf = 1 &amp;lt;&amp;lt; 30;
    var answer = Inf;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j + K &amp;lt;= W; j++)
        {
            var o = oX[i, j + K] - oX[i, j];
            var x = xX[i, j + K] - xX[i, j];
            if (x == 0) answer = Math.Min(answer, K - o);
        }
    }

    for (var j = 0; j &amp;lt; W; j++)
    {
        for (var i = 0; i + K &amp;lt;= H; i++)
        {
            if (S[i][j] == 'x') continue;

            var o = oY[i + K, j] - oY[i, j];
            var x = xY[i + K, j] - xY[i, j];
            if (x == 0) answer = Math.Min(answer, K - o);
        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc337/tasks/abc337_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC337/submissions/49502172"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;毒ワインで有名な問題です。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;本のジュースの毒を判別するための最少人数は&lt;code&gt;log2(N)&lt;/code&gt;人であり、&lt;code&gt;i&lt;/code&gt;番目の人が&lt;code&gt;x&lt;/code&gt;番目のジュースを飲むかどうかは、&lt;code&gt;x&lt;/code&gt;を2進数で見たときに&lt;code&gt;i&lt;/code&gt;番目のビットが&lt;code&gt;1&lt;/code&gt;である場合にのみ飲むことで、おなかを壊した人の文字列を2進数としてみることができるようになり、それを10進数に変換した番目のジュースが答えになります。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;例&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();

    var M = 0;
    while (1 &amp;lt;&amp;lt; M &amp;lt; N) M++;

    Console.WriteLine(M);
    var lists = new List&amp;lt;int&amp;gt;[M].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var k = 0; k &amp;lt; M; k++)
        {
            if ((i &amp;gt;&amp;gt; k &amp;amp; 1) == 1) lists[k].Add(i + 1);
        }
    }

    foreach (var list in lists)
    {
        Console.WriteLine($&amp;quot;{list.Count} {string.Join(&amp;quot; &amp;quot;, list)}&amp;quot;);
    }

    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        answer |= (S[i] - '0') &amp;lt;&amp;lt; i;
    }

    answer++;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>