<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>acon.log</title>
		<link>https://blog.aconcavy.dev/</link>
		<description />
		<copyright>Copyright © 2020-2023 AconCavy</copyright>
		<pubDate>Sat, 23 Sep 2023 18:52:08 GMT</pubDate>
		<lastBuildDate>Sat, 23 Sep 2023 18:52:08 GMT</lastBuildDate>
		<item>
			<title>ABC321</title>
			<link>https://blog.aconcavy.dev/posts/20230923abc321</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 321の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230923abc321</guid>
			<pubDate>Sat, 23 Sep 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 321の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc321"&gt;https://atcoder.jp/contests/abc321&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45817144"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;を文字列としてみたとき、全ての&lt;code&gt;1&amp;lt;=i&amp;lt;=N-1&lt;/code&gt;において&lt;code&gt;N[i]&amp;gt;N[i+1]&lt;/code&gt;が成り立つものが&lt;code&gt;321-like Number&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = true;
    for (var i = 0; i + 1 &amp;lt; N.Length; i++)
    {
        answer &amp;amp;= N[i] &amp;gt; N[i + 1];
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45824801"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後に&lt;code&gt;k&lt;/code&gt;点取ると固定したときの最終結果が&lt;code&gt;X&lt;/code&gt;以上になる&lt;code&gt;k&lt;/code&gt;を全探索します。&lt;br /&gt;
あらかじめ、&lt;code&gt;N-1&lt;/code&gt;試合の合計スコア(&lt;code&gt;sum&lt;/code&gt;)、最低スコア(&lt;code&gt;min&lt;/code&gt;)、最高スコア(&lt;code&gt;max&lt;/code&gt;)を計算しておくと、最終試験で&lt;code&gt;k&lt;/code&gt;点とった場合、最終結果は&lt;code&gt;sum + k - Min(min,k) - Max(max,k)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var min = A.Min();
    var max = A.Max();
    var sum = A.Sum();
    const int Inf = 1 &amp;lt;&amp;lt; 30;
    var answer = Inf;
    for (var k = 0; k &amp;lt;= 100; k++)
    {
        var mmin = Math.Min(min, k);
        var mmax = Math.Max(max, k);
        var x = sum + k - mmin - mmax;
        if (x &amp;gt;= X)
        {
            answer = Math.Min(answer, k);
        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45887284"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;321-like Number&lt;/code&gt;の各桁に同じ数字が現れることはないため、&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の数字をそれぞれ使う/使わないとしたときに、使う数字のみを降順に並べたものが&lt;code&gt;321-like Number&lt;/code&gt;になり得ます。&lt;br /&gt;
このことから、それぞれの数字を使う/使わないとする組み合わせ&lt;code&gt;2^10-1&lt;/code&gt;通りをbit全探索し、全ての&lt;code&gt;321-like Number&lt;/code&gt;を列挙してソートすることで、&lt;code&gt;K&lt;/code&gt;番目の値を得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new List&amp;lt;long&amp;gt;();
    for (var s = 1; s &amp;lt; 1 &amp;lt;&amp;lt; 10; s++)
    {
        var list = new List&amp;lt;int&amp;gt;();
        for (var i = 0; i &amp;lt; 10; i++)
        {
            if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1) list.Add(i);
        }

        list.Sort();
        list.Reverse();
        S.Add(long.Parse(string.Join(&amp;quot;&amp;quot;, list)));
    }

    S.Sort();
    var answer = S[K];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45853839"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある主菜&lt;code&gt;A[i]&lt;/code&gt;を固定したとき、副菜&lt;code&gt;B&lt;/code&gt;のうち価格が&lt;code&gt;P-A[i]&lt;/code&gt;以上のものは価格が&lt;code&gt;P&lt;/code&gt;となることから、&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;P-A[i]&lt;/code&gt;以上のものと&lt;code&gt;P-A[i]&lt;/code&gt;より小さいもので分けて考えることができます。&lt;br /&gt;
&lt;code&gt;P-A[i]&lt;/code&gt;以上のものの個数を&lt;code&gt;X&lt;/code&gt;としたとき、&lt;code&gt;P-A[i]&lt;/code&gt;以上のものの価格の総和は&lt;code&gt;M*P&lt;/code&gt;になります。&lt;br /&gt;
&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの個数は&lt;code&gt;M-X&lt;/code&gt;となり、&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格和を&lt;code&gt;S&lt;/code&gt;とすると、&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格の総和は&lt;code&gt;A[i]*(M-X)+S&lt;/code&gt;となります。
&lt;code&gt;B&lt;/code&gt;をあらかじめソートしておき、累積和を求めておくことで、各&lt;code&gt;A[i]&lt;/code&gt;ごとに&lt;code&gt;B&lt;/code&gt;のうち&lt;code&gt;P-A[i]&lt;/code&gt;以上の個数を時間計算量&lt;code&gt;O(logM)&lt;/code&gt;で求めることができ、累積和から&lt;code&gt;P-A[i]&lt;/code&gt;より小さいものの価格和を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。&lt;br /&gt;
よって、全体時間計算量&lt;code&gt;O(MlogM + NlogM)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, P) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(B);
    var cumB = new long[M + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        cumB[i + 1] = cumB[i] + B[i];
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var lb = LowerBound(B, Math.Max(0, P - A[i]));
        var x = A[i] * lb + cumB[lb];
        var y = (M - lb) * P;
        answer += x + y;
    }

    Console.WriteLine(answer);
}

public static int LowerBound&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
    =&amp;gt; LowerBound(System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source), key);

public static int LowerBound&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, T key) where T : IComparable&amp;lt;T&amp;gt;
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m].CompareTo(key) &amp;gt;= 0) r = m;
        else l = m;
    }

    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けていません。&lt;/p&gt;
&lt;!-- 
```csharp
``` --&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc321/tasks/abc321_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC321/submissions/45887679"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 現在のクエリまでみたとき、総和がsとなる組み合わせの個数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;if op == '+'
dp[j] += dp[i][j-x] (j=K,K-1,..,x+1,x)

if op == '-'
dp[j] -= dp[i][j-x] (j=x,x+1,..,K-1,K)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (Q, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new mint[K + 1];
    dp[0] = 1;
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (op, x) = Scanner.Scan&amp;lt;char, int&amp;gt;();
        if (op == '+')
        {
            for (var j = K; j &amp;gt;= x; j--)
            {
                dp[j] += dp[j - x];
            }
        }
        else
        {
            for (var j = x; j &amp;lt;= K; j++)
            {
                dp[j] -= dp[j - x];
            }
        }

        var answer = dp[K];
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC320</title>
			<link>https://blog.aconcavy.dev/posts/20230916abc320</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 320の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230916abc320</guid>
			<pubDate>Sat, 16 Sep 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 320の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320"&gt;https://atcoder.jp/contests/abc320&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45588498"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Math.Pow&lt;/code&gt;関数や、&lt;code&gt;for&lt;/code&gt;文で&lt;code&gt;A&lt;/code&gt;を&lt;code&gt;B&lt;/code&gt;回掛けたもの、&lt;code&gt;B&lt;/code&gt;を&lt;code&gt;A&lt;/code&gt;回掛けたものを求め、それぞれを足したものを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    var answer = Math.Pow(A, B) + Math.Pow(B, A);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45589841"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;連続する部分文字列の両端の組み合わせ&lt;code&gt;i,j (i&amp;lt;=j)&lt;/code&gt;を全探索し、その部分文字列が回文であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i; j &amp;lt; N; j++)
        {
            var ok = true;
            for (var k = 0; k &amp;lt;= j - i &amp;amp;&amp;amp; ok; k++)
            {
                var a = i + k;
                var b = j - k;
                ok &amp;amp;= S[a] == S[b];
            }

            if (ok)
            {
                answer = Math.Max(answer, j - i + 1);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45601337"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スロットのリールのうち、どの数字を止めるかを固定して考えます。&lt;br /&gt;
止める数字を固定したとき、各リールでその数字が出現する順番を全探索します。&lt;br /&gt;
出現する順番が一致しているリールが2つのとき、それぞれ1周目と2周目で止めることで、その数字をそろえることができます。&lt;br /&gt;
出現する順番が一致しているリールが3つのとき、それぞれ1周目、2週目、3週目で止めることで、その数字をそろえることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var M = Scanner.Scan&amp;lt;int&amp;gt;();
    var list = new List&amp;lt;int&amp;gt;[3][];
    for (var i = 0; i &amp;lt; 3; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
        list[i] = new List&amp;lt;int&amp;gt;[10].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
        for (var j = 0; j &amp;lt; M; j++)
        {
            list[i][S[j]].Add(j);
        }
    }

    const int Inf = (int)1e9;
    var answer = Inf;
    for (var k = 0; k &amp;lt; 10; k++)
    {
        foreach (var a in list[0][k])
        {
            foreach (var b in list[1][k])
            {
                foreach (var c in list[2][k])
                {
                    var x = a;
                    var y = b;
                    var z = c;
                    if (x == y &amp;amp;&amp;amp; y == z)
                    {
                        x += M;
                        y += M * 2;
                    }
                    else if (x == y)
                    {
                        y += M;
                    }
                    else if (x == z)
                    {
                        z += M;
                    }
                    else if (y == z)
                    {
                        z += M;
                    }

                    answer = Math.Min(answer, Math.Max(Math.Max(x, y), z));
                }
            }

        }
    }

    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45608907"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の頂点に対して、&lt;code&gt;M&lt;/code&gt;個の情報を&lt;code&gt;A[i]&lt;/code&gt;から&lt;code&gt;B[i]&lt;/code&gt;への&lt;code&gt;D(X[i],Y[i])&lt;/code&gt;となる有向辺と&lt;code&gt;B[i]&lt;/code&gt;から&lt;code&gt;A[i]&lt;/code&gt;への&lt;code&gt;D(-X[i],-Y[i])&lt;/code&gt;となる有向辺とした、&lt;code&gt;2M&lt;/code&gt;個の辺からなる有向グラフを構築し、人&lt;code&gt;1&lt;/code&gt;を始点とした幅優先探索を行い、それぞれの人の座標の集合を求めます。&lt;br /&gt;
各人のあり得る座標の集合において、一意に定まる場合はその座標を、それ以外の場合は&lt;code&gt;undecidable&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    const string Undecidable = &amp;quot;undecidable&amp;quot;;
    var G = new HashSet&amp;lt;(int, Point)&amp;gt;[N].Select(x =&amp;gt; new HashSet&amp;lt;(int, Point)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, x, y) = Scanner.Scan&amp;lt;int, int, long, long&amp;gt;();
        a--; b--;
        G[a].Add((b, new(x, y)));
        G[b].Add((a, new(-x, -y)));
    }

    var P = new HashSet&amp;lt;Point&amp;gt;[N].Select(_ =&amp;gt; new HashSet&amp;lt;Point&amp;gt;()).ToArray();
    P[0].Add(new(0, 0));
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(0);
    while (queue.TryDequeue(out var u))
    {
        var cp = P[u].First();
        foreach (var (v, diff) in G[u])
        {
            var (dx, dy) = diff;
            var np = new Point(cp.X + dx, cp.Y + dy);
            if (P[v].Contains(np)) continue;
            P[v].Add(np);
            queue.Enqueue(v);
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (P[i].Count == 1)
        {
            var p = P[i].First();
            Console.WriteLine($&amp;quot;{p.X} {p.Y}&amp;quot;);
        }
        else
        {
            Console.WriteLine(Undecidable);
        }
    }
}

public readonly record struct Point(long X, long Y);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc320/tasks/abc320_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc320/submissions/45623544"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待機列の人を番号順に管理できる優先度付きキューと、列から離れた人の番号と帰ってくる時間を時間順に管理できる優先度付きキューを用意し、そうめんが流れてくるごとに、その時間以前の列から離れた人を待機列に追加し、待機列の先頭の人にそうめんを獲得させ、その人を列から離れさせるというシミュレーションを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();

    var leavingID = new PriorityQueue&amp;lt;R&amp;gt;((x, y) =&amp;gt;
    {
        var result = x.Time.CompareTo(y.Time);
        if (result == 0) result = x.ID.CompareTo(y.ID);
        return result;
    });

    for (var i = 0; i &amp;lt; N; i++)
    {
        leavingID.Enqueue(new R(i, 0));
    }

    var waitingID = new PriorityQueue&amp;lt;int&amp;gt;((x, y) =&amp;gt; x.CompareTo(y));
    var answers = new long[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (t, w, s) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        while (leavingID.Count &amp;gt; 0 &amp;amp;&amp;amp; leavingID.Peek().Time &amp;lt;= t)
        {
            var (id, _) = leavingID.Dequeue();
            waitingID.Enqueue(id);
        }

        if (waitingID.Count == 0) continue;
        var waited = waitingID.Dequeue();
        answers[waited] += w;
        var nt = t + s;
        leavingID.Enqueue(new R(waited, nt));
    }

    Console.WriteLine(string.Join(Environment.NewLine, answers));
}

public readonly record struct R(int ID, long Time);

public class PriorityQueue&amp;lt;T&amp;gt; : IReadOnlyCollection&amp;lt;T&amp;gt;
{
    private readonly Comparison&amp;lt;T&amp;gt; _comparison;
    private readonly List&amp;lt;T&amp;gt; _heap;

    public PriorityQueue(IEnumerable&amp;lt;T&amp;gt; items, IComparer&amp;lt;T&amp;gt; comparer = null) : this(comparer)
    {
        foreach (var item in items) Enqueue(item);
    }

    public PriorityQueue(IEnumerable&amp;lt;T&amp;gt; items, Comparison&amp;lt;T&amp;gt; comparison) : this(comparison)
    {
        foreach (var item in items) Enqueue(item);
    }

    public PriorityQueue(IComparer&amp;lt;T&amp;gt; comparer = null) : this((comparer ?? Comparer&amp;lt;T&amp;gt;.Default).Compare) { }

    public PriorityQueue(Comparison&amp;lt;T&amp;gt; comparison)
    {
        _heap = new List&amp;lt;T&amp;gt;();
        _comparison = comparison;
    }

    public int Count =&amp;gt; _heap.Count;
    public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; _heap.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; GetEnumerator();

    public void Enqueue(T item)
    {
        var child = Count;
        _heap.Add(item);
        while (child &amp;gt; 0)
        {
            var parent = (child - 1) / 2;
            if (_comparison(_heap[parent], _heap[child]) &amp;lt;= 0) break;
            (_heap[parent], _heap[child]) = (_heap[child], _heap[parent]);
            child = parent;
        }
    }

    public T Dequeue()
    {
        if (Count == 0) throw new InvalidOperationException();
        var result = _heap[0];
        _heap[0] = _heap[Count - 1];
        _heap.RemoveAt(Count - 1);
        var parent = 0;
        while (parent * 2 + 1 &amp;lt; Count)
        {
            var left = parent * 2 + 1;
            var right = parent * 2 + 2;
            if (right &amp;lt; Count &amp;amp;&amp;amp; _comparison(_heap[left], _heap[right]) &amp;gt; 0)
                left = right;
            if (_comparison(_heap[parent], _heap[left]) &amp;lt;= 0) break;
            (_heap[parent], _heap[left]) = (_heap[left], _heap[parent]);
            parent = left;
        }

        return result;
    }

    public T Peek()
    {
        if (Count == 0) throw new InvalidOperationException();
        return _heap[0];
    }

    public bool TryDequeue(out T result)
    {
        if (Count &amp;gt; 0)
        {
            result = Dequeue();
            return true;
        }

        result = default;
        return false;
    }

    public bool TryPeek(out T result)
    {
        if (Count &amp;gt; 0)
        {
            result = Peek();
            return true;
        }

        result = default;
        return false;
    }

    public void Clear() =&amp;gt; _heap.Clear();
    public bool Contains(T item) =&amp;gt; _heap.Contains(item);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC319</title>
			<link>https://blog.aconcavy.dev/posts/20230909abc319</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 319の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230909abc319</guid>
			<pubDate>Sat, 09 Sep 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 319の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc319"&gt;https://atcoder.jp/contests/abc319&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45355649"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名前をキーとして辞書を作成し、対応するレートを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var T = &amp;#64;&amp;quot;tourist 3858
ksun48 3679
Benq 3658
Um_nik 3648
apiad 3638
Stonefeang 3630
ecnerwala 3613
mnbvmar 3555
newbiedmy 3516
semiexp 3481&amp;quot;;

    var dict = new Dictionary&amp;lt;string, string&amp;gt;();
    foreach (var line in T.Replace(&amp;quot;\r&amp;quot;, string.Empty).Split('\n'))
    {
        var array = line.Split(' ');
        dict[array[0]] = array[1];
    }

    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = dict[S];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45360297"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;i (0&amp;lt;=i&amp;lt;=N)&lt;/code&gt;について、条件を満たす&lt;code&gt;j (1&amp;lt;=j&amp;lt;=9)&lt;/code&gt;を全探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new char[N + 1];
    Array.Fill(S, '-');
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 1; j &amp;lt;= 9; j++)
        {
            if (N % j == 0 &amp;amp;&amp;amp; i % (N / j) == 0)
            {
                S[i] = (char)(j + '0');
                break;
            }
        }
    }

    var answer = new string(S);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45379425"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h&lt;/code&gt;行目&lt;code&gt;w&lt;/code&gt;列目(&lt;code&gt;0&amp;lt;=h,w&amp;lt;=2&lt;/code&gt;)のマス番号を&lt;code&gt;h*3+w&lt;/code&gt;とします。
高橋君が知るマス番号の順列について、&lt;code&gt;9!(362880)&lt;/code&gt;通りの全探索を行い、各マス番号の順列について、次の数字を管理しながらがっかりするものかどうかを判定します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt;行目の知った数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt;列目の知った数字&lt;/li&gt;
&lt;li&gt;左上から右下にかけての斜めの知った数字&lt;/li&gt;
&lt;li&gt;右上から左下にかけての斜めの知った数字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;(9! - がっかりしたマス番号の順列の個数) / 9!&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var C = new int[3][];
    for (var i = 0; i &amp;lt; 3; i++)
    {
        C[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    (int, int) F(int x) =&amp;gt; (x / 3, x % 3);

    var all = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;
    var p = all;
    var tate = new List&amp;lt;int&amp;gt;[3].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;(3)).ToArray();
    var yoko = new List&amp;lt;int&amp;gt;[3].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;(3)).ToArray();
    var naname1 = new List&amp;lt;int&amp;gt;();
    var naname2 = new List&amp;lt;int&amp;gt;();
    foreach (var items in Enumerable.Range(0, 9).Permute())
    {
        for (var i = 0; i &amp;lt; 3; i++)
        {
            yoko[i].Clear();
            tate[i].Clear();
        }
        naname1.Clear();
        naname2.Clear();

        var ng = false;
        for (var i = 0; i &amp;lt; 9 &amp;amp;&amp;amp; !ng; i++)
        {
            var (h, w) = F(items[i]);
            var v = C[h][w];
            yoko[h].Add(v);
            tate[w].Add(v);
            if (h - w == 0) naname1.Add(v);
            if (h + w == 2) naname2.Add(v);

            ng |= yoko[h].Count == 3 &amp;amp;&amp;amp; yoko[h][0] == yoko[h][1] &amp;amp;&amp;amp; yoko[h][0] != yoko[h][2];
            ng |= tate[w].Count == 3 &amp;amp;&amp;amp; tate[w][0] == tate[w][1] &amp;amp;&amp;amp; tate[w][0] != tate[w][2];
            ng |= naname1.Count == 3 &amp;amp;&amp;amp; naname1[0] == naname1[1] &amp;amp;&amp;amp; naname1[0] != naname1[2];
            ng |= naname2.Count == 3 &amp;amp;&amp;amp; naname2[0] == naname2[1] &amp;amp;&amp;amp; naname2[0] != naname2[2];
        }

        if (ng) p--;
    }

    var answer = (double)p / all;
    Console.WriteLine(answer);
}

public static partial class EnumerableExtension
{
    public static IEnumerable&amp;lt;T[]&amp;gt; Permute&amp;lt;T&amp;gt;(this IEnumerable&amp;lt;T&amp;gt; source)
    {
        if (source is null) throw new ArgumentNullException(nameof(source));
        IEnumerable&amp;lt;T[]&amp;gt; Inner()
        {
            var items = source.ToArray();
            var n = items.Length;
            var indices = new int[n];
            for (var i = 0; i &amp;lt; indices.Length; i++)
            {
                indices[i] = i;
            }
            T[] Result()
            {
                var result = new T[n];
                for (var i = 0; i &amp;lt; n; i++)
                {
                    result[i] = items[indices[i]];
                }
                return result;
            }
            yield return Result();
            while (true)
            {
                var (i, j) = (n - 2, n - 1);
                while (i &amp;gt;= 0)
                {
                    if (indices[i] &amp;lt; indices[i + 1]) break;
                    i--;
                }
                if (i == -1) yield break;
                while (true)
                {
                    if (indices[j] &amp;gt; indices[i]) break;
                    j--;
                }
                (indices[i], indices[j]) = (indices[j], indices[i]);
                Array.Reverse(indices, i + 1, n - 1 - i);
                yield return Result();
            }
        }
        return Inner();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45390878"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;幅を&lt;code&gt;W&lt;/code&gt;としたときに文章が&lt;code&gt;M&lt;/code&gt;行以内に収まるという判定式で、答えとなる&lt;code&gt;W&lt;/code&gt;を&lt;code&gt;[Max(L), Sum(L)+N-1)&lt;/code&gt;で二部探索します。&lt;br /&gt;
判定式では、&lt;code&gt;L[i]&lt;/code&gt;を順に見ていき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;現在見ている行の文字数が&lt;code&gt;0&lt;/code&gt;の場合、行の始まりなので文字数に&lt;code&gt;L[i]&lt;/code&gt;を足します。&lt;/li&gt;
&lt;li&gt;現在見ている行の文字数が&lt;code&gt;0&lt;/code&gt;より大きい場合、かつ空白と単語を追加できる場合、文字数に&lt;code&gt;1+L[i]&lt;/code&gt;を足します。&lt;/li&gt;
&lt;li&gt;現在見ている行の文字数が&lt;code&gt;0&lt;/code&gt;より大きい場合、かつ空白と単語を追加できない場合、行数を追加し文字数を&lt;code&gt;L[i]&lt;/code&gt;にします。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全ての&lt;code&gt;i&lt;/code&gt;を見たとき、行数が&lt;code&gt;M&lt;/code&gt;以内であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var L = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var min = L.Max();
    var max = L.Sum() + N - 1;

    bool F(long x)
    {
        var line = 1;
        long cum = 0;
        for (var i = 0; i &amp;lt; N; i++)
        {
            if (cum == 0)
            {
                cum += L[i];
            }
            else
            {
                if (cum + 1 + L[i] &amp;lt;= x)
                {
                    cum += 1 + L[i];
                }
                else
                {
                    cum = L[i];
                    line++;
                }
            }
        }

        return line &amp;lt;= M;
    }

    var answer = BinarySearch(min - 1, max, F);
    Console.WriteLine(answer);
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc319/tasks/abc319_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC319/submissions/45420594"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各バスについて&lt;code&gt;P[i]&lt;/code&gt;の周期があることから、全体で&lt;code&gt;Lcm(P)&lt;/code&gt;の周期があることがわかります。&lt;br /&gt;
そのため、高橋君の家から出発する時間をそれぞれ&lt;code&gt;0,1,...,Lcm(P)-1&lt;/code&gt;としたとき、青木君の家までかかる時間の累積和を時間計算量&lt;code&gt;O(Lcm*N)&lt;/code&gt;であらかじめ計算しておくことで、各クエリに対して時間計算量&lt;code&gt;O(1)&lt;/code&gt;で答えを求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var P = new int[N - 1];
    var T = new long[N - 1];
    long lcm = 1;
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var (p, t) = Scanner.Scan&amp;lt;int, long&amp;gt;();
        P[i] = p;
        T[i] = t;
        lcm = Lcm(lcm, p);
    }

    var cum = new long[lcm];
    for (var l = 0; l &amp;lt; lcm; l++)
    {
        cum[l] = l + X;
        for (var i = 0; i + 1 &amp;lt; N; i++)
        {
            cum[l] = (cum[l] + P[i] - 1) / P[i] * P[i] + T[i];
        }

        cum[l] += Y;
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var q = Scanner.Scan&amp;lt;int&amp;gt;();
        var answer = q / lcm * lcm + cum[q % lcm];
        Console.WriteLine(answer);
    }
}

public static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
public static long Lcm(long a, long b) =&amp;gt; a / Gcd(a, b) * b;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC318</title>
			<link>https://blog.aconcavy.dev/posts/20230902abc318</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 318の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230902abc318</guid>
			<pubDate>Sat, 02 Sep 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 318の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc318"&gt;https://atcoder.jp/contests/abc318&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45132398"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;日間のうち&lt;code&gt;M&lt;/code&gt;日目以降の期間は&lt;code&gt;N-M&lt;/code&gt;日間であり、この期間に&lt;code&gt;Floor(N-M)/P&lt;/code&gt;回満月を見ることができます。&lt;br /&gt;
これに&lt;code&gt;M&lt;/code&gt;日目を加えた、&lt;code&gt;Floor(N-M)/P+1&lt;/code&gt;が答えとなります。&lt;br /&gt;
&lt;code&gt;N-M&lt;/code&gt;が負数になることがあるので注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, P) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var answer = (N - M + P) / P;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45136636"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;シートは最大でも&lt;code&gt;0&amp;lt;=x&amp;lt;=100&lt;/code&gt;かつ&lt;code&gt;0&amp;lt;=y&amp;lt;=100&lt;/code&gt;なので、&lt;code&gt;100*100&lt;/code&gt;のグリッドを用意し、その領域がシートで覆われているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var H = 100;
    var W = 100;
    var G = new bool[H + 1, W + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b, c, d) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
        for (var x = a; x &amp;lt; b; x++)
        {
            for (var y = c; y &amp;lt; d; y++)
            {
                G[x, y] = true;
            }
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt;= H; i++)
    {
        for (var j = 0; j &amp;lt;= W; j++)
        {
            if (G[i, j]) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45140727"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周遊パスは好きな日に使うことができるので、&lt;code&gt;F&lt;/code&gt;をソートしても問題ありません。&lt;br /&gt;
次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i] := i日間の旅行でかかる最小金額
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;// i日目の運賃を通常料金で払うとき
dp[i+1] = Min(dp[i+1], dp[i]+F[i])

// i日目の運賃を周遊パスで払うとき
dp[i+D] = Min(dp[i+D], dp[i]+P)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i+D&lt;/code&gt;が&lt;code&gt;N&lt;/code&gt;より大きい場合は&lt;code&gt;N&lt;/code&gt;にまとめることができ、&lt;code&gt;dp[N]&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D, P) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var F = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(F);
    var cum = new long[N + 1];
    const long Inf = (long)1e18;
    Array.Fill(cum, Inf);
    cum[0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = Math.Min(cum[i + 1], cum[i] + F[i]);
        var x = Math.Min(i + D, N);
        cum[x] = Math.Min(cum[x], cum[i] + P);
    }

    var answer = cum[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45149396"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 既に選んだ頂点集合がsのときの選んだ重みの総和の最大値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;i番目の頂点とj番目の頂点がsに含まれていないとき、sにiとjを含んだ頂点集合をtとする。
dp[t] = Max(dp[t], dp[s]+D[i][j])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全ての頂点集合のうち、総和の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = new long[N, N];
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var d = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        for (var j = 0; j &amp;lt; d.Length; j++)
        {
            D[i, i + j + 1] = d[j];
        }
    }

    var dp = new long[1 &amp;lt;&amp;lt; N];
    dp[0] = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = i + 1; j &amp;lt; N; j++)
            {
                if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1 || (s &amp;gt;&amp;gt; j &amp;amp; 1) == 1) continue;
                var t = s | (1 &amp;lt;&amp;lt; i) | (1 &amp;lt;&amp;lt; j);
                dp[t] = Math.Max(dp[t], dp[s] + D[i, j]);
            }
        }
    }

    long answer = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        answer = Math.Max(answer, dp[s]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45196083"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;L[x]&lt;/code&gt;を現在左側にある&lt;code&gt;x&lt;/code&gt;の個数、&lt;code&gt;R[x]&lt;/code&gt;を現在右側にある&lt;code&gt;x&lt;/code&gt;の個数とします。&lt;br /&gt;
&lt;code&gt;j&lt;/code&gt;を固定したとき、&lt;code&gt;j&lt;/code&gt;に対して条件を満たす&lt;code&gt;i,k&lt;/code&gt;の組み合わせの個数は、&lt;code&gt;1&amp;lt;=y&amp;lt;=N&lt;/code&gt;かつ&lt;code&gt;y!=A[j]&lt;/code&gt;の&lt;code&gt;L[y]*R[y]&lt;/code&gt;の総和になります。&lt;br /&gt;
これにより、各&lt;code&gt;j&lt;/code&gt;に対して時間計算量&lt;code&gt;O(N)&lt;/code&gt;で組み合わせの個数を求めることができますが、全体時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、&lt;code&gt;j&lt;/code&gt;を1つずらしたとき、&lt;code&gt;L[A[j]]&lt;/code&gt;が1つ増え、&lt;code&gt;R[A[j]]&lt;/code&gt;が1つ減ることから、組み合わせの個数を累積和として管理し、各&lt;code&gt;j&lt;/code&gt;における差分のみを計算することで、各&lt;code&gt;j&lt;/code&gt;に対して時間計算量&lt;code&gt;O(1)&lt;/code&gt;で組み合わせの個数を求めることができるようになり、全体時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var L = new long[N + 1];
    var R = new long[N + 1];

    foreach (var a in A) R[a]++;

    long answer = 0;
    long cum = 0;
    foreach (var a in A)
    {
        cum -= L[a] * R[a];
        answer += cum;
        R[a]--;
        L[a]++;
        cum += L[a] * R[a];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC317</title>
			<link>https://blog.aconcavy.dev/posts/20230826abc317</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 317の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230826abc317</guid>
			<pubDate>Sat, 26 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 317の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc317"&gt;https://atcoder.jp/contests/abc317&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44936354"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;H+P[i]&amp;gt;=X&lt;/code&gt;となる最初の&lt;code&gt;i&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, H, X) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (H + P[i] &amp;gt;= X)
        {
            Console.WriteLine(i + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44940376"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;をソートし、&lt;code&gt;A[i-1]+1==A[i]&lt;/code&gt;ならば、それらの整数は連続しています。&lt;br /&gt;
そのため、&lt;code&gt;A[i-1]+1!=A[i]&lt;/code&gt;ならばそれらの整数が連続しておらず、&lt;code&gt;A[i-1]+1&lt;/code&gt;がなくした整数になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    Array.Sort(A);
    for (var i = 1; i &amp;lt; N; i++)
    {
        if (A[i - 1] + 1 != A[i])
        {
            Console.WriteLine(A[i - 1] + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44945752"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既に訪れた町と、現在通った道路の長さの和を管理しながら深さ優先探索を行います。
時間計算量&lt;code&gt;O(N!)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, c) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        G[a].Add((b, c));
        G[b].Add((a, c));
    }

    long answer = 0;
    var used = new bool[N];

    void Dfs(int u, long s)
    {
        answer = Math.Max(answer, s);
        used[v] = true;
        foreach (var (v, c) in G[u])
        {
            if (used[v]) continue;
            Dfs(v, s + c);
        }
        used[v] = false;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        Dfs(i, 0);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44957520"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44982250"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][s] := i番目の選挙区までみたとき、s議席獲得するために必要な鞍替えさせる必要がある人数の最小値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;v = (Max(0, Y[i]-X[i]) + 1) / 2; // i番目の選挙区において高橋派が過半数を得るために必要な、鞍替えさせる必要がある人数
dp[i+1][s] = Min(dp[i+1][s], dp[i][s-Z[i]] + v);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、&lt;code&gt;N&lt;/code&gt;個の選挙区全体として過半数の議席を獲得するには、全ての議席の数を&lt;code&gt;zs&lt;/code&gt;としたとき、必要な議席&lt;code&gt;req&lt;/code&gt;は&lt;code&gt;(zs+1)/2&lt;/code&gt;以上であるため、&lt;code&gt;dp[req]&lt;/code&gt;から&lt;code&gt;dp[zs]&lt;/code&gt;までの最小値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var V = new (long X, long Y, long Z)[N];
    long zs = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, z) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        V[i] = (x, y, z);
        zs += z;
    }

    const long Inf = (long)1e18;
    var dp = new long[zs + 1];
    Array.Fill(dp, Inf);
    dp[0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, z) = V[i];
        var v = (Math.Max(0, y - x) + 1) / 2;
        for (var s = zs; s &amp;gt;= z; s--)
        {
            dp[s] = Math.Min(dp[s], dp[s - z] + v);
        }
    }

    var req = (zs + 1) / 2;
    var answer = Inf;
    for (var s = req; s &amp;lt;= zs; s++)
    {
        answer = Math.Min(answer, dp[s]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44964613"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各人の視線をあらかじめ計算しておき、幅優先探索を行うことで答えを求めることができます。&lt;br /&gt;
グリッド内のマスのうち、侵入可能な&lt;code&gt;.&lt;/code&gt;、&lt;code&gt;S&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;のマスを侵入可能マス、人や障害物の侵入不可能マスをとしたとき、各人の視線は、各人のマスから各方向に対して侵入不可能マスまでの侵入可能マスを侵入不可能にします。&lt;br /&gt;
このことから&lt;code&gt;X[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目のマスを侵入可能かとしたとき、侵入不可能マスに加えて、侵入可能マスを侵入不可能にしたものに対して、&lt;code&gt;S&lt;/code&gt;のマスから&lt;code&gt;G&lt;/code&gt;のマスまでの最短距離を、グリッド上における4方向の幅優先探索で求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    var (sh, sw) = (-1, -1);
    var (gh, gw) = (-1, -1);
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == 'S') (sh, sw) = (i, j);
            if (G[i][j] == 'G') (gh, gw) = (i, j);
        }
    }

    bool IsPossible(int h, int w)
    {
        return 0 &amp;lt;= h &amp;amp;&amp;amp; h &amp;lt; H &amp;amp;&amp;amp; 0 &amp;lt;= w &amp;amp;&amp;amp; w &amp;lt; W &amp;amp;&amp;amp; (G[h][w] == '.' || G[h][w] == 'S' || G[h][w] == 'G');
    }

    var X = new bool[H, W];
    X[sh, sw] = X[gh, gw] = true;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (IsPossible(i, j)) X[i, j] = true;
        }
    }

    void F(char c)
    {
        var (dh, dw) = (0, 0);
        if (c == '&amp;gt;') dw = 1;
        if (c == 'v') dh = 1;
        if (c == '&amp;lt;') dw = -1;
        if (c == '^') dh = -1;

        for (var i = 0; i &amp;lt; H; i++)
        {
            for (var j = 0; j &amp;lt; W; j++)
            {
                if (G[i][j] == c)
                {
                    var k = 1;
                    while (IsPossible(i + dh * k, j + dw * k))
                    {
                        var ni = i + dh * k;
                        var nj = j + dw * k;
                        X[ni, nj] = false;
                        k++;
                    }
                }
            }
        }
    }

    F('&amp;gt;');
    F('v');
    F('&amp;lt;');
    F('^');

    var dp = new int[H, W];
    const int Inf = (int)1e9;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            dp[i, j] = Inf;
        }
    }

    dp[sh, sw] = 0;

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    var queue = new Queue&amp;lt;(int, int, int)&amp;gt;();
    queue.Enqueue((sh, sw, 0));
    while (queue.TryDequeue(out var top))
    {
        var (ch, cw, cc) = top;
        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            if (!X[nh, nw] || dp[nh, nw] &amp;lt;= cc + 1) continue;
            dp[nh, nw] = cc + 1;
            queue.Enqueue((nh, nw, cc + 1));
        }
    }

    var answer = dp[gh, gw];
    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC315</title>
			<link>https://blog.aconcavy.dev/posts/20230819abc315</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 315の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230819abc315</guid>
			<pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 315の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315"&gt;https://atcoder.jp/contests/abc315&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44708524"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aeiou&lt;/code&gt;以外の文字を連結したものが答えになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var builder = new StringBuilder();
    const string AEIOU = &amp;quot;aeiou&amp;quot;;
    foreach (var c in S)
    {
        if (!AEIOU.Contains(c)) builder.Append(c);
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44712931"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;真ん中の日&lt;code&gt;mid&lt;/code&gt;は、&lt;code&gt;(Dの総和+1)/2&lt;/code&gt;で求めることができます。&lt;br /&gt;
合計日数を数え上げながら順に月を見ていき、&lt;code&gt;その月以前の合計日数+その月の日数&lt;/code&gt;が&lt;code&gt;mid&lt;/code&gt;以上になったとき、その月が答えの月となり、&lt;code&gt;mid-その月以前の合計日数&lt;/code&gt;でその月の日にちを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var M = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var sum = D.Sum();
    var mid = (sum + 1) / 2;
    var cum = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        if (cum + D[i] &amp;lt; mid)
        {
            cum += D[i];
        }
        else
        {
            Console.WriteLine($&amp;quot;{i + 1} {(mid - cum)}&amp;quot;);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44732908"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2つのカップの組み合わせを愚直に探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、2つのカップの味が異なるときの最大値と、2つのカップの味が一緒の時の最大値を求め、最終的な最大値を求めます。&lt;br /&gt;
2つのカップの味が異なるとき、全てのカップのうち美味しさ&lt;code&gt;S&lt;/code&gt;が最大のものと、それとは異なる味のうち美味しさ&lt;code&gt;S&lt;/code&gt;が最大となるものが最大の満足度となります。&lt;br /&gt;
2つのカップの味が一緒のとき、各味において美味しさ&lt;code&gt;S&lt;/code&gt;が大きい方から2つ選んだものが、各味における満足度の最大となります。&lt;br /&gt;
これにより、2つのカップの味が異なるときの最大値と、各味2つ選んだ時の最大値のうち、最大となるものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new Dictionary&amp;lt;long, Dictionary&amp;lt;int, int&amp;gt;&amp;gt;();
    var ices = new (int F, long S)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (f, s) = Scanner.Scan&amp;lt;int, long&amp;gt;();
        ices[i] = (f, s);
    }

    Array.Sort(ices, (x, y) =&amp;gt; y.S.CompareTo(x.S));

    long answer = 0;
    for (var i = 1; i &amp;lt; N; i++)
    {
        if (ices[i].F != ices[0].F)
        {
            answer = ices[0].S + ices[i].S;
            break;
        }
    }

    var count = new int[N + 1];
    var same = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (f, s) = ices[i];
        if (count[f] == 0)
        {
            count[f]++;
            same[f] += s;
        }
        else if (count[f] == 1)
        {
            count[f]++;
            same[f] += s / 2;
        }
    }

    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer = Math.Max(answer, same[i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;また解けていません。&lt;/p&gt;
&lt;!-- [コンテスト提出]()  
[復習提出]()

```csharp
``` --&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44744826"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本&lt;code&gt;i&lt;/code&gt;の前提となる各本&lt;code&gt;P&lt;/code&gt;を、&lt;code&gt;i&lt;/code&gt;から各&lt;code&gt;P&lt;/code&gt;に対する有向辺としたグラフとしたとき、このグラフに対して&lt;code&gt;1&lt;/code&gt;を始点とした深さ優先探索の帰りがけ順に頂点を並べたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var queue = new Queue&amp;lt;int&amp;gt;();
    var used = new bool[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

        foreach (var v in P.Skip(1).Select(x =&amp;gt; x - 1))
        {
            G[i].Add(v);
        }
    }

    var answer = new List&amp;lt;int&amp;gt;();

    void Dfs(int u)
    {
        foreach (var v in G[u])
        {
            if (used[v]) continue;
            Dfs(v);
        }

        used[u] = true;
        answer.Add(u);
    }

    Dfs(0);

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Select(x =&amp;gt; x + 1).Where(x =&amp;gt; x != 1)));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC314</title>
			<link>https://blog.aconcavy.dev/posts/20230812abc314</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 314の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230812abc314</guid>
			<pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 314の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314"&gt;https://atcoder.jp/contests/abc314&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44488749"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;円周率を文字列&lt;code&gt;S&lt;/code&gt;としたとき、&lt;code&gt;3.&lt;/code&gt;と小数&lt;code&gt;N&lt;/code&gt;文字が答えとなるので、&lt;code&gt;S&lt;/code&gt;の先頭&lt;code&gt;N+2&lt;/code&gt;文字が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const string PI = &amp;quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&amp;quot;;
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = PI[..(N + 2)];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44495322"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[a,c]&lt;/code&gt;を&lt;code&gt;a&lt;/code&gt;に掛けた人のうち、掛けた個数が&lt;code&gt;c&lt;/code&gt;の人の番号の集合としたとき、空集合ではない&lt;code&gt;S[X,c]&lt;/code&gt;が答えとなり、そのような&lt;code&gt;c&lt;/code&gt;が存在しなければ、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int M = 37;
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new List&amp;lt;int&amp;gt;[M + 1, M + 1];
    for (var i = 0; i &amp;lt;= M; i++)
    {
        for (var j = 0; j &amp;lt;= M; j++)
        {
            S[i, j] = new List&amp;lt;int&amp;gt;();
        }
    }

    for (var i = 1; i &amp;lt;= N; i++)
    {
        var c = Scanner.Scan&amp;lt;int&amp;gt;();
        var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        foreach (var a in A)
        {
            S[a, c].Add(i);
        }
    }

    var X = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt;= M; i++)
    {
        if (S[X, i].Count == 0) continue;
        Console.WriteLine(S[X, i].Count);
        Console.WriteLine(string.Join(&amp;quot; &amp;quot;, S[X, i]));
        return;
    }

    Console.WriteLine(0);
    Console.WriteLine();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44498953"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各色ごとに出現位置を管理し、各文字を右シフトします。&lt;br /&gt;
現在の文字と同じ色の左の文字(一番左の場合は最後の文字)を&lt;code&gt;prev&lt;/code&gt;としたとき、現在の文字と&lt;code&gt;prev&lt;/code&gt;をスワップしていくことで、右シフトを実現できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var ID = new List&amp;lt;int&amp;gt;[M + 1].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        ID[C[i]].Add(i);
    }

    var T = S.ToCharArray();
    for (var i = 1; i &amp;lt;= M; i++)
    {
        if (ID[i].Count &amp;lt;= 1) continue;
        var idx = ID[i];
        var prev = T[idx[^1]];
        for (var j = 0; j &amp;lt; idx.Count; j++)
        {
            (T[idx[j]], prev) = (prev, T[idx[j]]);
        }
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44504779"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリを愚直に操作してしまうと、クエリが&lt;code&gt;t==2&lt;/code&gt;または&lt;code&gt;t==3&lt;/code&gt;のときごとに&lt;code&gt;S&lt;/code&gt;を全て見る必要があるため、全体時間計算量が&lt;code&gt;O(QN)&lt;/code&gt;になってしまい、実行時間制限に間に合いません。&lt;br /&gt;
&lt;code&gt;t==2&lt;/code&gt;のときと&lt;code&gt;t==3&lt;/code&gt;のときの操作を考えたとき、クエリが&lt;code&gt;t==2&lt;/code&gt;のとき、&lt;code&gt;S&lt;/code&gt;は全て小文字になり、&lt;code&gt;t==3&lt;/code&gt;のとき、&lt;code&gt;S&lt;/code&gt;は全て大文字になります。&lt;br /&gt;
このことから、&lt;code&gt;t==2&lt;/code&gt;または&lt;code&gt;t==3&lt;/code&gt;を大小の変更操作としたとき、クエリ全体の最後に出現する大小の変更操作より前の大小の変更操作は上書きされることがわかります。&lt;br /&gt;
あらかじめ、大小の変更操作の最終位置をクエリ先読みしておき、&lt;code&gt;t==1&lt;/code&gt;となるクエリを順に操作しつつ、大小の変更操作の最終位置でのみ&lt;code&gt;S&lt;/code&gt;の大小の変更操作を行うことで、&lt;code&gt;S&lt;/code&gt;を全てを操作することは1回で済むため、全体時間計算量&lt;code&gt;O(Q+N)&lt;/code&gt;で答えを求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var state = 0;
    var changed = -1;
    var T = S.ToCharArray();
    var queries = new (int T, int X, char C)[Q];
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (t, x, c) = Scanner.Scan&amp;lt;int, int, char&amp;gt;();
        x--;
        queries[i] = (t, x, c);
        if (t != 1)
        {
            state = t;
            changed = i;
        }
    }

    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (t, x, c) = queries[i];
        if (i == changed &amp;amp;&amp;amp; state != 1)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                T[j] = state == 2 ? char.ToLower(T[j]) : char.ToUpper(T[j]);
            }
        }

        if (t == 1)
        {
            T[x] = c;
        }
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC313</title>
			<link>https://blog.aconcavy.dev/posts/20230805abc313</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 313の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230805abc313</guid>
			<pubDate>Sat, 05 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 313の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313"&gt;https://atcoder.jp/contests/abc313&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44256971"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;が&lt;code&gt;1&lt;/code&gt;のときは、人&lt;code&gt;1&lt;/code&gt;が最強なので、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;br /&gt;
それ以外のときは、人&lt;code&gt;1&lt;/code&gt;以外の最大のプログラミング力に&lt;code&gt;+1&lt;/code&gt;したものから人&lt;code&gt;1&lt;/code&gt;のプログラミング力を引いたものが答えとなります。&lt;br /&gt;
ただし、人&lt;code&gt;1&lt;/code&gt;以外の最大のプログラミング力が人&lt;code&gt;1&lt;/code&gt;のプログラミング力よりも小さい場合、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var max = N &amp;gt; 1 ? P.Skip(1).Max() : 0;
    var answer = Math.Max(max + 1 - P[0], 0);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44268074"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;それぞれの人&lt;code&gt;x&lt;/code&gt;について、人&lt;code&gt;x&lt;/code&gt;よりも強い人の数を&lt;code&gt;deg[x]&lt;/code&gt;としたとき、&lt;code&gt;deg[x]&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;となる人&lt;code&gt;x&lt;/code&gt;が最強のプログラマー候補となります。&lt;br /&gt;
最強のプログラマー候補が複数人いる場合、最強となる人を特定することはできないので、答えは&lt;code&gt;-1&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var deg = new int[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        deg[b]++;
    }

    var answer = -1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (deg[i] != 0) continue;
        if (answer == -1)
        {
            answer = i + 1;
        }
        else
        {
            Console.WriteLine(-1);
            return;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44294553"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作を行ったところで、&lt;code&gt;A&lt;/code&gt;の合計値&lt;code&gt;Sum&lt;/code&gt;は変わらないことから、&lt;code&gt;A&lt;/code&gt;の平均値を&lt;code&gt;Ave&lt;/code&gt;としたとき、各要素は&lt;code&gt;Floor(Ave)&lt;/code&gt;もしくは&lt;code&gt;Ceil(Ave)&lt;/code&gt;にすることで、&lt;code&gt;A&lt;/code&gt;の最小値と最大値の差を&lt;code&gt;1&lt;/code&gt;以下にすることができます。&lt;br /&gt;
そして、&lt;code&gt;Ceil(Ave)&lt;/code&gt;になりうる値は、&lt;code&gt;Sum&lt;/code&gt;を&lt;code&gt;N&lt;/code&gt;で割った余り&lt;code&gt;M&lt;/code&gt;個であればいいことがわかります。&lt;br /&gt;
このことから、&lt;code&gt;A&lt;/code&gt;の大きい方から&lt;code&gt;M&lt;/code&gt;個を&lt;code&gt;Ceil(Ave)&lt;/code&gt;、残りの&lt;code&gt;N-M&lt;/code&gt;個を&lt;code&gt;Floor(Ceil)&lt;/code&gt;にしたときの回数を合わせ、&lt;code&gt;2&lt;/code&gt;で割ったものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    var sum = A.Sum();
    var ave = sum / N;
    var mod = sum % N;
    long answer = 0;
    for (var i = 0; i &amp;lt; N - mod; i++)
    {
        answer += Math.Abs(ave - A[i]);
    }

    for (var i = 0; i &amp;lt; mod; i++)
    {
        answer += Math.Abs(A[N - 1 - i] - (ave + 1));
    }

    answer = answer / 2;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC312</title>
			<link>https://blog.aconcavy.dev/posts/20230729abc312</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 312の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230729abc312</guid>
			<pubDate>Sat, 29 Jul 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 312の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc312"&gt;https://atcoder.jp/contests/abc312&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44032650"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;が候補となる文字列に存在するかを判定します。&lt;br /&gt;
一つ一つ判定しても答えを求めることができますが、あらかじめ候補となる文字列を配列などで管理しておき、存在判定することでも答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var OK = new string[] { &amp;quot;ACE&amp;quot;, &amp;quot;BDF&amp;quot;, &amp;quot;CEG&amp;quot;, &amp;quot;DFA&amp;quot;, &amp;quot;EGB&amp;quot;, &amp;quot;FAC&amp;quot;, &amp;quot;GBD&amp;quot; };
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = OK.Contains(S);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44045617"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;グリッドから&lt;code&gt;9*9&lt;/code&gt;の領域を全探索し、それぞれが条件を満たすかを判定します。&lt;br /&gt;
条件判定をそれぞれメソッドとして切り出すことで、読みやすくすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x == '#').ToArray();
    }

    bool CheckBlack(int h, int w)
    {
        var result = true;
        for (var i = 0; i &amp;lt; 3 &amp;amp;&amp;amp; result; i++)
        {
            for (var j = 0; j &amp;lt; 3 &amp;amp;&amp;amp; result; j++)
            {
                result &amp;amp;= G[h + i][w + j];
                result &amp;amp;= G[h + 6 + i][w + 6 + j];
            }
        }

        return result;
    }

    bool CheckWhite(int h, int w)
    {
        var result = true;
        for (var i = 0; i &amp;lt; 3 &amp;amp;&amp;amp; result; i++)
        {
            result &amp;amp;= !G[h + i][w + 3];
            result &amp;amp;= !G[h + 3][w + i];
            result &amp;amp;= !G[h + 6 + i][w + 6 - 1];
            result &amp;amp;= !G[h + 6 - 1][w + 6 + i];
        }

        result &amp;amp;= !G[h + 3][w + 3];
        result &amp;amp;= !G[h + 6 - 1][w + 6 - 1];

        return result;
    }

    for (var i = 0; i + 9 &amp;lt;= N; i++)
    {
        for (var j = 0; j + 9 &amp;lt;= M; j++)
        {
            if (CheckBlack(i, j) &amp;amp;&amp;amp; CheckWhite(i, j))
            {
                Console.WriteLine($&amp;quot;{i + 1} {j + 1}&amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44047011"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような&lt;code&gt;x&lt;/code&gt;を二部探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;りんごをx円で売ってもよいと考える売り手の人数が、りんごをx円で買ってもよいと考える買い手の人数以上である。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    bool F(long x)
    {
        var a = A.Count(v =&amp;gt; x &amp;gt;= v);
        var b = B.Count(v =&amp;gt; x &amp;lt;= v);
        return a &amp;gt;= b;
    }

    const long Inf = (long)1e18;
    var answer = BinarySearch(0, Inf, F);
    Console.WriteLine(answer);
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44050433"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;括弧列のレベルを、それまでの`(`の出現数から`)`の出現数を引いたものとしたとき、
dp[i,j] := i番目の文字まで見たとき、現在の括弧列のレベルがjとしてありえる文字列の数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;S[i]が`(`のとき、
dp[i+1,j+1] += dp[i,j] (0&amp;lt;=j&amp;lt;N)

S[i]が`)`のとき、
dp[i+1,j-1] += dp[i,j] (0&amp;lt;j&amp;lt;=N)

S[i]が`?`のとき、
dp[i+1,j+1] += dp[i,j] (0&amp;lt;=j&amp;lt;N)
dp[i+1,j-1] += dp[i,j] (0&amp;lt;j&amp;lt;=N)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;文字目までみたときの括弧列のレベルが&lt;code&gt;0&lt;/code&gt;となるものの数が答えとなります。
括弧列のレベルが0未満になる場合、その文字列は括弧列として成り立たないことに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var dp = new mint[N + 1, N + 1];
    dp[0, 0] = 1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i];
        if (c == '(' || c == '?')
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                dp[i + 1, j + 1] += dp[i, j];
            }
        }

        if (c == ')' || c == '?')
        {
            for (var j = 1; j &amp;lt;= N; j++)
            {
                dp[i + 1, j - 1] += dp[i, j];
            }
        }
    }

    var answer = dp[N, 0];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44087555"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3次元空間をグリッドとしてみたとき、各直方体がどのグリッドを占有しているかを管理し、各直方体のグリッドが面する直方体の種類数を数え上げます。&lt;br /&gt;
与えられる線分の座標は開区間であり、座標を開区間のまま管理すると面が重複してしまうことがあるため、半開区間に変換する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new int[105, 105, 105];
    var P = new (int X1, int Y1, int Z1, int X2, int Y2, int Z2)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x1, y1, z1, x2, y2, z2) = Scanner.Scan&amp;lt;int, int, int, int, int, int&amp;gt;();
        x1++; y1++; z1++;
        P[i] = (x1, y1, z1, x2, y2, z2);

        for (var x = x1; x &amp;lt;= x2; x++)
        {
            for (var y = y1; y &amp;lt;= y2; y++)
            {
                for (var z = z1; z &amp;lt;= z2; z++)
                {
                    G[x, y, z] = i + 1;
                }
            }
        }
    }

    foreach (var (x1, y1, z1, x2, y2, z2) in P)
    {
        var set = new HashSet&amp;lt;int&amp;gt;();
        for (var x = x1; x &amp;lt;= x2; x++)
        {
            for (var y = y1; y &amp;lt;= y2; y++)
            {
                for (var z = z1; z &amp;lt;= z2; z++)
                {
                    set.Add(G[x1 - 1, y, z]);
                    set.Add(G[x2 + 1, y, z]);
                    set.Add(G[x, y1 - 1, z]);
                    set.Add(G[x, y2 + 1, z]);
                    set.Add(G[x, y, z1 - 1]);
                    set.Add(G[x, y, z2 + 1]);
                }
            }
        }

        set.Remove(0);
        Console.WriteLine(set.Count);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44058275"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M&lt;/code&gt;個の品物のうち、缶切りが不要な缶を&lt;code&gt;x&lt;/code&gt;個として固定したとき、缶切りが必要な缶と缶切りを&lt;code&gt;M-x&lt;/code&gt;個選んだ時の満足度の最大値を求めます。&lt;br /&gt;
缶切りが不要な缶と缶切りが必要な缶は、いずれも満足度が大きいものから選ぶことが最適になります。&lt;br /&gt;
また、缶切りは使用できる缶の数が多い物から順に使うことが最適になります。&lt;br /&gt;
これにより、あらかじめ、缶切りが不要な缶を&lt;code&gt;a&lt;/code&gt;個選んだ時の満足度の累積和と、缶切りが必要な缶と缶切りを合わせて&lt;code&gt;b&lt;/code&gt;個選んだ時の満足度の累積和を求めておくことで、時間計算量&lt;code&gt;O(M)&lt;/code&gt;で満足度の最大値を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var cans0 = new List&amp;lt;long&amp;gt;();
    var cans1 = new List&amp;lt;long&amp;gt;();
    var openers = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (T, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (T == 0)
        {
            cans0.Add(X);
        }
        else if (T == 1)
        {
            cans1.Add(X);
        }
        else
        {
            openers.Add(X);
        }
    }

    cans0.Sort();
    cans0.Reverse();
    cans1.Sort();
    cans1.Reverse();
    openers.Sort();
    openers.Reverse();
    var N0 = cans0.Count;
    var N1 = cans1.Count;
    var N2 = openers.Count;

    var cum0 = new long[M + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        cum0[i + 1] = cum0[i];
        if (i &amp;lt; N0) cum0[i + 1] += cans0[i];
    }

    var cum1 = new long[M + 1];
    {
        var i = 0;
        var j = 0;
        var rem = 0;
        for (var k = 0; k &amp;lt; M; k++)
        {
            cum1[k + 1] += cum1[k];
            if (rem &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; N1)
            {
                cum1[k + 1] += cans1[i++];
                rem--;
            }
            else if (j &amp;lt; N2)
            {
                rem = openers[j++];
            }
        }
    }

    long answer = 0;
    for (var i = 0; i &amp;lt;= M; i++)
    {
        answer = Math.Max(answer, cum0[i] + cum1[M - i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC311</title>
			<link>https://blog.aconcavy.dev/posts/20230722abc311</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 311の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230722abc311</guid>
			<pubDate>Sat, 22 Jul 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 311の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc311"&gt;https://atcoder.jp/contests/abc311&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43827108"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;型は整数型として扱うことができるので、対象となる文字から&lt;code&gt;A&lt;/code&gt;を引くことで、&lt;code&gt;A&lt;/code&gt;の場合は&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;の場合は&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;の場合は&lt;code&gt;2&lt;/code&gt;にすることができ、配列のインデックスとして状態を管理することができます。&lt;br /&gt;
長さが&lt;code&gt;3&lt;/code&gt;の&lt;code&gt;bool&lt;/code&gt;型配列の全てが&lt;code&gt;true&lt;/code&gt;になったときが何番目かを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var used = new bool[3];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i] - 'A';
        used[c] = true;
        if (used.All(x =&amp;gt; x))
        {
            Console.WriteLine($&amp;quot;{i + 1}&amp;quot;);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43836246"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;番目の人の&lt;code&gt;j&lt;/code&gt;日目までに連続する暇な日数としたとき、&lt;code&gt;j&lt;/code&gt;日目の全ての人の連続する暇な日数の最小値は、&lt;code&gt;j&lt;/code&gt;日目における選べる日数の最大値になります。&lt;br /&gt;
このことから、全ての&lt;code&gt;j&lt;/code&gt;における選べる日数の最大値が答えとなります。
&lt;code&gt;j&lt;/code&gt;日目までに連続する暇な日数は累積和で求めることができ、全体時間計算量&lt;code&gt;O(ND)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var X = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        X[i] = new int[D + 1];
        for (var j = 0; j &amp;lt; D; j++)
        {
            if (s[j] == 'o')
            {
                X[i][j + 1] = X[i][j] + 1;
            }
        }
    }

    var answer = 0;
    const int Inf = (int)1e9;
    for (var j = 0; j &amp;lt;= D; j++)
    {
        var min = Inf;
        for (var i = 0; i &amp;lt; N; i++)
        {
            min = Math.Min(min, X[i][j]);
        }

        answer = Math.Max(answer, min);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43845949"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Disjoint Set Union&lt;/code&gt;などでグラフにおける閉路の検知と始点を決めます。
深さ優先探索を行い、現在の頂点から既に訪れた頂点にたどり着くことができるかを判定していき、たどり着くことができるならば、その頂点は閉路を構成しているため、答えに追加するという操作を行います。&lt;br /&gt;
この方法では、答えが逆順に追加されていることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var answer = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i].Add(A[i]);
    }

    var dsu = new DisjointSetUnion(N);
    var s = -1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (dsu.IsSame(i, A[i]))
        {
            s = A[i];
            break;
        }

        dsu.Merge(i, A[i]);
    }

    var used = new bool[N];
    bool Dfs(int u)
    {
        if (used[u]) return true;

        used[u] = true;
        var result = false;
        foreach (var v in G[u])
        {
            result |= Dfs(v);
        }

        if (result)
        {
            answer.Add(u);
        }

        return result;
    }

    Dfs(s);
    answer.Reverse();
    Console.WriteLine(answer.Count);
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Select(x =&amp;gt; x + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43852101"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;visited[i][j][d]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目に方向&lt;code&gt;d&lt;/code&gt;で訪れたことがあるかとした幅優先探索を行います。&lt;br /&gt;
いずれかの方向で&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目に訪れることができれば、プレイヤーが触れることができる氷とすることができ、この数の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x == '.').ToArray();
    }

    var visited = new bool[N, M, 4];
    var queue = new Queue&amp;lt;(int H, int W, int D)&amp;gt;();
    for (var i = 0; i &amp;lt; 4; i++)
    {
        visited[1, 1, i] = true;
        queue.Enqueue((1, 1, i));
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    while (queue.Count &amp;gt; 0)
    {
        var (ch, cw, d) = queue.Dequeue();

        var (dh1, dw1) = D4[d];
        var (nh1, nw1) = (ch + dh1, cw + dw1);

        if (nh1 &amp;lt; 0 || N &amp;lt;= nh1 || nw1 &amp;lt; 0 || M &amp;lt;= nw1) continue;
        if (visited[nh1, nw1, d]) continue;
        if (G[nh1][nw1])
        {
            visited[nh1, nw1, d] = true;
            queue.Enqueue((nh1, nw1, d));
        }
        else
        {
            for (var d = 0; d &amp;lt; 4; d++)
            {
                var (dh2, dw2) = D4[d];
                var (nh2, nw2) = (ch + dh2, cw + dw2);
                if (nh2 &amp;lt; 0 || N &amp;lt;= nh2 || nw2 &amp;lt; 0 || M &amp;lt;= nw2) continue;
                if (visited[nh2, nw2, d] || !G[nh2][nw2]) continue;
                visited[nh2, nw2, d] = true;
                queue.Enqueue((nh2, nw2, d));
            }
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; M; j++)
        {
            var ok = false;
            for (var d = 0; d &amp;lt; 4; d++)
            {
                ok |= visited[i, j, d];
            }

            if (ok) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43864378"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][j] := (i,j)を正方形の右下隅としたときの穴のない正方形の辺の長さの最大値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;(i,j)が穴ではないとき、
dp[i][j] = Min(dp[i-1,j], dp[i,j-1], dp[i-1,j-1]) + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;(i,j)&lt;/code&gt;を正方形の右下隅としたとき、&lt;code&gt;dp[i][j]&lt;/code&gt;通りの辺の長さの正方形を作ることができるので、全ての&lt;code&gt;(i,j)&lt;/code&gt;における&lt;code&gt;dp[i][j]&lt;/code&gt;の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var isHole = new bool[H, W];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        isHole[a, b] = true;
    }

    var dp = new int[H, W];
    for (var i = 0; i &amp;lt; H; i++)
    {
        if (!isHole[i, 0]) dp[i, 0] = 1;
    }

    for (var j = 0; j &amp;lt; W; j++)
    {
        if (!isHole[0, j]) dp[0, j] = 1;
    }

    const int Inf = (int)1e9;
    for (var i = 1; i &amp;lt; H; i++)
    {
        for (var j = 1; j &amp;lt; W; j++)
        {
            if (isHole[i, j]) continue;
            var min = Inf;
            min = Math.Min(min, dp[i - 1, j]);
            min = Math.Min(min, dp[i, j - 1]);
            min = Math.Min(min, dp[i - 1, j - 1]);
            dp[i, j] = min + 1;
        }
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            answer += dp[i, j];
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>