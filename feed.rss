<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://aconcavy.github.io/blog</link>
		<description />
		<copyright>Copyright © 2020-2022 AconCavy</copyright>
		<pubDate>Sun, 30 Jan 2022 16:52:56 GMT</pubDate>
		<lastBuildDate>Sun, 30 Jan 2022 16:52:56 GMT</lastBuildDate>
		<item>
			<title>ABC237</title>
			<link>https://aconcavy.github.io/blog/posts/20220130abc237</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 237の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20220130abc237</guid>
			<pubDate>Mon, 31 Jan 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 237の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237"&gt;https://atcoder.jp/contests/ABC237&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28899214"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#含めほとんどの言語では、&lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt;のようなビットシフト計算が備わっており、2の&lt;code&gt;x&lt;/code&gt;乗を表現することができます。
例えば、&lt;code&gt;1 &amp;lt;&amp;lt; 2&lt;/code&gt;は、1を2進数で表すと&lt;code&gt;1&lt;/code&gt;であり、2つ左にシフトすると&lt;code&gt;100&lt;/code&gt;になって、10進数では&lt;code&gt;4&lt;/code&gt;を表現します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
const long inf = 1L &amp;lt;&amp;lt; 31;
Console.WriteLine(-inf &amp;lt;= N &amp;amp;&amp;amp; N &amp;lt; inf ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28909504"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;転置行列は、&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目を&lt;code&gt;j&lt;/code&gt;行&lt;code&gt;i&lt;/code&gt;列目にしたものなので、そのまま添え字を入れ替えたものを結果として出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = new int[H, W];
for (var i = 0; i &amp;lt; H; i++)
{
    var AA = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var j = 0; j &amp;lt; W; j++)
    {
        A[i, j] = AA[j];
    }
}

var B = new int[W, H];
for (var i = 0; i &amp;lt; H; i++)
{
    for (var j = 0; j &amp;lt; W; j++)
    {
        B[j, i] = A[i, j];
    }
}

Printer.Print2D(B, &amp;quot; &amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28919221"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あらかじめ、文字列前方と後方の連続する&lt;code&gt;a&lt;/code&gt;を無視した文字列が回文であれば元の文が回文である可能性があります。
このとき、文字列前方の連続する&lt;code&gt;a&lt;/code&gt;の個数が文字列後方の連続する&lt;code&gt;a&lt;/code&gt;の個数以下場合は、足りない&lt;code&gt;a&lt;/code&gt;を前方に追加することで回文にすることができますが、それ以外(前方&amp;gt;後方)の場合は後方に&lt;code&gt;a&lt;/code&gt;を追加することはできないので、回文にすることはできません。
例えば、&lt;code&gt;aabcbaaa&lt;/code&gt;では、前方と後方の連続した&lt;code&gt;a&lt;/code&gt;を無視すると&lt;code&gt;bcb&lt;/code&gt;となり回文になり、前方(2)は後方(3)以下なので、回文にすることができます。一方で、
&lt;code&gt;aaabcbaa&lt;/code&gt;では、同様に無視すると&lt;code&gt;bcb&lt;/code&gt;となり回文になりますが、前方(3)は後方(2)より大きいため、回文にすることはできません。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.ScanLine();
var (l, r) = (0, S.Length - 1);
while (r &amp;gt;= 0 &amp;amp;&amp;amp; S[r] == 'a') r--;
while (l &amp;lt; r &amp;amp;&amp;amp; S[l] == 'a') l++;

var lc = l;
var rc = S.Length - r - 1;
if (lc &amp;gt; rc)
{
    Console.WriteLine(&amp;quot;No&amp;quot;);
    return;
}

var t = S[l..(r + 1)];
var answer = t == new string(t.Reverse().ToArray());
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28928816"&gt;コンテスト提出&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28958803"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数字をノードとしてみたときに、0をルートとするツリーを作成し、深さ優先探索の通りがかり順(左部分木-&amp;gt;自分-&amp;gt;右部分木)で見ていった結果が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var S = Scanner.ScanLine();
var nodes = new Node[N + 1];
for (var i = 0; i &amp;lt;= N; i++)
{
    nodes[i] = new Node();
}
 
foreach (var (c, i) in S.Select((x, i) =&amp;gt; (x, i)))
{
    if (c == 'L')
    {
        nodes[i].Left = i + 1;
    }
    else
    {
        nodes[i].Right = i + 1;
    }
}
 
var answer = new List&amp;lt;int&amp;gt;();
 
void Dfs(int curr)
{
    if (curr &amp;lt; 0) return;
    Dfs(nodes[curr].Left);
    answer.Add(curr);
    Dfs(nodes[curr].Right);
}
 
Dfs(0);
 
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Node&lt;/code&gt;は左側と右側を持つクラスです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class Node
{
    public int Left { get; set; } = -1;
    public int Right { get; set; } = -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Deque&lt;/code&gt;を使った場合は、文字列を逆順から見て、反対側に追加すればよいです。
C#には&lt;code&gt;Deque&lt;/code&gt;というクラスはありませんが、&lt;code&gt;LinkedList&amp;lt;T&amp;gt;&lt;/code&gt;という連結リストがあるため、それを使うことで代用することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var S = Scanner.ScanLine();
var deq = new Deque&amp;lt;int&amp;gt;();
deq.PushBack(N);
foreach (var (c, i) in S.Select((x, i) =&amp;gt; (x, i)).Reverse())
{
    if (c == 'L') deq.PushBack(i);
    else deq.PushFront(i);
}
 
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, deq));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28933145"&gt;コンテスト提出&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28962115"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;頂点&lt;code&gt;U&lt;/code&gt;と頂点&lt;code&gt;V&lt;/code&gt;をつなぐ辺にそれぞれ重みを付けてグラフを作成したときの、拡張ダイクストラ法で解くことを考えます。
楽しさの変化量を辺の重みとしてみたとき、&lt;code&gt;H&lt;/code&gt;を頂点の高さ、&lt;code&gt;d&lt;/code&gt;を高さの差の絶対値とすると、&lt;code&gt;H[U]&amp;lt;H[V]&lt;/code&gt;であれば&lt;code&gt;U-&amp;gt;V&lt;/code&gt;の辺は&lt;code&gt;d&lt;/code&gt;の重み、&lt;code&gt;H[U]&amp;gt;H[V}&lt;/code&gt;であれば&lt;code&gt;U-&amp;gt;V&lt;/code&gt;の辺は&lt;code&gt;-2d&lt;/code&gt;の重み、&lt;code&gt;H[U]=H[V]&lt;/code&gt;であれば&lt;code&gt;0&lt;/code&gt;の重みをそれぞれの辺につけます。&lt;br /&gt;
その重み付きグラフを用いて、頂点&lt;code&gt;0&lt;/code&gt;から優先度付きキューを用いて幅優先探索を行い、各頂点のコストを最大化したときの最大の値が答えとなります。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;嘘解放でした。この実装では、&lt;code&gt;after_contest&lt;/code&gt;でTLEになります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/kyopro_friends/status/1487807336202735617"&gt;競技プログラミングをするフレンズ E問題after_contest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;楽しさの減少を標高差のまま考えたとき、&lt;code&gt;U-&amp;gt;V&lt;/code&gt;に至る経路がどうであれ、楽しさは&lt;code&gt;H[U]-H[V]&lt;/code&gt;を得ることができます。楽しさの減少が標高差の2倍のときは、&lt;code&gt;U-&amp;gt;V&lt;/code&gt;に至る経路のうち&lt;code&gt;H[X]&amp;lt;H[Y]&lt;/code&gt;の移動を行ったときに、楽しさが&lt;code&gt;H[X]-H[Y]&lt;/code&gt;減少します。言い換えれば、減少分を辺のコストとしたときの単一始点最短経路問題として考えることができます。
そして、各頂点の得られる楽しさから最小化された頂点のコストを引くことで、頂点に対する楽しさの最大化を行うことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var H = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
for (var i = 0; i &amp;lt; M; i++)
{
    var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    u--; v--;
    G[u].Add((v, Math.Max(0, H[v] - H[u])));
    G[v].Add((u, Math.Max(0, H[u] - H[v])));
}

var costs = new long[N];
Array.Fill(costs, long.MaxValue);
costs[0] = 0;
var queue = new PriorityQueue&amp;lt;(int U, long Cost)&amp;gt;((x, y) =&amp;gt; x.Cost.CompareTo(y.Cost));
queue.Enqueue((0, 0));

while (queue.Count &amp;gt; 0)
{
    var (u, cu) = queue.Dequeue();
    if (costs[u] &amp;lt; cu) continue;
    foreach (var (v, cv) in G[u])
    {
        var c = costs[u] + cv;
        if (costs[v] &amp;lt;= c) continue;
        costs[v] = c;
        queue.Enqueue((v, c));
    }
}

var answer = 0L;
for (var i = 0; i &amp;lt; N; i++)
{
    answer = Math.Max(answer, H[0] - H[i] - costs[i]);
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2022年1月31日現在のAtCoderの&lt;code&gt;C#(.NET Core 3.1.201)&lt;/code&gt;では&lt;code&gt;PriorityQueue&lt;/code&gt;は標準ライブラリにないため、自作する必要があります。
&lt;code&gt;C#(.NET 6.0)&lt;/code&gt;以降であれば、&lt;code&gt;PriorityQueue&lt;/code&gt;が標準ライブラリに追加されるので、言語アップデートを待ちましょう。&lt;/p&gt;
&lt;h2 id="f"&gt;&lt;a href="https://atcoder.jp/contests/ABC237/tasks/ABC237_f"&gt;問題F&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC237/submissions/28958599"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NMMMのdp?&lt;/li&gt;
&lt;li&gt;部分増加列&lt;code&gt;a1&lt;/code&gt;、&lt;code&gt;a2&lt;/code&gt;、&lt;code&gt;a3&lt;/code&gt;を固定したときの&lt;code&gt;a1&lt;/code&gt;と&lt;code&gt;a2&lt;/code&gt;の間の数、&lt;code&gt;a2&lt;/code&gt;と&lt;code&gt;a3&lt;/code&gt;の間の数、&lt;code&gt;a3&lt;/code&gt;以降の数の組み合わせの数え上げ?&lt;/li&gt;
&lt;li&gt;www(a1)xxx(a2)yyy(a3)zzzのような数列の時、www:1通り、xxx:長さc1、yyy:長さc2、zzz:長さc3で組み合わせ?&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var a1 = 1; a1 &amp;lt;= M; a1++)
for(var a2 = a1 + 1; a1 + a2 &amp;lt;= M; a2++)
for(var a3 = a2 + 1; a1 + a2 + a3 &amp;lt;= M; a3++)
for(var c1 = 0; c1 &amp;lt;= N; c1++)
for(var c2 = 0; c1 + c2 &amp;lt;= N; c2++)
{
    var c3 = N - 3 - c1 - c2;
    // 組み合わせ?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、部分増加列の最後尾として考えられる最小値の数列の状態数を求めるdpでした。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][a1][a2][a3]&lt;/code&gt; := 長さが&lt;code&gt;i&lt;/code&gt;で、長さ&lt;code&gt;j&lt;/code&gt;の部分増加列の最後尾として考えられる最小値が&lt;code&gt;aj&lt;/code&gt;であるような数列の状態数&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var dp = new mint[N + 1, M + 2, M + 2, M + 2];
dp[0, M + 1, M + 1, M + 1] = 1;
for (var i = 0; i &amp;lt; N; i++)
{
    for (var a1 = 0; a1 &amp;lt;= M + 1; a1++)
    {
        for (var a2 = 0; a2 &amp;lt;= M + 1; a2++)
        {
            for (var a3 = 0; a3 &amp;lt;= M + 1; a3++)
            {
                for (var x = 1; x &amp;lt;= M; x++)
                {
                    if (x &amp;lt;= a1) dp[i + 1, x, a2, a3] += dp[i, a1, a2, a3];
                    else if (x &amp;lt;= a2) dp[i + 1, a1, x, a3] += dp[i, a1, a2, a3];
                    else if (x &amp;lt;= a3) dp[i + 1, a1, a2, x] += dp[i, a1, a2, a3];
                }
            }
        }
    }
}

mint answer = 0;
for (var a1 = 1; a1 &amp;lt;= M; a1++)
{
    for (var a2 = a1 + 1; a2 &amp;lt;= M; a2++)
    {
        for (var a3 = a2 + 1; a3 &amp;lt;= M; a3++)
        {
            answer += dp[N, a1, a2, a3];
        }
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC236</title>
			<link>https://aconcavy.github.io/blog/posts/20220123abc236</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 236の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20220123abc236</guid>
			<pubDate>Mon, 24 Jan 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 236の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236"&gt;https://atcoder.jp/contests/abc236&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28718361"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列を文字の配列としてとり、指定されたインデックスの中身を入れ替えます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
A--; B--;
(S[A], S[B]) = (S[B], S[A]);
Console.WriteLine(string.Join(&amp;quot;&amp;quot;, S));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;タプルを使うことで、一時変数を使わずに値を入れ替えることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var tmp = a;
a = b;
b = a;

(a, b) = (b, a); // 上と同じ
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28722017"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;カードはすべて数値なので、&lt;code&gt;4N&lt;/code&gt;枚のカードの総和&lt;code&gt;(4 * N * (N+1) / 2)&lt;/code&gt;から渡されたカードの束Aの総和を引くことで、抜き取られたカードを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var answer = 4L * (N * (N + 1) / 2) - A.Sum();
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28725764"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列をキーとした辞書を作成し、急行列車が止まる駅をチェックします。時間計算量は&lt;code&gt;O(NlogN)&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var S = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var T = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;string, bool&amp;gt;();
foreach (var s in S)
{
    dict[s] = false;
}

foreach (var t in T)
{
    dict[t] = true;
}

foreach (var s in S)
{
    Console.WriteLine(dict[s] ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ほかにも、&lt;code&gt;T&lt;/code&gt;は&lt;code&gt;S&lt;/code&gt;の部分列であることが制約で保証されているため、&lt;code&gt;S&lt;/code&gt;を前から順に見ていったとき、次の&lt;code&gt;T&lt;/code&gt;と一致した場合には&lt;code&gt;Yes&lt;/code&gt;を表示し、&lt;code&gt;T&lt;/code&gt;を次に進めるといった方法でも、時間計算量&lt;code&gt;O(N)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var S = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var T = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
var queue = new Queue&amp;lt;string&amp;gt;(T);
foreach (var s in S)
{
    if (queue.TryPeek(out var t) &amp;amp;&amp;amp; s == t)
    {
        queue.Dequeue();
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
    }
    else
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28749636"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今見ている人とスコアをもって深さ優先探索を行い、すべての人がペアを組み終わったときのスコアを最大値を求めます。遷移としては、既にペアを組んでいる場合は次の人に進み、組んでいない場合は今見ている人以降のまだペアを組んでいない人とペアを組みます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = new int[N * 2, N * 2];
for (var i = 0; i &amp;lt; N * 2 - 1; i++)
{
    var AA = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var j = 0; j &amp;lt; AA.Length; j++)
    {
        A[i, j + i + 1] = A[j + i + 1, i] = AA[j];
    }
}

var answer = 0;
var used = new bool[N * 2];

void Dfs(int curr, int xor)
{
    if (curr &amp;gt;= N * 2)
    {
        if (used.All(x =&amp;gt; x))
        {
            answer = Math.Max(answer, xor);
        }
        return;
    }

    if (!used[curr])
    {
        for (var next = curr + 1; next &amp;lt; N * 2; next++)
        {
            if (!used[next])
            {
                used[curr] = used[next] = true;
                Dfs(curr + 1, xor ^ A[curr, next]);
                used[curr] = used[next] = false;
            }
        }
    }
    else
    {
        Dfs(curr + 1, xor);
    }
}

Dfs(0, 0);

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc236/tasks/abc236_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc236/submissions/28760550"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二部探索?&lt;/li&gt;
&lt;li&gt;最初に奇数番目と偶数番目をそれぞれ分けて、もし値が増えるならそれぞれ足していくことで平均値はでそう?&lt;/li&gt;
&lt;li&gt;上の方針では、&lt;code&gt;1 2 4 5 7 8&lt;/code&gt;のように番目をとるとダメになる可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解説では、平均と中央値ともに二部探索でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

long DP(IEnumerable&amp;lt;long&amp;gt; source)
{
    var (x, y) = (0L, 0L);
    foreach (var v in source)
    {
        var z = Math.Max(x, y) + v;
        (x, y) = (y, z);
    }

    return Math.Max(x, y);
}

double Average()
{
    bool F(long k) =&amp;gt; DP(A.Select(x =&amp;gt; x * 1000 - k)) &amp;gt;= 0;
    return BinarySearch((long)1e12 + 1, 0, F) / 1000d;
}

long Median()
{
    bool F(long k) =&amp;gt; DP(A.Select(x =&amp;gt; x &amp;gt;= k ? 1L : -1L)) &amp;gt; 0;
    return BinarySearch((long)1e9 + 1, 0, F);
}

Console.WriteLine(Average());
Console.WriteLine(Median());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BinarySearch&lt;/code&gt;は&lt;code&gt;[ng, ok)&lt;/code&gt;の間で、&lt;code&gt;func&lt;/code&gt;の判定式を使って二部探索を行う関数です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC235</title>
			<link>https://aconcavy.github.io/blog/posts/20220115abc235</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 235の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20220115abc235</guid>
			<pubDate>Sun, 16 Jan 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 235の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235"&gt;https://atcoder.jp/contests/abc235&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28530777"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各桁を移動させて足します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var V = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
var answer = 0;
answer += V[0] * 100 + V[1] * 10 + V[2];
answer += V[1] * 100 + V[2] * 10 + V[0];
answer += V[2] * 100 + V[0] * 10 + V[1];

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28530905"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;順にみて前回より大きい場合は&lt;code&gt;curr&lt;/code&gt;を更新し、小さい場合は移動することができないため、&lt;code&gt;curr&lt;/code&gt;を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var H = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var curr = 0L;
for (var i = 0; i &amp;lt; N; i++)
{
    if (curr &amp;lt; H[i])
    {
        curr = H[i];
    }
    else
    {
        Console.WriteLine(curr);
        return;
    }
}

Console.WriteLine(curr);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28535489"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリのたびにすべてを走査すると&lt;code&gt;O(N*Q)&lt;/code&gt;となりTLEになるので、高速化する必要があります。
あらかじめ値をキーとした出現場所をもつ辞書を作成し、その値が何番目に出現するかを保持しておき、クエリによる&lt;code&gt;x&lt;/code&gt;の値が存在して、&lt;code&gt;k&lt;/code&gt;の値が辞書内に存在する&lt;code&gt;x&lt;/code&gt;の個数以内ならばその出現場所を表示し、それ以外の場合は&lt;code&gt;-1&lt;/code&gt;を表示することで、クエリ当たり&lt;code&gt;O(logN)&lt;/code&gt;で実行することができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var dict = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    if (!dict.ContainsKey(A[i])) dict[A[i]] = new List&amp;lt;int&amp;gt;();
    dict[A[i]].Add(i + 1);
}

while (Q-- &amp;gt; 0)
{
    var (x, k) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    k--;
    if (dict.ContainsKey(x))
    {
        if (k &amp;lt; dict[x].Count)
        {
            Console.WriteLine(dict[x][k]);
        }
        else
        {
            Console.WriteLine(-1);
        }
    }
    else
    {
        Console.WriteLine(-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28546896"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各操作をBFSで走査することにより、各値の更新は高々1回のみで十分になります。&lt;br /&gt;
シフト操作によって、&lt;code&gt;N&lt;/code&gt;の値より大きい数から&lt;code&gt;N&lt;/code&gt;より小さい値に変化する可能性もあるので、Nを文字列としてみたときの長さより大きい場合は無視することに注意します。&lt;br /&gt;
&lt;code&gt;Shift&lt;/code&gt;メソッドは配列を与えられた値だけシフトする関数です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (A, N) = Scanner.Scan&amp;lt;long, long&amp;gt;();
var dp = new Dictionary&amp;lt;long, int&amp;gt;();
dp[1] = 0;

var queue = new Queue&amp;lt;long&amp;gt;();
queue.Enqueue(1);
const int inf = (int)1e7;

void Push(long curr, long next)
{
    if (next &amp;gt; inf) return;
    if (dp.ContainsKey(next)) return;
    dp[next] = dp[curr] + 1;
    queue.Enqueue(next);
}

while (queue.Count &amp;gt; 0)
{
    var u = queue.Dequeue();
    if (u &amp;gt;= 10 &amp;amp;&amp;amp; u % 10 != 0)
    {
        var v = long.Parse(Shift(u.ToString().AsSpan(), 1));
        Push(u, v);
    }
    Push(u, u * A);
}
 
if (dp.ContainsKey(N))
{
    Console.WriteLine(dp[N]);
}
else
{
    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28551552"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに最小全域木を求めると、ソートに&lt;code&gt;(MlogM)&lt;/code&gt;、クラスカル法で最小全域木を求めるために&lt;code&gt;O(Ea(V))&lt;/code&gt;となり、TLEになってしまいます。
クエリに対してグラフはそれぞれ独立なため、あらかじめクエリを先読みしてすべての辺をまとめてソートし、クラスカル法で辺を見てその辺が有効な場合、もしその辺がクエリの辺である場合はそのクエリは有効であり、そうではない場合は最小全域木としてマージしていくことで、計算量を抑えることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M, Q) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
var E1 = new Edge[M];
var E2 = new Edge[Q];
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b, c) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    a--; b--;
    E1[i] = new Edge(-1, a, b, c);
}

for (var i = 0; i &amp;lt; Q; i++)
{
    var (a, b, c) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    a--; b--;
    E2[i] = new Edge(i, a, b, c);
}

var answer = new bool[Q];
var dsu = new DisjointSetUnion(N);
foreach (var e in E1.Concat(E2).OrderBy(x =&amp;gt; x.Cost))
{
    if (dsu.IsSame(e.U, e.V)) continue;
    if (e.ID == -1)
    {
        dsu.Merge(e.U, e.V);
    }
    else
    {
        answer[e.ID] = true;
    }
}

Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer.Select(x =&amp;gt; x ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc235/tasks/abc235_f"&gt;問題F&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc235/submissions/28569936"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;桁dp?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&amp;lt;&amp;lt;10&lt;/code&gt;(1024)通りの場合分け?&lt;/li&gt;
&lt;li&gt;総和の数え方がわからない...&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var dp = new mint[N + 1, 1 &amp;lt;&amp;lt; 10];
for(var i = 0; i &amp;lt; S.Length; i++)
{
    for(var j = 0; j &amp;lt; 1 &amp;lt;&amp;lt; 10; j++)
    {
        for(var k = 0; k &amp;lt; 10; k++)
        {
            // dp[i + 1, j | (1 &amp;lt;&amp;lt; k)] = ?;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、総和と個数をそれぞれ別に数え上げるそうです。
&lt;code&gt;mint&lt;/code&gt;は、あまりをとる整数型です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var V = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
var N = V.Length;
var M = Scanner.Scan&amp;lt;int&amp;gt;();
var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

var ok = 0;
foreach (var c in C)
{
    ok |= 1 &amp;lt;&amp;lt; c;
}

var max = 1 &amp;lt;&amp;lt; 10;
var count = new mint[2][] { new mint[max], new mint[max] };
var sum = new mint[2][] { new mint[max], new mint[max] };
mint curr = 0;
var digits = 0;

var t = 1;
for (var i = 0; i &amp;lt; N; i++)
{
    t ^= 1;
    var tt = t ^ 1;
    var c = V[i];
    Array.Fill(count[tt], 0);
    Array.Fill(sum[tt], 0);
    for (var j = 0; j &amp;lt; max; j++)
    {
        for (var d = 0; d &amp;lt; 10; d++)
        {
            var next = j | (1 &amp;lt;&amp;lt; d);
            count[tt][next] += count[t][j];
            sum[tt][next] += sum[t][j] * 10 + count[t][j] * d;
        }
    }

    if (i &amp;gt; 0)
    {
        for (var d = 1; d &amp;lt; 10; d++)
        {
            var next = 1 &amp;lt;&amp;lt; d;
            count[tt][next]++;
            sum[tt][next] += d;
        }
    }

    for (var d = 0; d &amp;lt; c; d++)
    {
        if (i == 0 &amp;amp;&amp;amp; d == 0) continue;
        var next = digits | (1 &amp;lt;&amp;lt; d);
        count[tt][next]++;
        sum[tt][next] += curr * 10 + d;
    }

    digits |= 1 &amp;lt;&amp;lt; c;
    curr = curr * 10 + c;
}

t ^= 1;
var answer = 0L;
for (var j = 0; j &amp;lt; max; j++)
{
    if ((j &amp;amp; ok) == ok)
    {
        answer += sum[t][j];
    }
}

if ((digits &amp;amp; ok) == ok)
{
    answer += curr;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC234</title>
			<link>https://aconcavy.github.io/blog/posts/20220108abc234</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 234の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20220108abc234</guid>
			<pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 234の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234"&gt;https://atcoder.jp/contests/abc234&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28380748"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F(x)&lt;/code&gt;を定義し、求める式を&lt;code&gt;G(x)&lt;/code&gt;とした時に、&lt;code&gt;G(T)&lt;/code&gt;の値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var T = Scanner.Scan&amp;lt;int&amp;gt;();
long F(long x) =&amp;gt; x * x + 2 * x + 3;
long G(long x) =&amp;gt; F(F(F(x) + x) + F(F(x)));
var answer = G(T);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28384115"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;すべての点の組み合わせを試すことで求めることができます。
最後に&lt;code&gt;Sqrt&lt;/code&gt;を取ることで誤差を回避しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var P = new (double X, double Y)[N];
for (var i = 0; i &amp;lt; N; i++)
{
    var (x, y) = Scanner.Scan&amp;lt;double, double&amp;gt;();
    P[i] = (x, y);
}

var answer = 0d;
foreach (var (x1, y1) in P)
{
    foreach (var (x2, y2) in P)
    {
        var (dx, dy) = (x2 - x1, y2 - y1);
        answer = Math.Max(answer, dx * dx + dy * dy);
    }
}

answer = Math.Sqrt(answer);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28387201"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt;を2進数表記したとき、&lt;code&gt;1&lt;/code&gt;の値を&lt;code&gt;2&lt;/code&gt;にしたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var K = Scanner.Scan&amp;lt;long&amp;gt;();
var list = new List&amp;lt;long&amp;gt;();
while (K &amp;gt; 0)
{
    list.Add(K &amp;amp; 1);
    K &amp;gt;&amp;gt;= 1;
}
list.Reverse();
var answer = string.Join(&amp;quot;&amp;quot;, list.Select(x =&amp;gt; x * 2));
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28404691"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc234/submissions/28418529"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;優先度付きキューを使い、キューのサイズが&lt;code&gt;K&lt;/code&gt;個の時の最小の値がそれぞれの状態の答えとなります。
最初は、先頭から&lt;code&gt;K&lt;/code&gt;個の値を入れたときの最小の値を表示し、それ以降は追加される値がキューの最小よりも小さい場合はK番目より小さいので無視し、大きい場合はキューを更新することで&lt;code&gt;K&lt;/code&gt;個を維持しつつ最小の値を管理できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var queue = new PriorityQueue&amp;lt;int&amp;gt;();
for (var i = 0; i &amp;lt; K; i++)
{
    queue.Enqueue(P[i]);
}

Console.WriteLine(queue.Peek());

for (var i = K; i &amp;lt; N; i++)
{
    if (queue.Peek() &amp;lt; P[i])
    {
        queue.Dequeue();
        queue.Enqueue(P[i]);
    }

    var answer = queue.Peek();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/284197124"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;答えとしてあり得る値を考えたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等差が&lt;code&gt;-9&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt; (19通り)&lt;/li&gt;
&lt;li&gt;最上位の桁が&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt; (10通り)&lt;/li&gt;
&lt;li&gt;桁数が17桁 (17通り)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;すべて合わせて&lt;code&gt;3230(19*10*17)&lt;/code&gt;通りのうち、各桁の値が&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の条件をもつ値すべてを全探索しすることで、&lt;code&gt;X&lt;/code&gt;以上を最小の値を求めることができる。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var X = Scanner.Scan&amp;lt;long&amp;gt;();
var hashset = new HashSet&amp;lt;long&amp;gt;(Enumerable.Range(0, 10).Select(x =&amp;gt; (long)x));
for (var d = -9; d &amp;lt;= 9; d++)
{
    for (var i = 0L; i &amp;lt;= 9; i++)
    {
        var x = i;
        for (var t = 1; t &amp;lt; 18; t++)
        {
            var mod = x % 10;
            if (mod + d &amp;lt; 0 || 10 &amp;lt;= mod + d) break;
            x *= 10;
            x += mod + d;
            hashset.Add(x);
        }
    }
}

var answer = hashset.Where(x =&amp;gt; x &amp;gt;= X).Min();
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;E問題を解こうとしてたはずなのにF問題やってたのでコンテスト中には解けませんでした。コンテスト後に気づいて解いてみたら解けてたので悔しいです。&lt;/del&gt;&lt;/p&gt;
&lt;h2 id="e-1"&gt;&lt;a href="https://atcoder.jp/contests/abc234/tasks/abc234_f"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc234/submissions/28417399"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;制約が&lt;code&gt;N&amp;lt;=5000&lt;/code&gt;だからdpと組み合わせ?&lt;/li&gt;
&lt;li&gt;2^Nから重複を引く?&lt;/li&gt;
&lt;li&gt;重複組み合わせ?&lt;/li&gt;
&lt;li&gt;長さが&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;のそれぞれの時に数え上げ?&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var s = 1; s &amp;lt; S.Length; s++)
{
    var sum = 0;
    for(var i = 0; i &amp;lt; 26; i++)
    {
        sum = Math.Min(count[i], s);
    }

    // ToDo
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、&lt;code&gt;i&lt;/code&gt;番目までのアルファベットを使った時の文字列の合計が&lt;code&gt;j&lt;/code&gt;である時の組み合わせを数え上げる動的計画法でした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();

var N = S.Length;
var fact = new mint[N + 1];
var ifact = new mint[N + 1];
fact[0] = ifact[0] = 1;
for (var i = 1; i &amp;lt;= N; i++)
{
    fact[i] = fact[i - 1] * i;
    ifact[i] = 1 / fact[i];
}

mint Combination(int n, int k)
{
    if (n &amp;lt; k || n &amp;lt; 0 || k &amp;lt; 0) return 0;
    return fact[n] * ifact[k] * ifact[n - k];
}

var count = new int[26];
foreach (var c in S)
{
    count[c - 'a']++;
}

var dp = new mint[27, N + 1];
dp[0, 0] = 1;

for (var i = 0; i &amp;lt; 26; i++)
{
    for (var j = 0; j &amp;lt;= N; j++)
    {
        for (var k = 0; k &amp;lt;= Math.Min(j, count[i]); k++)
        {
            dp[i + 1, j] += dp[i, j - k] * Combination(j, k);
        }
    }
}

mint answer = 0;
for (var i = 1; i &amp;lt;= N; i++)
{
    answer += dp[26, i];
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC233</title>
			<link>https://aconcavy.github.io/blog/posts/20211225abc233</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 233の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211225abc233</guid>
			<pubDate>Sat, 25 Dec 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 233の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233"&gt;https://atcoder.jp/contests/abc233&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28110738"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Y-X)&lt;/code&gt;を10で割ったときの切り上げの値が必要な切手の数となります。
&lt;code&gt;(Y-X)&lt;/code&gt;が負の場合は既に金額が足りているので、0と&lt;code&gt;Max&lt;/code&gt;を取ることで、&lt;code&gt;if&lt;/code&gt;文なくすことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (X, Y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var answer = Math.Max(0, ((Y - X) + 9) / 10);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28113146"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;code&gt;Array.Reverse&lt;/code&gt;メソッドを使うことで、配列の指定した範囲を逆順にすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (L, R) = Scanner.Scan&amp;lt;int, int&amp;gt;();
L--;
var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
Array.Reverse(S, L, R - L);
Console.WriteLine(string.Join(&amp;quot;&amp;quot;, S));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28122407"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;総積が&lt;code&gt;X&lt;/code&gt;になるためには、要素となる数が&lt;code&gt;X&lt;/code&gt;の倍数である必要があるため、それ以外を除いたものから、袋からそれぞれ1つずつ選んだ時の組み合わせの数となります。&lt;br /&gt;
再帰関数を使って&lt;code&gt;idx&lt;/code&gt;となる袋を順にみていくとき、ボールの値が現在の値&lt;code&gt;curr&lt;/code&gt;の倍数であり、&lt;code&gt;curr&lt;/code&gt;が0より大きい場合、次の袋に進むことができます。&lt;br /&gt;
もしすべての袋から1つずつ拾うことができて、&lt;code&gt;curr&lt;/code&gt;の値が1のときは、それまでに選んだボールの値の総積が&lt;code&gt;X&lt;/code&gt;となるので、その時の数を数え上げることで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, X) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = new long[N][];
for (var i = 0; i &amp;lt; N; i++)
{
    A[i] = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().Skip(1).Where(x =&amp;gt; X % x == 0).ToArray();
}

var answer = 0L;

void Dfs(int idx, long curr)
{
    if (idx == N)
    {
        if (curr == 1) answer++;
        return;
    }

    foreach (var a in A[idx])
    {
        if (curr % a == 0 &amp;amp;&amp;amp; curr / a != 0)
        {
            Dfs(idx + 1, curr / a);
        }
    }
}

Dfs(0, X);

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28148861"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;累積和で範囲を求められそう&lt;/li&gt;
&lt;li&gt;尺取り法は単調増加ではないから使えなさそう&lt;/li&gt;
&lt;li&gt;ディクショナリでまとめて数え上げられそう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;L&lt;/code&gt;を固定したときに&lt;code&gt;R&lt;/code&gt;の数を数え上げましたが、実装が間違っていたのかWAで時間切れとなりました。&lt;/p&gt;
&lt;p&gt;解説では&lt;code&gt;R&lt;/code&gt;を固定したときに&lt;code&gt;L&lt;/code&gt;の数を数え上げていました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var cum = new long[N + 1];
for (var i = 0; i &amp;lt; N; i++)
{
    cum[i + 1] = cum[i] + A[i];
}

var dict = new Dictionary&amp;lt;long, long&amp;gt;();
var answer = 0L;
for (var i = 1; i &amp;lt;= N; i++)
{
    if (!dict.ContainsKey(cum[i - 1]))
    {
        dict[cum[i - 1]] = 0;
    }
    dict[cum[i - 1]]++;
    if (dict.ContainsKey(cum[i] - K))
    {
        answer += dict[cum[i] - K];
    }
}
 
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28143437"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大きい桁から累積和を取ると、その桁に最終的に足される数を求めることができます。
累積和を小さい桁から見たとき、その桁の累積和の1の位の数が桁として確定し、累積和の1の位より大きい値は、その次の桁に繰り上げられるため、次の桁の累積和に足す必要があります。&lt;br /&gt;
出力では、一番大きい桁が0の場合は除外して表示する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var X = Scanner.Scan&amp;lt;string&amp;gt;();
var N = X.Length;
var cum = new int[N + 1];
for (var i = 0; i &amp;lt; N; i++)
{
    cum[i + 1] = cum[i] + X[i] - '0';
}

var answer = new int[X.Length + 1];
for (var i = N; i &amp;gt; 0; i--)
{
    answer[i] = cum[i] % 10;
    cum[i - 1] += cum[i] / 10;
}

answer[0] += cum[0];
if (answer[0] == 0)
{
    Console.WriteLine(string.Join(&amp;quot;&amp;quot;, answer.Skip(1)));
}
else
{
    Console.WriteLine(string.Join(&amp;quot;&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC230</title>
			<link>https://aconcavy.github.io/blog/posts/20211224abc230</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 230の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211224abc230</guid>
			<pubDate>Fri, 24 Dec 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 230の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230"&gt;https://atcoder.jp/contests/abc230&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27643596"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入力を取り、&lt;code&gt;N&lt;/code&gt;が42以上なら答えをインクリメントします。C#では出力をフォーマットできるので、0埋めフォーマットを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
if (N &amp;gt;= 42) N++;
// var answer = $&amp;quot;AGC{N.ToString(&amp;quot;000&amp;quot;)}&amp;quot;;
var answer = $&amp;quot;AGC{N:000}&amp;quot;;
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27651060"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc230/submissions/27674559"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3つ連続した部分文字列において、&lt;code&gt;x&lt;/code&gt;が3つ連続した場合、&lt;code&gt;oxo&lt;/code&gt;のように&lt;code&gt;o&lt;/code&gt;が2つ以上含まれている場合は答えは&lt;code&gt;No&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();
var answer = true;
for (var i = 0; i + 2 &amp;lt; S.Length; i++)
{
    answer &amp;amp;= (S[i], S[i + 1], S[i + 2]) != ('x', 'x', 'x');
    answer &amp;amp;= (S[i], S[i + 1], S[i + 2]) != ('o', 'x', 'o');
}

for (var i = 0; i + 1 &amp;lt; S.Length; i++)
{
    answer &amp;amp;= (S[i], S[i + 1]) != ('o', 'o');
}

Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、&lt;code&gt;Yes&lt;/code&gt;になるテンプレートは高々3つなので、そのテンプレートの順番で&lt;code&gt;o&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;が出現しているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();
foreach (var t in new[] { &amp;quot;oxx&amp;quot;, &amp;quot;xox&amp;quot;, &amp;quot;xxo&amp;quot; })
{
    var ok = true;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        ok &amp;amp;= S[i] == t[i % 3];
    }
 
    if (ok)
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }
}
 
Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27664018"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc230/submissions/27674563"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;黒く塗りつぶすべきマスは、&lt;code&gt;x&lt;/code&gt;の交点となる&lt;code&gt;(A,B)&lt;/code&gt;からの距離&lt;code&gt;dx&lt;/code&gt;と&lt;code&gt;dy&lt;/code&gt;の絶対値が一致する箇所になります。
そのため、対象となるマスを見ていくとき、&lt;code&gt;Abs(dx) == Abs(dy)&lt;/code&gt;になるマスを黒く塗れば、求められる出力が得られます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, A, B) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
var (P, Q, R, S) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();

for (var i = P; i &amp;lt;= Q; i++)
{
    for (var j = R; j &amp;lt;= S; j++)
    {
        Console.Write(Math.Abs(A - i) == Math.Abs(B - j) ? '#' : '.');
    }
    Console.WriteLine();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27665969"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D&lt;/code&gt;列まとめてダメージを与えられるということは、壁の当たり判定を&lt;code&gt;D-1&lt;/code&gt;伸ばして、パンチを1列にすることと同じことになります。
そのため、壁の&lt;code&gt;R&lt;/code&gt;に&lt;code&gt;D-1&lt;/code&gt;を追加したときの区間スケジューリング問題として扱うことができます。
&lt;code&gt;R&lt;/code&gt;で壁を昇順ソートして順にみたとき、&lt;code&gt;L&lt;/code&gt;が有効な場合に壁を叩くことができれば無効を&lt;code&gt;R&lt;/code&gt;に更新することで数え上げることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, D) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var W = new (long L, long R)[N];
for (var i = 0; i &amp;lt; N; i++)
{
    var (l, r) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    r += D - 1;
    W[i] = (l, r);
}

Array.Sort(W, (x, y) =&amp;gt; x.R.CompareTo(y.R));
var answer = 0;
var rr = 0L;
foreach (var (l, r) in W)
{
    if (rr &amp;gt;= l) continue;
    rr = r;
    answer++;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27675153"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Sqrt(N)&lt;/code&gt;まで見ればよさそう。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sqrt(N)&lt;/code&gt;以降は&lt;code&gt;i*count&lt;/code&gt;で求められそう&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;はどうやって求められるか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;時間切れになりました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N/i&lt;/code&gt;を&lt;code&gt;k&lt;/code&gt;としたとき、&lt;code&gt;k &amp;lt;= N/i &amp;lt; k+1&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;の個数は&lt;code&gt;N/i &amp;gt;= i &amp;gt; N/(K+1)&lt;/code&gt;となるため、&lt;code&gt;N/i - N/(i+1)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
var answer = 0L;
for (var i = 1L; i * i &amp;lt;= N; i++)
{
    if (i != N / i) answer += N / i;
    var count = (N / i) - (N / (i + 1));
    answer += i * count;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC231</title>
			<link>https://aconcavy.github.io/blog/posts/20211222abc231</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 231の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211222abc231</guid>
			<pubDate>Wed, 22 Dec 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 231の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231"&gt;https://atcoder.jp/contests/abc231&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27817574"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入力とって浮動小数点に変換100で割ります。
誤差は&lt;code&gt;10e-3&lt;/code&gt;なので特に気にしなくてもよさそう。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var D = Scanner.Scan&amp;lt;double&amp;gt;();
var answer = D / 100;
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27817722"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ディクショナリで数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var dict = new Dictionary&amp;lt;string, int&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    var s = Scanner.Scan&amp;lt;string&amp;gt;();
    if (!dict.ContainsKey(s)) dict[s] = 0;
    dict[s]++;
}

var answer = &amp;quot;&amp;quot;;
var curr = 0;
foreach (var (k, v) in dict)
{
    if (v &amp;gt;= curr)
    {
        curr = v;
        answer = k;
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27820376"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に探索を行うと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり、TLEになってしまいます。&lt;br /&gt;
そこで、入力された身長をあらかじめソートしておき、クエリごとに二部探索をすることで、クエリあたり時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができ、全体として時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
Array.Sort(A);
 
while (Q-- &amp;gt; 0)
{
    var x = Scanner.Scan&amp;lt;long&amp;gt;();
    var answer = N - LowerBound(A, x);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LowerBound&lt;/code&gt;関数は、ソート済みの配列において与えられた値以上が現れる初めてのインデックスを返します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static int LowerBound(long[] source, long key)
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m] &amp;gt;= key) r = m;
        else l = m;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27829619"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;グラフとして扱うと、一列に並べるということは、隣り合う頂点は2つ以下である必要があります。また、ループがある場合は一列に並べることはできません。&lt;br /&gt;
そのため、各頂点の辺の数とグラフのループ判定を行うことで解くことができます。&lt;br /&gt;
ループ判定はDFSでおこない、既に訪れた頂点があればループがあるという判定を行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
var deg = new int[N];
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--; b--;
    G[a].Add(b);
    G[b].Add(a);
    deg[a]++;
    deg[b]++;
}

var used = new bool[N];

bool Dfs(int u, int p)
{
    var result = true;
    foreach (var v in G[u])
    {
        if (v == p) continue;
        if (used[v]) return false;
        used[v] = true;
        result &amp;amp;= Dfs(v, u);
    }
    return result;
}

var answer = deg.All(x =&amp;gt; x &amp;lt;= 2);
for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; answer; i++)
{
    if (used[i] || deg[i] == 0) continue;
    used[i] = true;
    answer &amp;amp;= Dfs(i, -1);
}
 
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27854595"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察では、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;それぞれの硬貨の選び方は、&lt;code&gt;Ceil(X/A)&lt;/code&gt;または&lt;code&gt;Floor(X/A)&lt;/code&gt;の2通りを大きな硬貨から選ぶことができる。&lt;/li&gt;
&lt;li&gt;大きな硬貨から値を引いていき、0になるまでの距離として考えることができるので、絶対値で考えられる。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;void Dfs(long curr, long count, int idx)
{
    if(curr == 0)
    {
        answer = Math.Min(answer, count);
        return;
    }
    if(idx &amp;lt; 0) return;
    
    var ceil = (curr + A[idx] - 1) / A[idx];
    var floor = curr / A[idx];
    Dfs(Math.Abs(curr - A[idx] * ceil), count + ceil, idx + 1);
    Dfs(Math.Abs(curr - A[idx] * floor), count + floor, idx + 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;メモ化がうまくできずF問題に移りました。&lt;/p&gt;
&lt;p&gt;解説を見たところ、考え方はあっていたので、ディクショナリを使ったdpをしました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;const long inf = (long)1e18;
var dp1 = new Dictionary&amp;lt;long, long&amp;gt;();
dp1[X] = 0;
for (var i = N - 1; i &amp;gt;= 0; i--)
{
    var dp2 = new Dictionary&amp;lt;long, long&amp;gt;();
    foreach (var (x, c) in dp1)
    {
        var ceil = (x + A[i] - 1) / A[i];
        var a = Math.Abs(x - ceil * A[i]);
        if (!dp2.ContainsKey(a)) dp2[a] = inf;
        dp2[a] = Math.Min(dp2[a], c + ceil);
 
        var floor = x / A[i];
        var b = Math.Abs(x - floor * A[i]);
        if (!dp2.ContainsKey(b)) dp2[b] = inf;
        dp2[b] = Math.Min(dp2[b], c + floor);
    }
 
    dp1 = dp2;
}

var answer = dp1[0];
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_f"&gt;問題F&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27903993"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察では、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求めるものは&lt;code&gt;A[i] &amp;gt;= A[j] &amp;amp;&amp;amp; B[i] &amp;lt;= B[j]&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;の組み合わせの数。&lt;/li&gt;
&lt;li&gt;何かしらのソートの後に&lt;code&gt;FenwickTree&lt;/code&gt;でどうにかできそう。&lt;/li&gt;
&lt;li&gt;値が大きいが圧縮すればよさそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;頭の中で考えがまとまらず、実装ができずに時間切れになりました。&lt;/p&gt;
&lt;p&gt;復習時の考察では上記に加えて、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AとBをセットにしたとき、Aの降順かつBの昇順でソートすればよさそう。&lt;/li&gt;
&lt;li&gt;AとBの値が同じものが複数あった場合の処理が必要そう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AとBを圧縮後、ABをタプルとしてディクショナリで数え上げます。
Aの降順かつBの昇順でソートし、順番に見ていくことでそれ以前のAの値は現在のAの値よりも大きく、&lt;code&gt;FenwickTree&lt;/code&gt;でBの個数を管理することで、現在のBの値より小さいBの個数を数え上げることができます。その値にABタプルの個数を掛けることで、同じABの組み合わせが複数あった場合に対処できるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var (ca, _) = Compress(A);
var (cb, _) = Compress(B);
var dict = new Dictionary&amp;lt;(int A, int B), int&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    var ab = (ca[A[i]], cb[B[i]]);
    if (!dict.ContainsKey(ab)) dict[ab] = 0;
    dict[ab]++;
}

var ABC = dict.Select(x =&amp;gt; (A: x.Key.A, B: x.Key.B, C: x.Value)).ToArray();
Array.Sort(ABC, (x, y) =&amp;gt;
{
    var result = y.A.CompareTo(x.A);
    return result == 0 ? x.B.CompareTo(y.B) : result;
});

var answer = 0L;
var ft = new FenwickTree(N);
foreach (var (a, b, c) in ABC)
{
    ft.Add(b, c);
    answer += ft.Sum(b + 1) * c;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC232</title>
			<link>https://aconcavy.github.io/blog/posts/20211220abc232</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 232の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211220abc232</guid>
			<pubDate>Wed, 22 Dec 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 232の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232"&gt;https://atcoder.jp/contests/abc232&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/27984773"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;で文字列を分けてそれぞれ掛けます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Console.ReadLine().Trim().Split('x');
var answer = long.Parse(S[0]) * long.Parse(S[1]);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制約が3文字なので、&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;からそれぞれ文字&lt;code&gt;0&lt;/code&gt;を引いて掛けるだけいいと思います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Console.ReadLine().Trim();
var answer = (S[0] - '0') * (S[2] - '0');
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/27989086"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a-z&lt;/code&gt;を&lt;code&gt;0-25&lt;/code&gt;とし、26通りのずらし方を試すことで、全部のパターンを調べることができます。&lt;br /&gt;
&lt;code&gt;z&lt;/code&gt;の次は&lt;code&gt;a&lt;/code&gt;なので、&lt;code&gt;26&lt;/code&gt;は&lt;code&gt;a&lt;/code&gt;となるため、&lt;code&gt;26&lt;/code&gt;で余りを取ることで26の周期として扱うことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
var T = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
for (var k = 0; k &amp;lt; 26; k++)
{
    var ok = true;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        ok &amp;amp;= (S[i] + k) % 26 == T[i] % 26;
    }

    if (ok)
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }
}
Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/27999013"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc232/submissions/28020954"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2つのグラフ&lt;code&gt;G1&lt;/code&gt;と&lt;code&gt;G2&lt;/code&gt;が同じ形であることは、&lt;code&gt;G2&lt;/code&gt;の頂点番号のみを適切に置き換えたときに、&lt;code&gt;G1&lt;/code&gt;のそれぞれの辺に対応する辺を持つことを示すことで判定することができます。&lt;br /&gt;
制約も&lt;code&gt;1&amp;lt;=N&amp;lt;=8&lt;/code&gt;と小さいので、&lt;code&gt;G2&lt;/code&gt;のそれぞれの頂点に対応する順列を総当たりし、&lt;code&gt;G2&lt;/code&gt;の辺&lt;code&gt;E2&lt;/code&gt;の頂点を置き換えた辺すべてが、&lt;code&gt;G1&lt;/code&gt;の辺&lt;code&gt;E1&lt;/code&gt;に存在するかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var E1 = new bool[N, N];
var E2 = new (int A, int B)[M];
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--; b--;
    E1[a, b] = E1[b, a] = true;
}
 
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--; b--;
    E2[i] = (a, b);
}
 
foreach (var order in Enumerable.Range(0, N).Permute())
{
    var ok = true;
    foreach (var (c, d) in E2)
    {
        ok &amp;amp;= E1[order[c], order[d]];
    }

    if (ok)
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }
}

Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Permute&lt;/code&gt;メソッドは自作のLINQ拡張メソッドです。&lt;/p&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/28004343"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc232/submissions/28021337"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移動方法が&lt;code&gt;i+1&lt;/code&gt;か&lt;code&gt;j+1&lt;/code&gt;のみなので、左上のマスから行くことができるマスを数え上げます。&lt;br /&gt;
もし隣り合うマスが&lt;code&gt;.&lt;/code&gt;ならば、そのマスの現在の値と今いるマスの値+1との最大を集計することで、そのマスまで通ったマスの数の最大値をまとめることができます。&lt;br /&gt;
制約により左上の値が1のため、マスの値が0の場合は、マスが&lt;code&gt;#&lt;/code&gt;、または到達不可能といえるので、判定を無視することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var C = new char[H][];
for (var i = 0; i &amp;lt; H; i++)
{
    C[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToArray();
}
var G = new int[H, W];
G[0, 0] = 1;
var answer = 0;
for (var i = 0; i &amp;lt; H; i++)
{
    for (var j = 0; j &amp;lt; W; j++)
    {
        if (G[i, j] == 0) continue;
        answer = Math.Max(answer, G[i, j]);
        if (i + 1 &amp;lt; H &amp;amp;&amp;amp; C[i + 1][j] == '.')
        {
            G[i + 1, j] = Math.Max(G[i + 1, j], G[i, j] + 1);
        }

        if (j + 1 &amp;lt; W &amp;amp;&amp;amp; C[i][j + 1] == '.')
        {
            G[i, j + 1] = Math.Max(G[i, j + 1], G[i, j] + 1);
        }
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;高橋君がマス (1,1) から歩き始めるとき&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;del&gt;ほかの場所から再開できると勘違いして4WAしました。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;解説では、逆順にマスの値を確定させていくことで、左上のマスに最終的な値をまとめているみたいです。&lt;/p&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/28020203"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K=1&lt;/code&gt;の時は、&lt;code&gt;(x1 == x2 &amp;amp;&amp;amp; y1 != y2) || (x1 != x2 &amp;amp;&amp;amp; y1 == y2)&lt;/code&gt;の場合のみ到達可能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K=2&lt;/code&gt;の時は、
&lt;code&gt;(x1 == x2 &amp;amp;&amp;amp; y1 == y2)&lt;/code&gt;ならば、&lt;code&gt;H-1&lt;/code&gt;または&lt;code&gt;W-1&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;(x1 == x2 &amp;amp;&amp;amp; y1 != y2)&lt;/code&gt;ならば、&lt;code&gt;H-2&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;(x1 != x2 &amp;amp;&amp;amp; y1 == y2)&lt;/code&gt;ならば、&lt;code&gt;W-2&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;(x1 != x2 &amp;amp;&amp;amp; y1 != y2)&lt;/code&gt;ならば、&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K&amp;gt;=3&lt;/code&gt;の時は、
&lt;code&gt;K-2&lt;/code&gt;を数え上げたうえで&lt;code&gt;K=2&lt;/code&gt;の盤面ができれば解くことができないだろうか。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var h = 0; h &amp;lt; K - 2; h++)
{
    var w = K - 2 - h;
    // 組み合わせ?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;時間切れになりました。&lt;/p&gt;
&lt;p&gt;解説では、4通りの状態のdpでした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;// dp[k, 0, 0]: k回動いた時の(x1 == x2 &amp;amp;&amp;amp; y1 == y2)の状態
// dp[k, 0, 1]: k回動いた時の(x1 == x2 &amp;amp;&amp;amp; y1 != y2)の状態
// dp[k, 1, 0]: k回動いた時の(x1 != x2 &amp;amp;&amp;amp; y1 == y2)の状態
// dp[k, 1, 1]: k回動いた時の(x1 != x2 &amp;amp;&amp;amp; y1 != y2)の状態

// 初期状態
dp[0, x1 == x2 ? 0 : 1, y1 == y2 ? 0 : 1] = 1;

for (var k = 0; k &amp;lt; K; k++)
{
    dp[k + 1, 0, 0] = dp[k, 0, 1] + dp[k, 1, 0];
    dp[k + 1, 0, 1] = dp[k, 0, 0] * (W - 1) + dp[k, 0, 1] * (W - 2) + dp[k, 1, 1];
    dp[k + 1, 1, 0] = dp[k, 0, 0] * (H - 1) + dp[k, 1, 0] * (H - 2) + dp[k, 1, 1];
    dp[k + 1, 1, 1] = dp[k, 0, 1] * (H - 1) + dp[k, 1, 0] * (W - 1) + dp[k, 1, 1] * (H + W - 4);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>じゃんけん</title>
			<link>https://aconcavy.github.io/blog/posts/20210302rockpaperscissors</link>
			<description>&lt;p&gt;&lt;code&gt;if&lt;/code&gt; を使わずにじゃんけんします。
じゃんけんの結果はC#8の機能の &lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/operators/switch-expression"&gt;switch式&lt;/a&gt; を使って受け取ります。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20210302rockpaperscissors</guid>
			<pubDate>Tue, 02 Mar 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; を使わずにじゃんけんします。
じゃんけんの結果はC#8の機能の &lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/operators/switch-expression"&gt;switch式&lt;/a&gt; を使って受け取ります。&lt;/p&gt;
&lt;p&gt;先駆者様&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/tadsan/items/65d91ba6b50535fc8815"&gt;https://qiita.com/tadsan/items/65d91ba6b50535fc8815&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/libraplanet/items/bcf17c22143dc77f875b"&gt;https://qiita.com/libraplanet/items/bcf17c22143dc77f875b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/AconCavy/items/b86b9e835a362795d33f"&gt;Qiita&lt;/a&gt;とのクロスポストです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;勝敗判定&lt;/h1&gt;
&lt;p&gt;じゃんけんのルールとして、&lt;code&gt;-&amp;gt;&lt;/code&gt; の右側が強いものとすると、 &lt;code&gt;Rock&lt;/code&gt; -&amp;gt; &lt;code&gt;Paper&lt;/code&gt; -&amp;gt; &lt;code&gt;Scissors&lt;/code&gt; -&amp;gt; &lt;code&gt;Rock&lt;/code&gt; の関係性が成り立ち、3つの手を周期として勝敗が決まります。
ここで、&lt;code&gt;Rock&lt;/code&gt; を0、&lt;code&gt;Paper&lt;/code&gt; を1、&lt;code&gt;Scissors&lt;/code&gt; を2として、関係性をそれぞれ1の距離を持った有効グラフだとすると、自分の手と相手の手の距離が1では負け、距離が2では勝ち、距離が0(3)ではあいこのような表現することができます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/rps_dia.webp" class="img-fluid" alt="rps_dia.png"&gt;&lt;/p&gt;
&lt;p&gt;このことから、&lt;code&gt;相手の手 - 自分の手&lt;/code&gt; を計算することで距離を求めることができます。
しかし、自分の手が2で、相手の手が0だった場合、&lt;code&gt;0 - 2 == -2&lt;/code&gt;のように、距離が負数になってしまいます。このとき、じゃんけんは3つの手を周期としているため、自分の手や相手の手を3つ移動させたところで手は変わらず、勝敗は変わりません。つまり、距離に3を足したり、3で剰余を取ったとしても勝敗は変わりません。このことから、&lt;code&gt;(相手の手 - 自分の手 + 3) % 3&lt;/code&gt; とすることで、距離を0、1、2の3つにすることができ、負数と3以上になることを避けることができます。&lt;/p&gt;
&lt;h1 id="section-2"&gt;実装&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Rps&lt;/code&gt; (Rock-Paper-Scissors) クラスに &lt;code&gt;Hand&lt;/code&gt; (グー、チョキ、パー) と &lt;code&gt;Result&lt;/code&gt; (引き分け、負け、勝ち) の &lt;code&gt;enum&lt;/code&gt; を定義することで、&lt;code&gt;Battle&lt;/code&gt; 関数の引数と戻り値にそれぞれ意味を持たせます。&lt;/p&gt;
&lt;p&gt;C#の &lt;code&gt;enum&lt;/code&gt; は、既定値として &lt;code&gt;int&lt;/code&gt; の0をとり、要素が増えるにつれて1増えます。そのため、この場合は、 &lt;code&gt;Rock (0)&lt;/code&gt;、 &lt;code&gt;Paper (1)&lt;/code&gt;、 &lt;code&gt;Scissors (2)&lt;/code&gt; のようにそれぞれ値を持つことができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Battle&lt;/code&gt; 関数は、自分の手と相手の手を渡すことで、&lt;code&gt;Result.Draw&lt;/code&gt;、 &lt;code&gt;Result.Lose&lt;/code&gt;、 &lt;code&gt;Result.Win&lt;/code&gt; のいずれかを返します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Rps
{
    public enum Hand
    {
        Rock,
        Paper,
        Scissors
    }

    public enum Result
    {
        Draw,
        Lose,
        Win
    }

    public static Result Battle(Hand own, Hand opponent)
    {
        var result = ((int)opponent - (int)own + 3) % 3;
        return (Result)result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;呼び出し側では、例に倣ってそれぞれの絵文字を割り当てます。
&lt;code&gt;switch式&lt;/code&gt; を使うことで、&lt;code&gt;Battle&lt;/code&gt; が返す可能性のあるパターンに、 &lt;code&gt;あいこ&lt;/code&gt;、&lt;code&gt;あなたの負け&lt;/code&gt;、&lt;code&gt;あなたの勝ち&lt;/code&gt; を割り当て、一致した要素を &lt;code&gt;result&lt;/code&gt; として受け、自分の手、相手の手と一緒に表示します。 &lt;code&gt;_ =&amp;gt; throw new ArgumentOutOfRangeException()&lt;/code&gt; では、対象となる値以外の値として判定された際に該当するアームになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Program
{
    public static void Main()
    {
        const string draw = "あいこ";
        const string lose = "あなたの負け";
        const string win = "あなたの勝ち";

        var map = new Dictionary&amp;lt;Rps.Hand, string&amp;gt;
        {
            [Rps.Hand.Rock] = "✊", [Rps.Hand.Paper] = "🖐", [Rps.Hand.Scissors] = "✌"
        };

        // var hands = new[] { Rps.Hand.Rock, Rps.Hand.Paper, Rps.Hand.Scissors };
        var hands = Enum.GetValues(typeof(Rps.Hand)).Cast&amp;lt;Rps.Hand&amp;gt;().ToArray();

        foreach (var own in hands)
        foreach (var opponent in hands)
        {
            // Draw, Lose, Winのままなら
            // var result = Rps.Battle(own, opponent).ToString();
            
            var result = Rps.Battle(own, opponent) switch
            {
                Rps.Result.Draw =&amp;gt; draw,
                Rps.Result.Lose =&amp;gt; lose,
                Rps.Result.Win =&amp;gt; win,
                _ =&amp;gt; throw new ArgumentOutOfRangeException()
            };
            Console.WriteLine($"{map[own]} vs {map[opponent]}: {result}");
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-3"&gt;実行結果&lt;/h1&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/rps.webp" class="img-fluid" alt="rps.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sharplab.io/#v2:C4LgTgrgdgPgAgJgIwFgBQcAMACOSAsA3OlrkgHQAyAllAI7FrpQCGAtgKYDOADiwMYdsAZRZQAJgCMA9gA90Ab3TYVuBAGZlqpWlV61CLfuw7jx/tKhdgZHOLAsA7tgC82AESAhBkAiDIGUGd4xm+hZWNng4ADbSXEJuXoBWDID6DIB2DIAFMYCKDAFGQdgh1rbYjrSuHp5JyYC7SoCGDFlMujkqAG4sYNhsLDwlUBzOACLU/MDUli0AngA8AEo8XOQAEmLiADS2AHzZQaYN+gDa07MLEuST0vwA1gC6Je6AUOTuK3sz84vkAAodHGBXcYC8G4AJu/dsI8Di9hPxqFwuNIwFxvh5ADDk7g2ZgAvoFtgB6DHYZqtAAWiy4XR6OyuCmw+2eRxO5xWlMO4jeHzAdKeDPIYIhUJh2DRyOMuOwBIkRLcAFEoBA2OQAOIcYAANRYEQg3AAFMBRjwONIAGZq+mLACURvIAGEWNYpmzFqs1aaACrSACCYAco3tjH5+l10I4Ajx2DVgukjig2GKwvEXCN3r0vrA/v4geDLWw0h4PEsHCgNkjhNj9QaW22qixOLTia4EAiNjclIAQixgMAIhw1aGoCsM1nurnHdJhMAwLQAOaeuNmQVVmt1ilPJsttsdsPdzPZ/vYLhFYDJyfGEul/SUybcWfkXoOZwuVbYexOJb7nIns+1qjRWK3qIxR9Fo96F9qzfAB1Yob0KWhf3/YwAH1XFvYA8TAUNsG6ZxXVHKUc2AAB5CBcN1SYxFHDgxVkQQeCGSx7SfPQ+T/Us8AATjVAASdwFHaHgdk7C4URxIlOI6Hj1z7YA+JAEwZ1rFF3CNdEGhRb0lL/FTsjgdQyAANjUecuGyQ89A07AcylbAGW9QyzBpM4oO2d5tRZJ9OUhaF9IY1Q1I8lRjNMtgKVfYBLKfS8HyfSgPzshpQKgZT0G9Yy8B008gJsRdW3bBl01XczFnTUTsMLTYn2nQKSjVNVaGAI0ew3GwAFogyqmqw2wABqbB1CNbAAFJOoUnI4AAdiDFLZyNaTgAGujshUlEgA==="&gt;sharplabでの実行結果&lt;/a&gt;&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>GitHub ActionsからNuGetにパッケージをアップロードした</title>
			<link>https://aconcavy.github.io/blog/posts/20210121uploadnuget</link>
			<description>&lt;p&gt;GitHub Actionsで.NETプロジェクトからNuGetパッケージの作成、Releaseの作成およびNuGetにパッケージをアップロードするまでをまとめた記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20210121uploadnuget</guid>
			<pubDate>Thu, 21 Jan 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;GitHub Actionsで.NETプロジェクトからNuGetパッケージの作成、Releaseの作成およびNuGetにパッケージをアップロードするまでをまとめた記事です。&lt;/p&gt;
&lt;p&gt;リポジトリは&lt;a href="https://github.com/AconCavy/Mulinq"&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="tldr"&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GitHub ActionsでNuGetパッケージを作成した。&lt;/li&gt;
&lt;li&gt;作成したNuGetパッケージをNuGetにアップロードした。&lt;/li&gt;
&lt;li&gt;タグからリリース/プレリリースを判断できるようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="net"&gt;対象の.NETプロジェクトの設定&lt;/h1&gt;
&lt;p&gt;パッケージ化する.NETプロジェクトの&lt;code&gt;.csproj&lt;/code&gt;ファイルを更新します。
今回はビルド構成として.NET 5と.NET Core 3.1のdllを生成するために、&lt;code&gt;TargetFrameworks&lt;/code&gt;に&lt;code&gt;net5.0&lt;/code&gt;と&lt;code&gt;netcoreapp3.1&lt;/code&gt;を構成します。&lt;/p&gt;
&lt;p&gt;そして、NuGetの情報を構成します。今回は&lt;code&gt;.csproj&lt;/code&gt;に構成しましたが、&lt;code&gt;.nuspec&lt;/code&gt;ファイルを作成してNuGet情報だけを切り離して構成することも可能なようです。
&lt;code&gt;PackageVersion&lt;/code&gt;はcsprojをリリースのたびに変更せずに、ビルド時にバージョンを指定できるように、&lt;code&gt;$(Version)&lt;/code&gt;の環境変数を使います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml line-numbers"&gt;&amp;lt;Project Sdk="Microsoft.NET.Sdk"&amp;gt;

    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;TargetFrameworks&amp;gt;net5.0;netcoreapp3.1&amp;lt;/TargetFrameworks&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;
    
    &amp;lt;!-- NuGet --&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;PackageId&amp;gt;Mulinq&amp;lt;/PackageId&amp;gt;
        &amp;lt;PackageVersion&amp;gt;$(Version)&amp;lt;/PackageVersion&amp;gt;
        &amp;lt;Title&amp;gt;Mulinq&amp;lt;/Title&amp;gt;
        &amp;lt;Authors&amp;gt;AconCavy&amp;lt;/Authors&amp;gt;
        &amp;lt;Description&amp;gt;Mulinq is C# LINQ extensions for collections and for multidimensional arrays.&amp;lt;/Description&amp;gt;
        &amp;lt;PackageProjectUrl&amp;gt;https://github.com/AconCavy/Mulinq&amp;lt;/PackageProjectUrl&amp;gt;
        &amp;lt;PackageLicenseExpression&amp;gt;MIT&amp;lt;/PackageLicenseExpression&amp;gt;
        &amp;lt;RepositoryUrl&amp;gt;https://github.com/AconCavy/Mulinq&amp;lt;/RepositoryUrl&amp;gt;
        &amp;lt;PackageTags&amp;gt;LINQ&amp;lt;/PackageTags&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="nuget"&gt;NuGetの設定&lt;/h1&gt;
&lt;p&gt;NuGetアカウントを持っていない場合はアカウントの作成をします。Microsoftアカウントから作成もできるみたいです。&lt;/p&gt;
&lt;p&gt;NuGetパッケージのアップロードには、NuGetのAPIキーが必要なので、APIキーを生成します。
画面右上のユーザから、&lt;code&gt;API Keys&lt;/code&gt;のページに移動し、&lt;code&gt;Create&lt;/code&gt;フォームから、&lt;code&gt;Key Name&lt;/code&gt;や&lt;code&gt;Package Owner&lt;/code&gt;等必要な情報を埋め、APIキーを生成します。
生成に成功すると、&lt;code&gt;Manage&lt;/code&gt;パネルに生成したAPIキーが並ぶので、&lt;code&gt;Copy&lt;/code&gt;でAPIキーをコピーします。一度ページから離れてしまうと、再びコピーできなくなるので、できなくなった場合は&lt;code&gt;Regenerate&lt;/code&gt;から再生成します。&lt;/p&gt;
&lt;p&gt;コピーしたAPIキーをGitHubリポジトリの&lt;code&gt;Secrets&lt;/code&gt;に登録することで、GitHub Actionsの環境変数としてアクセスできるようになります。リポジトリの&lt;code&gt;Setting -&amp;gt; Secrets -&amp;gt; New repository secret&lt;/code&gt;で新しいシークレットを作成し、名前とAPIキーを登録します。今回は&lt;code&gt;NUGET_API_KEY&lt;/code&gt;として登録しました。&lt;/p&gt;
&lt;h1 id="workflow"&gt;Workflowの作成&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://aconcavy.github.io/blog/20201212createrepository"&gt;リポジトリを作成したときにやっておきたいこと&lt;/a&gt;のReleaseの作成をもとにWorkflowを作成します。&lt;/p&gt;
&lt;p&gt;RelaseのWorkflowを実行するトリガーとして、&lt;code&gt;v1.0.0&lt;/code&gt;や&lt;code&gt;v1.0.0-alpha&lt;/code&gt;のようなGitのタグがpushされたときに限定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;on:
  push:
    tags: 
    - 'v[0-9]+.[0-9]+.[0-9]+*'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最初にテストを実行します。今回はTargetFrameworkが複数あるため、複数の.NET SDKをセットアップします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Test
      run: dotnet test -c Release --verbosity normal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次にテストが成功した場合のみリリースを実行します。&lt;code&gt;needs: [test]&lt;/code&gt;とすることで、&lt;code&gt;test&lt;/code&gt;のjobが成功した場合のみ実行されるようになります。
まず、プロジェクトからNuGetパッケージを作成します。このとき、&lt;code&gt;-p:Version&lt;/code&gt;にバージョンを指定します。タグのバージョン情報を取得するために、&lt;code&gt;${GITHUB_REF##*/v}&lt;/code&gt;を指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;dotnet pack ./src/Mulinq/Mulinq.csproj -c Release -p:Version=${GITHUB_REF##*/v} -o ./publish
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;GITHUB_REF&lt;/code&gt;の環境変数では、ワークフローをトリガーしたタグのrefを取得でき、&lt;code&gt;v1.0.0&lt;/code&gt;のようなタグの場合は&lt;code&gt;refs/heads/v1.0.0&lt;/code&gt;という文字列を取得できます。そこから&lt;code&gt;1.0.0&lt;/code&gt;の部分だけ取得し、&lt;code&gt;Version&lt;/code&gt;の環境変数に指定します。
ビルドに成功した場合は、&lt;code&gt;./publish&lt;/code&gt;に&lt;code&gt;Mulinq.1.0.0.nupkg&lt;/code&gt;が生成されます。&lt;/p&gt;
&lt;p&gt;そして、NuGetのAPIを叩き、作成した&lt;code&gt;.nupkg&lt;/code&gt;をアップロードします。&lt;code&gt;secrets.NUGET_API_KEY&lt;/code&gt;から、リポジトリに登録したNuGetのAPIキーを参照します。&lt;code&gt;secrets.&amp;lt;*&amp;gt;&lt;/code&gt;は上記で登録したシークレットの名前になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;release:
    runs-on: ubuntu-latest
    needs: [test]
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET Core 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Build
      run: dotnet pack ./src/Mulinq/Mulinq.csproj -c Release -p:Version=${GITHUB_REF##*/v} -o ./publish
    - name: Upload to NuGet
      run: dotnet nuget push ./publish/*.nupkg -k ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json
    
    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: ${{ github.ref }}
        draft: false
        prerelease: ${{ contains(github.ref, '-') }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、GitHubにReleaseを作成します。
&lt;code&gt;prerelease&lt;/code&gt;のプロパティに&lt;code&gt;true|false&lt;/code&gt;を指定することで、作成するリリースがプレリリースか否かを指定できます。そのため、タグに&lt;code&gt;-&lt;/code&gt;が含まれているかをチェックする&lt;code&gt;contains&lt;/code&gt;関数を使用して、&lt;code&gt;v1.0.0&lt;/code&gt;のような普通のリリースの場合と、&lt;code&gt;v1.0.0-alpha&lt;/code&gt;のようなプレリリースを区別できるようにしました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;- name: Create Release
  id: create_release
  uses: actions/create-release@v1
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  with:
    tag_name: ${{ github.ref }}
    release_name: ${{ github.ref }}
    draft: false
    prerelease: ${{ contains(github.ref, '-') }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Workflow全体としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;name: Release

on:
  push:
    tags: 
    - 'v[0-9]+.[0-9]+.[0-9]+*'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Test
      run: dotnet test -c Release --verbosity normal
  
  release:
    runs-on: ubuntu-latest
    needs: [test]
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET Core 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Build
      run: dotnet pack ./src/Mulinq/Mulinq.csproj -c Release -p:Version=${GITHUB_REF##*/v} -o ./publish
    - name: Upload to NuGet
      run: dotnet nuget push ./publish/*.nupkg -k ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json
    
    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: ${{ github.ref }}
        draft: false
        prerelease: ${{ contains(github.ref, '-') }}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="workflow-1"&gt;Workflowの実行&lt;/h1&gt;
&lt;p&gt;適当にコミットを作成し、&lt;code&gt;v0.0.1-alpha&lt;/code&gt;というタグをつけ、GitHub上にプッシュします。&lt;/p&gt;
&lt;p&gt;作成したWorkflowが実行され、テスト、ビルド、アップロード、Releaseの作成が行われます。&lt;/p&gt;
&lt;p&gt;NuGetへアップロード直後は&lt;code&gt;Unlisted Packages&lt;/code&gt;の状態でしたが、しばらくすると&lt;code&gt;Published Packages&lt;/code&gt;になりました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/nuget_upload.webp" class="img-fluid" alt="succeeded upload to nuget"&gt;&lt;/p&gt;
&lt;p&gt;GitHubのリリースのほうは、ちゃんと&lt;code&gt;Pre-Release&lt;/code&gt;で作成されています。
&lt;img src="https://aconcavy.github.io/blog/assets/images/gha_prerelease.webp" class="img-fluid" alt="pre-release"&gt;&lt;/p&gt;
&lt;h1 id="section-1"&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;GitHub ActionsでNuGetパッケージを作成した。&lt;/li&gt;
&lt;li&gt;作成したNuGetパッケージをNuGetにアップロードした。&lt;/li&gt;
&lt;li&gt;タグからリリース/プレリリースを判断できるようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NuGetのパッケージ作成は怖くない！&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>