<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://aconcavy.github.io/blog</link>
		<description />
		<copyright>Copyright © 2020-2022 AconCavy</copyright>
		<pubDate>Sat, 08 Jan 2022 14:54:24 GMT</pubDate>
		<lastBuildDate>Sat, 08 Jan 2022 14:54:24 GMT</lastBuildDate>
		<item>
			<title>abc233</title>
			<link>https://aconcavy.github.io/blog/posts/20211225abc233</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 233の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211225abc233</guid>
			<pubDate>Sat, 08 Jan 2022 14:53:50 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 233の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233"&gt;https://atcoder.jp/contests/abc233&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28110738"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(Y-X)&lt;/code&gt;を10で割ったときの切り上げの値が必要な切手の数となります。
&lt;code&gt;(Y-X)&lt;/code&gt;が負の場合は既に金額が足りているので、0と&lt;code&gt;Max&lt;/code&gt;を取ることで、&lt;code&gt;if&lt;/code&gt;文なくすことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (X, Y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var answer = Math.Max(0, ((Y - X) + 9) / 10);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28113146"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;code&gt;Array.Reverse&lt;/code&gt;メソッドを使うことで、配列の指定した範囲を逆順にすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (L, R) = Scanner.Scan&amp;lt;int, int&amp;gt;();
L--;
var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
Array.Reverse(S, L, R - L);
Console.WriteLine(string.Join(&amp;quot;&amp;quot;, S));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28122407"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;総積が&lt;code&gt;X&lt;/code&gt;になるためには、要素となる数が&lt;code&gt;X&lt;/code&gt;の倍数である必要があるため、それ以外を除いたものから、袋からそれぞれ1つずつ選んだ時の組み合わせの数となります。&lt;br /&gt;
再帰関数を使って&lt;code&gt;idx&lt;/code&gt;となる袋を順にみていくとき、ボールの値が現在の値&lt;code&gt;curr&lt;/code&gt;の倍数であり、&lt;code&gt;curr&lt;/code&gt;が0より大きい場合、次の袋に進むことができます。&lt;br /&gt;
もしすべての袋から1つずつ拾うことができて、&lt;code&gt;curr&lt;/code&gt;の値が1のときは、それまでに選んだボールの値の総積が&lt;code&gt;X&lt;/code&gt;となるので、その時の数を数え上げることで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, X) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = new long[N][];
for (var i = 0; i &amp;lt; N; i++)
{
    A[i] = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().Skip(1).Where(x =&amp;gt; X % x == 0).ToArray();
}

var answer = 0L;

void Dfs(int idx, long curr)
{
    if (idx == N)
    {
        if (curr == 1) answer++;
        return;
    }

    foreach (var a in A[idx])
    {
        if (curr % a == 0 &amp;amp;&amp;amp; curr / a != 0)
        {
            Dfs(idx + 1, curr / a);
        }
    }
}

Dfs(0, X);

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28148861"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;累積和で範囲を求められそう&lt;/li&gt;
&lt;li&gt;尺取り法は単調増加ではないから使えなさそう&lt;/li&gt;
&lt;li&gt;ディクショナリでまとめて数え上げられそう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;L&lt;/code&gt;を固定したときに&lt;code&gt;R&lt;/code&gt;の数を数え上げましたが、実装が間違っていたのかWAで時間切れとなりました。&lt;/p&gt;
&lt;p&gt;解説では&lt;code&gt;R&lt;/code&gt;を固定したときに&lt;code&gt;L&lt;/code&gt;の数を数え上げていました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
var cum = new long[N + 1];
for (var i = 0; i &amp;lt; N; i++)
{
    cum[i + 1] = cum[i] + A[i];
}

var dict = new Dictionary&amp;lt;long, long&amp;gt;();
var answer = 0L;
for (var i = 1; i &amp;lt;= N; i++)
{
    if (!dict.ContainsKey(cum[i - 1]))
    {
        dict[cum[i - 1]] = 0;
    }
    dict[cum[i - 1]]++;
    if (dict.ContainsKey(cum[i] - K))
    {
        answer += dict[cum[i] - K];
    }
}
 
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc233/tasks/abc233_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc233/submissions/28143437"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大きい桁から累積和を取ると、その桁に最終的に足される数を求めることができます。
累積和を小さい桁から見たとき、その桁の累積和の1の位の数が桁として確定し、累積和の1の位より大きい値は、その次の桁に繰り上げられるため、次の桁の累積和に足す必要があります。&lt;br /&gt;
出力では、一番大きい桁が0の場合は除外して表示する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var X = Scanner.Scan&amp;lt;string&amp;gt;();
var N = X.Length;
var cum = new int[N + 1];
for (var i = 0; i &amp;lt; N; i++)
{
    cum[i + 1] = cum[i] + X[i] - '0';
}

var answer = new int[X.Length + 1];
for (var i = N; i &amp;gt; 0; i--)
{
    answer[i] = cum[i] % 10;
    cum[i - 1] += cum[i] / 10;
}

answer[0] += cum[0];
if (answer[0] == 0)
{
    Console.WriteLine(string.Join(&amp;quot;&amp;quot;, answer.Skip(1)));
}
else
{
    Console.WriteLine(string.Join(&amp;quot;&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC230</title>
			<link>https://aconcavy.github.io/blog/posts/20211224abc230</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 230の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211224abc230</guid>
			<pubDate>Sat, 08 Jan 2022 14:53:50 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 230の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230"&gt;https://atcoder.jp/contests/abc230&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27643596"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入力を取り、&lt;code&gt;N&lt;/code&gt;が42以上なら答えをインクリメントします。C#では出力をフォーマットできるので、0埋めフォーマットを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
if (N &amp;gt;= 42) N++;
// var answer = $&amp;quot;AGC{N.ToString(&amp;quot;000&amp;quot;)}&amp;quot;;
var answer = $&amp;quot;AGC{N:000}&amp;quot;;
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27651060"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc230/submissions/27674559"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3つ連続した部分文字列において、&lt;code&gt;x&lt;/code&gt;が3つ連続した場合、&lt;code&gt;oxo&lt;/code&gt;のように&lt;code&gt;o&lt;/code&gt;が2つ以上含まれている場合は答えは&lt;code&gt;No&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();
var answer = true;
for (var i = 0; i + 2 &amp;lt; S.Length; i++)
{
    answer &amp;amp;= (S[i], S[i + 1], S[i + 2]) != ('x', 'x', 'x');
    answer &amp;amp;= (S[i], S[i + 1], S[i + 2]) != ('o', 'x', 'o');
}

for (var i = 0; i + 1 &amp;lt; S.Length; i++)
{
    answer &amp;amp;= (S[i], S[i + 1]) != ('o', 'o');
}

Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解説では、&lt;code&gt;Yes&lt;/code&gt;になるテンプレートは高々3つなので、そのテンプレートの順番で&lt;code&gt;o&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;が出現しているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;();
foreach (var t in new[] { &amp;quot;oxx&amp;quot;, &amp;quot;xox&amp;quot;, &amp;quot;xxo&amp;quot; })
{
    var ok = true;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        ok &amp;amp;= S[i] == t[i % 3];
    }
 
    if (ok)
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }
}
 
Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27664018"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc230/submissions/27674563"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;黒く塗りつぶすべきマスは、&lt;code&gt;x&lt;/code&gt;の交点となる&lt;code&gt;(A,B)&lt;/code&gt;からの距離&lt;code&gt;dx&lt;/code&gt;と&lt;code&gt;dy&lt;/code&gt;の絶対値が一致する箇所になります。
そのため、対象となるマスを見ていくとき、&lt;code&gt;Abs(dx) == Abs(dy)&lt;/code&gt;になるマスを黒く塗れば、求められる出力が得られます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, A, B) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
var (P, Q, R, S) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();

for (var i = P; i &amp;lt;= Q; i++)
{
    for (var j = R; j &amp;lt;= S; j++)
    {
        Console.Write(Math.Abs(A - i) == Math.Abs(B - j) ? '#' : '.');
    }
    Console.WriteLine();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27665969"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D&lt;/code&gt;列まとめてダメージを与えられるということは、壁の当たり判定を&lt;code&gt;D-1&lt;/code&gt;伸ばして、パンチを1列にすることと同じことになります。
そのため、壁の&lt;code&gt;R&lt;/code&gt;に&lt;code&gt;D-1&lt;/code&gt;を追加したときの区間スケジューリング問題として扱うことができます。
&lt;code&gt;R&lt;/code&gt;で壁を昇順ソートして順にみたとき、&lt;code&gt;L&lt;/code&gt;が有効な場合に壁を叩くことができれば無効を&lt;code&gt;R&lt;/code&gt;に更新することで数え上げることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, D) = Scanner.Scan&amp;lt;int, long&amp;gt;();
var W = new (long L, long R)[N];
for (var i = 0; i &amp;lt; N; i++)
{
    var (l, r) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    r += D - 1;
    W[i] = (l, r);
}

Array.Sort(W, (x, y) =&amp;gt; x.R.CompareTo(y.R));
var answer = 0;
var rr = 0L;
foreach (var (l, r) in W)
{
    if (rr &amp;gt;= l) continue;
    rr = r;
    answer++;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc230/tasks/abc230_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc230/submissions/27675153"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Sqrt(N)&lt;/code&gt;まで見ればよさそう。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sqrt(N)&lt;/code&gt;以降は&lt;code&gt;i*count&lt;/code&gt;で求められそう&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;はどうやって求められるか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;時間切れになりました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N/i&lt;/code&gt;を&lt;code&gt;k&lt;/code&gt;としたとき、&lt;code&gt;k &amp;lt;= N/i &amp;lt; k+1&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;の個数は&lt;code&gt;N/i &amp;gt;= i &amp;gt; N/(K+1)&lt;/code&gt;となるため、&lt;code&gt;N/i - N/(i+1)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;long&amp;gt;();
var answer = 0L;
for (var i = 1L; i * i &amp;lt;= N; i++)
{
    if (i != N / i) answer += N / i;
    var count = (N / i) - (N / (i + 1));
    answer += i * count;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC231</title>
			<link>https://aconcavy.github.io/blog/posts/20211222abc231</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 231の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211222abc231</guid>
			<pubDate>Sat, 08 Jan 2022 14:53:50 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;AtCoder Beginner Contest 231の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231"&gt;https://atcoder.jp/contests/abc231&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27817574"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入力とって浮動小数点に変換100で割ります。
誤差は&lt;code&gt;10e-3&lt;/code&gt;なので特に気にしなくてもよさそう。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var D = Scanner.Scan&amp;lt;double&amp;gt;();
var answer = D / 100;
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27817722"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ディクショナリで数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var dict = new Dictionary&amp;lt;string, int&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    var s = Scanner.Scan&amp;lt;string&amp;gt;();
    if (!dict.ContainsKey(s)) dict[s] = 0;
    dict[s]++;
}

var answer = &amp;quot;&amp;quot;;
var curr = 0;
foreach (var (k, v) in dict)
{
    if (v &amp;gt;= curr)
    {
        curr = v;
        answer = k;
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27820376"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に探索を行うと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり、TLEになってしまいます。&lt;br /&gt;
そこで、入力された身長をあらかじめソートしておき、クエリごとに二部探索をすることで、クエリあたり時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で求めることができ、全体として時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
Array.Sort(A);
 
while (Q-- &amp;gt; 0)
{
    var x = Scanner.Scan&amp;lt;long&amp;gt;();
    var answer = N - LowerBound(A, x);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LowerBound&lt;/code&gt;関数は、ソート済みの配列において与えられた値以上が現れる初めてのインデックスを返します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static int LowerBound(long[] source, long key)
{
    var (l, r) = (-1, source.Length);
    while (r - l &amp;gt; 1)
    {
        var m = l + (r - l) / 2;
        if (source[m] &amp;gt;= key) r = m;
        else l = m;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27829619"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;グラフとして扱うと、一列に並べるということは、隣り合う頂点は2つ以下である必要があります。また、ループがある場合は一列に並べることはできません。&lt;br /&gt;
そのため、各頂点の辺の数とグラフのループ判定を行うことで解くことができます。&lt;br /&gt;
ループ判定はDFSでおこない、既に訪れた頂点があればループがあるという判定を行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
var deg = new int[N];
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--; b--;
    G[a].Add(b);
    G[b].Add(a);
    deg[a]++;
    deg[b]++;
}

var used = new bool[N];

bool Dfs(int u, int p)
{
    var result = true;
    foreach (var v in G[u])
    {
        if (v == p) continue;
        if (used[v]) return false;
        used[v] = true;
        result &amp;amp;= Dfs(v, u);
    }
    return result;
}

var answer = deg.All(x =&amp;gt; x &amp;lt;= 2);
for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; answer; i++)
{
    if (used[i] || deg[i] == 0) continue;
    used[i] = true;
    answer &amp;amp;= Dfs(i, -1);
}
 
Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27854595"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察では、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;それぞれの硬貨の選び方は、&lt;code&gt;Ceil(X/A)&lt;/code&gt;または&lt;code&gt;Floor(X/A)&lt;/code&gt;の2通りを大きな硬貨から選ぶことができる。&lt;/li&gt;
&lt;li&gt;大きな硬貨から値を引いていき、0になるまでの距離として考えることができるので、絶対値で考えられる。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;void Dfs(long curr, long count, int idx)
{
    if(curr == 0)
    {
        answer = Math.Min(answer, count);
        return;
    }
    if(idx &amp;lt; 0) return;
    
    var ceil = (curr + A[idx] - 1) / A[idx];
    var floor = curr / A[idx];
    Dfs(Math.Abs(curr - A[idx] * ceil), count + ceil, idx + 1);
    Dfs(Math.Abs(curr - A[idx] * floor), count + floor, idx + 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;メモ化がうまくできずF問題に移りました。&lt;/p&gt;
&lt;p&gt;解説を見たところ、考え方はあっていたので、ディクショナリを使ったdpをしました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;const long inf = (long)1e18;
var dp1 = new Dictionary&amp;lt;long, long&amp;gt;();
dp1[X] = 0;
for (var i = N - 1; i &amp;gt;= 0; i--)
{
    var dp2 = new Dictionary&amp;lt;long, long&amp;gt;();
    foreach (var (x, c) in dp1)
    {
        var ceil = (x + A[i] - 1) / A[i];
        var a = Math.Abs(x - ceil * A[i]);
        if (!dp2.ContainsKey(a)) dp2[a] = inf;
        dp2[a] = Math.Min(dp2[a], c + ceil);
 
        var floor = x / A[i];
        var b = Math.Abs(x - floor * A[i]);
        if (!dp2.ContainsKey(b)) dp2[b] = inf;
        dp2[b] = Math.Min(dp2[b], c + floor);
    }
 
    dp1 = dp2;
}

var answer = dp1[0];
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc231/tasks/abc231_f"&gt;問題F&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc231/submissions/27903993"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察では、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求めるものは&lt;code&gt;A[i] &amp;gt;= A[j] &amp;amp;&amp;amp; B[i] &amp;lt;= B[j]&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;の組み合わせの数。&lt;/li&gt;
&lt;li&gt;何かしらのソートの後に&lt;code&gt;FenwickTree&lt;/code&gt;でどうにかできそう。&lt;/li&gt;
&lt;li&gt;値が大きいが圧縮すればよさそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;頭の中で考えがまとまらず、実装ができずに時間切れになりました。&lt;/p&gt;
&lt;p&gt;復習時の考察では上記に加えて、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AとBをセットにしたとき、Aの降順かつBの昇順でソートすればよさそう。&lt;/li&gt;
&lt;li&gt;AとBの値が同じものが複数あった場合の処理が必要そう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AとBを圧縮後、ABをタプルとしてディクショナリで数え上げます。
Aの降順かつBの昇順でソートし、順番に見ていくことでそれ以前のAの値は現在のAの値よりも大きく、&lt;code&gt;FenwickTree&lt;/code&gt;でBの個数を管理することで、現在のBの値より小さいBの個数を数え上げることができます。その値にABタプルの個数を掛けることで、同じABの組み合わせが複数あった場合に対処できるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var N = Scanner.Scan&amp;lt;int&amp;gt;();
var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
var (ca, _) = Compress(A);
var (cb, _) = Compress(B);
var dict = new Dictionary&amp;lt;(int A, int B), int&amp;gt;();
for (var i = 0; i &amp;lt; N; i++)
{
    var ab = (ca[A[i]], cb[B[i]]);
    if (!dict.ContainsKey(ab)) dict[ab] = 0;
    dict[ab]++;
}

var ABC = dict.Select(x =&amp;gt; (A: x.Key.A, B: x.Key.B, C: x.Value)).ToArray();
Array.Sort(ABC, (x, y) =&amp;gt;
{
    var result = y.A.CompareTo(x.A);
    return result == 0 ? x.B.CompareTo(y.B) : result;
});

var answer = 0L;
var ft = new FenwickTree(N);
foreach (var (a, b, c) in ABC)
{
    ft.Add(b, c);
    answer += ft.Sum(b + 1) * c;
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC232</title>
			<link>https://aconcavy.github.io/blog/posts/20211220abc232</link>
			<description>&lt;p&gt;2021年12月20日に行われた、M-SOLUTIONS プロコンオープン2021(AtCoder Beginner Contest 232)の復習記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20211220abc232</guid>
			<pubDate>Sat, 08 Jan 2022 14:53:50 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;2021年12月20日に行われた、M-SOLUTIONS プロコンオープン2021(AtCoder Beginner Contest 232)の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;コンテスト&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232"&gt;https://atcoder.jp/contests/abc232&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_a"&gt;問題A&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/27984773"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;で文字列を分けてそれぞれ掛けます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Console.ReadLine().Trim().Split('x');
var answer = long.Parse(S[0]) * long.Parse(S[1]);
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制約が3文字なので、&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;からそれぞれ文字&lt;code&gt;0&lt;/code&gt;を引いて掛けるだけいいと思います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Console.ReadLine().Trim();
var answer = (S[0] - '0') * (S[2] - '0');
Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_b"&gt;問題B&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/27989086"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a-z&lt;/code&gt;を&lt;code&gt;0-25&lt;/code&gt;とし、26通りのずらし方を試すことで、全部のパターンを調べることができます。&lt;br /&gt;
&lt;code&gt;z&lt;/code&gt;の次は&lt;code&gt;a&lt;/code&gt;なので、&lt;code&gt;26&lt;/code&gt;は&lt;code&gt;a&lt;/code&gt;となるため、&lt;code&gt;26&lt;/code&gt;で余りを取ることで26の周期として扱うことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
var T = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
for (var k = 0; k &amp;lt; 26; k++)
{
    var ok = true;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        ok &amp;amp;= (S[i] + k) % 26 == T[i] % 26;
    }

    if (ok)
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }
}
Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_c"&gt;問題C&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/27999013"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc232/submissions/28020954"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2つのグラフ&lt;code&gt;G1&lt;/code&gt;と&lt;code&gt;G2&lt;/code&gt;が同じ形であることは、&lt;code&gt;G2&lt;/code&gt;の頂点番号のみを適切に置き換えたときに、&lt;code&gt;G1&lt;/code&gt;のそれぞれの辺に対応する辺を持つことを示すことで判定することができます。&lt;br /&gt;
制約も&lt;code&gt;1&amp;lt;=N&amp;lt;=8&lt;/code&gt;と小さいので、&lt;code&gt;G2&lt;/code&gt;のそれぞれの頂点に対応する順列を総当たりし、&lt;code&gt;G2&lt;/code&gt;の辺&lt;code&gt;E2&lt;/code&gt;の頂点を置き換えた辺すべてが、&lt;code&gt;G1&lt;/code&gt;の辺&lt;code&gt;E1&lt;/code&gt;に存在するかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var E1 = new bool[N, N];
var E2 = new (int A, int B)[M];
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--; b--;
    E1[a, b] = E1[b, a] = true;
}
 
for (var i = 0; i &amp;lt; M; i++)
{
    var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    a--; b--;
    E2[i] = (a, b);
}
 
foreach (var order in Enumerable.Range(0, N).Permute())
{
    var ok = true;
    foreach (var (c, d) in E2)
    {
        ok &amp;amp;= E1[order[c], order[d]];
    }

    if (ok)
    {
        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }
}

Console.WriteLine(&amp;quot;No&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Permute&lt;/code&gt;メソッドは自作のLINQ拡張メソッドです。&lt;/p&gt;
&lt;h2 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_d"&gt;問題D&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/28004343"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc232/submissions/28021337"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移動方法が&lt;code&gt;i+1&lt;/code&gt;か&lt;code&gt;j+1&lt;/code&gt;のみなので、左上のマスから行くことができるマスを数え上げます。&lt;br /&gt;
もし隣り合うマスが&lt;code&gt;.&lt;/code&gt;ならば、そのマスの現在の値と今いるマスの値+1との最大を集計することで、そのマスまで通ったマスの数の最大値をまとめることができます。&lt;br /&gt;
制約により左上の値が1のため、マスの値が0の場合は、マスが&lt;code&gt;#&lt;/code&gt;、または到達不可能といえるので、判定を無視することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
var C = new char[H][];
for (var i = 0; i &amp;lt; H; i++)
{
    C[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToArray();
}
var G = new int[H, W];
G[0, 0] = 1;
var answer = 0;
for (var i = 0; i &amp;lt; H; i++)
{
    for (var j = 0; j &amp;lt; W; j++)
    {
        if (G[i, j] == 0) continue;
        answer = Math.Max(answer, G[i, j]);
        if (i + 1 &amp;lt; H &amp;amp;&amp;amp; C[i + 1][j] == '.')
        {
            G[i + 1, j] = Math.Max(G[i + 1, j], G[i, j] + 1);
        }

        if (j + 1 &amp;lt; W &amp;amp;&amp;amp; C[i][j + 1] == '.')
        {
            G[i, j + 1] = Math.Max(G[i, j + 1], G[i, j] + 1);
        }
    }
}

Console.WriteLine(answer);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;高橋君がマス (1,1) から歩き始めるとき&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;del&gt;ほかの場所から再開できると勘違いして4WAしました。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;解説では、逆順にマスの値を確定させていくことで、左上のマスに最終的な値をまとめているみたいです。&lt;/p&gt;
&lt;h2 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc232/tasks/abc232_e"&gt;問題E&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc232/submissions/28020203"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中の考察です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K=1&lt;/code&gt;の時は、&lt;code&gt;(x1 == x2 &amp;amp;&amp;amp; y1 != y2) || (x1 != x2 &amp;amp;&amp;amp; y1 == y2)&lt;/code&gt;の場合のみ到達可能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K=2&lt;/code&gt;の時は、
&lt;code&gt;(x1 == x2 &amp;amp;&amp;amp; y1 == y2)&lt;/code&gt;ならば、&lt;code&gt;H-1&lt;/code&gt;または&lt;code&gt;W-1&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;(x1 == x2 &amp;amp;&amp;amp; y1 != y2)&lt;/code&gt;ならば、&lt;code&gt;H-2&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;(x1 != x2 &amp;amp;&amp;amp; y1 == y2)&lt;/code&gt;ならば、&lt;code&gt;W-2&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;(x1 != x2 &amp;amp;&amp;amp; y1 != y2)&lt;/code&gt;ならば、&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K&amp;gt;=3&lt;/code&gt;の時は、
&lt;code&gt;K-2&lt;/code&gt;を数え上げたうえで&lt;code&gt;K=2&lt;/code&gt;の盤面ができれば解くことができないだろうか。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;for(var h = 0; h &amp;lt; K - 2; h++)
{
    var w = K - 2 - h;
    // 組み合わせ?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;時間切れになりました。&lt;/p&gt;
&lt;p&gt;解説では、4通りの状態のdpでした。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;// dp[k, 0, 0]: k回動いた時の(x1 == x2 &amp;amp;&amp;amp; y1 == y2)の状態
// dp[k, 0, 1]: k回動いた時の(x1 == x2 &amp;amp;&amp;amp; y1 != y2)の状態
// dp[k, 1, 0]: k回動いた時の(x1 != x2 &amp;amp;&amp;amp; y1 == y2)の状態
// dp[k, 1, 1]: k回動いた時の(x1 != x2 &amp;amp;&amp;amp; y1 != y2)の状態

// 初期状態
dp[0, x1 == x2 ? 0 : 1, y1 == y2 ? 0 : 1] = 1;

for (var k = 0; k &amp;lt; K; k++)
{
    dp[k + 1, 0, 0] = dp[k, 0, 1] + dp[k, 1, 0];
    dp[k + 1, 0, 1] = dp[k, 0, 0] * (W - 1) + dp[k, 0, 1] * (W - 2) + dp[k, 1, 1];
    dp[k + 1, 1, 0] = dp[k, 0, 0] * (H - 1) + dp[k, 1, 0] * (H - 2) + dp[k, 1, 1];
    dp[k + 1, 1, 1] = dp[k, 0, 1] * (H - 1) + dp[k, 1, 0] * (W - 1) + dp[k, 1, 1] * (H + W - 4);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>じゃんけん</title>
			<link>https://aconcavy.github.io/blog/posts/20210302rockpaperscissors</link>
			<description>&lt;p&gt;&lt;code&gt;if&lt;/code&gt; を使わずにじゃんけんします。
じゃんけんの結果はC#8の機能の &lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/operators/switch-expression"&gt;switch式&lt;/a&gt; を使って受け取ります。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20210302rockpaperscissors</guid>
			<pubDate>Tue, 02 Mar 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; を使わずにじゃんけんします。
じゃんけんの結果はC#8の機能の &lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/operators/switch-expression"&gt;switch式&lt;/a&gt; を使って受け取ります。&lt;/p&gt;
&lt;p&gt;先駆者様&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/tadsan/items/65d91ba6b50535fc8815"&gt;https://qiita.com/tadsan/items/65d91ba6b50535fc8815&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/libraplanet/items/bcf17c22143dc77f875b"&gt;https://qiita.com/libraplanet/items/bcf17c22143dc77f875b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://qiita.com/AconCavy/items/b86b9e835a362795d33f"&gt;Qiita&lt;/a&gt;とのクロスポストです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;勝敗判定&lt;/h1&gt;
&lt;p&gt;じゃんけんのルールとして、&lt;code&gt;-&amp;gt;&lt;/code&gt; の右側が強いものとすると、 &lt;code&gt;Rock&lt;/code&gt; -&amp;gt; &lt;code&gt;Paper&lt;/code&gt; -&amp;gt; &lt;code&gt;Scissors&lt;/code&gt; -&amp;gt; &lt;code&gt;Rock&lt;/code&gt; の関係性が成り立ち、3つの手を周期として勝敗が決まります。
ここで、&lt;code&gt;Rock&lt;/code&gt; を0、&lt;code&gt;Paper&lt;/code&gt; を1、&lt;code&gt;Scissors&lt;/code&gt; を2として、関係性をそれぞれ1の距離を持った有効グラフだとすると、自分の手と相手の手の距離が1では負け、距離が2では勝ち、距離が0(3)ではあいこのような表現することができます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/rps_dia.webp" class="img-fluid" alt="rps_dia.png"&gt;&lt;/p&gt;
&lt;p&gt;このことから、&lt;code&gt;相手の手 - 自分の手&lt;/code&gt; を計算することで距離を求めることができます。
しかし、自分の手が2で、相手の手が0だった場合、&lt;code&gt;0 - 2 == -2&lt;/code&gt;のように、距離が負数になってしまいます。このとき、じゃんけんは3つの手を周期としているため、自分の手や相手の手を3つ移動させたところで手は変わらず、勝敗は変わりません。つまり、距離に3を足したり、3で剰余を取ったとしても勝敗は変わりません。このことから、&lt;code&gt;(相手の手 - 自分の手 + 3) % 3&lt;/code&gt; とすることで、距離を0、1、2の3つにすることができ、負数と3以上になることを避けることができます。&lt;/p&gt;
&lt;h1 id="section-2"&gt;実装&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Rps&lt;/code&gt; (Rock-Paper-Scissors) クラスに &lt;code&gt;Hand&lt;/code&gt; (グー、チョキ、パー) と &lt;code&gt;Result&lt;/code&gt; (引き分け、負け、勝ち) の &lt;code&gt;enum&lt;/code&gt; を定義することで、&lt;code&gt;Battle&lt;/code&gt; 関数の引数と戻り値にそれぞれ意味を持たせます。&lt;/p&gt;
&lt;p&gt;C#の &lt;code&gt;enum&lt;/code&gt; は、既定値として &lt;code&gt;int&lt;/code&gt; の0をとり、要素が増えるにつれて1増えます。そのため、この場合は、 &lt;code&gt;Rock (0)&lt;/code&gt;、 &lt;code&gt;Paper (1)&lt;/code&gt;、 &lt;code&gt;Scissors (2)&lt;/code&gt; のようにそれぞれ値を持つことができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Battle&lt;/code&gt; 関数は、自分の手と相手の手を渡すことで、&lt;code&gt;Result.Draw&lt;/code&gt;、 &lt;code&gt;Result.Lose&lt;/code&gt;、 &lt;code&gt;Result.Win&lt;/code&gt; のいずれかを返します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Rps
{
    public enum Hand
    {
        Rock,
        Paper,
        Scissors
    }

    public enum Result
    {
        Draw,
        Lose,
        Win
    }

    public static Result Battle(Hand own, Hand opponent)
    {
        var result = ((int)opponent - (int)own + 3) % 3;
        return (Result)result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;呼び出し側では、例に倣ってそれぞれの絵文字を割り当てます。
&lt;code&gt;switch式&lt;/code&gt; を使うことで、&lt;code&gt;Battle&lt;/code&gt; が返す可能性のあるパターンに、 &lt;code&gt;あいこ&lt;/code&gt;、&lt;code&gt;あなたの負け&lt;/code&gt;、&lt;code&gt;あなたの勝ち&lt;/code&gt; を割り当て、一致した要素を &lt;code&gt;result&lt;/code&gt; として受け、自分の手、相手の手と一緒に表示します。 &lt;code&gt;_ =&amp;gt; throw new ArgumentOutOfRangeException()&lt;/code&gt; では、対象となる値以外の値として判定された際に該当するアームになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Program
{
    public static void Main()
    {
        const string draw = "あいこ";
        const string lose = "あなたの負け";
        const string win = "あなたの勝ち";

        var map = new Dictionary&amp;lt;Rps.Hand, string&amp;gt;
        {
            [Rps.Hand.Rock] = "✊", [Rps.Hand.Paper] = "🖐", [Rps.Hand.Scissors] = "✌"
        };

        // var hands = new[] { Rps.Hand.Rock, Rps.Hand.Paper, Rps.Hand.Scissors };
        var hands = Enum.GetValues(typeof(Rps.Hand)).Cast&amp;lt;Rps.Hand&amp;gt;().ToArray();

        foreach (var own in hands)
        foreach (var opponent in hands)
        {
            // Draw, Lose, Winのままなら
            // var result = Rps.Battle(own, opponent).ToString();
            
            var result = Rps.Battle(own, opponent) switch
            {
                Rps.Result.Draw =&amp;gt; draw,
                Rps.Result.Lose =&amp;gt; lose,
                Rps.Result.Win =&amp;gt; win,
                _ =&amp;gt; throw new ArgumentOutOfRangeException()
            };
            Console.WriteLine($"{map[own]} vs {map[opponent]}: {result}");
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-3"&gt;実行結果&lt;/h1&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/rps.webp" class="img-fluid" alt="rps.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sharplab.io/#v2:C4LgTgrgdgPgAgJgIwFgBQcAMACOSAsA3OlrkgHQAyAllAI7FrpQCGAtgKYDOADiwMYdsAZRZQAJgCMA9gA90Ab3TYVuBAGZlqpWlV61CLfuw7jx/tKhdgZHOLAsA7tgC82AESAhBkAiDIGUGd4xm+hZWNng4ADbSXEJuXoBWDID6DIB2DIAFMYCKDAFGQdgh1rbYjrSuHp5JyYC7SoCGDFlMujkqAG4sYNhsLDwlUBzOACLU/MDUli0AngA8AEo8XOQAEmLiADS2AHzZQaYN+gDa07MLEuST0vwA1gC6Je6AUOTuK3sz84vkAAodHGBXcYC8G4AJu/dsI8Di9hPxqFwuNIwFxvh5ADDk7g2ZgAvoFtgB6DHYZqtAAWiy4XR6OyuCmw+2eRxO5xWlMO4jeHzAdKeDPIYIhUJh2DRyOMuOwBIkRLcAFEoBA2OQAOIcYAANRYEQg3AAFMBRjwONIAGZq+mLACURvIAGEWNYpmzFqs1aaACrSACCYAco3tjH5+l10I4Ajx2DVgukjig2GKwvEXCN3r0vrA/v4geDLWw0h4PEsHCgNkjhNj9QaW22qixOLTia4EAiNjclIAQixgMAIhw1aGoCsM1nurnHdJhMAwLQAOaeuNmQVVmt1ilPJsttsdsPdzPZ/vYLhFYDJyfGEul/SUybcWfkXoOZwuVbYexOJb7nIns+1qjRWK3qIxR9Fo96F9qzfAB1Yob0KWhf3/YwAH1XFvYA8TAUNsG6ZxXVHKUc2AAB5CBcN1SYxFHDgxVkQQeCGSx7SfPQ+T/Us8AATjVAASdwFHaHgdk7C4URxIlOI6Hj1z7YA+JAEwZ1rFF3CNdEGhRb0lL/FTsjgdQyAANjUecuGyQ89A07AcylbAGW9QyzBpM4oO2d5tRZJ9OUhaF9IY1Q1I8lRjNMtgKVfYBLKfS8HyfSgPzshpQKgZT0G9Yy8B008gJsRdW3bBl01XczFnTUTsMLTYn2nQKSjVNVaGAI0ew3GwAFogyqmqw2wABqbB1CNbAAFJOoUnI4AAdiDFLZyNaTgAGujshUlEgA==="&gt;sharplabでの実行結果&lt;/a&gt;&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>GitHub ActionsからNuGetにパッケージをアップロードした</title>
			<link>https://aconcavy.github.io/blog/posts/20210121uploadnuget</link>
			<description>&lt;p&gt;GitHub Actionsで.NETプロジェクトからNuGetパッケージの作成、Releaseの作成およびNuGetにパッケージをアップロードするまでをまとめた記事です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20210121uploadnuget</guid>
			<pubDate>Thu, 21 Jan 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;GitHub Actionsで.NETプロジェクトからNuGetパッケージの作成、Releaseの作成およびNuGetにパッケージをアップロードするまでをまとめた記事です。&lt;/p&gt;
&lt;p&gt;リポジトリは&lt;a href="https://github.com/AconCavy/Mulinq"&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="tldr"&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GitHub ActionsでNuGetパッケージを作成した。&lt;/li&gt;
&lt;li&gt;作成したNuGetパッケージをNuGetにアップロードした。&lt;/li&gt;
&lt;li&gt;タグからリリース/プレリリースを判断できるようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="net"&gt;対象の.NETプロジェクトの設定&lt;/h1&gt;
&lt;p&gt;パッケージ化する.NETプロジェクトの&lt;code&gt;.csproj&lt;/code&gt;ファイルを更新します。
今回はビルド構成として.NET 5と.NET Core 3.1のdllを生成するために、&lt;code&gt;TargetFrameworks&lt;/code&gt;に&lt;code&gt;net5.0&lt;/code&gt;と&lt;code&gt;netcoreapp3.1&lt;/code&gt;を構成します。&lt;/p&gt;
&lt;p&gt;そして、NuGetの情報を構成します。今回は&lt;code&gt;.csproj&lt;/code&gt;に構成しましたが、&lt;code&gt;.nuspec&lt;/code&gt;ファイルを作成してNuGet情報だけを切り離して構成することも可能なようです。
&lt;code&gt;PackageVersion&lt;/code&gt;はcsprojをリリースのたびに変更せずに、ビルド時にバージョンを指定できるように、&lt;code&gt;$(Version)&lt;/code&gt;の環境変数を使います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml line-numbers"&gt;&amp;lt;Project Sdk="Microsoft.NET.Sdk"&amp;gt;

    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;TargetFrameworks&amp;gt;net5.0;netcoreapp3.1&amp;lt;/TargetFrameworks&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;
    
    &amp;lt;!-- NuGet --&amp;gt;
    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;PackageId&amp;gt;Mulinq&amp;lt;/PackageId&amp;gt;
        &amp;lt;PackageVersion&amp;gt;$(Version)&amp;lt;/PackageVersion&amp;gt;
        &amp;lt;Title&amp;gt;Mulinq&amp;lt;/Title&amp;gt;
        &amp;lt;Authors&amp;gt;AconCavy&amp;lt;/Authors&amp;gt;
        &amp;lt;Description&amp;gt;Mulinq is C# LINQ extensions for collections and for multidimensional arrays.&amp;lt;/Description&amp;gt;
        &amp;lt;PackageProjectUrl&amp;gt;https://github.com/AconCavy/Mulinq&amp;lt;/PackageProjectUrl&amp;gt;
        &amp;lt;PackageLicenseExpression&amp;gt;MIT&amp;lt;/PackageLicenseExpression&amp;gt;
        &amp;lt;RepositoryUrl&amp;gt;https://github.com/AconCavy/Mulinq&amp;lt;/RepositoryUrl&amp;gt;
        &amp;lt;PackageTags&amp;gt;LINQ&amp;lt;/PackageTags&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="nuget"&gt;NuGetの設定&lt;/h1&gt;
&lt;p&gt;NuGetアカウントを持っていない場合はアカウントの作成をします。Microsoftアカウントから作成もできるみたいです。&lt;/p&gt;
&lt;p&gt;NuGetパッケージのアップロードには、NuGetのAPIキーが必要なので、APIキーを生成します。
画面右上のユーザから、&lt;code&gt;API Keys&lt;/code&gt;のページに移動し、&lt;code&gt;Create&lt;/code&gt;フォームから、&lt;code&gt;Key Name&lt;/code&gt;や&lt;code&gt;Package Owner&lt;/code&gt;等必要な情報を埋め、APIキーを生成します。
生成に成功すると、&lt;code&gt;Manage&lt;/code&gt;パネルに生成したAPIキーが並ぶので、&lt;code&gt;Copy&lt;/code&gt;でAPIキーをコピーします。一度ページから離れてしまうと、再びコピーできなくなるので、できなくなった場合は&lt;code&gt;Regenerate&lt;/code&gt;から再生成します。&lt;/p&gt;
&lt;p&gt;コピーしたAPIキーをGitHubリポジトリの&lt;code&gt;Secrets&lt;/code&gt;に登録することで、GitHub Actionsの環境変数としてアクセスできるようになります。リポジトリの&lt;code&gt;Setting -&amp;gt; Secrets -&amp;gt; New repository secret&lt;/code&gt;で新しいシークレットを作成し、名前とAPIキーを登録します。今回は&lt;code&gt;NUGET_API_KEY&lt;/code&gt;として登録しました。&lt;/p&gt;
&lt;h1 id="workflow"&gt;Workflowの作成&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://aconcavy.github.io/blog/20201212createrepository"&gt;リポジトリを作成したときにやっておきたいこと&lt;/a&gt;のReleaseの作成をもとにWorkflowを作成します。&lt;/p&gt;
&lt;p&gt;RelaseのWorkflowを実行するトリガーとして、&lt;code&gt;v1.0.0&lt;/code&gt;や&lt;code&gt;v1.0.0-alpha&lt;/code&gt;のようなGitのタグがpushされたときに限定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;on:
  push:
    tags: 
    - 'v[0-9]+.[0-9]+.[0-9]+*'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最初にテストを実行します。今回はTargetFrameworkが複数あるため、複数の.NET SDKをセットアップします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Test
      run: dotnet test -c Release --verbosity normal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次にテストが成功した場合のみリリースを実行します。&lt;code&gt;needs: [test]&lt;/code&gt;とすることで、&lt;code&gt;test&lt;/code&gt;のjobが成功した場合のみ実行されるようになります。
まず、プロジェクトからNuGetパッケージを作成します。このとき、&lt;code&gt;-p:Version&lt;/code&gt;にバージョンを指定します。タグのバージョン情報を取得するために、&lt;code&gt;${GITHUB_REF##*/v}&lt;/code&gt;を指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;dotnet pack ./src/Mulinq/Mulinq.csproj -c Release -p:Version=${GITHUB_REF##*/v} -o ./publish
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;GITHUB_REF&lt;/code&gt;の環境変数では、ワークフローをトリガーしたタグのrefを取得でき、&lt;code&gt;v1.0.0&lt;/code&gt;のようなタグの場合は&lt;code&gt;refs/heads/v1.0.0&lt;/code&gt;という文字列を取得できます。そこから&lt;code&gt;1.0.0&lt;/code&gt;の部分だけ取得し、&lt;code&gt;Version&lt;/code&gt;の環境変数に指定します。
ビルドに成功した場合は、&lt;code&gt;./publish&lt;/code&gt;に&lt;code&gt;Mulinq.1.0.0.nupkg&lt;/code&gt;が生成されます。&lt;/p&gt;
&lt;p&gt;そして、NuGetのAPIを叩き、作成した&lt;code&gt;.nupkg&lt;/code&gt;をアップロードします。&lt;code&gt;secrets.NUGET_API_KEY&lt;/code&gt;から、リポジトリに登録したNuGetのAPIキーを参照します。&lt;code&gt;secrets.&amp;lt;*&amp;gt;&lt;/code&gt;は上記で登録したシークレットの名前になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;release:
    runs-on: ubuntu-latest
    needs: [test]
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET Core 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Build
      run: dotnet pack ./src/Mulinq/Mulinq.csproj -c Release -p:Version=${GITHUB_REF##*/v} -o ./publish
    - name: Upload to NuGet
      run: dotnet nuget push ./publish/*.nupkg -k ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json
    
    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: ${{ github.ref }}
        draft: false
        prerelease: ${{ contains(github.ref, '-') }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、GitHubにReleaseを作成します。
&lt;code&gt;prerelease&lt;/code&gt;のプロパティに&lt;code&gt;true|false&lt;/code&gt;を指定することで、作成するリリースがプレリリースか否かを指定できます。そのため、タグに&lt;code&gt;-&lt;/code&gt;が含まれているかをチェックする&lt;code&gt;contains&lt;/code&gt;関数を使用して、&lt;code&gt;v1.0.0&lt;/code&gt;のような普通のリリースの場合と、&lt;code&gt;v1.0.0-alpha&lt;/code&gt;のようなプレリリースを区別できるようにしました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;- name: Create Release
  id: create_release
  uses: actions/create-release@v1
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  with:
    tag_name: ${{ github.ref }}
    release_name: ${{ github.ref }}
    draft: false
    prerelease: ${{ contains(github.ref, '-') }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Workflow全体としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;name: Release

on:
  push:
    tags: 
    - 'v[0-9]+.[0-9]+.[0-9]+*'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Test
      run: dotnet test -c Release --verbosity normal
  
  release:
    runs-on: ubuntu-latest
    needs: [test]
    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET Core 3.1.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.x
    - name: Setup .NET 5.0.x
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Build
      run: dotnet pack ./src/Mulinq/Mulinq.csproj -c Release -p:Version=${GITHUB_REF##*/v} -o ./publish
    - name: Upload to NuGet
      run: dotnet nuget push ./publish/*.nupkg -k ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json
    
    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: ${{ github.ref }}
        draft: false
        prerelease: ${{ contains(github.ref, '-') }}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="workflow-1"&gt;Workflowの実行&lt;/h1&gt;
&lt;p&gt;適当にコミットを作成し、&lt;code&gt;v0.0.1-alpha&lt;/code&gt;というタグをつけ、GitHub上にプッシュします。&lt;/p&gt;
&lt;p&gt;作成したWorkflowが実行され、テスト、ビルド、アップロード、Releaseの作成が行われます。&lt;/p&gt;
&lt;p&gt;NuGetへアップロード直後は&lt;code&gt;Unlisted Packages&lt;/code&gt;の状態でしたが、しばらくすると&lt;code&gt;Published Packages&lt;/code&gt;になりました。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/nuget_upload.webp" class="img-fluid" alt="succeeded upload to nuget"&gt;&lt;/p&gt;
&lt;p&gt;GitHubのリリースのほうは、ちゃんと&lt;code&gt;Pre-Release&lt;/code&gt;で作成されています。
&lt;img src="https://aconcavy.github.io/blog/assets/images/gha_prerelease.webp" class="img-fluid" alt="pre-release"&gt;&lt;/p&gt;
&lt;h1 id="section-1"&gt;まとめ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;GitHub ActionsでNuGetパッケージを作成した。&lt;/li&gt;
&lt;li&gt;作成したNuGetパッケージをNuGetにアップロードした。&lt;/li&gt;
&lt;li&gt;タグからリリース/プレリリースを判断できるようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NuGetのパッケージ作成は怖くない！&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>MagicOnionに入門した</title>
			<link>https://aconcavy.github.io/blog/posts/20210103magiconion</link>
			<description>&lt;p&gt;友人がC#のgRPCライブラリの&lt;code&gt;MagicOnion&lt;/code&gt;の導入に苦戦してたので、手伝いながら使ってみたときにつまったところを纏めたものです。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20210103magiconion</guid>
			<pubDate>Wed, 24 Feb 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;友人がC#のgRPCライブラリの&lt;code&gt;MagicOnion&lt;/code&gt;の導入に苦戦してたので、手伝いながら使ってみたときにつまったところを纏めたものです。&lt;/p&gt;
&lt;p&gt;リポジトリは&lt;a href="https://github.com/AconCavy/practice-magiconion"&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="magiconion"&gt;MagicOnion&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion&lt;/a&gt;は、共通のインターフェースを介してクライアントとサーバーで手続きを呼び合う技術の&lt;a href="https://github.com/grpc/grpc"&gt;gRPC&lt;/a&gt;をC#用に最適化した、リアルタイム通信ライブラリです。&lt;/p&gt;
&lt;p&gt;ASP.NET CoreにもgRPCのテンプレートは存在しますが、そちらは&lt;code&gt;proto&lt;/code&gt;ファイルを作成し、そのファイルにインターフェースを定義を行います。一方MagicOnionの場合は、C#の&lt;code&gt;interface&lt;/code&gt;を定義すればめんどくさいことはMagicOnion側でいろいろやってくれるため、クライアントとサーバーでどちらもC#を利用する場合には一つのソースを使いまわすことができたりと嬉しいことが多いです。そのため、クライアントはUnity、サーバーはASP.NET Coreを使うモバイルゲームなどのプロジェクトでよく使われるそうです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;環境&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Unity 2019.4.17f1&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Cysharp/MagicOnion/releases/tag/4.0.4"&gt;MagicOnion 4.0.4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/neuecc/MessagePack-CSharp/releases/tag/v2.2.85"&gt;MessagePack for C# 2.2.85&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gRPC (&lt;a href="https://packages.grpc.io/archive/2020/12/d7b70c3ea25c48ffdae7b8bd3c757594d4fff4b6-2be69c7e-9b25-4273-a7d4-3840da2d6723/csharp/grpc_unity_package.2.35.0-dev202012021242.zip"&gt;grpc_unity_package.2.35.0-dev202012021242&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-2"&gt;作ってみる1&lt;/h1&gt;
&lt;p&gt;MagicOnionを使うにあたって、ASP.NET Coreでのサーバー、Unityでのクライアント、共有Apiの3つのプロジェクトを構成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;MagicOnionSample/
  |- MagicOnionSample.Server/
  |- MagicOnionSample.Shared/
  |- MagicOnionSample.Unity/
  |
  |- MagicOnionSample.sln
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MagicOnionSample.Server&lt;/code&gt;はASP.NET CoreのgRPCテンプレートで作成しました。
&lt;code&gt;MagicOnionSample.Unity&lt;/code&gt;にはUnityプロジェクトを作成します。
&lt;code&gt;MagicOnionSample.sln&lt;/code&gt;には&lt;code&gt;MagicOnionSample.Server&lt;/code&gt;と&lt;code&gt;MagicOnionSample.Shared&lt;/code&gt;を追加します。&lt;/p&gt;
&lt;h2 id="section-3"&gt;クライアント側の準備&lt;/h2&gt;
&lt;p&gt;プロジェクトを作成したら、はじめに&lt;code&gt;Project Settings&lt;/code&gt;を以下に変更します。&lt;/p&gt;
&lt;div class="table-responsive"&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Item&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Scripting Backend&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Mono&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Api Compatibility Level&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;.NET 4.x&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Allow unsafe code&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;True&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;次に、MagicOnionとMessagePackの&lt;code&gt;unitypackage&lt;/code&gt;をプロジェクトにインポートします。
また、gRPCのパッケージから、&lt;code&gt;Google.Protobuf&lt;/code&gt;、&lt;code&gt;Grpc.Core&lt;/code&gt;、 &lt;code&gt;Grpc.Core.Api&lt;/code&gt;の3つのフォルダを&lt;code&gt;Assets/Plugins/&lt;/code&gt;にインポートします。&lt;/p&gt;
&lt;p&gt;MagicOnionとMessagePackのバージョンによってはUnityのコンパイルエラーは発生しませんが、MagicOnion 4.0.4とMessagePack 2.2.85の場合はMagicOnion側でコンパイルエラーが発生してしまいます。MessagePack 2.2.85からMessagePackの属性が含まれている名前空間が&lt;code&gt;MessagePack&lt;/code&gt;から&lt;code&gt;MessagePack.Annotations&lt;/code&gt;に変更されているようなので、&lt;code&gt;Assets/Scripts/MagicOnion.Client/MagicOnion.Client.asmdef&lt;/code&gt;の &lt;code&gt;AssemblyDefinition References&lt;/code&gt;に&lt;code&gt;MessagePack.Annotations&lt;/code&gt;の参照を追加することでコンパイルエラーを解消できます。&lt;/p&gt;
&lt;h2 id="section-4"&gt;サーバー側の準備&lt;/h2&gt;
&lt;p&gt;ASP.NET CoreのgRPCテンプレートで作成した場合、以下のような構成でプロジェクトが作成されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;MagicOnionSample
  |-MagicOnionSample.Server
      |- Properties/
      |    |- launchSettings.json
      |- Protos/
      |    |- greet.proto
      |- Services/
      |    |- GreeterService.cs
      |- appsettings.json
      |- appsettings.development.json
      |- Program.cs
      |- Startup.cs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この状態から、&lt;code&gt;Protos&lt;/code&gt;ディレクトリと、&lt;code&gt;GreeterService.cs&lt;/code&gt;を削除します。
次に&lt;code&gt;Startup.cs&lt;/code&gt;の&lt;code&gt;GenericHost&lt;/code&gt;の構成にMagicOnionを追加します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;

namespace MagicOnionSample.Server
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddGrpc();
            services.AddMagicOnion(); // Here
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            app.UseRouting();
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapMagicOnionService(); // Here
                endpoints.MapGet(&amp;quot;/&amp;quot;,
                    async context =&amp;gt;
                    {
                        await context.Response.WriteAsync(
                            &amp;quot;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909&amp;quot;);
                    });
            });
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、今回は&lt;code&gt;localhost&lt;/code&gt;で通信を行うので、&lt;code&gt;appsettings.development.json&lt;/code&gt;に以下の設定を追加します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json line-numbers"&gt;...
&amp;quot;Kestrel&amp;quot;: {
    &amp;quot;Endpoints&amp;quot;: {
      &amp;quot;Grpc&amp;quot;: {
        &amp;quot;Url&amp;quot;: &amp;quot;http://localhost:5000&amp;quot;,
        &amp;quot;Protocols&amp;quot;: &amp;quot;Http2&amp;quot;
      },
      &amp;quot;Https&amp;quot;: {
        &amp;quot;Url&amp;quot;: &amp;quot;https://localhost:5001&amp;quot;,
        &amp;quot;Protocols&amp;quot;: &amp;quot;Http1AndHttp2&amp;quot;
      },
      &amp;quot;Http&amp;quot;: {
        &amp;quot;Url&amp;quot;: &amp;quot;http://localhost:5002&amp;quot;,
        &amp;quot;Protocols&amp;quot;: &amp;quot;Http1&amp;quot;
      }
    }
  }
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、&lt;code&gt;Program.cs&lt;/code&gt;の&lt;code&gt;CreateHostBuilder&lt;/code&gt;に&lt;code&gt;Kestrel&lt;/code&gt;とHttp2を使うための設定を追加します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Server.Kestrel.Core;
using Microsoft.Extensions.Hosting;

namespace MagicOnionSample.Server
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args)
        {
            return Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt; webBuilder
                    .UseKestrel(options =&amp;gt; options.ConfigureEndpointDefaults(endpointOptions =&amp;gt;
                        endpointOptions.Protocols = HttpProtocols.Http2))
                    .UseStartup&amp;lt;Startup&amp;gt;());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Httpsで通信を行う場合は、&lt;a href="https://docs.microsoft.com/ja-jp/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0&amp;amp;tabs=visual-studio"&gt;こちら&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;h2 id="api"&gt;共有Apiの定義&lt;/h2&gt;
&lt;p&gt;Unityに戻り、MagicOnionで使用する&lt;code&gt;interface&lt;/code&gt;やモデルクラス類を作成します。
今回は&lt;code&gt;Assets/MagicOnionSample/Scripts/Shared/&lt;/code&gt;に共有Apiを構成します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Shared&lt;/code&gt;ディレクトリに&lt;code&gt;ISampleService.cs&lt;/code&gt;を作成し,&lt;code&gt;string&lt;/code&gt;の値を渡すと挨拶の&lt;code&gt;string&lt;/code&gt;を返す&lt;code&gt;interface&lt;/code&gt;を定義します。また、この&lt;code&gt;interface&lt;/code&gt;には&lt;code&gt;IService&amp;lt;T&amp;gt;&lt;/code&gt;もあわせて定義します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using MagicOnion;

namespace MagicOnionSample.Shared
{
    public interface ISampleService : IService&amp;lt;ISampleService&amp;gt;
    {
        UnaryResult&amp;lt;string&amp;gt; GreetAsync(string name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-5"&gt;クライアント側の実装&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Shared&lt;/code&gt;ディレクトリでは、クライアントとサーバーで共有できるクラスやインターフェースのみを持たせるために、&lt;code&gt;Shared&lt;/code&gt;ディレクトリとは別に、&lt;code&gt;Assets/MagicOnionSample/Scripts/Unity/&lt;/code&gt;を作成し、名前空間と実装を分離します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unity&lt;/code&gt;ディレクトリに&lt;code&gt;SampleEntryPoint.cs&lt;/code&gt;を作成し、サーバーにローカルホストでアクセスする実装をします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MagicOnionClient&lt;/code&gt;から&lt;code&gt;ISampleService&lt;/code&gt;のエンドポイントに対して、上記で定義した&lt;code&gt;GreetAsync&lt;/code&gt;を&lt;code&gt;interface&lt;/code&gt;経由で呼び、結果を&lt;code&gt;Debug.Log&lt;/code&gt;に表示させます。
&lt;code&gt;interface&lt;/code&gt;経由で呼ぶことで、クライアント側は実装を気にする必要がありません。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using System.Threading.Tasks;
using Grpc.Core;
using MagicOnion.Client;
using MagicOnionSample.Shared;
using UnityEngine;

namespace MagicOnionSample.Unity
{
    public class SampleEntryPoint : MonoBehaviour
    {
        public string host = &amp;quot;localhost&amp;quot;;
        public int port = 5000;

        public string user = &amp;quot;Foo&amp;quot;;
        public string room = &amp;quot;Bar&amp;quot;;

        private Channel _channel;

        private async Task Start()
        {
            _channel = new Channel(host, port, ChannelCredentials.Insecure);

            var client = MagicOnionClient.Create&amp;lt;ISampleService&amp;gt;(_channel);
            var greet = await client.GreetAsync(user);
            Debug.Log(greet);
        }

        private async Task OnDestroy()
        {
            await _channel.ShutdownAsync();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作成後、UnityのHierarchyに適当なGameObjectを作成し、&lt;code&gt;SampleEntryPoint&lt;/code&gt;を付与します。&lt;/p&gt;
&lt;h2 id="api-1"&gt;サーバー側における共有Api&lt;/h2&gt;
&lt;p&gt;Unityがコンパイルできるスクリプトは&lt;code&gt;Assets/&lt;/code&gt;以下にあるものに限るため、サーバー側で共有Api用のプロジェクトを作成すると不整合がおきてしまうかもしれません。そのため、&lt;code&gt;MagicOnionSample.Shared&lt;/code&gt;のプロジェクトでは、中身を実際には持たずに、上記で作成したUnityプロジェクト内の&lt;code&gt;Assets/MagicOnionSample/Scripts/Shared&lt;/code&gt;ディレクトリにあるスクリプトを参照することでサーバー側でも共有Apiとして使えるようにします。&lt;/p&gt;
&lt;p&gt;そのため、&lt;code&gt;MagicOnionSample.Shared&lt;/code&gt;のディレクトリ構成は以下のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;MagicOnionSample
  |-MagicOnionSample.Shared
      |-MagicOnionSample.Shared.csproj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nugetから&lt;code&gt;MagicOnion&lt;/code&gt;、&lt;code&gt;MagicOnion.Abstractions&lt;/code&gt;、&lt;code&gt;MessagePack&lt;/code&gt;、&lt;code&gt;MessagePack.UnityShims&lt;/code&gt;をインストールします。
&lt;code&gt;MessagePack.UnityShims&lt;/code&gt;をインストールすることで、UnityEngineのApiを利用することができるため、&lt;code&gt;Vector3&lt;/code&gt;や&lt;code&gt;Quatarnion&lt;/code&gt;などを使う場合はインストールします。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;Compile Include=&amp;quot;path/to/file&amp;quot;/&amp;gt;&lt;/code&gt;を定義することで、指定したパスのファイルをコンパイルに含めることができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;csproj&lt;/code&gt;は以下のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml line-numbers"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;

    &amp;lt;ItemGroup&amp;gt;
        &amp;lt;PackageReference Include=&amp;quot;MagicOnion&amp;quot; Version=&amp;quot;4.0.4&amp;quot; /&amp;gt;
        &amp;lt;PackageReference Include=&amp;quot;MagicOnion.Abstractions&amp;quot; Version=&amp;quot;4.0.4&amp;quot; /&amp;gt;
        &amp;lt;PackageReference Include=&amp;quot;MessagePack&amp;quot; Version=&amp;quot;2.2.85&amp;quot; /&amp;gt;
        &amp;lt;PackageReference Include=&amp;quot;MessagePack.UnityShims&amp;quot; Version=&amp;quot;2.2.85&amp;quot; /&amp;gt;
    &amp;lt;/ItemGroup&amp;gt;

    &amp;lt;ItemGroup&amp;gt;
        &amp;lt;Compile Include=&amp;quot;../MagicOnionSample.Unity/Assets/MagicOnionSample/Scripts/Shared/**/*.cs&amp;quot; /&amp;gt;
    &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-6"&gt;サーバー側の実装&lt;/h2&gt;
&lt;p&gt;上記で準備した共有Apiのプロジェクトをサーバー側のプロジェクトで参照することで、Unity上で定義した&lt;code&gt;ISampleService&lt;/code&gt;を利用することができるようになります。
&lt;code&gt;SampleService.cs&lt;/code&gt;を作成し、&lt;code&gt;ISampleService&lt;/code&gt;の実装を行います。
簡単な文字列を返すように実装しました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using System;
using MagicOnion;
using MagicOnion.Server;
using MagicOnionSample.Shared;

namespace MagicOnionSample.Server.Services
{
    public class SampleService : ServiceBase&amp;lt;ISampleService&amp;gt;, ISampleService
    {
        public async UnaryResult&amp;lt;string&amp;gt; GreetAsync(string name)
        {
            await Console.Out.WriteLineAsync(name);
            return $&amp;quot;Welcome {name}!&amp;quot;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-7"&gt;動作確認&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dotnet run&lt;/code&gt;コマンド等でサーバーを起動し、&lt;code&gt;SampleEntryPoint&lt;/code&gt;が適当なGameObjectに付与されているのを確認した後にUnityを実行し、UnityのConsoleに&lt;code&gt;Welcome Foo!&lt;/code&gt;と表示されたら成功です。
以上で、サーバーとクライアントの1対1のApiコールができました。&lt;/p&gt;
&lt;h1 id="section-8"&gt;作ってみる2&lt;/h1&gt;
&lt;p&gt;前の項では、サーバーとクライアントの1対1のApiコールを実装しました。次に、サーバーとクライアントの1対多のApiコールを実装します。
マルチプレイでプレイヤーの座標をリアルタイムで同期させるといったことが用途としてあげられます。&lt;/p&gt;
&lt;p&gt;今回は、プレイヤーが部屋に参加したかどうかを知らせるApiを実装します。&lt;/p&gt;
&lt;h2 id="api-2"&gt;共有Apiの定義&lt;/h2&gt;
&lt;p&gt;初めに、&lt;code&gt;Player&lt;/code&gt;を一つのモデルとして管理するために、&lt;code&gt;Shared&lt;/code&gt;ディレクトリに&lt;code&gt;Player.cs&lt;/code&gt;を作成します。
&lt;code&gt;MessagePackObject&lt;/code&gt;の属性をクラスや構造体に付与することで、MessagePackがシリアライズできるようになり、&lt;code&gt;Key&lt;/code&gt;によってそれぞれのプロパティを管理します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using MessagePack;

namespace MagicOnionSample.Shared
{
    [MessagePackObject]
    public class Player
    {
        [Key(0)] public string Name { get; set; }
        [Key(1)] public string Room { get; set; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に、&lt;code&gt;Shared&lt;/code&gt;ディレクトリに&lt;code&gt;ISampleHubReceiver.cs&lt;/code&gt;を作成します。
&lt;code&gt;Player&lt;/code&gt;が部屋に参加したことを知らせるコールバークとしての&lt;code&gt;interface&lt;/code&gt;を定義します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;namespace MagicOnionSample.Shared
{
    public interface ISampleHubReceiver
    {
        void OnJoin(Player player);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、&lt;code&gt;Shared&lt;/code&gt;ディレクトリに&lt;code&gt;ISampleHub.cs&lt;/code&gt;を作成します。
&lt;code&gt;name&lt;/code&gt;と&lt;code&gt;room&lt;/code&gt;を渡すことで、部屋に参加する&lt;code&gt;interface&lt;/code&gt;を定義します。この&lt;code&gt;interface&lt;/code&gt;には&lt;code&gt;IStreamingHub&amp;lt;T, U&amp;gt;&lt;/code&gt;もあわせて定義します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ISampleService&lt;/code&gt;と同じようにApiコール用の&lt;code&gt;interface&lt;/code&gt;です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using System.Threading.Tasks;
using MagicOnion;

namespace MagicOnionSample.Shared
{
    public interface ISampleHub : IStreamingHub&amp;lt;ISampleHub, ISampleHubReceiver&amp;gt;
    {
        Task JoinAsync(string name, string room);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これらのApiコールのの流れとして、&lt;code&gt;ISampleHub&lt;/code&gt;の&lt;code&gt;JoinAsync&lt;/code&gt;を呼ぶことで、サーバーに名前と部屋名を渡し、サーバー側の処理が完了すると&lt;code&gt;ISampleHubReceiver&lt;/code&gt;の&lt;code&gt;OnJoin&lt;/code&gt;がコールバックとして呼ばれる形になります。&lt;/p&gt;
&lt;h2 id="section-9"&gt;クライアント側の実装&lt;/h2&gt;
&lt;p&gt;クライアント側では、&lt;code&gt;ISampleHubReceiver&lt;/code&gt;を実装した&lt;code&gt;SampleHubReceiver&lt;/code&gt;を作成します。
&lt;code&gt;Unity&lt;/code&gt;ディレクトリに&lt;code&gt;SampleHubReceiver.cs&lt;/code&gt;を作成し、コールバックの内容を実装します。
&lt;code&gt;Player&lt;/code&gt;が参加したら&lt;code&gt;Player&lt;/code&gt;の&lt;code&gt;Name&lt;/code&gt;と&lt;code&gt;Room&lt;/code&gt;がUnityのConsoleに表示されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using MagicOnionSample.Shared;
using UnityEngine;

namespace MagicOnionSample.Unity
{
    public class SampleHubReceiver : ISampleHubReceiver
    {
        public void OnJoin(Player player)
        {
            Debug.Log($&amp;quot;{player.Name}, {player.Room}&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記で作成した&lt;code&gt;SampleEntryPoint.cs&lt;/code&gt;を更新します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Channel&lt;/code&gt;と&lt;code&gt;ISampleReceiver&lt;/code&gt;のインスタンスを&lt;code&gt;StreamingHubClient.Connect&lt;/code&gt;に渡すことで、&lt;code&gt;ISampleHub&lt;/code&gt;を実装したインスタンスを得ることができます。このインスタンスはサーバー側で実装されるので、クライアント側は気にする必要がありません。
&lt;code&gt;ISampleHub&lt;/code&gt;のインスタンスを使って&lt;code&gt;JoinAsync&lt;/code&gt;を呼ぶことで、サーバー側に&lt;code&gt;name&lt;/code&gt;と&lt;code&gt;room&lt;/code&gt;を渡すことができ、コールバックとして&lt;code&gt;SampleHubReceiver&lt;/code&gt;の&lt;code&gt;OnJoin&lt;/code&gt;に&lt;code&gt;Player&lt;/code&gt;のインスタンスが渡されます。
また、&lt;code&gt;ISampleHub&lt;/code&gt;は&lt;code&gt;IDisposable&lt;/code&gt;なので、忘れずに&lt;code&gt;Dispose&lt;/code&gt;でリソースを解放します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using System.Threading.Tasks;
using Grpc.Core;
using MagicOnion.Client;
using MagicOnionSample.Shared;
using UnityEngine;

namespace MagicOnionSample.Unity
{
    public class SampleEntryPoint : MonoBehaviour
    {
        public string host = &amp;quot;localhost&amp;quot;;
        public int port = 5000;

        public string user = &amp;quot;Foo&amp;quot;;
        public string room = &amp;quot;Bar&amp;quot;;

        private Channel _channel;

        // Here
        private ISampleHub _hub;
        private ISampleHubReceiver _receiver;

        private async Task Start()
        {
            _channel = new Channel(host, port, ChannelCredentials.Insecure);

            var client = MagicOnionClient.Create&amp;lt;ISampleService&amp;gt;(_channel);
            var greet = await client.GreetAsync(user);
            Debug.Log(greet);

            // Here
            _receiver = new SampleHubReceiver();
            _hub = StreamingHubClient.Connect&amp;lt;ISampleHub, ISampleHubReceiver&amp;gt;(_channel, _receiver);
            await _hub.JoinAsync(user, room);
        }

        private async Task OnDestroy()
        {
            await _hub.DisposeAsync(); // Here
            await _channel.ShutdownAsync();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-10"&gt;サーバー側の実装&lt;/h2&gt;
&lt;p&gt;サーバー側では&lt;code&gt;ISampleHub&lt;/code&gt;の実装を行います。
&lt;code&gt;SampleHub.cs&lt;/code&gt;を作成し、&lt;code&gt;name&lt;/code&gt;と&lt;code&gt;room&lt;/code&gt;が与えられたら&lt;code&gt;Player&lt;/code&gt;を作成して返すといった実装を行います。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Broadcast&lt;/code&gt;に&lt;code&gt;IGroup&lt;/code&gt;のインスタンスを渡すことで、グループ内のすべてのクライアントに対してコールバックを呼ぶことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;using System;
using System.Threading.Tasks;
using MagicOnion.Server.Hubs;
using MagicOnionSample.Shared;

namespace MagicOnionSample.Server.Hubs
{
    public class SampleHub : StreamingHubBase&amp;lt;ISampleHub, ISampleHubReceiver&amp;gt;, ISampleHub
    {
        private Player _player;
        private IGroup _room;

        public async Task JoinAsync(string name, string room)
        {
            _player = new Player {Name = name, Room = room};
            await Console.Out.WriteLineAsync($&amp;quot;Join {_player.Name} to the {_player.Room}&amp;quot;);
            (_room, _) = await Group.AddAsync(_player.Room, _player);
            Broadcast(_room).OnJoin(_player);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-11"&gt;動作確認&lt;/h2&gt;
&lt;p&gt;上記の動作確認と同じように、&lt;code&gt;dotnet run&lt;/code&gt;コマンド等でサーバーを起動してUnityを実行すると、UnityのConsoleに&lt;code&gt;Welcome Foo!&lt;/code&gt;と&lt;code&gt;Foo, bar&lt;/code&gt;表示されたら成功です。
また、サーバー側のConsoleでは&lt;code&gt;Join Foo to the Bar&lt;/code&gt;と表示されます。
以上で、サーバーとクライアントの1対多のApiコールができました。&lt;/p&gt;
&lt;h1 id="section-12"&gt;その他注意点&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;や&lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;などをMessagePackに渡す場合は、シリアライズの時に&lt;code&gt;null&lt;/code&gt;の場合、エラーが発生することがあります。プロパティの初期化子を使って初期化をすることで、シリアライズでエラーを回避することができます。&lt;/p&gt;
&lt;p&gt;自作クラスのコンストラクタを実装する場合、コンストラクタ引数がないコンストラクタをMessagePackに渡すと、シリアライズ時にエラーが発生するため、引数があるコンストラクタに加えて、引数がないコンストラクタを作成する必要があります。&lt;/p&gt;
&lt;h1 id="section-13"&gt;まとめ&lt;/h1&gt;
&lt;p&gt;MagicOnionを使ってリアルタイム通信の世界に入門しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UnityプロジェクトにインストールしたMagicOnionとMessagePackでコンパイルエラーが発生する場合は&lt;code&gt;MagicOnion.Client&lt;/code&gt;に&lt;code&gt;MessagePack.Annotations&lt;/code&gt;を追加する&lt;/li&gt;
&lt;li&gt;1対1では&lt;code&gt;IService&amp;lt;T&amp;gt;&lt;/code&gt;を使う&lt;/li&gt;
&lt;li&gt;1対多では&lt;code&gt;IStreamingHub&amp;lt;T, U&amp;gt;&lt;/code&gt;を使う&lt;/li&gt;
&lt;li&gt;MessagePackでは&lt;code&gt;null&lt;/code&gt;に注意&lt;/li&gt;
&lt;li&gt;MessagePackではコンストラクタに注意&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マルチプレイのゲームを作るときには有効活用したいです。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>リポジトリを作成したときにやっておきたいこと</title>
			<link>https://aconcavy.github.io/blog/posts/20201212createrepository</link>
			<description>&lt;p&gt;リポジトリを作成したときにやっておくと後々楽になるかもしれないことをまとめたメモです。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20201212createrepository</guid>
			<pubDate>Sun, 13 Dec 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;これ何&lt;/h1&gt;
&lt;p&gt;リポジトリを作成したときにやっておくと後々楽になるかもしれないことをまとめたメモです。&lt;/p&gt;
&lt;h1 id="section-1"&gt;開発環境ごとの差異をなくすために&lt;/h1&gt;
&lt;p&gt;開発者によってOSやエディタ等の開発環境が異なるのでルールを決めます。&lt;/p&gt;
&lt;h2 id="git-config"&gt;git config&lt;/h2&gt;
&lt;p&gt;WindowsとMacOS / LinuxではOSにより行の終端が異なるため、何も変更していないつもりでも、OSが異なるとdiffが発生してしまう場合があります。それを避けるために、Gitの設定でbranchをcheckoutしたときに、ファイルをどの形式で認識するかを設定します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;core.autocrlf&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;にすると、ファイル形式が&lt;code&gt;CRLF&lt;/code&gt;と&lt;code&gt;LF&lt;/code&gt;のどちらであってもcheckout時に&lt;code&gt;CRLF&lt;/code&gt;に変換され、commit時には自動的に&lt;code&gt;LF&lt;/code&gt;へと変換されます。
また、&lt;code&gt;core.autocrlf&lt;/code&gt;を&lt;code&gt;input&lt;/code&gt;にすると、&lt;code&gt;LF&lt;/code&gt;のままcheckoutとcommitが行われます。
そのため、Windowsでは&lt;code&gt;true&lt;/code&gt;、MacOS / Linuxでは&lt;code&gt;input&lt;/code&gt;を指定しておくといいでしょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-powershell line-numbers"&gt;git config --global core.autocrlf true
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Mac OS / Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;git config --global core.autocrlf input
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="gitattributes"&gt;.gitattributes&lt;/h2&gt;
&lt;p&gt;リポジトリ単位で行の終端処理を行う場合は、&lt;code&gt;.gitattributes&lt;/code&gt;をリポジトリのルートに作成して設定を行うことで、&lt;code&gt;core.autocrlf&lt;/code&gt;を設定していない開発者がいてもGitが自動的にファイルの終端を変更してくれます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;* text=auto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.gitattributes&lt;/code&gt;には&lt;a href="https://git-lfs.github.com/"&gt;GitLFS&lt;/a&gt;の設定をすることもできるので、音声や画像、データセットなどの容量が大きなファイルはLFSの設定をするといいかもしれません。&lt;/p&gt;
&lt;p&gt;その他詳しくは&lt;a href="https://docs.github.com/ja/free-pro-team@latest/github/using-git/configuring-git-to-handle-line-endings"&gt;こちら (GitHub Docs, 行終端を処理するようGitを設定する)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="gitignore"&gt;.gitignore&lt;/h2&gt;
&lt;p&gt;プロジェクトの生成物やエディタが生成するファイルなど、プロジェクトに関わりのないファイルやディレクトリを指定しましょう。&lt;/p&gt;
&lt;p&gt;エディタの設定ファイルに関しては、リポジトリに開発者ごとのエディタ設定を無視させるのではなく、開発者自身が&lt;code&gt;.gitignore_global&lt;/code&gt;を設定した方がいいかもしれません。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-powershell line-numbers"&gt;git config --global core.excludesfile core.excludesfile path/to/.gitignore_global
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;MacOS / Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;git config --global core.excludesfile core.excludesfile ~/.gitignore_global
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="editorconfig"&gt;.editorconfig&lt;/h2&gt;
&lt;p&gt;エディタによってインデントのサイズやコードスタイルなどのフォーマットの設定が変わります。ファイルごとにバラバラなフォーマットが適用されてしまうことを避けるために&lt;a href="https://editorconfig.org/"&gt;EditorConfig&lt;/a&gt;を利用して、フォーマットスタイルを統一させます。EditorConfigはJetbrainsのIDEやVisualStudio等のIDEでは標準で搭載しており、Visual Studio Codeなどのエディタでもプラグインをインストールすることで利用することができるようになります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.editorconfig&lt;/code&gt;を作成し、エディタのフォーマット機能やEditorConfig対応のcliを利用することで、そのリポジトリのファイルを決まったルールでフォーマットすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;root = true

# すべてのファイル
[*]
end_of_line = lf              # フォーマット時に終端をLFに変換 .gitattributesで指定してるならいらないかも
charset = utf-8
insert_final_newline = true   # ファイルの最後に改行
indent_style = space          # インデントはスペースで
indent_size = 4               # インデント4

# jsonとymlファイル
[*.{json, yml}]
indent_size = 2               # インデント2
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="ci-cd"&gt;CI / CD&lt;/h1&gt;
&lt;p&gt;Unit Testや正しくファイルがフォーマットされているかのチェック、Releaseの作成、デプロイ等を自動化することによって、繰り返しの作業が楽になるので可能ならやっておきたいです。&lt;/p&gt;
&lt;p&gt;以下dotnetのプロジェクトをGitHub ActionsでWorkflowを構築した場合の場合&lt;/p&gt;
&lt;h2 id="unit-test"&gt;Unit test&lt;/h2&gt;
&lt;p&gt;GitHub Workflowの&lt;code&gt;.NET Core&lt;/code&gt;を選択すれば必要最低限のWorkflowは実現できます。&lt;/p&gt;
&lt;p&gt;リポジトリにコミットされた際にテストを実行し、一つでもテストが通らなかった場合は以下のように確認することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;name: Unit Test

on: [push, pull_request]

jobs:
  test:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET 5
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Install dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --configuration Release --no-restore
    - name: Test
      run: dotnet test --no-restore --verbosity normal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/gha_test_fail.webp" class="img-fluid" alt="github action test failed"&gt;&lt;/p&gt;
&lt;h2 id="code-format"&gt;Code format&lt;/h2&gt;
&lt;p&gt;EditorConfigを設定しているとdotnet toolの&lt;code&gt;dotnet-format&lt;/code&gt;を使うことでEditorConfigに合ったファイルのフォーマットの確認ができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;dotnet tool update -g dotnet-format
dotnet format --check
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GitHub Workflowの&lt;code&gt;.NET Core&lt;/code&gt;をベースにフォーマットを実行し、1つでもファイルがフォーマットされればWorkflowを失敗させるWorkflowを作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;name: Lint

on: [push, pull_request]

jobs:
  format:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Install dotnet-format
      run: dotnet tool update -g dotnet-format
    - name: Lint
      run: dotnet format --check --verbosity diagnostic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/gha_lint_fail.webp" class="img-fluid" alt="github action lint failed"&gt;&lt;/p&gt;
&lt;h1 id="release"&gt;Releaseの作成&lt;/h1&gt;
&lt;p&gt;Releaseでは、Release用のTagがpushされたときに成果物をリポジトリのReleaseにアップロードします。次の例では.dllファイルをアップロードします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml line-numbers"&gt;name: Release

on:
  push:
    tags: 
    - 'v[0-9]+.[0-9]+.[0-9]+*' # v0.0.1のようなTagがpushされたとき

jobs:  
  release:
    runs-on: ubuntu-latest
    needs: [test]
    
    steps:
    
    # Build
    - uses: actions/checkout@v2
    - name: Setup .NET 5
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: Build
      run: dotnet build -c Release
    
    # リリースを作成
    - name: Create Release 
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: ${{ github.ref }}
        # body |
        # hoge hoge # Releaseコメント
        draft: false
        prerelease: false

    # リリースの成果物にHello.dllを追加
    - name: Upload Release Asset
      id: upload-release-asset 
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./src/Hello/bin/Release/net5.0/Hello.dll
        asset_name: Hello.dll
        asset_content_type: application/octet-stream # .dllファイルのcontent type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Workflowを実行すると次のようなReleaseが作成されます。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://aconcavy.github.io/blog/assets/images/gha_release.webp" class="img-fluid" alt="github action release"&gt;&lt;/p&gt;
&lt;h1 id="section-2"&gt;まとめ&lt;/h1&gt;
&lt;p&gt;リポジトリを作った初めに設定を色々とやっておくと後々楽ができるかもしれません。
開発環境の差異をなくすための設定だけでもやっておくと混沌度が下がると思います。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>dotnet newのカスタムテンプレート</title>
			<link>https://aconcavy.github.io/blog/posts/20201129dotnettemplate</link>
			<description>&lt;p&gt;&lt;a href="https://github.com/AconCavy/CompetitiveProgrammingTemplateCSharp"&gt;競プロ用のプロジェクトテンプレート&lt;/a&gt;を整備したので、&lt;code&gt;dotnet new&lt;/code&gt;のカスタムテンプレート作成の備忘録です。&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20201129dotnettemplate</guid>
			<pubDate>Tue, 08 Dec 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/AconCavy/CompetitiveProgrammingTemplateCSharp"&gt;競プロ用のプロジェクトテンプレート&lt;/a&gt;を整備したので、&lt;code&gt;dotnet new&lt;/code&gt;のカスタムテンプレート作成の備忘録です。&lt;/p&gt;
&lt;h1 id="dotnet-new"&gt;dotnet new のカスタムテンプレートとは&lt;/h1&gt;
&lt;p&gt;公式の情報は&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/core/tools/custom-templates"&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NETのプロジェクトを作成する際、&lt;code&gt;dotnet&lt;/code&gt;コマンドを利用してプロジェクトを生成します。
例えば、コンソールアプリケーションを作成する場合、&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;dotnet new console -n Sample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のようなコマンドを実行することで、&lt;code&gt;Sample&lt;/code&gt;という名称のプロジェクトが作成されます。
これは、&lt;code&gt;dotnet new&lt;/code&gt;コマンドで、&lt;code&gt;console&lt;/code&gt;というデフォルトテンプレートを使ってプロジェクトを生成するという意味になります。&lt;/p&gt;
&lt;p&gt;この&lt;code&gt;dotnet new&lt;/code&gt;コマンドに、プロジェクトやスクリプトをカスタムテンプレートとして登録しておくことで、プロジェクトやファイルの作成を使いまわすことができます。&lt;/p&gt;
&lt;p&gt;既定のテンプレートとして、&lt;code&gt;dotnet new&lt;/code&gt;コマンドに&lt;code&gt;-l|--list&lt;/code&gt;オプションをつけて実行すると、現在インストールされている&lt;code&gt;dotnet new&lt;/code&gt;コマンドで生成できるテンプレートを確認することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;dotnet new -l
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-1"&gt;作ってみる&lt;/h1&gt;
&lt;p&gt;テンプレートの基本として、テンプレート化したいプロジェクトのディレクトリ下に、&lt;code&gt;.template.config&lt;/code&gt;のディレクトリを作成し、さらにその下に、&lt;code&gt;template.json&lt;/code&gt;を作成します。
そして、&lt;code&gt;template.json&lt;/code&gt;にプロパティを設定し、&lt;code&gt;dotnet new&lt;/code&gt;コマンドを使ってインストールすることで、テンプレートを使うことができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;dotnet new -i path-to-template
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;競技プロ用のプロジェクトテンプレートでは、次の3つをテンプレートとして準備します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プロジェクト&lt;/li&gt;
&lt;li&gt;解答用のクラス&lt;/li&gt;
&lt;li&gt;テスト用のクラス&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;プロジェクトのテンプレート&lt;/h2&gt;
&lt;p&gt;プロジェクトでは、解答用のクラスとテスト用クラスを配置するための骨組みとしてのプロジェクトを生成するようにします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;Template.Project/
    |
    |- Tasks/
    |    |
    |    |- Tasks.csproj
    |
    |- Tests/
    |    |
    |    |- Tester.cs
    |    |- Tests.csproj
    |
    |- Template.Project.sln
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このプロジェクトをベースとして、&lt;code&gt;Project/&lt;/code&gt;下に&lt;code&gt;.template.config/&lt;/code&gt;ディレクトリを作成し、その下に&lt;code&gt;template.json&lt;/code&gt;を作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;Template.Project/
    |
    |- .template.config
    |    |
    |    |- template.json
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;では、次のメンバを記述します。&lt;/p&gt;
&lt;div class="table-responsive"&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;メンバ&lt;/th&gt;
&lt;th style="text-align: left;"&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;$schema&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;&lt;code&gt;template.json&lt;/code&gt;のスキーマ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;author&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;テンプレートの作成者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;classfication&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;テンプレートの種類&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;テンプレートのタグ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;テンプレートの識別子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;テンプレートの名前&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;shortName&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;&lt;code&gt;dotnet new&lt;/code&gt; で指定する際の名前 (例: &lt;code&gt;dotnet new cpproj&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;sourceName&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;テンプレート使用時に置き換える文字列  (&lt;code&gt;dotnet new&lt;/code&gt;コマンドに、&lt;code&gt;-n|--name&lt;/code&gt;オプションで名前を指定することで、指定された文字列を全てその名前に置換することができます)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;preferNameDirectory&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;出力先ディレクトリがない場合テンプレートのディレクトリを作成するか (既定値: false)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;例えば、上記のプロジェクトでは次のような&lt;code&gt;json&lt;/code&gt;を記述します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json line-numbers"&gt;{
    &amp;quot;$schema&amp;quot;: &amp;quot;http://json.schemastore.org/template&amp;quot;,
    &amp;quot;author&amp;quot;: &amp;quot;AconCavy&amp;quot;,
    &amp;quot;classifications&amp;quot;: [
        &amp;quot;C#&amp;quot;,
        &amp;quot;Console&amp;quot;
    ],
    &amp;quot;tags&amp;quot;: {
        &amp;quot;language&amp;quot;: &amp;quot;C#&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;project&amp;quot;
    },
    &amp;quot;name&amp;quot;: &amp;quot;Template Project&amp;quot;,
    &amp;quot;identity&amp;quot;: &amp;quot;AconCavy.Template.Project&amp;quot;,
    &amp;quot;shortName&amp;quot;: &amp;quot;cpproj&amp;quot;,
    &amp;quot;sourceName&amp;quot;: &amp;quot;Template.Project&amp;quot;,
    &amp;quot;preferNameDirectory&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sourceName&lt;/code&gt;に設定した文字列は、テンプレート以下のすべての対象の文字列が置換されるため、&lt;code&gt;dotnet new cpproj -n Sample&lt;/code&gt;を実行した場合、&lt;code&gt;Template.Project/&lt;/code&gt;ディレクトリ、&lt;code&gt;Template.Project.sln&lt;/code&gt;が&lt;code&gt;Sample/&lt;/code&gt;ディレクトリ、&lt;code&gt;Sample.sln&lt;/code&gt;に置換されて生成されます。ファイル内の文字列も置換されるため注意が必要です。&lt;/p&gt;
&lt;p&gt;この状態で、&lt;code&gt;dotnet new -i path-to-template&lt;/code&gt;コマンドでインストールし、&lt;code&gt;dotnet new cpproj -n Sample&lt;/code&gt;を実行することで、上記のプロジェクトテンプレートをもとに以下のようなプロジェクトが生成されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;Sample/
    |
    |- Tasks/
    |    |
    |    |- Tasks.csproj
    |
    |- Tests/
    |    |
    |    |- Tester.cs
    |    |- Tests.csproj
    |
    |- Sample.sln
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-3"&gt;コマンドの追加オプション&lt;/h3&gt;
&lt;p&gt;また、&lt;code&gt;Task.csproj&lt;/code&gt;と&lt;code&gt;Tests.csproj&lt;/code&gt;のターゲットフレームワークをテンプレート生成時に指定できるようにするため、&lt;code&gt;dotnet new cpproj&lt;/code&gt;コマンドにオプションを追加します。&lt;/p&gt;
&lt;p&gt;まず、&lt;code&gt;.template.config&lt;/code&gt;下に&lt;code&gt;dotnetcli.host.json&lt;/code&gt;を追加します。
&lt;code&gt;symbolInfo&lt;/code&gt;メンバに、&lt;code&gt;longName&lt;/code&gt;のオプションに&lt;code&gt;framework&lt;/code&gt;を、&lt;code&gt;shortName&lt;/code&gt;に&lt;code&gt;f&lt;/code&gt;をもった&lt;code&gt;Framework&lt;/code&gt;というメンバを追加します。
追加することで、&lt;code&gt;dotnet new cpproj&lt;/code&gt;にオプションとして、&lt;code&gt;-f|--framework&lt;/code&gt;のオプションを付与することができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json line-numbers"&gt;{
    &amp;quot;$schema&amp;quot;: &amp;quot;http://json.schemastore.org/dotnetcli.host&amp;quot;,
    &amp;quot;symbolInfo&amp;quot;: {
        &amp;quot;Framework&amp;quot;: {
            &amp;quot;longName&amp;quot;: &amp;quot;framework&amp;quot;,
            &amp;quot;shortName&amp;quot;: &amp;quot;f&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次に&lt;code&gt;template.json&lt;/code&gt;に&lt;code&gt;symbols&lt;/code&gt;というメンバを追加し、ここに先ほど定義した&lt;code&gt;Framework&lt;/code&gt;メンバを追加します。
ここではオプションの振る舞いを定義します。&lt;/p&gt;
&lt;p&gt;今回はターゲットフレームワークを&lt;code&gt;.NET 5&lt;/code&gt;と&lt;code&gt;.NET Core 3.1&lt;/code&gt;を選択肢として定義します。
&lt;code&gt;datatype&lt;/code&gt;を&lt;code&gt;choice&lt;/code&gt;にして、&lt;code&gt;choices&lt;/code&gt;に選択肢を定義します。
&lt;code&gt;csproj&lt;/code&gt;の&lt;code&gt;TargetFramework&lt;/code&gt;に指定する文字列として、&lt;code&gt;.NET 5&lt;/code&gt;の場合は&lt;code&gt;net5.0&lt;/code&gt;、&lt;code&gt;.NET Core 3.1&lt;/code&gt;の場合は&lt;code&gt;netcoreapp3.1&lt;/code&gt;を&lt;code&gt;choice&lt;/code&gt;に設定します。
&lt;code&gt;replaces&lt;/code&gt;に置換する文字列を、&lt;code&gt;defaultValue&lt;/code&gt;にオプションを指定しない場合の文字列を設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json line-numbers"&gt;{
    ...
    &amp;quot;symbols&amp;quot;: {
        &amp;quot;Framework&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;parameter&amp;quot;,
            &amp;quot;description&amp;quot;: &amp;quot;The target framework for the project.&amp;quot;,
            &amp;quot;datatype&amp;quot;: &amp;quot;choice&amp;quot;,
            &amp;quot;choices&amp;quot;: [
                {
                    &amp;quot;choice&amp;quot;: &amp;quot;net5.0&amp;quot;,
                    &amp;quot;description&amp;quot;: &amp;quot;Target net5.0&amp;quot;
                },
                {
                    &amp;quot;choice&amp;quot;: &amp;quot;netcoreapp3.1&amp;quot;,
                    &amp;quot;description&amp;quot;: &amp;quot;Target netcoreapp3.1&amp;quot;
                }
            ],
            &amp;quot;replaces&amp;quot;: &amp;quot;netcoreapp3.1&amp;quot;,
            &amp;quot;defaultValue&amp;quot;: &amp;quot;netcoreapp3.1&amp;quot;
        }
    },
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、&lt;code&gt;Tasks.csproj&lt;/code&gt;と&lt;code&gt;Tests.csproj&lt;/code&gt;の&lt;code&gt;TargetFramework&lt;/code&gt;に&lt;code&gt;replaces&lt;/code&gt;で設定した文字列を設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml line-numbers"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    ...
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt;
    ...
  &amp;lt;/PropertyGroup&amp;gt;
  ...

&amp;lt;/Project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この状態で、&lt;code&gt;dotnet new cpproj -n Sample -f net5.0&lt;/code&gt;を実行することで、&lt;code&gt;TargetFramework&lt;/code&gt;に&lt;code&gt;net5.0&lt;/code&gt;が設定されたプロジェクトを生成することができます。&lt;/p&gt;
&lt;h2 id="section-4"&gt;解答用のクラスとテスト用のクラスのテンプレート&lt;/h2&gt;
&lt;p&gt;単一のファイルのみ生成するように、テンプレートを構築します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;Template.Solver/
    |
    |- .template.config/
    |    |
    |    |- template.json
    |
    |- Template.Solver.cs

Template.Tests/
    |
    |- .template.config/
    |    |
    |    |- template.json
    |
    |- Template.TestsTests.cs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プロジェクトのテンプレートの作り方と同様に、&lt;code&gt;template.json&lt;/code&gt;を記述しますが、単一ファイルのみ生成させるため、&lt;code&gt;preferNameDirectory&lt;/code&gt;を削除、または&lt;code&gt;false&lt;/code&gt;にします。&lt;/p&gt;
&lt;p&gt;解答用の&lt;code&gt;sourceName&lt;/code&gt;を&lt;code&gt;Template.Solver&lt;/code&gt;に、テスト用の&lt;code&gt;sourceName&lt;/code&gt;を&lt;code&gt;Template.Tests&lt;/code&gt;にすることで、&lt;code&gt;dotnet new&lt;/code&gt;コマンドの&lt;code&gt;-n|--name&lt;/code&gt;オプションに&lt;code&gt;Sample&lt;/code&gt;を指定すると、それぞれ&lt;code&gt;Sample.cs&lt;/code&gt;と&lt;code&gt;SampleTests.cs&lt;/code&gt;が生成されます。&lt;/p&gt;
&lt;h2 id="section-5"&gt;プロジェクトのパッケージ化&lt;/h2&gt;
&lt;p&gt;テンプレートが3つ用意できましたが、テンプレートをインストールする際にはそれぞれ個別にインストールが必要となります。
そのため、3つのテンプレートまとめて、1つの&lt;code&gt;nuget&lt;/code&gt;パッケージを生成します。
3つのディレクトリを一つのディレクトリにまとめ、そのディレクトリと同じ階層に&lt;code&gt;csproj&lt;/code&gt;ファイルを生成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;CPTemplate/
    |
    |- content/
    |    |
    |    |- Template.Project/
    |    |- Template.Solver/
    |    |- Template.Tests/
    |
    |- CPTemplate.csproj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ディレクトリを整理したら、&lt;code&gt;CPTemplate.csproj&lt;/code&gt;を編集し、ビルド情報を定義します。&lt;/p&gt;
&lt;div class="table-responsive"&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;メンバ&lt;/th&gt;
&lt;th style="text-align: left;"&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;PackageType&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;&lt;code&gt;nuget&lt;/code&gt;パッケージタイプ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;PackageVersion&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージのバージョン&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;PackageId&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージの識別子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Title&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージの名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Authors&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージの作成者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Description&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージの説明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;PackageTags&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージのタグ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;TargetFramework&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージをビルドするためのターゲットフレームワーク&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;PackageProjectUrl&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;プロジェクトURL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;IncludeBuildOutput&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;ビルド時に生成されるファイルをパッケージに含めるか&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;ContentTargetFolders&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージ化するプロジェクトのルートが&lt;code&gt;content&lt;/code&gt;か&lt;code&gt;contentFiles&lt;/code&gt;以外の場合は設定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&lt;code&gt;Content&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left;"&gt;パッケージに含めるファイルや除くファイルを設定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class="language-xml line-numbers"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;PackageType&amp;gt;Template&amp;lt;/PackageType&amp;gt;
    &amp;lt;PackageVersion&amp;gt;1.0&amp;lt;/PackageVersion&amp;gt;
    &amp;lt;PackageId&amp;gt;AconCavy.Templates&amp;lt;/PackageId&amp;gt;
    &amp;lt;Title&amp;gt;Templates&amp;lt;/Title&amp;gt;
    &amp;lt;Authors&amp;gt;AconCavy&amp;lt;/Authors&amp;gt;
    &amp;lt;Description&amp;gt;sample template.&amp;lt;/Description&amp;gt;
    &amp;lt;PackageTags&amp;gt;dotnet-new;templates;competitive-programming&amp;lt;/PackageTags&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.1&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;PackageProjectUrl&amp;gt;https://github.com/AconCavy/CompetitiveProgrammingTemplateCSharp&amp;lt;/PackageProjectUrl&amp;gt;

    &amp;lt;IncludeBuildOutput&amp;gt;false&amp;lt;/IncludeBuildOutput&amp;gt;
    &amp;lt;ContentTargetFolders&amp;gt;content&amp;lt;/ContentTargetFolders&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Content Include=&amp;quot;content/**/*&amp;quot; Exclude=&amp;quot;content/**/bin/**;content/**/obj/**&amp;quot; /&amp;gt;
    &amp;lt;Compile Remove=&amp;quot;**/*&amp;quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、それぞれのテンプレートの&lt;code&gt;template.json&lt;/code&gt;に&lt;code&gt;groupIdentity&lt;/code&gt;を追加します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json line-numbers"&gt;// Project
&amp;quot;groupIdentity&amp;quot;: &amp;quot;AconCavy.Templates.Project&amp;quot;

// Solver
&amp;quot;groupIdentity&amp;quot;: &amp;quot;AconCavy.Templates.Solver&amp;quot;

// Tests
&amp;quot;groupIdentity&amp;quot;: &amp;quot;AconCavy.Templates.Tests&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dotnet pack&lt;/code&gt;コマンドを実行することで&lt;code&gt;nuget&lt;/code&gt;パッケージを生成することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;dotnet pack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行後、&lt;code&gt;bin/Debug/&lt;/code&gt;下に&lt;code&gt;{PackageId}.{PackageVersion}.nupkg&lt;/code&gt;が生成されます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="line-numbers"&gt;CPTemplate/
    |
    |- bin/
    |    |
    |    |- Debug/
    |    |    |
    |    |    |- AconCavy.Templates.1.0.0.nupkg
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この&lt;code&gt;nupkg&lt;/code&gt;を&lt;code&gt;dotnet new&lt;/code&gt;コマンドでインストールすることで、3つのテンプレートを1回でインストールすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh line-numbers"&gt;dotnet new -i ./bin/Debug/AconCavy.Templates.1.0.0.nupkg
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-6"&gt;まとめ&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;dotnet new&lt;/code&gt;のカスタムテンプレートの作り方と、テンプレートのパッケージ化の手順をまとめました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレートのルートに&lt;code&gt;.template.config&lt;/code&gt;ディレクトリを作成し、内に&lt;code&gt;template.json&lt;/code&gt;を作成する。&lt;/li&gt;
&lt;li&gt;テンプレートが複数ある場合は1つのディレクトリにまとめ、&lt;code&gt;dotnet pack&lt;/code&gt;コマンドでパッケージ化する。&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Statiqがmarkdownから生成するhtmlのカスタマイズ</title>
			<link>https://aconcavy.github.io/blog/posts/20201119statiqextension</link>
			<description>&lt;p&gt;Statiqがmarkdownから生成するhtmlの任意のタグにクラスを追加する方法の備忘録&lt;/p&gt;</description>
			<guid>https://aconcavy.github.io/blog/posts/20201119statiqextension</guid>
			<pubDate>Thu, 19 Nov 2020 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h1 id="section"&gt;はじめに&lt;/h1&gt;
&lt;p&gt;Statiqがmarkdownから生成するhtmlの任意のタグにクラスを追加する方法の備忘録&lt;/p&gt;
&lt;h1 id="section-1"&gt;方法&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Bootstrapper&lt;/code&gt;において、&lt;code&gt;Statiq.Web&lt;/code&gt;でWebサイトを生成するメソッドである&lt;code&gt;CreateWeb()&lt;/code&gt;では、markdownに関わるModuleの&lt;code&gt;RenderMarkdown&lt;/code&gt;を&lt;code&gt;Templates&lt;/code&gt;内で設定している。
そのため、&lt;code&gt;ConfigureTemplates()&lt;/code&gt;を通じて、予め設定されたModuleを上書きすることで好みの設定を反映することができる。
Statiqでは、markdownを生成するために&lt;a href="https://github.com/lunet-io/markdig"&gt;markdig&lt;/a&gt;を使っているようなので、markdownの設定を追加するには&lt;code&gt;IMarkdownExtension&lt;/code&gt;を継承したクラスを&lt;code&gt;Rendermarkdown.UseExtension&amp;lt;TExtension&amp;gt;()&lt;/code&gt;に渡す必要がある。&lt;/p&gt;
&lt;p&gt;今回は、&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;タグをレスポンシブ対応と、&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;タグにクラスを追加するために、markdigの&lt;code&gt;BootstrapExtension&lt;/code&gt;を設定に追加する。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static async Task&amp;lt;int&amp;gt; Main(string[] args) =&amp;gt;
    await Bootstrapper.Factory
        .CreateWeb(args)
        .ConfigureTemplates(templates =&amp;gt;
        {
            // 新しい設定のModuleを作成
            // デフォルトはUseExtensionsのみ
            var markdownModule = new RenderMarkdown()
                .UseExtensions()
                .UseExtension&amp;lt;BootstrapExtension&amp;gt;() // bootstrap
                .UseExtension&amp;lt;PrismJsExtension&amp;gt;(); // オリジナル
            if (templates.ContainsKey(MediaTypes.Markdown)) 
                templates[MediaTypes.Markdown].Module = markdownModule; // 既にあるならば書き換え
            else 
                templates.Add(MediaTypes.Markdown,
                    new Template(ContentType.Content, Phase.Process, markdownModule)); // 無ければ追加
        })
        .RunAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、&lt;code&gt;prism.js&lt;/code&gt;のコードブロックに行数を表示するクラスの&lt;code&gt;line-number&lt;/code&gt;を追加するために、新しく&lt;code&gt;PrismJsExtension.cs&lt;/code&gt;を作成し、&lt;code&gt;BootstrapExtension&lt;/code&gt;に倣い、&lt;code&gt;MarkdownObject&lt;/code&gt;が&lt;code&gt;CodeBlock&lt;/code&gt;であれば&lt;code&gt;line-numbers&lt;/code&gt;をクラスに追加するメソッドの&lt;code&gt;PipelineOnDocumentProcessed()&lt;/code&gt;markdigの生成パイプラインにデリゲートを追加する。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;// PrismJsExtension.cs
using Markdig;
using Markdig.Renderers;
using Markdig.Renderers.Html;
using Markdig.Syntax;

namespace Blog.Extensions
{
    public class PrismJsExtension : IMarkdownExtension
    {
        public void Setup(MarkdownPipelineBuilder pipeline)
        {
            pipeline.DocumentProcessed -= PipelineOnDocumentProcessed;
            pipeline.DocumentProcessed += PipelineOnDocumentProcessed;
        }

        public void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer)
        {
        }

        private static void PipelineOnDocumentProcessed(MarkdownDocument document)
        {
            foreach (var node in document.Descendants())
            {
                if (node is CodeBlock)
                {
                    node.GetAttributes().AddClass(&amp;quot;line-numbers&amp;quot;); // 行数表示のクラスを追加
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上の2つの設定を追加してビルドすることで、bootstrapによる&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;タグのレスポンシブ対応、&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;タグのレイアウト、prism.jsの言語を指定したコードブロックに行数が表示されるようになる。&lt;/p&gt;
&lt;h1 id="section-2"&gt;まとめ&lt;/h1&gt;
&lt;p&gt;StatiqのBootstrapperにて&lt;code&gt;ConfigureTemplates()&lt;/code&gt;からテンプレートのmarkdownに関わるModuleを書き換えることで、markdownからhtmlを生成する設定を変更することができ、&lt;code&gt;RenderMarkdown.UseExtension&amp;lt;TExtension&amp;gt;()&lt;/code&gt;に&lt;code&gt;IMarkdownExtension&lt;/code&gt;を継承したクラスを設定することで、htmlタグのクラス等を変更することができる。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>