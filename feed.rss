<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://blog.aconcavy.dev/</link>
		<description />
		<copyright>Copyright © 2020-2023 AconCavy</copyright>
		<pubDate>Sat, 25 Mar 2023 14:54:21 GMT</pubDate>
		<lastBuildDate>Sat, 25 Mar 2023 14:54:21 GMT</lastBuildDate>
		<item>
			<title>ABC295</title>
			<link>https://blog.aconcavy.dev/posts/20230325abc295</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 295の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230325abc295</guid>
			<pubDate>Sat, 25 Mar 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 295の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc295"&gt;https://atcoder.jp/contests/abc295&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40021040"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;W&lt;/code&gt;について、&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;not&lt;/code&gt;、&lt;code&gt;that&lt;/code&gt;、&lt;code&gt;the&lt;/code&gt;、&lt;code&gt;you&lt;/code&gt;のいずれかと一致するかを判定します。
対象となる5つの語を配列にまとめることで、&lt;code&gt;Contains&lt;/code&gt;メソッドで引数に指定した値が配列内に存在するかを判定することでき、この操作を各&lt;code&gt;W&lt;/code&gt;について
行い、いずれかが一致すれば答えは&lt;code&gt;Yes&lt;/code&gt;、しなければ答えは&lt;code&gt;No&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var W = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
    var words = new[] { &amp;quot;and&amp;quot;, &amp;quot;not&amp;quot;, &amp;quot;that&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;you&amp;quot; };
    var answer = W.Any(x =&amp;gt; words.Contains(x));
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40027852"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;爆発後の盤面を&lt;code&gt;G&lt;/code&gt;としたとき、&lt;code&gt;G&lt;/code&gt;の初期状態は&lt;code&gt;B&lt;/code&gt;であり、&lt;code&gt;B[r1][c1]&lt;/code&gt;が爆弾の場合は、マンハッタン距離が&lt;code&gt;B[r1][c1]&lt;/code&gt;以下となる&lt;code&gt;G[r2][c2]&lt;/code&gt;を空きマスにします。&lt;br /&gt;
&lt;code&gt;1&amp;lt;=R,C&amp;lt;=20&lt;/code&gt;と制約が小さいため、&lt;code&gt;r1&lt;/code&gt;、&lt;code&gt;c1&lt;/code&gt;、&lt;code&gt;r2&lt;/code&gt;、&lt;code&gt;c2&lt;/code&gt;を全探索しても、最大でも&lt;code&gt;20^4=160,000&lt;/code&gt;なので十分高速です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (R, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var B = new char[R][];
    for (var i = 0; i &amp;lt; R; i++)
    {
        B[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    bool IsWallOrEmpty(char c) =&amp;gt; c == '#' || c == '.';
    int Distance(int r1, int c1, int r2, int c2) =&amp;gt; Math.Abs(r1 - r2) + Math.Abs(c1 - c2);

    var G = new char[R, C];
    for (var i = 0; i &amp;lt; R; i++)
    {
        for (var j = 0; j &amp;lt; C; j++)
        {
            G[i, j] = B[i][j];
        }
    }

    for (var r1 = 0; r1 &amp;lt; R; r1++)
    {
        for (var c1 = 0; c1 &amp;lt; C; c1++)
        {
            if (IsWallOrEmpty(B[r1][c1])) continue;
            var x = B[r1][c1] - '0';
            for (var r2 = 0; r2 &amp;lt; R; r2++)
            {
                for (var c2 = 0; c2 &amp;lt; C; c2++)
                {
                    if (Distance(r1, c1, r2, c2) &amp;lt;= x)
                    {
                        G[r2, c2] = '.';
                    }
                }
            }
        }
    }

    Printer.Print2D(G);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40029453"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書などのデータ構造を使って各色の靴下の個数をそれぞれ数え上げ、各色の&lt;code&gt;靴下の個数/2&lt;/code&gt;の合計が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    foreach (var a in A)
    {
        if (!dict.ContainsKey(a)) dict[a] = 0;
        dict[a]++;
    }

    var answer = dict.Values.Sum(x =&amp;gt; x / 2);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc295/tasks/abc295_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC295/submissions/40047728"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嬉しい文字列である条件は、その文字列に存在する各数字について、全ての個数が偶数であることが条件です。&lt;br /&gt;
ある数字に注目したとき、範囲&lt;code&gt;[l,r)&lt;/code&gt;に存在する数字個数は、&lt;code&gt;cum[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;文字目までの累積和としたとき、&lt;code&gt;cum[r]-cum[l]&lt;/code&gt;で求めることができます。&lt;br /&gt;
また、範囲&lt;code&gt;[l,r)&lt;/code&gt;に存在する数字の個数が偶数であるには、&lt;code&gt;cum[r]-cum[l]&lt;/code&gt;が&lt;code&gt;偶数-偶数&lt;/code&gt;、または&lt;code&gt;奇数-奇数&lt;/code&gt;である必要があります。&lt;br /&gt;
この条件が全ての数字に当てはまることから、&lt;code&gt;l&lt;/code&gt;文字目まで見たときの各数字の個数の偶奇と、&lt;code&gt;r&lt;/code&gt;文字目まで見たときの各数字の個数の偶奇が一致すれば、その&lt;code&gt;[l,r)&lt;/code&gt;は嬉しい文字列であることがわかります。&lt;br /&gt;
このことから、各&lt;code&gt;0&amp;lt;=i&amp;lt;=|S|&lt;/code&gt;について、各数字の個数の偶奇の集合の個数を数え上げ、集合が&lt;code&gt;x&lt;/code&gt;個ある場合、&lt;code&gt;x&lt;/code&gt;個のうちから2個選ぶ組み合わせが、その集合になる&lt;code&gt;[l,r)&lt;/code&gt;の組み合わせの個数になります。&lt;/p&gt;
&lt;p&gt;各数字の個数の偶奇の集合について、数字は&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;9&lt;/code&gt;の10種類のみかつそれぞれ偶奇の2通りのため、整数型の各ビットに偶奇フラグとして保持することができます。&lt;br /&gt;
これは、初期状態&lt;code&gt;0&lt;/code&gt;に対して、&lt;code&gt;1&amp;lt;&amp;lt;S[i]&lt;/code&gt;の排他的論理和を累積していくことで、&lt;code&gt;i&lt;/code&gt;まで見たときの各数字の個数の偶奇の集合として管理することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
    var N = S.Length;
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    var curr = 0;
    dict[curr] = 1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        curr ^= 1 &amp;lt;&amp;lt; S[i];
        if (!dict.ContainsKey(curr)) dict[curr] = 0;
        dict[curr]++;
    }

    var answer = dict.Values.Sum(x =&amp;gt; x * (x - 1) / 2);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC294</title>
			<link>https://blog.aconcavy.dev/posts/20230319abc294</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 294の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230319abc294</guid>
			<pubDate>Sun, 19 Mar 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 294の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc294"&gt;https://atcoder.jp/contests/abc294&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc294/tasks/abc294_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC294/submissions/39840357"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LiNQの&lt;code&gt;Where&lt;/code&gt;を使うことで、シーケンスに対してフィルタをかけることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A.Where(x =&amp;gt; x % 2 == 0)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc294/tasks/abc294_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC294/submissions/39845536"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F(n)&lt;/code&gt;を&lt;code&gt;n&lt;/code&gt;番目の英大文字としたとき、ASCIIコードより&lt;code&gt;F(n)&lt;/code&gt;は&lt;code&gt;(char)('A'+n-1)&lt;/code&gt;で求めることができます。
また、&lt;code&gt;A[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列の数字、&lt;code&gt;G[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列の文字としたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A[i][j]&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;ならば、&lt;code&gt;G[i][j]&lt;/code&gt;は&lt;code&gt;'.'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A[i][j]&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;以外ならば、&lt;code&gt;G[i][j]&lt;/code&gt;は&lt;code&gt;F(A[i][j])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;に置換したものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    char F(int n) =&amp;gt; (char)('A' + n - 1);

    var G = new char[H, W];
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            G[i, j] = A[i][j] == 0 ? '.' : F(A[i][j]);
        }
    }

    Printer.Print2D(G);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc294/tasks/abc294_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC294/submissions/39848569"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;を合わせ、ソートした配列&lt;code&gt;C&lt;/code&gt;において、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;における任意の数値が&lt;code&gt;C&lt;/code&gt;における何番目かを求められることが必要です。
これは辞書などのデータ構造を使って``dict[C[i]]=i`を管理することで高速に求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var (map, _) = Compress(A.Concat(B));
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A.Select(x =&amp;gt; map[x] + 1)));
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B.Select(x =&amp;gt; map[x] + 1)));
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }

    return (map, remap);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc294/tasks/abc294_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC294/submissions/39854709"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC294/submissions/39883961"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;受付に呼ばれていない人の集合&lt;code&gt;S1&lt;/code&gt;と既に受付に呼ばれているが受付に行っていない人の集合&lt;code&gt;S2&lt;/code&gt;としたとき、それぞれの集合を順序付き集合で管理することで、クエリ当たりの時間計算量&lt;code&gt;O(logN)&lt;/code&gt;、全体時間計算量で&lt;code&gt;O(QlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S1 = new SortedSet&amp;lt;int&amp;gt;(Enumerable.Range(0, N));
    var S2 = new SortedSet&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var e = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (e[0] == 1)
        {
            var x = S1.Min;
            S1.Remove(x);
            S2.Add(x);
        }
        else if (e[0] == 2)
        {
            var x = e[1] - 1;
            S2.Remove(x);
        }
        else
        {
            var x = S2.Min;
            Console.WriteLine(x + 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc294/tasks/abc294_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC294/submissions/39878202"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC294/submissions/39883508"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各要素&lt;code&gt;V&lt;/code&gt;について、要素の始まりの位置&lt;code&gt;L&lt;/code&gt;と要素の終わりの位置&lt;code&gt;R&lt;/code&gt;を管理し、対象の範囲を左から順に尺取り法で走査していきます。&lt;br /&gt;
1行目の&lt;code&gt;V&lt;/code&gt;、&lt;code&gt;L&lt;/code&gt;、&lt;code&gt;R&lt;/code&gt;をそれぞれ&lt;code&gt;V1&lt;/code&gt;、&lt;code&gt;L1&lt;/code&gt;、&lt;code&gt;R1&lt;/code&gt;とし、2行目の&lt;code&gt;V&lt;/code&gt;、&lt;code&gt;L&lt;/code&gt;、&lt;code&gt;R&lt;/code&gt;をそれぞれ&lt;code&gt;V2&lt;/code&gt;、&lt;code&gt;L2&lt;/code&gt;、&lt;code&gt;R2&lt;/code&gt;としたとき、対象となる範囲&lt;code&gt;V1&lt;/code&gt;と&lt;code&gt;V2&lt;/code&gt;が一致しているとき、&lt;code&gt;Min(R1,R2)-Max(L1,L2)&lt;/code&gt;個の要素が一致します。&lt;br /&gt;
そして、&lt;code&gt;R1&amp;lt;=R2&lt;/code&gt;ならば、1行目の対象の範囲を1つずらし、&lt;code&gt;R1&amp;gt;R2&lt;/code&gt;ならば2行目の対象の範囲を1つずらします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L, N1, N2) = Scanner.Scan&amp;lt;long, int, int&amp;gt;();
    var S1 = new S[N1];
    var S2 = new S[N2];
    for (var k = 0; k &amp;lt; 2; k++)
    {
        var (N, S) = k == 0 ? (N1, S1) : (N2, S2);
        long l = 0;
        for (var i = 0; i &amp;lt; N; i++)
        {
            var (v, len) = Scanner.Scan&amp;lt;long, long&amp;gt;();
            var r = l + len;
            S[i] = new S(v, l, r);
            l = r;
        }
    }

    long answer = 0;
    var (i1, i2) = (0, 0);
    while (i1 &amp;lt; N1 &amp;amp;&amp;amp; i2 &amp;lt; N2)
    {
        if (S1[i1].V == S2[i2].V)
        {
            var l = Math.Max(S1[i1].L, S2[i2].L);
            var r = Math.Min(S1[i1].R, S2[i2].R);
            answer += Math.Max(0, r - l);
        }

        if (S1[i1].R &amp;lt;= S2[i2].R) i1++;
        else i2++;
    }

    Console.WriteLine(answer);
}

public readonly struct S
{
    public readonly long V;
    public readonly long L;
    public readonly long R;
    public S(long v, long l, long r) =&amp;gt; (V, L, R) = (v, l, r);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC293</title>
			<link>https://blog.aconcavy.dev/posts/20230311abc293</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 293の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230311abc293</guid>
			<pubDate>Sat, 11 Mar 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 293の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc293"&gt;https://atcoder.jp/contests/abc293&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc293/tasks/abc293_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC293/submissions/39600481"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての奇数番目の文字と偶数番目の文字を入れ替えたものを出力します。
&lt;code&gt;0-indexed&lt;/code&gt;の場合、偶数番目と奇数番目であることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    var N = S.Length;
    for (var i = 0; i &amp;lt; N / 2; i++)
    {
        (S[i * 2], S[i * 2 + 1]) = (S[i * 2 + 1], S[i * 2]);
    }

    var T = new string(S);
    Console.WriteLine(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc293/tasks/abc293_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC293/submissions/39607963"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&amp;lt;=i&amp;lt;=N&lt;/code&gt;について、&lt;code&gt;i&lt;/code&gt;番目の人が呼ばれているかを配列で保持しながら、&lt;code&gt;i&lt;/code&gt;が呼ばれていなければ&lt;code&gt;A[i]&lt;/code&gt;を呼ぶという操作を行います。&lt;br /&gt;
そして、呼ばれていない&lt;code&gt;i&lt;/code&gt;を列挙します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var called = new bool[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (!called[i]) called[A[i] - 1] = true;
    }

    var answers = Enumerable.Range(0, N).Where(x =&amp;gt; !called[x]).ToArray();
    Console.WriteLine(answers.Length);
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers.Select(x =&amp;gt; x + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc293/tasks/abc293_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC293/submissions/39616941"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(1,1)&lt;/code&gt;から&lt;code&gt;(H,W)&lt;/code&gt;に移動するために必要な移動回数は、右移動&lt;code&gt;H-1&lt;/code&gt;回、下移動&lt;code&gt;W-1&lt;/code&gt;回の計&lt;code&gt;H+W-2&lt;/code&gt;回です。&lt;br /&gt;
右移動を&lt;code&gt;0&lt;/code&gt;、下移動を&lt;code&gt;1&lt;/code&gt;としたとき、&lt;code&gt;2^(H+W-2)&lt;/code&gt;通りの移動方法をbit全探索し、右&lt;code&gt;H-1&lt;/code&gt;回、下&lt;code&gt;W-1&lt;/code&gt;回になる移動方法を調べます。
全体の時間計算量は&lt;code&gt;O(2^(H+W-2)(H+W-2))&lt;/code&gt;となり、最大でも&lt;code&gt;2^18*18==4718592&lt;/code&gt;の計算で済み、十分高速です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new long[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    }

    var K = H + W - 2;
    var answer = 0;

    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; K; s++)
    {
        var delta = new List&amp;lt;(int, int)&amp;gt;(K);
        for (var i = 0; i &amp;lt; K; i++)
        {
            if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 0) delta.Add((1, 0));
            else delta.Add((0, 1));
        }

        var ok = true;

        var set = new HashSet&amp;lt;long&amp;gt;();
        var (ch, cw) = (0, 0);
        set.Add((A[0][0]));
        foreach (var (dh, dw) in delta)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw || set.Contains(A[nh][nw]))
            {
                ok = false;
                break;
            }

            set.Add(A[nh][nw]);
            ch = nh;
            cw = nw;
        }

        if (ok)
        {
            answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc293/tasks/abc293_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC293/submissions/39620255"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;b&lt;/code&gt;が連結であり、頂点&lt;code&gt;a&lt;/code&gt;と頂点&lt;code&gt;c&lt;/code&gt;が連結であるとき、頂点&lt;code&gt;b&lt;/code&gt;と頂点&lt;code&gt;c&lt;/code&gt;間に辺を追加すると閉路ができます。&lt;br /&gt;
これは、&lt;code&gt;DisjointSetUnion&lt;/code&gt;で高速に判定することができます。&lt;/p&gt;
&lt;p&gt;問題について、各ロープには赤と青の区別された端があることから、赤と青の端をそれぞれ別の頂点としたとき、赤と青の頂点間に辺があると言えます。&lt;br /&gt;
あらかじめ各ロープの赤と青の頂点を連結し、各クエリごとにロープとその色に対応する頂点同士を閉路ができるかを判定しながら連結していくことで、環状になっているロープの組の数を数え上げることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dsu = new DisjointSetUnion(N * 2);
    for (var i = 0; i &amp;lt; N; i++)
    {
        dsu.Merge(i * 2, i * 2 + 1);
    }

    var x = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
        var (u, v) = ((int.Parse(query[0]) - 1) * 2, (int.Parse(query[2]) - 1) * 2);
        var (uc, vc) = (query[1], query[2]);
        if (uc == &amp;quot;B&amp;quot;) u++;
        if (vc == &amp;quot;B&amp;quot;) v++;
        if (dsu.IsSame(u, v)) x++;
        dsu.Merge(u, v);
    }

    var y = dsu.GetGroups().Count() - x;
    Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC292</title>
			<link>https://blog.aconcavy.dev/posts/20230304abc292</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 292の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230304abc292</guid>
			<pubDate>Sat, 04 Mar 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 292の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc292"&gt;https://atcoder.jp/contests/abc292&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc292/tasks/abc292_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC292/submissions/39402822"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string.ToUpper&lt;/code&gt;で文字列をすべて大文字にすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.ToUpper();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc292/tasks/abc292_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC292/submissions/39407218"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Y[x]&lt;/code&gt;をその時点の&lt;code&gt;x&lt;/code&gt;のイエローカードの数とし、レッドカードはイエローカード2枚分であるとします。
そして、各イベントについて次のような処理を行います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;イベントが&lt;code&gt;1&lt;/code&gt;の場合、&lt;code&gt;Y[x]+=1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;イベントが&lt;code&gt;2&lt;/code&gt;の場合、&lt;code&gt;Y[x]+=2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;イベントが&lt;code&gt;3&lt;/code&gt;の場合、&lt;code&gt;Y[x]&amp;gt;=2&lt;/code&gt;ならば退場処分を受けている。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = new int[N];
    while (Q-- &amp;gt; 0)
    {
        var (e, x) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--;
        if (e == 3)
        {
            var answer = C[x] &amp;gt;= 2 ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;;
            Console.WriteLine(answer);
        }
        else
        {
            C[x] += e;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc292/tasks/abc292_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC292/submissions/39436921"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;AB&lt;/code&gt;の値が&lt;code&gt;X&lt;/code&gt;の場合、&lt;code&gt;A*B==X&lt;/code&gt;となる&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;の組み合わせの個数は、&lt;code&gt;X&lt;/code&gt;の約数の個数と一致します。
これは、時間計算量&lt;code&gt;O(Sqrt(X))&lt;/code&gt;で求めることができます。
また、&lt;code&gt;C(n)&lt;/code&gt;を&lt;code&gt;n&lt;/code&gt;の約数の個数としたとき、&lt;code&gt;X+Y=N&lt;/code&gt;となる組み合わせは&lt;code&gt;C(X)*C(Y)&lt;/code&gt;個になります。
そして、&lt;code&gt;AB&lt;/code&gt;の値を&lt;code&gt;X&lt;/code&gt;としたとき、&lt;code&gt;CD&lt;/code&gt;の値は&lt;code&gt;Y=N-X&lt;/code&gt;で求められるので、&lt;code&gt;AB&lt;/code&gt;を固定することで全体計算量&lt;code&gt;O(NSqrt(N))&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var dict = new Dictionary&amp;lt;long, long&amp;gt;();

    long F(long n)
    {
        if (dict.ContainsKey(n)) return dict[n];
        long result = 0;
        for (var a = 1L; a * a &amp;lt;= n; a++)
        {
            if (n % a != 0) continue;
            var b = n / a;
            if (a == b) result++;
            else result += 2;
        }

        return dict[n] = result;
    }

    long answer = 0;
    for (var ab = 1; ab &amp;lt; N; ab++)
    {
        var cd = N - ab;
        answer += F(ab) * F(cd);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc292/tasks/abc292_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC292/submissions/39429436"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DisjointSetUnion&lt;/code&gt;を使って、各連結成分の代表する頂点を求められるようにしておきます。
そして、連結成分の頂点の個数と辺の個数をそれぞれ各連結成分の代表にまとめ、それらを比較することで、各連結成分の頂点の個数を辺の個数が一致するかを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var E = new (int U, int V)[M];
    var dsu = new DisjointSetUnion(N);
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        E[i] = (u, v);
        dsu.Merge(u, v);
    }

    var vc = new int[N];
    for (var u = 0; u &amp;lt; N; u++)
    {
        vc[dsu.LeaderOf(u)]++;
    }

    var ec = new int[N];
    foreach (var (u, _) in E)
    {
        ec[dsu.LeaderOf(u)]++;
    }

    var answer = true;
    for (var u = 0; u &amp;lt; N; u++)
    {
        answer &amp;amp;= vc[u] == ec[u];
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc292/tasks/abc292_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC292/submissions/39444776"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある頂点を始点&lt;code&gt;s&lt;/code&gt;としたとき、その頂点からたどり着くことができる頂点&lt;code&gt;t&lt;/code&gt;に対して、&lt;code&gt;s-&amp;gt;t&lt;/code&gt;の辺を張ることができます。
このことから、各頂点を始点としたときに、たどり着くことができる頂点を幅優先探索などで探索することで、張ることができる辺の数を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[u].Add(v);
    }

    var used = new bool[N];
    var queue = new Queue&amp;lt;int&amp;gt;();
    var answer = -M;
    for (var i = 0; i &amp;lt; N; i++)
    {
        Array.Fill(used, false);
        used[i] = true;
        queue.Enqueue(i);
        while (queue.Count &amp;gt; 0)
        {
            var u = queue.Dequeue();
            foreach (var v in G[u])
            {
                if (used[v]) continue;
                used[v] = true;
                answer++;
                queue.Enqueue(v);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC291</title>
			<link>https://blog.aconcavy.dev/posts/20230226abc291</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 291の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230226abc291</guid>
			<pubDate>Mon, 27 Feb 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 291の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc291"&gt;https://atcoder.jp/contests/abc291&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc291/tasks/abc291_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC291/submissions/39224701"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[i]&lt;/code&gt;が大文字かどうかは&lt;code&gt;char.IsUpper&lt;/code&gt;で調べることができ、その&lt;code&gt;i&lt;/code&gt;の値を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        if (char.IsUpper(S[i]))
        {
            Console.WriteLine(i + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc291/tasks/abc291_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC291/submissions/39230017"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;をソートし、先頭&lt;code&gt;N&lt;/code&gt;人と末尾&lt;code&gt;N&lt;/code&gt;人を除いた&lt;code&gt;3N&lt;/code&gt;人の平均を求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(X);
    var s = X.Skip(N).Take(3 * N).Sum();
    var answer = (double)s / (3 * N);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc291/tasks/abc291_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC291/submissions/39233135"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既に訪れた座標を管理しながら現在の座標を遷移させることで、既に訪れたことがあるかを求めます。
訪れた座標のペアを&lt;code&gt;HashSet&lt;/code&gt;などのデータ構造で管理することで、時間計算量&lt;code&gt;O(1)&lt;/code&gt;で現在の座標が訪れたことがあるかを調べることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var set = new HashSet&amp;lt;(int, int)&amp;gt;();
    var x = 0;
    var y = 0;
    set.Add((x, y));
    foreach (var c in S)
    {
        var dx = 0;
        var dy = 0;
        if (c == 'R') dx = 1;
        if (c == 'L') dx = -1;
        if (c == 'U') dy = 1;
        if (c == 'D') dy = -1;
        x += dx;
        y += dy;
        if (set.Contains((x, y)))
        {
            Console.WriteLine(&amp;quot;Yes&amp;quot;);
            return;
        }
        set.Add((x, y));
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc291/tasks/abc291_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC291/submissions/39250928"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,j] := i番目のカードまで見たとき、i番目のカードがj(表,裏)のとき条件を満たすものの数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;i=1のとき、
dp[1,0] = 1
dp[1,1] = 1

i&amp;gt;1のとき、
dp[i,0] += dp[i-1,0] (A[i]!=A[i-1])
dp[i,0] += dp[i-1,1] (A[i]!=B[i-1])
dp[i,1] += dp[i-1,0] (B[i]!=A[i-1])
dp[i,1] += dp[i-1,1] (B[i]!=B[i-1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答えは、&lt;code&gt;dp[N,0]+dp[N,1]&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N];
    var B = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        A[i] = a;
        B[i] = b;
    }

    var dp = new mint[N, 2];
    dp[0, 0] = dp[0, 1] = 1;
    for (var i = 1; i &amp;lt; N; i++)
    {
        if (A[i] != A[i - 1]) dp[i, 0] += dp[i - 1, 0];
        if (A[i] != B[i - 1]) dp[i, 0] += dp[i - 1, 1];
        if (B[i] != A[i - 1]) dp[i, 1] += dp[i - 1, 0];
        if (B[i] != B[i - 1]) dp[i, 1] += dp[i - 1, 1];
    }

    var answer = dp[N - 1, 0] + dp[N - 1, 1];
    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc291/tasks/abc291_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC291/submissions/39253701"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;各整数の組について頂点&lt;code&gt;X&lt;/code&gt;から頂点&lt;code&gt;Y&lt;/code&gt;の有効辺としたグラフを考えたとき、グラフをトポロジカルソートすることができ、かつ始点と終点が一意に定まるかが条件となります。&lt;/del&gt;&lt;br /&gt;
&lt;del&gt;始点が一意に定まるかは、頂点の入次数が&lt;code&gt;0&lt;/code&gt;の頂点数が&lt;code&gt;1&lt;/code&gt;つであることで判定できます。&lt;/del&gt;&lt;br /&gt;
&lt;del&gt;同様に、終点が一意に定まるかは頂点の出次数が&lt;code&gt;0&lt;/code&gt;の頂点数が&lt;code&gt;1&lt;/code&gt;つであることで判定できます。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;誤答でした。&lt;/p&gt;
&lt;p&gt;各整数の組について頂点&lt;code&gt;X&lt;/code&gt;から頂点&lt;code&gt;Y&lt;/code&gt;の有効辺としたグラフを考えたとき、グラフをトポロジカルソートすることができ、頂点の遷移が一意であることが条件となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var E = new HashSet&amp;lt;(int, int)&amp;gt;();
    var deg = new int[N];

    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--; y--;
        if (E.Contains((x, y))) continue;
        E.Add((x, y));
        G[x].Add(y);
        deg[y]++;
    }

    var queue = new Queue&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (deg[i] == 0) queue.Enqueue(i);
    }

    var result = new int[N];
    var idx = 0;
    while (queue.Count &amp;gt; 0)
    {
        if (queue.Count &amp;gt; 1)
        {
            Console.WriteLine(&amp;quot;No&amp;quot;);
            return;
        }

        var u = queue.Dequeue();
        foreach (var v in G[u])
        {
            deg[v]--;
            if (deg[v] == 0) queue.Enqueue(v);
        }

        result[idx++] = u;
    }

    if (idx != N)
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
        return;
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
    var answer = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        answer[result[i]] = i + 1;
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc291/tasks/abc291_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC291/submissions/39268553"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp1[i]&lt;/code&gt;を都市&lt;code&gt;1&lt;/code&gt;から都市&lt;code&gt;i&lt;/code&gt;までにかかる最小の移動回数、&lt;code&gt;dpN[j]&lt;/code&gt;を都市&lt;code&gt;j&lt;/code&gt;から都市&lt;code&gt;N&lt;/code&gt;までにかかる最小の移動回数としたとき、&lt;code&gt;dp1[u]+dpN[v]+1 (1&amp;lt;=u&amp;lt;k&amp;lt;v&amp;lt;=N,v&amp;lt;=u+M)&lt;/code&gt;の最小値が都市&lt;code&gt;k&lt;/code&gt;を通らずに都市&lt;code&gt;1&lt;/code&gt;から都市&lt;code&gt;N&lt;/code&gt;への最小の移動回数となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    var dpS = new long[N];
    var dpT = new long[N];
    const long Inf = (long)1e18;
    Array.Fill(dpS, Inf);
    Array.Fill(dpT, Inf);
    dpS[0] = dpT[N - 1] = 0;
    for (var v = 1; v &amp;lt; N; v++)
    {
        for (var u = Math.Max(v - M, 0); u &amp;lt; v; u++)
        {
            if (S[u][v - u - 1] == '1') dpS[v] = Math.Min(dpS[v], dpS[u] + 1);
        }
    }

    for (var v = N - 1; v &amp;gt; 0; v--)
    {
        for (var u = Math.Max(v - M, 0); u &amp;lt; v; u++)
        {
            if (S[u][v - u - 1] == '1') dpT[u] = Math.Min(dpT[u], dpT[v] + 1);
        }
    }

    var answers = new List&amp;lt;long&amp;gt;(N - 2);
    for (var k = 1; k &amp;lt; N - 1; k++)
    {
        var answer = Inf;
        for (var u = Math.Max(k - M, 0); u &amp;lt; k; u++)
        {
            for (var v = k + 1; v &amp;lt; Math.Min(u + M + 1, N); v++)
            {
                if (S[u][v - u - 1] == '1') answer = Math.Min(answer, dpS[u] + dpT[v] + 1);
            }
        }

        answers.Add(answer == Inf ? -1 : answer);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answers));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC290</title>
			<link>https://blog.aconcavy.dev/posts/20230219abc290</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 290の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230219abc290</guid>
			<pubDate>Sun, 19 Feb 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 290の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc290"&gt;https://atcoder.jp/contests/abc290&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc290/tasks/abc290_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC290/submissions/39009849"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[B[i]]&lt;/code&gt;の合計値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = B.Sum(x =&amp;gt; A[x - 1]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc290/tasks/abc290_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC290/submissions/39013731"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;o&lt;/code&gt;の数が&lt;code&gt;K&lt;/code&gt;の場合かつ&lt;code&gt;S[i]&lt;/code&gt;が&lt;code&gt;o&lt;/code&gt;の場合は&lt;code&gt;T[i]&lt;/code&gt;は&lt;code&gt;o&lt;/code&gt;となり、それ以外の場合は&lt;code&gt;T[i]&lt;/code&gt;は&lt;code&gt;x&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var buffer = new char[N];
    var k = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (k &amp;lt; K &amp;amp;&amp;amp; S[i] == 'o')
        {
            buffer[i] = 'o';
            k++;
        }
        else
        {
            buffer[i] = 'x';
        }
    }
    var answer = new string(buffer);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc290/tasks/abc290_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC290/submissions/39017322"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の重複を取り除き昇順にソートした初めの&lt;code&gt;K&lt;/code&gt;個以内のものを&lt;code&gt;C&lt;/code&gt;としたとき、&lt;code&gt;0&lt;/code&gt;から順に数えて初めて&lt;code&gt;C&lt;/code&gt;に出現しなかった数が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var mex = 0;
    foreach(var x in A.OrderBy(x =&amp;gt; x).Distinct().Take(K))
    {
        if(x == mex) mex++;
        else break;
    }

    Console.WriteLine(mex);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc290/tasks/abc290_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC290/submissions/39040221"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;マスが無限に続き、手順i-iiiを&lt;code&gt;t&lt;/code&gt;回操作したのときの&lt;code&gt;x&lt;/code&gt;を&lt;code&gt;f(t)&lt;/code&gt;としたとき、&lt;code&gt;f(t)==D*(t-1)&lt;/code&gt;になります。
また、マスが&lt;code&gt;N&lt;/code&gt;個で始点を&lt;code&gt;0&lt;/code&gt;としたときに、手順i-iiiを繰り返して再び始点&lt;code&gt;0&lt;/code&gt;に戻ってくる、つまり&lt;code&gt;f(t)%N==0&lt;/code&gt;となるには、&lt;code&gt;Lcm(a,b)&lt;/code&gt;を&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;の最小公倍数としたとき、&lt;code&gt;f(t)==Lcm(N,D)&lt;/code&gt;になる必要があります。&lt;br /&gt;
そして、手順iiにより始点に再び戻ってきたときに始点を&lt;code&gt;+1&lt;/code&gt;することから、&lt;code&gt;K&lt;/code&gt;回操作したときの始点の変更回数は、&lt;code&gt;f(K)/Lcm(N,D)&lt;/code&gt;回であることがわかります。
このことから、&lt;code&gt;K&lt;/code&gt;回目の&lt;code&gt;x&lt;/code&gt;の位置は&lt;code&gt;(f(K) + f(K)/Lcm(N,D)) % N&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var T = Scanner.Scan&amp;lt;int&amp;gt;();
    while (T-- &amp;gt; 0)
    {
        var (N, D, K) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        var x = D * (K - 1);
        var answer = (x + x / Lcm(N, D)) % N;
        Console.WriteLine(answer);
    }
}

public static long Lcm(long a, long b) =&amp;gt; a / Gcd(a, b) * b;
public static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC289</title>
			<link>https://blog.aconcavy.dev/posts/20230211abc289</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 289の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230211abc289</guid>
			<pubDate>Sat, 11 Feb 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 289の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc289"&gt;https://atcoder.jp/contests/abc289&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc289/tasks/abc289_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC289/submissions/38780229"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各文字の排他的論理和(XOR)を取ることで、&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;を反転させることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = string.Join(&amp;quot;&amp;quot;, S.Select(x =&amp;gt; (x - '0') ^ 1));
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc289/tasks/abc289_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC289/submissions/38785497"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;a&lt;/code&gt;の前に&lt;code&gt;a+1&lt;/code&gt;を読む必要があるので、&lt;code&gt;a&lt;/code&gt;から&lt;code&gt;a+1&lt;/code&gt;に対する有効辺を繋いだグラフを作成し、各連結成分の葉から順に読み上げたものが答えとなります。&lt;br /&gt;
これは、各連結成分ごとに深さ優先探索を行うことで求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    foreach (var a in A)
    {
        var b = a + 1;
        G[a].Add(b);
    }

    var answer = new List&amp;lt;int&amp;gt;(N);
    var used = new bool[N];
    void Dfs(int u)
    {
        foreach (var v in G[u])
        {
            Dfs(v);
        }

        answer.Add(u);
        used[u] = true;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (!used[i]) Dfs(i);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Select(x =&amp;gt; x + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc289/tasks/abc289_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC289/submissions/38789756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;集合の数が&lt;code&gt;1&amp;lt;=M&amp;lt;=10&lt;/code&gt;と少ないので、&lt;code&gt;2^M-1&lt;/code&gt;通りの集合の組み合わせを&lt;code&gt;bit全探索&lt;/code&gt;で走査し、&lt;code&gt;1&amp;lt;=x&amp;lt;=N&lt;/code&gt;の全ての&lt;code&gt;x&lt;/code&gt;が組み合わせの集合のうちいずれかに存在しているかを調べます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = new int[M];
    var A = new int[M][];
    for (var i = 0; i &amp;lt; M; i++)
    {
        C[i] = Scanner.Scan&amp;lt;int&amp;gt;();
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var answer = 0;
    for (var s = 1; s &amp;lt; 1 &amp;lt;&amp;lt; M; s++)
    {
        var exists = new int[N + 1];
        for (var i = 0; i &amp;lt; M; i++)
        {
            if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 0) continue;
            foreach (var a in A[i])
            {
                exists[a] = true;
            }
        }
        
        var ok = Enumerable.Range(1, N).All(x =&amp;gt; exists[x]);
        if (ok) answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc289/tasks/abc289_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC289/submissions/38789756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i] := i段目に上ることができるか
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;i段目にもちが設置されている場合、その段からは移動できない。

i段目にもちが設置されていない場合、各A[j](1&amp;lt;=j&amp;lt;=N)において、i+A[j]段に移動できる。
dp[i+A[j]] |= dp[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;段目にもちが設置されているかを時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求められるようにしておくことで、時間計算量は全体で&lt;code&gt;O(XN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var M = Scanner.Scan&amp;lt;int&amp;gt;();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var X = Scanner.Scan&amp;lt;int&amp;gt;();
    var dp = new bool[X + 1];
    dp[0] = true;
    var mochi = new bool[X + 1];
    foreach (var b in B)
    {
        mochi[b] = true;
    }

    for (var i = 0; i &amp;lt; X; i++)
    {
        if (mochi[i]) continue;
        foreach (var a in A.Where(x =&amp;gt; i + x &amp;lt;= X))
        {
            dp[i + a] |= dp[i];
        }
    }

    var answer = dp[X];
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc289/tasks/abc289_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC289/submissions/38810517"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリにおいてグラフを構築し、高橋君が頂点&lt;code&gt;u&lt;/code&gt;、青木君が頂点&lt;code&gt;v&lt;/code&gt;にいるときの最小の移動回数を幅優先探索で求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var T = Scanner.Scan&amp;lt;int&amp;gt;();
    var queue = new Queue&amp;lt;(int, int)&amp;gt;();
    while (T-- &amp;gt; 0)
    {
        var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
        for (var i = 0; i &amp;lt; M; i++)
        {
            var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
            u--; v--;
            G[u].Add(v);
            G[v].Add(u);
        }

        var costs = new int[N, N];
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                costs[i, j] = -1;
            }
        }

        costs[0, N - 1] = 0;
        queue.Enqueue((0, N - 1));
        while (queue.Count &amp;gt; 0)
        {
            var (u1, u2) = queue.Dequeue();
            foreach (var v1 in G[u1])
            {
                foreach (var v2 in G[u2])
                {
                    if (C[v1] == C[v2]) continue;
                    if (costs[v1, v2] != -1) continue;
                    costs[v1, v2] = costs[u1, u2] + 1;
                    queue.Enqueue((v1, v2));
                }
            }
        }

        var answer = costs[N - 1, 0];
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC288</title>
			<link>https://blog.aconcavy.dev/posts/20230204abc288</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 288の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230204abc288</guid>
			<pubDate>Sat, 04 Feb 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 288の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc288"&gt;https://atcoder.jp/contests/abc288&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC288/submissions/38605622"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリに対して&lt;code&gt;A+B&lt;/code&gt;の答えを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        var answer = A + B;
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC288/submissions/38601324"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上位&lt;code&gt;K&lt;/code&gt;人のみ取得し、辞書順にソートしたものを出力します。
C#では、文字列の配列に対して、&lt;code&gt;Array.Sort&lt;/code&gt;メソッドを使うことでソートすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[K];
    for (var i = 0; i &amp;lt; K; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    Array.Sort(S);
    Console.WriteLine(string.Join(Environment.NewLine, S));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC288/submissions/38595128"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;A&lt;/code&gt;と頂点&lt;code&gt;B&lt;/code&gt;が同じ連結成分である場合、&lt;code&gt;A&lt;/code&gt;と&lt;code&gt;B&lt;/code&gt;に辺を追加してしまうと閉路ができてしまいます。
そのため、&lt;code&gt;DisjointSetUnion&lt;/code&gt;などのデータ構造を使い、辺をつなごうとする頂点同士が同じ連結成分であるかを判定し、同じ連結成分であればその辺を削除します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dsu = new DisjointSetUnion(N);
    var answer = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        if (dsu.IsSame(a, b)) answer++;
        dsu.Merge(a, b);
    }

    Console.WriteLine(answer);
}

public class DisjointSetUnion
{
    public int Length { get; }
    private readonly int[] _parentOrSize;
    public DisjointSetUnion(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _parentOrSize = new int[Length];
        Array.Fill(_parentOrSize, -1);
    }
    public int Merge(int u, int v)
    {
        if (u &amp;lt; 0 || Length &amp;lt;= u) throw new ArgumentOutOfRangeException(nameof(u));
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        var (x, y) = (LeaderOf(u), LeaderOf(v));
        if (x == y) return x;
        if (-_parentOrSize[x] &amp;lt; -_parentOrSize[y]) (x, y) = (y, x);
        _parentOrSize[x] += _parentOrSize[y];
        _parentOrSize[y] = x;
        return x;
    }
    public bool IsSame(int u, int v)
    {
        if (u &amp;lt; 0 || Length &amp;lt;= u) throw new ArgumentOutOfRangeException(nameof(u));
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        return LeaderOf(u) == LeaderOf(v);
    }
    public int LeaderOf(int v)
    {
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        if (_parentOrSize[v] &amp;lt; 0) return v;
        return _parentOrSize[v] = LeaderOf(_parentOrSize[v]);
    }
    public int SizeOf(int v)
    {
        if (v &amp;lt; 0 || Length &amp;lt;= v) throw new ArgumentOutOfRangeException(nameof(v));
        return -_parentOrSize[LeaderOf(v)];
    }
    public IEnumerable&amp;lt;IReadOnlyCollection&amp;lt;int&amp;gt;&amp;gt; GetGroups()
    {
        var result = new List&amp;lt;int&amp;gt;[Length].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
        for (var i = 0; i &amp;lt; Length; i++) result[LeaderOf(i)].Add(i);
        return result.Where(x =&amp;gt; x.Count &amp;gt; 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc288/tasks/abc288_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;まだ解けてません;;&lt;/p&gt;
&lt;!-- [コンテスト提出]()  
[復習提出]()

```csharp
``` --&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC287</title>
			<link>https://blog.aconcavy.dev/posts/20230128abc287</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 287の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230128abc287</guid>
			<pubDate>Sat, 28 Jan 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 287の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287"&gt;https://atcoder.jp/contests/abc287&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38375686"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入力から&lt;code&gt;For&lt;/code&gt;の個数を数え上げ、その個数の2倍が&lt;code&gt;N&lt;/code&gt;より大きければ過半数が提案に賛成しています。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var f = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        if (S == &amp;quot;For&amp;quot;) f++;
    }

    var answer = f * 2 &amp;gt; N ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38380732"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;S&lt;/code&gt;の末尾3文字が&lt;code&gt;T&lt;/code&gt;のいずれかと一致しているかを各&lt;code&gt;S&lt;/code&gt;と各&lt;code&gt;T&lt;/code&gt;の組み合わせを全探索することで、時間計算量&lt;code&gt;O(NM)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
また、&lt;code&gt;T&lt;/code&gt;の集合を&lt;code&gt;Set&lt;/code&gt;や&lt;code&gt;HashSet&lt;/code&gt;などのデータ構造で管理することで、時間計算量を&lt;code&gt;O(NlogM)&lt;/code&gt;、&lt;code&gt;O(N)&lt;/code&gt;にすることもできます。&lt;br /&gt;
ほかにも、入力が数値のみであることから、大きさが&lt;code&gt;1000&lt;/code&gt;以上の配列を用意して&lt;code&gt;T&lt;/code&gt;を配列のインデックスとして存在判定し、&lt;code&gt;S%1000&lt;/code&gt;でその配列にアクセスすることで、時間計算量&lt;code&gt;O(N+M)&lt;/code&gt;で解くこともできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        S[i] = s[3..];
    }

    var T = new HashSet&amp;lt;string&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var t = Scanner.Scan&amp;lt;string&amp;gt;();
        T.Add(t);
    }

    var answer = 0;
    foreach (var s in S)
    {
        if (T.Contains(s)) answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38385675"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直線になるようなグラフがパスグラフになります。
これは、グラフを構成する辺が&lt;code&gt;N-1&lt;/code&gt;本であり、端点となる2つの頂点は次数が&lt;code&gt;1&lt;/code&gt;、それ以外は次数が&lt;code&gt;2&lt;/code&gt;であり、連結であるグラフです。
グラフが連結であるかどうかは幅/深さ優先探索や&lt;code&gt;DisjointSetUnion&lt;/code&gt;で調べることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        G[u].Add(v);
        G[v].Add(u);
    }

    if (M != N - 1 || G.Any(x =&amp;gt; x.Count &amp;gt; 2))
    {
        Console.WriteLine(&amp;quot;No&amp;quot;);
        return;
    }

    var used = new bool[N];
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(0);
    used[0] = true;
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        foreach (var v in G[u].Where(x =&amp;gt; !used[x]))
        {
            used[v] = true;
            queue.Enqueue(v);
        }
    }

    var answer = used.All(x =&amp;gt; x);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38402756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の先頭から&lt;code&gt;i&lt;/code&gt;文字が一致しているかを&lt;code&gt;first[i]&lt;/code&gt;としたとき、&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;i==0のとき、
first[0] = true

i&amp;gt;=1のとき、
f1 = S[i] == T[i]
f2 = S[i] == '?'
f3 = T[i] == '?'
first[i] = first[i - 1] &amp;amp;&amp;amp; (f1 || f2 || f3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同様に末尾から&lt;code&gt;i&lt;/code&gt;文字が一致しているかを&lt;code&gt;last[i]&lt;/code&gt;とすると、各&lt;code&gt;x&lt;/code&gt;に対する答えを&lt;code&gt;f(x)&lt;/code&gt;とすると次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;f(x) == first[x] &amp;amp;&amp;amp; last[|T| - x]`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事前に&lt;code&gt;first&lt;/code&gt;と&lt;code&gt;last&lt;/code&gt;を時間計算量&lt;code&gt;O(|T|)&lt;/code&gt;で求めておくことで、&lt;code&gt;f(x)&lt;/code&gt;は時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができ、全体計算量は&lt;code&gt;O(|T|)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = T.Length;
    var first = new bool[N + 1];
    var last = new bool[N + 1];
    first[0] = last[0] = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var sj = S.Length - 1 - i;
        var tj = T.Length - 1 - i;
        var ff = S[i] == '?' || T[i] == '?' || S[i] == T[i];
        var fl = S[sj] == '?' || T[tj] == '?' || S[sj] == T[tj];
        first[i + 1] = first[i] &amp;amp;&amp;amp; ff;
        last[i + 1] = last[i] &amp;amp;&amp;amp; fl;
    }

    for (var x = 0; x &amp;lt;= N; x++)
    {
        var y = N - x;
        var answer = first[x] &amp;amp;&amp;amp; last[y];
        Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc287/tasks/abc287_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc287/submissions/38399917"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての文字列において、長さ&lt;code&gt;0&amp;lt;=k&amp;lt;=|S|&lt;/code&gt;の連続部分文字列&lt;code&gt;T&lt;/code&gt;となる個数をあらかじめ求めておき、各&lt;code&gt;i&lt;/code&gt;における長さ&lt;code&gt;k&lt;/code&gt;の&lt;code&gt;T&lt;/code&gt;の個数が2個以上存在する場合、&lt;code&gt;LCP(i,?)==k&lt;/code&gt;が成立するため、その&lt;code&gt;k&lt;/code&gt;の最大が&lt;code&gt;i&lt;/code&gt;に対する答えとなります。
連続部分文字列の管理に&lt;code&gt;RollingHash&lt;/code&gt;などを使うことで、連続部分列の計算を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができ、全体時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new string[N];
    var dict = new Dictionary&amp;lt;ulong, Dictionary&amp;lt;int, int&amp;gt;&amp;gt;();
    var rhs = new RollingHash[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        S[i] = s;
        var rh = new RollingHash(s);
        rhs[i] = rh;
        for (var j = 0; j &amp;lt;= s.Length; j++)
        {
            var h = rh.SlicedHash(0, j);
            if (!dict.ContainsKey(h)) dict[h] = new Dictionary&amp;lt;int, int&amp;gt;();
            if (!dict[h].ContainsKey(j)) dict[h][j] = 0;
            dict[h][j]++;
        }
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var answer = 0;
        for (var j = 0; j &amp;lt;= S[i].Length; j++)
        {
            var h = rhs[i].SlicedHash(0, j);
            if (dict[h].ContainsKey(j) &amp;amp;&amp;amp; dict[h][j] &amp;gt;= 2) answer = j;
        }

        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RollingHash&lt;/code&gt;について、keymoonさんの&lt;a href="https://qiita.com/keymoon/items/11fac5627672a6d6a9f6"&gt;安全で爆速なRollingHashの話&lt;/a&gt;を参考にしました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class RollingHash
{
    private const ulong Mask30 = (1UL &amp;lt;&amp;lt; 30) - 1;
    private const ulong Mask31 = (1UL &amp;lt;&amp;lt; 31) - 1;
    private const ulong Modulo = (1UL &amp;lt;&amp;lt; 61) - 1;
    private const ulong Positivizer = Modulo * ((1UL &amp;lt;&amp;lt; 3) - 1);
    public static readonly ulong Base;
    static RollingHash()
    {
        Base = (ulong)new Random().Next(1 &amp;lt;&amp;lt; 8, int.MaxValue);
    }
    private readonly ulong[] _powers;
    private readonly ulong[] _hash;
    public RollingHash(ReadOnlySpan&amp;lt;char&amp;gt; s)
    {
        _powers = new ulong[s.Length + 1];
        _powers[0] = 1;
        _hash = new ulong[s.Length + 1];
        for (var i = 0; i &amp;lt; s.Length; i++)
        {
            _powers[i + 1] = CalcModulo(Multiply(_powers[i], Base));
            _hash[i + 1] = CalcModulo(Multiply(_hash[i], Base) + s[i]);
        }
    }
    public ulong SlicedHash(int start, int length)
    {
        return CalcModulo(_hash[start + length] + Positivizer - Multiply(_hash[start], _powers[length]));
    }
    private static ulong Multiply(ulong a, ulong b)
    {
        var au = a &amp;gt;&amp;gt; 31;
        var ad = a &amp;amp; Mask31;
        var bu = b &amp;gt;&amp;gt; 31;
        var bd = b &amp;amp; Mask31;
        var m = ad * bu + au * bd;
        var mu = m &amp;gt;&amp;gt; 30;
        var md = m &amp;amp; Mask30;
        return ((au * bu) &amp;lt;&amp;lt; 1) + mu + (md &amp;lt;&amp;lt; 31) + ad * bd;
    }
    private static ulong CalcModulo(ulong v)
    {
        var vu = v &amp;gt;&amp;gt; 61;
        var vd = v &amp;amp; Modulo;
        var x = vu + vd;
        return x &amp;lt; Modulo ? x : x - Modulo;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC286</title>
			<link>https://blog.aconcavy.dev/posts/20230121abc286</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 286の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230121abc286</guid>
			<pubDate>Sat, 21 Jan 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 286の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc286"&gt;https://atcoder.jp/contests/abc286&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38191422"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;入れ替える数列の個数は&lt;code&gt;M=Q-P(==S-R)&lt;/code&gt;個であり、&lt;code&gt;0&amp;lt;=i&amp;lt;M&lt;/code&gt;の&lt;code&gt;A[P+i]&lt;/code&gt;と&lt;code&gt;A[R+i]&lt;/code&gt;を入れ替えたものが&lt;code&gt;B&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P, Q, R, S) = Scanner.Scan&amp;lt;int, int, int, int, int&amp;gt;();
    P--; R--;
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var M = Q - P;
    for (var i = 0; i &amp;lt; M; i++)
    {
        (A[P + i], A[R + i]) = (A[R + i], A[P + i]);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38192528"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;のうち、&lt;code&gt;na&lt;/code&gt;を&lt;code&gt;nya&lt;/code&gt;に置き換えたものが答えとなるので、&lt;code&gt;string&lt;/code&gt;の&lt;code&gt;Replace&lt;/code&gt;メソッドや、文字を順にみていき&lt;code&gt;n&lt;/code&gt;の次に&lt;code&gt;a&lt;/code&gt;がある場合、&lt;code&gt;y&lt;/code&gt;を追加するといったアルゴリズムで解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = S.Replace(&amp;quot;na&amp;quot;, &amp;quot;nya&amp;quot;);
    Console.WriteLine(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var builder = new StringBuilder();
    for (var i = 0; i &amp;lt; N; i++)
    {
        builder.Append(S[i]);
        if(i + 1 &amp;lt; N &amp;amp;&amp;amp; S[i] == 'n' &amp;amp;&amp;amp; S[i + 1] == 'a')
        {
            builder.Append('y');
        }
    }
    var T = builder.ToString();
    Console.WriteLine(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38202828"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に文字列をシフトして、シフトした文字列が回文かどうかを判定することで、時間計算量&lt;code&gt;O(N^2)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, A, B) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    const long inf = (long)1e18;
    var answer = inf;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A * i &amp;gt;= answer) continue;
        var sum = A * i;
        var T = Shift&amp;lt;char&amp;gt;(S, -i);

        for (var j = 0; j * 2 &amp;lt; N; j++)
        {
            if (T[j] == T[N - 1 - j]) continue;
            sum += B;
        }

        answer = Math.Min(answer, sum);
    }

    Console.WriteLine(answer);
}

public static T[] Shift&amp;lt;T&amp;gt;(ReadOnlySpan&amp;lt;T&amp;gt; source, int shift)
{
    shift = (shift + source.Length) % source.Length;
    if (shift == 0) return source.ToArray();
    var result = new T[source.Length];
    source[^shift..].CopyTo(result.AsSpan(..shift));
    source[..^shift].CopyTo(result.AsSpan(shift..));
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38205698"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][j] := i番目まで見たときちょうどj円にする組み合わせを作ることができるか
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、状態は次のような遷移が可能です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i+1][j+a*k] |= dp[i][j] (0&amp;lt;=j&amp;lt;=X, 0&amp;lt;=k&amp;lt;=b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;時間計算量は&lt;code&gt;O(NX^2)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new bool[N + 1, X + 1];
    dp[0, 0] = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        for (var j = 0; j &amp;lt;= X; j++)
        {
            if (!dp[i, j]) continue;
            for (var k = 0; k &amp;lt;= b &amp;amp;&amp;amp; j + a * k &amp;lt;= X; k++)
            {
                dp[i + 1, j + a * k] |= dp[i, j];
            }
        }
    }

    var answer = dp[N, X];
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc286/tasks/abc286_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC286/submissions/38218817"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;都市&lt;code&gt;u&lt;/code&gt;から都市&lt;code&gt;v&lt;/code&gt;に移動すると、お土産の価値の合計は&lt;code&gt;A[u]+A[v]&lt;/code&gt;になります。
また、都市&lt;code&gt;u&lt;/code&gt;から都市&lt;code&gt;k&lt;/code&gt;を経由して都市&lt;code&gt;v&lt;/code&gt;に移動すると、お土産の価値の合計は、&lt;code&gt;A[u]+A[k]+A[v]&lt;/code&gt;ですが、これは都市&lt;code&gt;u&lt;/code&gt;から都市&lt;code&gt;k&lt;/code&gt;に移動したときのお土産の価値(&lt;code&gt;A[u]+A[k]&lt;/code&gt;)と都市&lt;code&gt;k&lt;/code&gt;から都市&lt;code&gt;v&lt;/code&gt;に移動したときのお土産の価値(&lt;code&gt;A[k]+A[v]&lt;/code&gt;)から、&lt;code&gt;A[k]&lt;/code&gt;を引いたもの、つまり&lt;code&gt;(A[u]+A[k])+(A[k]+A[v])-A[k]&lt;/code&gt;として求めることができます。&lt;/p&gt;
&lt;p&gt;この法則を利用し、ワーシャルフロイド法で使う直行便の数が最小となる時のお土産の価値の総和を時間計算量&lt;code&gt;O(N^3)&lt;/code&gt;であらかじめ求めておくことで、クエリ当たり時間計算量&lt;code&gt;O(1)&lt;/code&gt;で答えることができるようになります。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;から&lt;code&gt;j&lt;/code&gt;に移動するときに使う直行便の数、&lt;code&gt;V[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;から&lt;code&gt;j&lt;/code&gt;に移動するときのお土産の価値としたとき、&lt;code&gt;k&lt;/code&gt;を経由した&lt;code&gt;C[i][j]&lt;/code&gt;と&lt;code&gt;V[i][j]&lt;/code&gt;の更新は、&lt;code&gt;c=C[i][k]+C[k][j]&lt;/code&gt;、&lt;code&gt;v=V[i][k]+V[k][j]-A[k]&lt;/code&gt;としたとき、次のようになります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c == C[i][j]&lt;/code&gt;のとき、&lt;code&gt;V[i][j]=Max(V[i][j], v)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c &amp;lt; C[i][j]&lt;/code&gt;のとき、&lt;code&gt;C[i][j]=c&lt;/code&gt;、&lt;code&gt;V[i][j]=v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        G[i] = S.Select(x =&amp;gt; x == 'Y').ToArray();
    }

    const long inf = (long)1e18;
    var values = new long[N, N];
    var counts = new long[N, N];

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            values[i, j] = G[i][j] ? A[i] + A[j] : -inf;
            counts[i, j] = G[i][j] ? 1 : inf;
        }

        values[i, i] = 0;
        counts[i, i] = 0;
    }

    for (var k = 0; k &amp;lt; N; k++)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                var count = counts[i, k] + counts[k, j];
                var value = values[i, k] + values[k, j] - A[k];
                if (count == counts[i, j])
                {
                    values[i, j] = Math.Max(values[i, j], value);
                }
                else if (count &amp;lt; counts[i, j])
                {
                    counts[i, j] = count;
                    values[i, j] = value;
                }
            }
        }
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        var count = counts[u, v];
        var value = values[u, v];
        if (count == inf)
        {
            Console.WriteLine(&amp;quot;Impossible&amp;quot;);
        }
        else
        {
            Console.WriteLine($&amp;quot;{count} {value}&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>