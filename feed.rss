<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>acon.log</title>
		<link>https://blog.aconcavy.dev/</link>
		<description />
		<copyright>Copyright © 2020-2023 AconCavy</copyright>
		<pubDate>Sat, 02 Sep 2023 15:33:41 GMT</pubDate>
		<lastBuildDate>Sat, 02 Sep 2023 15:33:41 GMT</lastBuildDate>
		<item>
			<title>ABC318</title>
			<link>https://blog.aconcavy.dev/posts/20230902abc318</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 318の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230902abc318</guid>
			<pubDate>Sat, 02 Sep 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 318の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc318"&gt;https://atcoder.jp/contests/abc318&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45132398"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;日間のうち&lt;code&gt;M&lt;/code&gt;日目以降の期間は&lt;code&gt;N-M&lt;/code&gt;日間であり、この期間に&lt;code&gt;Floor(N-M)/P&lt;/code&gt;回満月を見ることができます。&lt;br /&gt;
これに&lt;code&gt;M&lt;/code&gt;日目を加えた、&lt;code&gt;Floor(N-M)/P+1&lt;/code&gt;が答えとなります。&lt;br /&gt;
&lt;code&gt;N-M&lt;/code&gt;が負数になることがあるので注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, P) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var answer = (N - M + P) / P;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45136636"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;シートは最大でも&lt;code&gt;0&amp;lt;=x&amp;lt;=100&lt;/code&gt;かつ&lt;code&gt;0&amp;lt;=y&amp;lt;=100&lt;/code&gt;なので、&lt;code&gt;100*100&lt;/code&gt;のグリッドを用意し、その領域がシートで覆われているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var H = 100;
    var W = 100;
    var G = new bool[H + 1, W + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b, c, d) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
        for (var x = a; x &amp;lt; b; x++)
        {
            for (var y = c; y &amp;lt; d; y++)
            {
                G[x, y] = true;
            }
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt;= H; i++)
    {
        for (var j = 0; j &amp;lt;= W; j++)
        {
            if (G[i, j]) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45140727"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周遊パスは好きな日に使うことができるので、&lt;code&gt;F&lt;/code&gt;をソートしても問題ありません。&lt;br /&gt;
次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i] := i日間の旅行でかかる最小金額
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;// i日目の運賃を通常料金で払うとき
dp[i+1] = Min(dp[i+1], dp[i]+F[i])

// i日目の運賃を周遊パスで払うとき
dp[i+D] = Min(dp[i+D], dp[i]+P)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i+D&lt;/code&gt;が&lt;code&gt;N&lt;/code&gt;より大きい場合は&lt;code&gt;N&lt;/code&gt;にまとめることができ、&lt;code&gt;dp[N]&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D, P) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var F = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(F);
    var cum = new long[N + 1];
    const long Inf = (long)1e18;
    Array.Fill(cum, Inf);
    cum[0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = Math.Min(cum[i + 1], cum[i] + F[i]);
        var x = Math.Min(i + D, N);
        cum[x] = Math.Min(cum[x], cum[i] + P);
    }

    var answer = cum[N];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45149396"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[s] := 既に選んだ頂点集合がsのときの選んだ重みの総和の最大値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;i番目の頂点とj番目の頂点がsに含まれていないとき、sにiとjを含んだ頂点集合をtとする。
dp[t] = Max(dp[t], dp[s]+D[i][j])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全ての頂点集合のうち、総和の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = new long[N, N];
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        var d = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        for (var j = 0; j &amp;lt; d.Length; j++)
        {
            D[i, i + j + 1] = d[j];
        }
    }

    var dp = new long[1 &amp;lt;&amp;lt; N];
    dp[0] = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = i + 1; j &amp;lt; N; j++)
            {
                if ((s &amp;gt;&amp;gt; i &amp;amp; 1) == 1 || (s &amp;gt;&amp;gt; j &amp;amp; 1) == 1) continue;
                var t = s | (1 &amp;lt;&amp;lt; i) | (1 &amp;lt;&amp;lt; j);
                dp[t] = Math.Max(dp[t], dp[s] + D[i, j]);
            }
        }
    }

    long answer = 0;
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; N; s++)
    {
        answer = Math.Max(answer, dp[s]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc318/tasks/abc318_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC318/submissions/45196083"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;L[x]&lt;/code&gt;を現在左側にある&lt;code&gt;x&lt;/code&gt;の個数、&lt;code&gt;R[x]&lt;/code&gt;を現在右側にある&lt;code&gt;x&lt;/code&gt;の個数とします。&lt;br /&gt;
&lt;code&gt;j&lt;/code&gt;を固定したとき、&lt;code&gt;j&lt;/code&gt;に対して条件を満たす&lt;code&gt;i,k&lt;/code&gt;の組み合わせの個数は、&lt;code&gt;1&amp;lt;=y&amp;lt;=N&lt;/code&gt;かつ&lt;code&gt;y!=A[j]&lt;/code&gt;の&lt;code&gt;L[y]*R[y]&lt;/code&gt;の総和になります。&lt;br /&gt;
これにより、各&lt;code&gt;j&lt;/code&gt;に対して時間計算量&lt;code&gt;O(N)&lt;/code&gt;で組み合わせの個数を求めることができますが、全体時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、&lt;code&gt;j&lt;/code&gt;を1つずらしたとき、&lt;code&gt;L[A[j]]&lt;/code&gt;が1つ増え、&lt;code&gt;R[A[j]]&lt;/code&gt;が1つ減ることから、組み合わせの個数を累積和として管理し、各&lt;code&gt;j&lt;/code&gt;における差分のみを計算することで、各&lt;code&gt;j&lt;/code&gt;に対して時間計算量&lt;code&gt;O(1)&lt;/code&gt;で組み合わせの個数を求めることができるようになり、全体時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var L = new long[N + 1];
    var R = new long[N + 1];

    foreach (var a in A) R[a]++;

    long answer = 0;
    long cum = 0;
    foreach (var a in A)
    {
        cum -= L[a] * R[a];
        answer += cum;
        R[a]--;
        L[a]++;
        cum += L[a] * R[a];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC317</title>
			<link>https://blog.aconcavy.dev/posts/20230826abc317</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 317の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230826abc317</guid>
			<pubDate>Sat, 26 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 317の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc317"&gt;https://atcoder.jp/contests/abc317&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44936354"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;H+P[i]&amp;gt;=X&lt;/code&gt;となる最初の&lt;code&gt;i&lt;/code&gt;を出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, H, X) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (H + P[i] &amp;gt;= X)
        {
            Console.WriteLine(i + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44940376"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;をソートし、&lt;code&gt;A[i-1]+1==A[i]&lt;/code&gt;ならば、それらの整数は連続しています。&lt;br /&gt;
そのため、&lt;code&gt;A[i-1]+1!=A[i]&lt;/code&gt;ならばそれらの整数が連続しておらず、&lt;code&gt;A[i-1]+1&lt;/code&gt;がなくした整数になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    Array.Sort(A);
    for (var i = 1; i &amp;lt; N; i++)
    {
        if (A[i - 1] + 1 != A[i])
        {
            Console.WriteLine(A[i - 1] + 1);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44945752"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既に訪れた町と、現在通った道路の長さの和を管理しながら深さ優先探索を行います。
時間計算量&lt;code&gt;O(N!)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;(int, long)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int, long)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b, c) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        a--; b--;
        G[a].Add((b, c));
        G[b].Add((a, c));
    }

    long answer = 0;
    var used = new bool[N];

    void Dfs(int u, long s)
    {
        answer = Math.Max(answer, s);
        used[v] = true;
        foreach (var (v, c) in G[u])
        {
            if (used[v]) continue;
            Dfs(v, s + c);
        }
        used[v] = false;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        Dfs(i, 0);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44957520"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44982250"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][s] := i番目の選挙区までみたとき、s議席獲得するために必要な鞍替えさせる必要がある人数の最小値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移としては次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;v = (Max(0, Y[i]-X[i]) + 1) / 2; // i番目の選挙区において高橋派が過半数を得るために必要な、鞍替えさせる必要がある人数
dp[i+1][s] = Min(dp[i+1][s], dp[i][s-Z[i]] + v);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そして、&lt;code&gt;N&lt;/code&gt;個の選挙区全体として過半数の議席を獲得するには、全ての議席の数を&lt;code&gt;zs&lt;/code&gt;としたとき、必要な議席&lt;code&gt;req&lt;/code&gt;は&lt;code&gt;(zs+1)/2&lt;/code&gt;以上であるため、&lt;code&gt;dp[req]&lt;/code&gt;から&lt;code&gt;dp[zs]&lt;/code&gt;までの最小値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var V = new (long X, long Y, long Z)[N];
    long zs = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, z) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        V[i] = (x, y, z);
        zs += z;
    }

    const long Inf = (long)1e18;
    var dp = new long[zs + 1];
    Array.Fill(dp, Inf);
    dp[0] = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, z) = V[i];
        var v = (Math.Max(0, y - x) + 1) / 2;
        for (var s = zs; s &amp;gt;= z; s--)
        {
            dp[s] = Math.Min(dp[s], dp[s - z] + v);
        }
    }

    var req = (zs + 1) / 2;
    var answer = Inf;
    for (var s = req; s &amp;lt;= zs; s++)
    {
        answer = Math.Min(answer, dp[s]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc317/tasks/abc317_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC317/submissions/44964613"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各人の視線をあらかじめ計算しておき、幅優先探索を行うことで答えを求めることができます。&lt;br /&gt;
グリッド内のマスのうち、侵入可能な&lt;code&gt;.&lt;/code&gt;、&lt;code&gt;S&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;のマスを侵入可能マス、人や障害物の侵入不可能マスをとしたとき、各人の視線は、各人のマスから各方向に対して侵入不可能マスまでの侵入可能マスを侵入不可能にします。&lt;br /&gt;
このことから&lt;code&gt;X[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目のマスを侵入可能かとしたとき、侵入不可能マスに加えて、侵入可能マスを侵入不可能にしたものに対して、&lt;code&gt;S&lt;/code&gt;のマスから&lt;code&gt;G&lt;/code&gt;のマスまでの最短距離を、グリッド上における4方向の幅優先探索で求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    var (sh, sw) = (-1, -1);
    var (gh, gw) = (-1, -1);
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == 'S') (sh, sw) = (i, j);
            if (G[i][j] == 'G') (gh, gw) = (i, j);
        }
    }

    bool IsPossible(int h, int w)
    {
        return 0 &amp;lt;= h &amp;amp;&amp;amp; h &amp;lt; H &amp;amp;&amp;amp; 0 &amp;lt;= w &amp;amp;&amp;amp; w &amp;lt; W &amp;amp;&amp;amp; (G[h][w] == '.' || G[h][w] == 'S' || G[h][w] == 'G');
    }

    var X = new bool[H, W];
    X[sh, sw] = X[gh, gw] = true;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (IsPossible(i, j)) X[i, j] = true;
        }
    }

    void F(char c)
    {
        var (dh, dw) = (0, 0);
        if (c == '&amp;gt;') dw = 1;
        if (c == 'v') dh = 1;
        if (c == '&amp;lt;') dw = -1;
        if (c == '^') dh = -1;

        for (var i = 0; i &amp;lt; H; i++)
        {
            for (var j = 0; j &amp;lt; W; j++)
            {
                if (G[i][j] == c)
                {
                    var k = 1;
                    while (IsPossible(i + dh * k, j + dw * k))
                    {
                        var ni = i + dh * k;
                        var nj = j + dw * k;
                        X[ni, nj] = false;
                        k++;
                    }
                }
            }
        }
    }

    F('&amp;gt;');
    F('v');
    F('&amp;lt;');
    F('^');

    var dp = new int[H, W];
    const int Inf = (int)1e9;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            dp[i, j] = Inf;
        }
    }

    dp[sh, sw] = 0;

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    var queue = new Queue&amp;lt;(int, int, int)&amp;gt;();
    queue.Enqueue((sh, sw, 0));
    while (queue.TryDequeue(out var top))
    {
        var (ch, cw, cc) = top;
        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            if (!X[nh, nw] || dp[nh, nw] &amp;lt;= cc + 1) continue;
            dp[nh, nw] = cc + 1;
            queue.Enqueue((nh, nw, cc + 1));
        }
    }

    var answer = dp[gh, gw];
    if (answer == Inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC315</title>
			<link>https://blog.aconcavy.dev/posts/20230819abc315</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 315の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230819abc315</guid>
			<pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 315の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315"&gt;https://atcoder.jp/contests/abc315&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44708524"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aeiou&lt;/code&gt;以外の文字を連結したものが答えになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var builder = new StringBuilder();
    const string AEIOU = &amp;quot;aeiou&amp;quot;;
    foreach (var c in S)
    {
        if (!AEIOU.Contains(c)) builder.Append(c);
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44712931"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;真ん中の日&lt;code&gt;mid&lt;/code&gt;は、&lt;code&gt;(Dの総和+1)/2&lt;/code&gt;で求めることができます。&lt;br /&gt;
合計日数を数え上げながら順に月を見ていき、&lt;code&gt;その月以前の合計日数+その月の日数&lt;/code&gt;が&lt;code&gt;mid&lt;/code&gt;以上になったとき、その月が答えの月となり、&lt;code&gt;mid-その月以前の合計日数&lt;/code&gt;でその月の日にちを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var M = Scanner.Scan&amp;lt;int&amp;gt;();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var sum = D.Sum();
    var mid = (sum + 1) / 2;
    var cum = 0;
    for (var i = 0; i &amp;lt; M; i++)
    {
        if (cum + D[i] &amp;lt; mid)
        {
            cum += D[i];
        }
        else
        {
            Console.WriteLine($&amp;quot;{i + 1} {(mid - cum)}&amp;quot;);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44732908"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2つのカップの組み合わせを愚直に探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、2つのカップの味が異なるときの最大値と、2つのカップの味が一緒の時の最大値を求め、最終的な最大値を求めます。&lt;br /&gt;
2つのカップの味が異なるとき、全てのカップのうち美味しさ&lt;code&gt;S&lt;/code&gt;が最大のものと、それとは異なる味のうち美味しさ&lt;code&gt;S&lt;/code&gt;が最大となるものが最大の満足度となります。&lt;br /&gt;
2つのカップの味が一緒のとき、各味において美味しさ&lt;code&gt;S&lt;/code&gt;が大きい方から2つ選んだものが、各味における満足度の最大となります。&lt;br /&gt;
これにより、2つのカップの味が異なるときの最大値と、各味2つ選んだ時の最大値のうち、最大となるものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new Dictionary&amp;lt;long, Dictionary&amp;lt;int, int&amp;gt;&amp;gt;();
    var ices = new (int F, long S)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (f, s) = Scanner.Scan&amp;lt;int, long&amp;gt;();
        ices[i] = (f, s);
    }

    Array.Sort(ices, (x, y) =&amp;gt; y.S.CompareTo(x.S));

    long answer = 0;
    for (var i = 1; i &amp;lt; N; i++)
    {
        if (ices[i].F != ices[0].F)
        {
            answer = ices[0].S + ices[i].S;
            break;
        }
    }

    var count = new int[N + 1];
    var same = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (f, s) = ices[i];
        if (count[f] == 0)
        {
            count[f]++;
            same[f] += s;
        }
        else if (count[f] == 1)
        {
            count[f]++;
            same[f] += s / 2;
        }
    }

    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer = Math.Max(answer, same[i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;また解けていません。&lt;/p&gt;
&lt;!-- [コンテスト提出]()  
[復習提出]()

```csharp
``` --&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc315/tasks/abc315_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc315/submissions/44744826"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本&lt;code&gt;i&lt;/code&gt;の前提となる各本&lt;code&gt;P&lt;/code&gt;を、&lt;code&gt;i&lt;/code&gt;から各&lt;code&gt;P&lt;/code&gt;に対する有向辺としたグラフとしたとき、このグラフに対して&lt;code&gt;1&lt;/code&gt;を始点とした深さ優先探索の帰りがけ順に頂点を並べたものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var queue = new Queue&amp;lt;int&amp;gt;();
    var used = new bool[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

        foreach (var v in P.Skip(1).Select(x =&amp;gt; x - 1))
        {
            G[i].Add(v);
        }
    }

    var answer = new List&amp;lt;int&amp;gt;();

    void Dfs(int u)
    {
        foreach (var v in G[u])
        {
            if (used[v]) continue;
            Dfs(v);
        }

        used[u] = true;
        answer.Add(u);
    }

    Dfs(0);

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Select(x =&amp;gt; x + 1).Where(x =&amp;gt; x != 1)));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC314</title>
			<link>https://blog.aconcavy.dev/posts/20230812abc314</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 314の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230812abc314</guid>
			<pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 314の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314"&gt;https://atcoder.jp/contests/abc314&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44488749"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;円周率を文字列&lt;code&gt;S&lt;/code&gt;としたとき、&lt;code&gt;3.&lt;/code&gt;と小数&lt;code&gt;N&lt;/code&gt;文字が答えとなるので、&lt;code&gt;S&lt;/code&gt;の先頭&lt;code&gt;N+2&lt;/code&gt;文字が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const string PI = &amp;quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&amp;quot;;
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = PI[..(N + 2)];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44495322"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[a,c]&lt;/code&gt;を&lt;code&gt;a&lt;/code&gt;に掛けた人のうち、掛けた個数が&lt;code&gt;c&lt;/code&gt;の人の番号の集合としたとき、空集合ではない&lt;code&gt;S[X,c]&lt;/code&gt;が答えとなり、そのような&lt;code&gt;c&lt;/code&gt;が存在しなければ、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int M = 37;
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = new List&amp;lt;int&amp;gt;[M + 1, M + 1];
    for (var i = 0; i &amp;lt;= M; i++)
    {
        for (var j = 0; j &amp;lt;= M; j++)
        {
            S[i, j] = new List&amp;lt;int&amp;gt;();
        }
    }

    for (var i = 1; i &amp;lt;= N; i++)
    {
        var c = Scanner.Scan&amp;lt;int&amp;gt;();
        var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        foreach (var a in A)
        {
            S[a, c].Add(i);
        }
    }

    var X = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt;= M; i++)
    {
        if (S[X, i].Count == 0) continue;
        Console.WriteLine(S[X, i].Count);
        Console.WriteLine(string.Join(&amp;quot; &amp;quot;, S[X, i]));
        return;
    }

    Console.WriteLine(0);
    Console.WriteLine();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44498953"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各色ごとに出現位置を管理し、各文字を右シフトします。&lt;br /&gt;
現在の文字と同じ色の左の文字(一番左の場合は最後の文字)を&lt;code&gt;prev&lt;/code&gt;としたとき、現在の文字と&lt;code&gt;prev&lt;/code&gt;をスワップしていくことで、右シフトを実現できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var ID = new List&amp;lt;int&amp;gt;[M + 1].Select(_ =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; N; i++)
    {
        ID[C[i]].Add(i);
    }

    var T = S.ToCharArray();
    for (var i = 1; i &amp;lt;= M; i++)
    {
        if (ID[i].Count &amp;lt;= 1) continue;
        var idx = ID[i];
        var prev = T[idx[^1]];
        for (var j = 0; j &amp;lt; idx.Count; j++)
        {
            (T[idx[j]], prev) = (prev, T[idx[j]]);
        }
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc314/tasks/abc314_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc314/submissions/44504779"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各クエリを愚直に操作してしまうと、クエリが&lt;code&gt;t==2&lt;/code&gt;または&lt;code&gt;t==3&lt;/code&gt;のときごとに&lt;code&gt;S&lt;/code&gt;を全て見る必要があるため、全体時間計算量が&lt;code&gt;O(QN)&lt;/code&gt;になってしまい、実行時間制限に間に合いません。&lt;br /&gt;
&lt;code&gt;t==2&lt;/code&gt;のときと&lt;code&gt;t==3&lt;/code&gt;のときの操作を考えたとき、クエリが&lt;code&gt;t==2&lt;/code&gt;のとき、&lt;code&gt;S&lt;/code&gt;は全て小文字になり、&lt;code&gt;t==3&lt;/code&gt;のとき、&lt;code&gt;S&lt;/code&gt;は全て大文字になります。&lt;br /&gt;
このことから、&lt;code&gt;t==2&lt;/code&gt;または&lt;code&gt;t==3&lt;/code&gt;を大小の変更操作としたとき、クエリ全体の最後に出現する大小の変更操作より前の大小の変更操作は上書きされることがわかります。&lt;br /&gt;
あらかじめ、大小の変更操作の最終位置をクエリ先読みしておき、&lt;code&gt;t==1&lt;/code&gt;となるクエリを順に操作しつつ、大小の変更操作の最終位置でのみ&lt;code&gt;S&lt;/code&gt;の大小の変更操作を行うことで、&lt;code&gt;S&lt;/code&gt;を全てを操作することは1回で済むため、全体時間計算量&lt;code&gt;O(Q+N)&lt;/code&gt;で答えを求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var state = 0;
    var changed = -1;
    var T = S.ToCharArray();
    var queries = new (int T, int X, char C)[Q];
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (t, x, c) = Scanner.Scan&amp;lt;int, int, char&amp;gt;();
        x--;
        queries[i] = (t, x, c);
        if (t != 1)
        {
            state = t;
            changed = i;
        }
    }

    for (var i = 0; i &amp;lt; Q; i++)
    {
        var (t, x, c) = queries[i];
        if (i == changed &amp;amp;&amp;amp; state != 1)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                T[j] = state == 2 ? char.ToLower(T[j]) : char.ToUpper(T[j]);
            }
        }

        if (t == 1)
        {
            T[x] = c;
        }
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC313</title>
			<link>https://blog.aconcavy.dev/posts/20230805abc313</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 313の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230805abc313</guid>
			<pubDate>Sat, 05 Aug 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 313の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313"&gt;https://atcoder.jp/contests/abc313&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44256971"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;が&lt;code&gt;1&lt;/code&gt;のときは、人&lt;code&gt;1&lt;/code&gt;が最強なので、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;br /&gt;
それ以外のときは、人&lt;code&gt;1&lt;/code&gt;以外の最大のプログラミング力に&lt;code&gt;+1&lt;/code&gt;したものから人&lt;code&gt;1&lt;/code&gt;のプログラミング力を引いたものが答えとなります。&lt;br /&gt;
ただし、人&lt;code&gt;1&lt;/code&gt;以外の最大のプログラミング力が人&lt;code&gt;1&lt;/code&gt;のプログラミング力よりも小さい場合、答えは&lt;code&gt;0&lt;/code&gt;になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var max = N &amp;gt; 1 ? P.Skip(1).Max() : 0;
    var answer = Math.Max(max + 1 - P[0], 0);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44268074"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;それぞれの人&lt;code&gt;x&lt;/code&gt;について、人&lt;code&gt;x&lt;/code&gt;よりも強い人の数を&lt;code&gt;deg[x]&lt;/code&gt;としたとき、&lt;code&gt;deg[x]&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;となる人&lt;code&gt;x&lt;/code&gt;が最強のプログラマー候補となります。&lt;br /&gt;
最強のプログラマー候補が複数人いる場合、最強となる人を特定することはできないので、答えは&lt;code&gt;-1&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var deg = new int[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        deg[b]++;
    }

    var answer = -1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (deg[i] != 0) continue;
        if (answer == -1)
        {
            answer = i + 1;
        }
        else
        {
            Console.WriteLine(-1);
            return;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc313/tasks/abc313_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc313/submissions/44294553"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作を行ったところで、&lt;code&gt;A&lt;/code&gt;の合計値&lt;code&gt;Sum&lt;/code&gt;は変わらないことから、&lt;code&gt;A&lt;/code&gt;の平均値を&lt;code&gt;Ave&lt;/code&gt;としたとき、各要素は&lt;code&gt;Floor(Ave)&lt;/code&gt;もしくは&lt;code&gt;Ceil(Ave)&lt;/code&gt;にすることで、&lt;code&gt;A&lt;/code&gt;の最小値と最大値の差を&lt;code&gt;1&lt;/code&gt;以下にすることができます。&lt;br /&gt;
そして、&lt;code&gt;Ceil(Ave)&lt;/code&gt;になりうる値は、&lt;code&gt;Sum&lt;/code&gt;を&lt;code&gt;N&lt;/code&gt;で割った余り&lt;code&gt;M&lt;/code&gt;個であればいいことがわかります。&lt;br /&gt;
このことから、&lt;code&gt;A&lt;/code&gt;の大きい方から&lt;code&gt;M&lt;/code&gt;個を&lt;code&gt;Ceil(Ave)&lt;/code&gt;、残りの&lt;code&gt;N-M&lt;/code&gt;個を&lt;code&gt;Floor(Ceil)&lt;/code&gt;にしたときの回数を合わせ、&lt;code&gt;2&lt;/code&gt;で割ったものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    Array.Sort(A);
    var sum = A.Sum();
    var ave = sum / N;
    var mod = sum % N;
    long answer = 0;
    for (var i = 0; i &amp;lt; N - mod; i++)
    {
        answer += Math.Abs(ave - A[i]);
    }

    for (var i = 0; i &amp;lt; mod; i++)
    {
        answer += Math.Abs(A[N - 1 - i] - (ave + 1));
    }

    answer = answer / 2;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC312</title>
			<link>https://blog.aconcavy.dev/posts/20230729abc312</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 312の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230729abc312</guid>
			<pubDate>Sat, 29 Jul 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 312の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc312"&gt;https://atcoder.jp/contests/abc312&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44032650"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;が候補となる文字列に存在するかを判定します。&lt;br /&gt;
一つ一つ判定しても答えを求めることができますが、あらかじめ候補となる文字列を配列などで管理しておき、存在判定することでも答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var OK = new string[] { &amp;quot;ACE&amp;quot;, &amp;quot;BDF&amp;quot;, &amp;quot;CEG&amp;quot;, &amp;quot;DFA&amp;quot;, &amp;quot;EGB&amp;quot;, &amp;quot;FAC&amp;quot;, &amp;quot;GBD&amp;quot; };
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = OK.Contains(S);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44045617"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;グリッドから&lt;code&gt;9*9&lt;/code&gt;の領域を全探索し、それぞれが条件を満たすかを判定します。&lt;br /&gt;
条件判定をそれぞれメソッドとして切り出すことで、読みやすくすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x == '#').ToArray();
    }

    bool CheckBlack(int h, int w)
    {
        var result = true;
        for (var i = 0; i &amp;lt; 3 &amp;amp;&amp;amp; result; i++)
        {
            for (var j = 0; j &amp;lt; 3 &amp;amp;&amp;amp; result; j++)
            {
                result &amp;amp;= G[h + i][w + j];
                result &amp;amp;= G[h + 6 + i][w + 6 + j];
            }
        }

        return result;
    }

    bool CheckWhite(int h, int w)
    {
        var result = true;
        for (var i = 0; i &amp;lt; 3 &amp;amp;&amp;amp; result; i++)
        {
            result &amp;amp;= !G[h + i][w + 3];
            result &amp;amp;= !G[h + 3][w + i];
            result &amp;amp;= !G[h + 6 + i][w + 6 - 1];
            result &amp;amp;= !G[h + 6 - 1][w + 6 + i];
        }

        result &amp;amp;= !G[h + 3][w + 3];
        result &amp;amp;= !G[h + 6 - 1][w + 6 - 1];

        return result;
    }

    for (var i = 0; i + 9 &amp;lt;= N; i++)
    {
        for (var j = 0; j + 9 &amp;lt;= M; j++)
        {
            if (CheckBlack(i, j) &amp;amp;&amp;amp; CheckWhite(i, j))
            {
                Console.WriteLine($&amp;quot;{i + 1} {j + 1}&amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44047011"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような&lt;code&gt;x&lt;/code&gt;を二部探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;りんごをx円で売ってもよいと考える売り手の人数が、りんごをx円で買ってもよいと考える買い手の人数以上である。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();

    bool F(long x)
    {
        var a = A.Count(v =&amp;gt; x &amp;gt;= v);
        var b = B.Count(v =&amp;gt; x &amp;lt;= v);
        return a &amp;gt;= b;
    }

    const long Inf = (long)1e18;
    var answer = BinarySearch(0, Inf, F);
    Console.WriteLine(answer);
}

public static long BinarySearch(long ng, long ok, Func&amp;lt;long, bool&amp;gt; func)
{
    while (Math.Abs(ok - ng) &amp;gt; 1)
    {
        var m = (ok + ng) / 2;
        if (func(m)) ok = m;
        else ng = m;
    }
    return ok;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44050433"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;括弧列のレベルを、それまでの`(`の出現数から`)`の出現数を引いたものとしたとき、
dp[i,j] := i番目の文字まで見たとき、現在の括弧列のレベルがjとしてありえる文字列の数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;S[i]が`(`のとき、
dp[i+1,j+1] += dp[i,j] (0&amp;lt;=j&amp;lt;N)

S[i]が`)`のとき、
dp[i+1,j-1] += dp[i,j] (0&amp;lt;j&amp;lt;=N)

S[i]が`?`のとき、
dp[i+1,j+1] += dp[i,j] (0&amp;lt;=j&amp;lt;N)
dp[i+1,j-1] += dp[i,j] (0&amp;lt;j&amp;lt;=N)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;文字目までみたときの括弧列のレベルが&lt;code&gt;0&lt;/code&gt;となるものの数が答えとなります。
括弧列のレベルが0未満になる場合、その文字列は括弧列として成り立たないことに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var dp = new mint[N + 1, N + 1];
    dp[0, 0] = 1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i];
        if (c == '(' || c == '?')
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                dp[i + 1, j + 1] += dp[i, j];
            }
        }

        if (c == ')' || c == '?')
        {
            for (var j = 1; j &amp;lt;= N; j++)
            {
                dp[i + 1, j - 1] += dp[i, j];
            }
        }
    }

    var answer = dp[N, 0];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44087555"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3次元空間をグリッドとしてみたとき、各直方体がどのグリッドを占有しているかを管理し、各直方体のグリッドが面する直方体の種類数を数え上げます。&lt;br /&gt;
与えられる線分の座標は開区間であり、座標を開区間のまま管理すると面が重複してしまうことがあるため、半開区間に変換する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new int[105, 105, 105];
    var P = new (int X1, int Y1, int Z1, int X2, int Y2, int Z2)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x1, y1, z1, x2, y2, z2) = Scanner.Scan&amp;lt;int, int, int, int, int, int&amp;gt;();
        x1++; y1++; z1++;
        P[i] = (x1, y1, z1, x2, y2, z2);

        for (var x = x1; x &amp;lt;= x2; x++)
        {
            for (var y = y1; y &amp;lt;= y2; y++)
            {
                for (var z = z1; z &amp;lt;= z2; z++)
                {
                    G[x, y, z] = i + 1;
                }
            }
        }
    }

    foreach (var (x1, y1, z1, x2, y2, z2) in P)
    {
        var set = new HashSet&amp;lt;int&amp;gt;();
        for (var x = x1; x &amp;lt;= x2; x++)
        {
            for (var y = y1; y &amp;lt;= y2; y++)
            {
                for (var z = z1; z &amp;lt;= z2; z++)
                {
                    set.Add(G[x1 - 1, y, z]);
                    set.Add(G[x2 + 1, y, z]);
                    set.Add(G[x, y1 - 1, z]);
                    set.Add(G[x, y2 + 1, z]);
                    set.Add(G[x, y, z1 - 1]);
                    set.Add(G[x, y, z2 + 1]);
                }
            }
        }

        set.Remove(0);
        Console.WriteLine(set.Count);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc312/tasks/abc312_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC312/submissions/44058275"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M&lt;/code&gt;個の品物のうち、缶切りが不要な缶を&lt;code&gt;x&lt;/code&gt;個として固定したとき、缶切りが必要な缶と缶切りを&lt;code&gt;M-x&lt;/code&gt;個選んだ時の満足度の最大値を求めます。&lt;br /&gt;
缶切りが不要な缶と缶切りが必要な缶は、いずれも満足度が大きいものから選ぶことが最適になります。&lt;br /&gt;
また、缶切りは使用できる缶の数が多い物から順に使うことが最適になります。&lt;br /&gt;
これにより、あらかじめ、缶切りが不要な缶を&lt;code&gt;a&lt;/code&gt;個選んだ時の満足度の累積和と、缶切りが必要な缶と缶切りを合わせて&lt;code&gt;b&lt;/code&gt;個選んだ時の満足度の累積和を求めておくことで、時間計算量&lt;code&gt;O(M)&lt;/code&gt;で満足度の最大値を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var cans0 = new List&amp;lt;long&amp;gt;();
    var cans1 = new List&amp;lt;long&amp;gt;();
    var openers = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (T, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (T == 0)
        {
            cans0.Add(X);
        }
        else if (T == 1)
        {
            cans1.Add(X);
        }
        else
        {
            openers.Add(X);
        }
    }

    cans0.Sort();
    cans0.Reverse();
    cans1.Sort();
    cans1.Reverse();
    openers.Sort();
    openers.Reverse();
    var N0 = cans0.Count;
    var N1 = cans1.Count;
    var N2 = openers.Count;

    var cum0 = new long[M + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        cum0[i + 1] = cum0[i];
        if (i &amp;lt; N0) cum0[i + 1] += cans0[i];
    }

    var cum1 = new long[M + 1];
    {
        var i = 0;
        var j = 0;
        var rem = 0;
        for (var k = 0; k &amp;lt; M; k++)
        {
            cum1[k + 1] += cum1[k];
            if (rem &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; N1)
            {
                cum1[k + 1] += cans1[i++];
                rem--;
            }
            else if (j &amp;lt; N2)
            {
                rem = openers[j++];
            }
        }
    }

    long answer = 0;
    for (var i = 0; i &amp;lt;= M; i++)
    {
        answer = Math.Max(answer, cum0[i] + cum1[M - i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC311</title>
			<link>https://blog.aconcavy.dev/posts/20230722abc311</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 311の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230722abc311</guid>
			<pubDate>Sat, 22 Jul 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 311の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc311"&gt;https://atcoder.jp/contests/abc311&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43827108"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;型は整数型として扱うことができるので、対象となる文字から&lt;code&gt;A&lt;/code&gt;を引くことで、&lt;code&gt;A&lt;/code&gt;の場合は&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;の場合は&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;の場合は&lt;code&gt;2&lt;/code&gt;にすることができ、配列のインデックスとして状態を管理することができます。&lt;br /&gt;
長さが&lt;code&gt;3&lt;/code&gt;の&lt;code&gt;bool&lt;/code&gt;型配列の全てが&lt;code&gt;true&lt;/code&gt;になったときが何番目かを出力します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var used = new bool[3];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i] - 'A';
        used[c] = true;
        if (used.All(x =&amp;gt; x))
        {
            Console.WriteLine($&amp;quot;{i + 1}&amp;quot;);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43836246"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X[i][j]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;番目の人の&lt;code&gt;j&lt;/code&gt;日目までに連続する暇な日数としたとき、&lt;code&gt;j&lt;/code&gt;日目の全ての人の連続する暇な日数の最小値は、&lt;code&gt;j&lt;/code&gt;日目における選べる日数の最大値になります。&lt;br /&gt;
このことから、全ての&lt;code&gt;j&lt;/code&gt;における選べる日数の最大値が答えとなります。
&lt;code&gt;j&lt;/code&gt;日目までに連続する暇な日数は累積和で求めることができ、全体時間計算量&lt;code&gt;O(ND)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, D) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var X = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        X[i] = new int[D + 1];
        for (var j = 0; j &amp;lt; D; j++)
        {
            if (s[j] == 'o')
            {
                X[i][j + 1] = X[i][j] + 1;
            }
        }
    }

    var answer = 0;
    const int Inf = (int)1e9;
    for (var j = 0; j &amp;lt;= D; j++)
    {
        var min = Inf;
        for (var i = 0; i &amp;lt; N; i++)
        {
            min = Math.Min(min, X[i][j]);
        }

        answer = Math.Max(answer, min);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43845949"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Disjoint Set Union&lt;/code&gt;などでグラフにおける閉路の検知と始点を決めます。
深さ優先探索を行い、現在の頂点から既に訪れた頂点にたどり着くことができるかを判定していき、たどり着くことができるならば、その頂点は閉路を構成しているため、答えに追加するという操作を行います。&lt;br /&gt;
この方法では、答えが逆順に追加されていることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var answer = new List&amp;lt;int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i].Add(A[i]);
    }

    var dsu = new DisjointSetUnion(N);
    var s = -1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (dsu.IsSame(i, A[i]))
        {
            s = A[i];
            break;
        }

        dsu.Merge(i, A[i]);
    }

    var used = new bool[N];
    bool Dfs(int u)
    {
        if (used[u]) return true;

        used[u] = true;
        var result = false;
        foreach (var v in G[u])
        {
            result |= Dfs(v);
        }

        if (result)
        {
            answer.Add(u);
        }

        return result;
    }

    Dfs(s);
    answer.Reverse();
    Console.WriteLine(answer.Count);
    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer.Select(x =&amp;gt; x + 1)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43852101"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;visited[i][j][d]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目に方向&lt;code&gt;d&lt;/code&gt;で訪れたことがあるかとした幅優先探索を行います。&lt;br /&gt;
いずれかの方向で&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列目に訪れることができれば、プレイヤーが触れることができる氷とすることができ、この数の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x == '.').ToArray();
    }

    var visited = new bool[N, M, 4];
    var queue = new Queue&amp;lt;(int H, int W, int D)&amp;gt;();
    for (var i = 0; i &amp;lt; 4; i++)
    {
        visited[1, 1, i] = true;
        queue.Enqueue((1, 1, i));
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    while (queue.Count &amp;gt; 0)
    {
        var (ch, cw, d) = queue.Dequeue();

        var (dh1, dw1) = D4[d];
        var (nh1, nw1) = (ch + dh1, cw + dw1);

        if (nh1 &amp;lt; 0 || N &amp;lt;= nh1 || nw1 &amp;lt; 0 || M &amp;lt;= nw1) continue;
        if (visited[nh1, nw1, d]) continue;
        if (G[nh1][nw1])
        {
            visited[nh1, nw1, d] = true;
            queue.Enqueue((nh1, nw1, d));
        }
        else
        {
            for (var d = 0; d &amp;lt; 4; d++)
            {
                var (dh2, dw2) = D4[d];
                var (nh2, nw2) = (ch + dh2, cw + dw2);
                if (nh2 &amp;lt; 0 || N &amp;lt;= nh2 || nw2 &amp;lt; 0 || M &amp;lt;= nw2) continue;
                if (visited[nh2, nw2, d] || !G[nh2][nw2]) continue;
                visited[nh2, nw2, d] = true;
                queue.Enqueue((nh2, nw2, d));
            }
        }
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; M; j++)
        {
            var ok = false;
            for (var d = 0; d &amp;lt; 4; d++)
            {
                ok |= visited[i, j, d];
            }

            if (ok) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc311/tasks/abc311_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC311/submissions/43864378"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i][j] := (i,j)を正方形の右下隅としたときの穴のない正方形の辺の長さの最大値
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遷移は次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;(i,j)が穴ではないとき、
dp[i][j] = Min(dp[i-1,j], dp[i,j-1], dp[i-1,j-1]) + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;(i,j)&lt;/code&gt;を正方形の右下隅としたとき、&lt;code&gt;dp[i][j]&lt;/code&gt;通りの辺の長さの正方形を作ることができるので、全ての&lt;code&gt;(i,j)&lt;/code&gt;における&lt;code&gt;dp[i][j]&lt;/code&gt;の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var isHole = new bool[H, W];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        isHole[a, b] = true;
    }

    var dp = new int[H, W];
    for (var i = 0; i &amp;lt; H; i++)
    {
        if (!isHole[i, 0]) dp[i, 0] = 1;
    }

    for (var j = 0; j &amp;lt; W; j++)
    {
        if (!isHole[0, j]) dp[0, j] = 1;
    }

    const int Inf = (int)1e9;
    for (var i = 1; i &amp;lt; H; i++)
    {
        for (var j = 1; j &amp;lt; W; j++)
        {
            if (isHole[i, j]) continue;
            var min = Inf;
            min = Math.Min(min, dp[i - 1, j]);
            min = Math.Min(min, dp[i, j - 1]);
            min = Math.Min(min, dp[i - 1, j - 1]);
            dp[i, j] = min + 1;
        }
    }

    long answer = 0;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            answer += dp[i, j];
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC310</title>
			<link>https://blog.aconcavy.dev/posts/20230715abc310</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 310の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230715abc310</guid>
			<pubDate>Sat, 15 Jul 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 310の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc310"&gt;https://atcoder.jp/contests/abc310&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43582409"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ドリンクのみか、割引券とともに最安値の料理を注文するかの方法のうち、安くなる方が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P, Q) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var D = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = Math.Min(P, Q + D.Min());
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43597894"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;価格&lt;code&gt;P&lt;/code&gt;の集合&lt;code&gt;S&lt;/code&gt;と、価格&lt;code&gt;Q&lt;/code&gt;の集合&lt;code&gt;T&lt;/code&gt;を比較したときに、&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;一致しているかつ値段が異なる、または&lt;code&gt;T&lt;/code&gt;は&lt;code&gt;S&lt;/code&gt;の部分集合かつ&lt;code&gt;|S|&amp;gt;|T|&lt;/code&gt;であるかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var PS = new (int P, HashSet&amp;lt;int&amp;gt; S)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var array = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var p = array[0];
        var c = array[1];
        var s = new HashSet&amp;lt;int&amp;gt;(array.Skip(2));
        PS[i] = (p, s);
    }

    Array.Sort(PS, (x, y) =&amp;gt; x.P.CompareTo(y.P));

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var (p, s) = PS[i];
            var (q, t) = PS[j];

            if ((s.SetEquals(t) &amp;amp;&amp;amp; p &amp;lt; q) || t.IsSubsetOf(s) &amp;amp;&amp;amp; s.Count &amp;gt; t.Count)
            {
                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43600578"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列を順にみていき、その文字列とその文字列を反転させたものがそれまでに出現しているかを判定していきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var set = new HashSet&amp;lt;string&amp;gt;();
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        var T = new string(S.Reverse().ToArray());
        if (!set.Contains(S) &amp;amp;&amp;amp; !set.Contains(T))
        {
            set.Add(S);
            set.Add(T);
            answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43646845"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全探索を行います。&lt;br /&gt;
現在できているチームを管理しながら、相性の悪い組ができないように選手を順番に追加していきます。&lt;br /&gt;
場合分けとして、現在できているチームのいずれかに選手を追加することができます。&lt;br /&gt;
また、現在できているチーム数が&lt;code&gt;T&lt;/code&gt;未満の場合、新しくチームを作成して選手を追加することができます。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;人全ての選手をチームに追加したときのチーム数が&lt;code&gt;T&lt;/code&gt;組であるときの組み合わせを数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T, M) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var ng = new int[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        ng[a] |= 1 &amp;lt;&amp;lt; b;
        ng[b] |= 1 &amp;lt;&amp;lt; a;
    }

    var teams = new List&amp;lt;int&amp;gt;(T);

    int Dfs(int i)
    {
        if (i == N)
        {
            return teams.Count == T ? 1 : 0;
        }

        var sum = 0;
        for (var t = 0; t &amp;lt; teams.Count; t++)
        {
            if ((teams[t] &amp;amp; ng[i]) != 0) continue;
            teams[t] += 1 &amp;lt;&amp;lt; i;
            sum += Dfs(i + 1);
            teams[t] -= 1 &amp;lt;&amp;lt; i;
        }

        if (teams.Count &amp;lt; T)
        {
            teams.Add(1 &amp;lt;&amp;lt; i);
            sum += Dfs(i + 1);
            teams.RemoveAt(teams.Count - 1);
        }

        return sum;
    }

    var answer = Dfs(0);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc310/tasks/abc310_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC310/submissions/43647339"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;次のような動的計画法を解きます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i,f] := i番目までみたときのf(0|1)の個数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;に対して否定論理積をとる場合、&lt;code&gt;0⊼0=1&lt;/code&gt;、&lt;code&gt;1⊼0=1&lt;/code&gt;であることから、それまでの&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;の個数が&lt;code&gt;1&lt;/code&gt;になることがわかります。
また、&lt;code&gt;1&lt;/code&gt;に対して否定論理積をとる場合、&lt;code&gt;0⊼1=1&lt;/code&gt;、&lt;code&gt;1⊼1=0&lt;/code&gt;であることから、それまでの&lt;code&gt;0&lt;/code&gt;の個数が&lt;code&gt;1&lt;/code&gt;になり、それまでの&lt;code&gt;1&lt;/code&gt;の個数が&lt;code&gt;0&lt;/code&gt;になることがわかります。&lt;br /&gt;
これらのことから、遷移としては、次のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;S[i]==0のとき
dp[i+1,0] += 1       // S[i]
dp[i+1,1] += dp[i,0] // 0⊼0=1
dp[i+1,1] += dp[i,1] // 1⊼0=1

S[i]==1のとき
dp[i+1,0] += dp[i,1] // 1⊼1=0
dp[i+1,1] += dp[i,0] // 0⊼1=1
dp[i+1,1] += 1       // S[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各&lt;code&gt;i&lt;/code&gt;番目までみたときの&lt;code&gt;1&lt;/code&gt;の個数の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var dp = new long[N + 1, 2];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var f = S[i] - '0';
        dp[i + 1, f]++;
        if (f == 0)
        {
            dp[i + 1, 1] += dp[i, 0] + dp[i, 1];
        }
        else
        {
            dp[i + 1, 0] += dp[i, 1];
            dp[i + 1, 1] += dp[i, 0];
        }
    }

    long answer = 0;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        answer += dp[i, 1];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC309</title>
			<link>https://blog.aconcavy.dev/posts/20230708abc309</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 309の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230708abc309</guid>
			<pubDate>Sat, 08 Jul 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 309の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc309"&gt;https://atcoder.jp/contests/abc309&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43337977"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&amp;lt;B&lt;/code&gt;であることから、&lt;code&gt;A+1==B&lt;/code&gt;であることが条件の一つとなります。
また、&lt;code&gt;A&lt;/code&gt;が&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;6&lt;/code&gt;、&lt;code&gt;9&lt;/code&gt;の場合、右に隣接する&lt;code&gt;B&lt;/code&gt;は存在しないため、&lt;code&gt;A&lt;/code&gt;が3の倍数ではないときが、もう一つの条件となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = A + 1 == B &amp;amp;&amp;amp; (A % 3 != 0);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43351302"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;時計回りに&lt;code&gt;1&lt;/code&gt;行目、&lt;code&gt;N&lt;/code&gt;列目、&lt;code&gt;N&lt;/code&gt;行目、&lt;code&gt;1&lt;/code&gt;列目を更新していくことを考えます。&lt;br /&gt;
ある場所を更新するとき、その直前に更新した値がその場所に移動し、更新された値が次の場所に移動することがわかります。&lt;br /&gt;
このことから、直前に更新した値を保持しながら外側のマスを順番に更新していくことで、答えを得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x - '0').ToArray();
    }

    var tmp1 = A[1][0];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var tmp2 = A[0][i];
        A[0][i] = tmp1;
        tmp1 = tmp2;
    }

    for (var i = 1; i &amp;lt; N; i++)
    {
        var tmp2 = A[i][N - 1];
        A[i][N - 1] = tmp1;
        tmp1 = tmp2;
    }

    for (var i = N - 2; i &amp;gt;= 0; i--)
    {
        var tmp2 = A[N - 1][i];
        A[N - 1][i] = tmp1;
        tmp1 = tmp2;
    }

    for (var i = N - 2; i &amp;gt;= 0; i--)
    {
        var tmp2 = A[i][0];
        A[i][0] = tmp1;
        tmp1 = tmp2;
    }

    Printer.Print2D(A);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43355518"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初日に飲む必要がある薬は&lt;code&gt;b&lt;/code&gt;の総和となり、各&lt;code&gt;a+1&lt;/code&gt;日目に飲む分は&lt;code&gt;b&lt;/code&gt;錠減ることがわかります。&lt;br /&gt;
このことから、各&lt;code&gt;a+1&lt;/code&gt;日目に何錠減るかをまとめ、薬が減る日が早い順に飲む必要がある薬を減らしていき、&lt;code&gt;K&lt;/code&gt;以下になった日が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var dict = new Dictionary&amp;lt;long, long&amp;gt;();
    dict[1] = 0;
    long cum = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        cum += b;
        if (!dict.ContainsKey(a + 1)) dict[a + 1] = 0;
        dict[a + 1] += b;
    }


    foreach (var (a, b) in dict.OrderBy(x =&amp;gt; x.Key))
    {
        cum -= b;
        if (cum &amp;lt;= K)
        {
            Console.WriteLine(a);
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43359818"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;頂点&lt;code&gt;1&lt;/code&gt;から頂点&lt;code&gt;N1+N2&lt;/code&gt;への最長となる経路は、頂点&lt;code&gt;1&lt;/code&gt;から最も遠い頂点と頂点&lt;code&gt;N1+N2&lt;/code&gt;から最も遠い頂点間に辺を結ぶことで達成することができます。&lt;br /&gt;
このことから、&lt;code&gt;N1&lt;/code&gt;個の頂点からなるグラフ&lt;code&gt;G1&lt;/code&gt;において頂点&lt;code&gt;1&lt;/code&gt;から距離と、&lt;code&gt;N2&lt;/code&gt;個の頂点からなるグラフ&lt;code&gt;G2&lt;/code&gt;において頂点&lt;code&gt;N1+N2&lt;/code&gt;からの距離をそれぞれ幅優先探索などを行い求め、各距離の最大値に辺を一つ追加したものが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N1, N2, M) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G1 = new List&amp;lt;int&amp;gt;[N1].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var G2 = new List&amp;lt;int&amp;gt;[N2].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--; b--;
        if (a &amp;lt; N1)
        {
            G1[a].Add(b);
            G1[b].Add(a);
        }
        else
        {
            a -= N1;
            b -= N1;
            G2[a].Add(b);
            G2[b].Add(a);
        }
    }

    int MaxDist(List&amp;lt;int&amp;gt;[] G, int N, int s)
    {
        var dist = new int[N];
        Array.Fill(dist, -1);
        var queue = new Queue&amp;lt;int&amp;gt;();
        queue.Enqueue(s);
        dist[s] = 0;
        while (queue.Count &amp;gt; 0)
        {
            var u = queue.Dequeue();
            foreach (var v in G[u])
            {
                if (dist[v] != -1) continue;
                dist[v] = dist[u] + 1;
                queue.Enqueue(v);
            }
        }

        return dist.Max();
    }

    var answer = MaxDist(G1, N1, 0) + MaxDist(G2, N2, N2 - 1) + 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc309/tasks/abc309_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC309/submissions/43370895"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各親&lt;code&gt;u&lt;/code&gt;から子&lt;code&gt;v&lt;/code&gt;への有向辺を張ったグラフを&lt;code&gt;G&lt;/code&gt;とします。&lt;br /&gt;
人&lt;code&gt;i&lt;/code&gt;からみた保証対象となる代の最大値を&lt;code&gt;dp[i]&lt;/code&gt;、親を&lt;code&gt;u&lt;/code&gt;、子を&lt;code&gt;v&lt;/code&gt;としたとき、&lt;code&gt;dp[v]&lt;/code&gt;の最大値は&lt;code&gt;Max(dp[v],dp[u]-1)&lt;/code&gt;になります。
&lt;code&gt;P[i]&amp;lt;=i-1&lt;/code&gt;であることから、親を順に走査して子に最大値を伝播してくことで各&lt;code&gt;dp[i]&lt;/code&gt;の値を求めることができ、&lt;code&gt;dp[i]&amp;gt;=0&lt;/code&gt;となる人の数が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();

    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    for (var i = 0; i &amp;lt; P.Length; i++)
    {
        var u = P[i] - 1;
        var v = i + 1;
        G[u].Add(v);
    }

    var dp = new int[N];
    Array.Fill(dp, -1);
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        x--;
        dp[x] = Math.Max(dp[x], y);
    }

    var answer = 0;
    for (var u = 0; u &amp;lt; N; u++)
    {
        foreach (var v in G[u])
        {
            dp[v] = Math.Max(dp[v], dp[u] - 1);
        }

        if (dp[u] &amp;gt;= 0) answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC308</title>
			<link>https://blog.aconcavy.dev/posts/20230701abc308</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 308の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20230701abc308</guid>
			<pubDate>Sat, 01 Jul 2023 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 308の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Scannerクラス&lt;/summary&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static class Scanner
{
    public static T Scan&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; Convert&amp;lt;T&amp;gt;(ScanStringArray()[0]);
    public static (T1, T2) Scan&amp;lt;T1, T2&amp;gt;() where T1 : IConvertible where T2 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]));
    }
    public static (T1, T2, T3) Scan&amp;lt;T1, T2, T3&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]));
    }
    public static (T1, T2, T3, T4) Scan&amp;lt;T1, T2, T3, T4&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]));
    }
    public static (T1, T2, T3, T4, T5) Scan&amp;lt;T1, T2, T3, T4, T5&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]));
    }
    public static (T1, T2, T3, T4, T5, T6) Scan&amp;lt;T1, T2, T3, T4, T5, T6&amp;gt;() where T1 : IConvertible where T2 : IConvertible where T3 : IConvertible where T4 : IConvertible where T5 : IConvertible where T6 : IConvertible
    {
        var input = ScanStringArray();
        return (Convert&amp;lt;T1&amp;gt;(input[0]), Convert&amp;lt;T2&amp;gt;(input[1]), Convert&amp;lt;T3&amp;gt;(input[2]), Convert&amp;lt;T4&amp;gt;(input[3]), Convert&amp;lt;T5&amp;gt;(input[4]), Convert&amp;lt;T6&amp;gt;(input[5]));
    }
    public static IEnumerable&amp;lt;T&amp;gt; ScanEnumerable&amp;lt;T&amp;gt;() where T : IConvertible =&amp;gt; ScanStringArray().Select(Convert&amp;lt;T&amp;gt;);
    private static string[] ScanStringArray()
    {
        var line = Console.ReadLine()?.Trim() ?? string.Empty;
        return string.IsNullOrEmpty(line) ? Array.Empty&amp;lt;string&amp;gt;() : line.Split(' ');
    }
    private static T Convert&amp;lt;T&amp;gt;(string value) where T : IConvertible =&amp;gt; (T)System.Convert.ChangeType(value, typeof(T));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308"&gt;https://atcoder.jp/contests/abc308&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43089067"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての&lt;code&gt;S[i]&lt;/code&gt;において各条件を満たすかどうかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    bool F1(int x) =&amp;gt; 100 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= 675;
    bool F2(int x) =&amp;gt; x % 25 == 0;
    var answer = F1(A[0]) &amp;amp;&amp;amp; F2(A[1]);
    for (var i = 1; i &amp;lt; A.Length; i++)
    {
        answer &amp;amp;= A[i] &amp;gt;= A[i - 1] &amp;amp;&amp;amp; F1(A[i]) &amp;amp;&amp;amp; F2(A[i]);
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43094426"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書などを使って料理名に対して値段を設定し、食べた料理の価格の合計を計算します。&lt;br /&gt;
&lt;code&gt;D&lt;/code&gt;に存在しない料理名の価格は&lt;code&gt;P[0]&lt;/code&gt;になることに注意します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var C = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
    var D = Scanner.ScanEnumerable&amp;lt;string&amp;gt;().ToArray();
    var P = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;string, long&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        dict[D[i]] = P[i + 1];
    }

    var answer = C.Sum(x =&amp;gt; dict.ContainsKey(x) ? dict[x] : P[0]);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43098637"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;成功率を浮動小数点で計算してしまうと誤差が発生してしまうため、整数型で管理できるようにします。
ある確率&lt;code&gt;X&lt;/code&gt;が整数&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;で&lt;code&gt;a/b&lt;/code&gt;、確率&lt;code&gt;Y&lt;/code&gt;が整数&lt;code&gt;c&lt;/code&gt;と&lt;code&gt;d&lt;/code&gt;で&lt;code&gt;c/d&lt;/code&gt;で表すことができるとき、不等式&lt;code&gt;X&amp;gt;Y&lt;/code&gt;は&lt;code&gt;a/b&amp;gt;c/d&lt;/code&gt;となりますが、両辺に&lt;code&gt;b*d&lt;/code&gt;を掛けることで、&lt;code&gt;a*d&amp;gt;c*b&lt;/code&gt;とすることができ、整数型で比較を行うことができるようになります。
そのため、整数型で分母と分子を管理しながら成功率が高い順に並べることで、答えを求めることができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = new Fraction[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        P[i] = new Fraction(a, a + b);
    }

    var H = Enumerable.Range(0, N).ToArray();
    Array.Sort(H, (x, y) =&amp;gt;
    {
        var result = P[y].CompareTo(P[x]);
        return result == 0 ? x.CompareTo(y) : result;
    });

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, H.Select(x =&amp;gt; x + 1)));
}

public readonly struct Fraction : IComparable&amp;lt;Fraction&amp;gt;, IEquatable&amp;lt;Fraction&amp;gt;
{
    public long Y { get; }
    public long X { get; }

    public Fraction(long y, long x)
    {
        static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
        var g = Gcd(y, x);
        (Y, X) = (y / g, x / g);
    }

    public static bool operator &amp;lt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt; 0;
    public static bool operator &amp;lt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;lt;= 0;
    public static bool operator &amp;gt;(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt; 0;
    public static bool operator &amp;gt;=(Fraction left, Fraction right) =&amp;gt; left.CompareTo(right) &amp;gt;= 0;
    public static bool operator ==(Fraction left, Fraction right) =&amp;gt; left.Equals(right);
    public static bool operator !=(Fraction left, Fraction right) =&amp;gt; !left.Equals(right);
    public int CompareTo(Fraction other) =&amp;gt; (Y * other.X).CompareTo(X * other.Y);
    public bool Equals(Fraction other) =&amp;gt; Y == other.Y &amp;amp;&amp;amp; X == other.X;
    public override bool Equals(object obj) =&amp;gt; obj is Fraction other &amp;amp;&amp;amp; Equals(other);
    public override int GetHashCode() =&amp;gt; HashCode.Combine(Y, X);
    public override string ToString() =&amp;gt; $&amp;quot;{Y}/{X}&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43105604"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各マスを頂点とし、現在の文字が&lt;code&gt;snuke&lt;/code&gt;文字列の何番目であるかを管理しながら、幅優先探索を行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; F(x)).ToArray();
    }

    int F(char c)
    {
        return c switch
        {
            's' =&amp;gt; 0,
            'n' =&amp;gt; 1,
            'u' =&amp;gt; 2,
            'k' =&amp;gt; 3,
            'e' =&amp;gt; 4,
            _ =&amp;gt; -1,
        };
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    var used = new bool[H, W];
    var queue = new Queue&amp;lt;(int H, int W, int S)&amp;gt;();
    if (G[0][0] == 0)
    {
        used[0, 0] = true;
        queue.Enqueue((0, 0, 0));
    }

    while (queue.Count &amp;gt; 0)
    {
        var (ch, cw, cs) = queue.Dequeue();
        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            var ns = G[nh][nw];
            if (ns == (cs + 1) % 5 &amp;amp;&amp;amp; !used[nh, nw])
            {
                used[nh, nw] = true;
                queue.Enqueue((nh, nw, ns));
            }
        }
    }

    var answer = used[H - 1, W - 1];
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43154883"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;j&lt;/code&gt;を固定したとき、その&lt;code&gt;j&lt;/code&gt;からありえる&lt;code&gt;MEX&lt;/code&gt;の組み合わせは、&lt;code&gt;A[i]&lt;/code&gt;の値が&lt;code&gt;0,1,2&lt;/code&gt;の3通りと&lt;code&gt;A[k]&lt;/code&gt;の値が&lt;code&gt;0,1,2&lt;/code&gt;の3通りの合計9通りになります。&lt;br /&gt;
&lt;code&gt;j&lt;/code&gt;までに出現する&lt;code&gt;{0,1,2}&lt;/code&gt;の個数、&lt;code&gt;j&lt;/code&gt;以降に出現する&lt;code&gt;{0,1,2}&lt;/code&gt;の個数に対して&lt;code&gt;mex({0,1,2},A[j],{0,1,2})&lt;/code&gt;を掛けることで、その&lt;code&gt;j&lt;/code&gt;に対する&lt;code&gt;mex(A[i],A[j],A[k])&lt;/code&gt;の総和を求めることができます。&lt;br /&gt;
あらかじめ累積和で各値が出現する個数を求めておくことで、&lt;code&gt;j&lt;/code&gt;における各&lt;code&gt;mex(A[i],A[j],A[k])&lt;/code&gt;の値を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができ、全体で時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    var countM = new long[N + 1, 3];
    var countX = new long[N + 1, 3];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var m = 0; m &amp;lt; 3; m++)
        {
            countM[i + 1, m] += countM[i, m];
            countX[i + 1, m] += countX[i, m];
        }

        if (S[i] == 'M') countM[i + 1, A[i]]++;
        if (S[i] == 'X') countX[i + 1, A[i]]++;
    }

    int Mex(int a, int b, int c)
    {
        for (var mex = 0; mex &amp;lt; 3; mex++)
        {
            if (mex != a &amp;amp;&amp;amp; mex != b &amp;amp;&amp;amp; mex != c) return mex;
        }

        return 3;
    }

    long answer = 0;
    for (var j = 0; j &amp;lt; N; j++)
    {
        if (S[j] != 'E') continue;
        for (var i = 0; i &amp;lt; 3; i++)
        {
            for (var k = 0; k &amp;lt; 3; k++)
            {
                var ci = countM[j, i];
                var ck = countX[N, k] - countX[j, k];
                answer += ci * ck * Mex(i, A[j], k);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc308/tasks/abc308_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc308/submissions/43152464"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P&lt;/code&gt;を小さい順に見ていき、各&lt;code&gt;P[i]&lt;/code&gt;に対して利用可能な最大の&lt;code&gt;D[j]&lt;/code&gt;を使用していくことで、最小値を求めることができます。
利用可能な最大の&lt;code&gt;D[j]&lt;/code&gt;は、&lt;code&gt;L[j]&lt;/code&gt;を小さい順にソートし、現在見ている&lt;code&gt;P[i]&lt;/code&gt;以下の&lt;code&gt;L[j]&lt;/code&gt;に対応する&lt;code&gt;D[j]&lt;/code&gt;を優先度付きキューに挿入していき、優先度付きキューの先頭にあるものを消費することで求めることができ、全体時間計算量`O(NlogN+MlogM)で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var L = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var D = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var LD = L.Zip(D).ToArray();
    Array.Sort(P, (x, y) =&amp;gt; x.CompareTo(y));
    Array.Sort(LD, (x, y) =&amp;gt; x.First.CompareTo(y.First));

    var queue = new PriorityQueue&amp;lt;long&amp;gt;((x, y) =&amp;gt; y.CompareTo(x));
    var idx = 0;
    long answer = 0;
    foreach (var p in P)
    {
        answer += p;
        while (idx &amp;lt; M &amp;amp;&amp;amp; LD[idx].First &amp;lt;= p)
        {
            queue.Enqueue(LD[idx++].Second);
        }

        if (queue.Count &amp;gt; 0)
        {
            answer -= queue.Dequeue();
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>