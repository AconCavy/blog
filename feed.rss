<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://blog.aconcavy.dev/</link>
		<description />
		<copyright>Copyright © 2020-2022 AconCavy</copyright>
		<pubDate>Sat, 24 Dec 2022 14:56:44 GMT</pubDate>
		<lastBuildDate>Sat, 24 Dec 2022 14:56:44 GMT</lastBuildDate>
		<item>
			<title>ABC283</title>
			<link>https://blog.aconcavy.dev/posts/20221224abc283</link>
			<description>&lt;p&gt;AtCoder Grand Contest 283の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221224abc283</guid>
			<pubDate>Sat, 24 Dec 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Grand Contest 283の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc283"&gt;https://atcoder.jp/contests/abc283&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37481456"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A^B&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;に&lt;code&gt;A&lt;/code&gt;を&lt;code&gt;B&lt;/code&gt;回掛けたものなので、それを計算します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();
    long answer = 1;
    while (B-- &amp;gt; 0)
    {
        answer *= A;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37485282"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリが&lt;code&gt;1 k x&lt;/code&gt;の場合は&lt;code&gt;A[k] = x&lt;/code&gt;で更新し、&lt;code&gt;2 k&lt;/code&gt;の場合は&lt;code&gt;A[k]&lt;/code&gt;を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        if (query[0] == 1)
        {
            var (k, x) = (query[1] - 1, query[2]);
            A[k] = x;
        }
        else
        {
            var k = query[1] - 1;
            Console.WriteLine(A[k]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37489912"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;以外の場合はそのボタンを1回を押し、&lt;code&gt;0&lt;/code&gt;が1以上連続する場合は&lt;code&gt;0&lt;/code&gt;の数が偶数の場合はその半数の&lt;code&gt;00&lt;/code&gt;ボタンを押し、&lt;code&gt;0&lt;/code&gt;の数が奇数の場合は&lt;code&gt;0&lt;/code&gt;を1回押して残りの半数を&lt;code&gt;00&lt;/code&gt;で押せばいいことがわかります。
そのため、&lt;code&gt;S&lt;/code&gt;を順にみていき、&lt;code&gt;0&lt;/code&gt;以外の場合は1回、&lt;code&gt;0&lt;/code&gt;の場合は&lt;code&gt;Ceil(連続する0の数/2)&lt;/code&gt;回押すことで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var answer = 0;
    var l = 0;
    while (l &amp;lt; N)
    {
        if (S[l] == '0')
        {
            var r = l;
            while (r &amp;lt; N &amp;amp;&amp;amp; S[r] == '0') r++;
            var c = r - l;
            answer += (c + 1) / 2;
            l = r;
        }
        else
        {
            answer++;
            l++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37504595"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;を順にみるとき、&lt;code&gt;(&lt;/code&gt;が出現したときにレベルを&lt;code&gt;+1&lt;/code&gt;し、&lt;code&gt;)&lt;/code&gt;が出現したときにレベルを&lt;code&gt;-1&lt;/code&gt;すると、良い文字列のレベルごとに含まれる文字の集合を管理することができます。例えば&lt;code&gt;a(b(c)d(e))&lt;/code&gt;のときは以下のようなレベルになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;L2:    (c) (e)
L1:  (b   d   )
L0: a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このとき、&lt;code&gt;)&lt;/code&gt;の操作は、&lt;code&gt;そのレベルに含まれる文字の箱に入れたボールを箱から取り出す&lt;/code&gt;という操作になります。&lt;br /&gt;
そのため、&lt;code&gt;S&lt;/code&gt;を順にみていき、以下のような操作をすることで答えを求めることができます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(&lt;/code&gt;の場合は、レベルを&lt;code&gt;+1&lt;/code&gt;する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;)&lt;/code&gt;の場合は、現在のレベルに含まれているボールを箱から取り出してレベルを&lt;code&gt;-1&lt;/code&gt;する。&lt;/li&gt;
&lt;li&gt;それ以外の場合は、
&lt;ul&gt;
&lt;li&gt;ボールが箱にある場合は、&lt;code&gt;No&lt;/code&gt;を出力する。&lt;/li&gt;
&lt;li&gt;ボールが箱にない場合は、ボールを箱に入れ、現在のレベルにボールを追加する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全て完了できるならば&lt;code&gt;Yes&lt;/code&gt;を出力する。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    var balls = new bool[26];
    var level = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    var curr = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (!level.ContainsKey(curr)) level[curr] = new List&amp;lt;int&amp;gt;();

        if (S[i] == '(')
        {
            curr++;
        }
        else if (S[i] == ')')
        {
            foreach (var c in level[curr])
            {
                balls[c] = false;
            }

            level[curr].Clear();
            curr--;
        }
        else
        {
            var c = S[i] - 'a';
            if (balls[c])
            {
                Console.WriteLine(&amp;quot;No&amp;quot;);
                return;
            }

            balls[c] = true;
            level[curr].Add(c);
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc283/tasks/abc283_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC283/submissions/37519410"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作は、&lt;code&gt;i&lt;/code&gt;行目を反転させること、つまり&lt;code&gt;i&lt;/code&gt;行目の全ての列の値を&lt;code&gt;0/1&lt;/code&gt;反転させることになります。&lt;br /&gt;
また、&lt;code&gt;A[i][j]&lt;/code&gt;が孤立しない状態を作ることができるかは、&lt;code&gt;A[i-1][j]&lt;/code&gt;、&lt;code&gt;A[i+1][j]&lt;/code&gt;、&lt;code&gt;A[i][j-1]&lt;/code&gt;、&lt;code&gt;A[i][j+1]&lt;/code&gt;のいずれかが同じ値である必要があり、&lt;code&gt;i&lt;/code&gt;行目の状態&lt;code&gt;curr&lt;/code&gt;、&lt;code&gt;i-1&lt;/code&gt;行目の状態&lt;code&gt;prev&lt;/code&gt;、&lt;code&gt;i+1&lt;/code&gt;行目の状態&lt;code&gt;next&lt;/code&gt;が分かれば、&lt;code&gt;i&lt;/code&gt;行目の全ての列が孤立しない状態として成り立つか判断することができます。
そのため、&lt;code&gt;curr&lt;/code&gt;、&lt;code&gt;prev&lt;/code&gt;、&lt;code&gt;next&lt;/code&gt;がそれぞれ行が反転していない(0),反転している(1)の状態であるとき、&lt;br /&gt;
&lt;code&gt;dp[i][curr][prev][next]:=i行目まで見たとき、それぞれcurr、prev、nextかつi行目が孤立していない状態の最小値&lt;/code&gt;&lt;br /&gt;
とした動的計画法を解くことで操作回数の最小値を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var dp = new int[H, 2, 2, 2];
    const int inf = (int)1e9;
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var curr = 0; curr &amp;lt; 2; curr++)
        {
            for (var next = 0; next &amp;lt; 2; next++)
            {
                for (var prev = 0; prev &amp;lt; 2; prev++)
                {
                    dp[i, curr, next, prev] = inf;
                }
            }
        }
    }

    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var curr = 0; curr &amp;lt; 2; curr++)
        {
            for (var next = 0; next &amp;lt; 2; next++)
            {
                for (var prev = 0; prev &amp;lt; 2; prev++)
                {
                    var okW = true;
                    for (var j = 0; j &amp;lt; W; j++)
                    {
                        var ok = false;
                        if (i - 1 &amp;gt;= 0) ok |= (A[i][j] ^ curr) == (A[i - 1][j] ^ prev);
                        if (i + 1 &amp;lt; H) ok |= (A[i][j] ^ curr) == (A[i + 1][j] ^ next);
                        if (j - 1 &amp;gt;= 0) ok |= (A[i][j] ^ curr) == (A[i][j - 1] ^ curr);
                        if (j + 1 &amp;lt; W) ok |= (A[i][j] ^ curr) == (A[i][j + 1] ^ curr);
                        okW &amp;amp;= ok;
                    }

                    if (!okW) continue;
                    var cost = curr;
                    if (i == 0)
                    {
                        dp[i, curr, next, prev] = Math.Min(dp[i, curr, next, prev], cost);
                    }
                    else
                    {
                        dp[i, curr, next, prev] = Math.Min(dp[i, curr, next, prev], dp[i - 1, prev, curr, 0] + cost);
                        dp[i, curr, next, prev] = Math.Min(dp[i, curr, next, prev], dp[i - 1, prev, curr, 1] + cost);
                    }
                }
            }
        }
    }

    var answer = inf;
    for (var curr = 0; curr &amp;lt; 2; curr++)
    {
        for (var next = 0; next &amp;lt; 2; next++)
        {
            for (var prev = 0; prev &amp;lt; 2; prev++)
            {
                answer = Math.Min(answer, dp[H - 1, curr, next, prev]);
            }
        }
    }

    if (answer == inf)
    {
        Console.WriteLine(-1);
    }
    else
    {
        answer = Math.Min(answer, H - answer);
        Console.WriteLine(answer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC282</title>
			<link>https://blog.aconcavy.dev/posts/20221217abc282</link>
			<description>&lt;p&gt;AtCoder Grand Contest 282の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221217abc282</guid>
			<pubDate>Sat, 17 Dec 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Grand Contest 282の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282"&gt;https://atcoder.jp/contests/abc282&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37322378"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C++やC#などの言語では、&lt;code&gt;char&lt;/code&gt;型の&lt;code&gt;A&lt;/code&gt;に&lt;code&gt;+0&lt;/code&gt;すると&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;+1&lt;/code&gt;すると&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;+25&lt;/code&gt;すると&lt;code&gt;Z&lt;/code&gt;の文字を取得することができます。
これは、文字&lt;code&gt;A&lt;/code&gt;は数値&lt;code&gt;65&lt;/code&gt;を&lt;code&gt;char&lt;/code&gt;型にしたものに対応しており、文字&lt;code&gt;B&lt;/code&gt;や文字&lt;code&gt;Z&lt;/code&gt;はそれぞれ数値&lt;code&gt;66&lt;/code&gt;と数値&lt;code&gt;90&lt;/code&gt;に対応します。
そのため、&lt;code&gt;A&lt;/code&gt;から&lt;code&gt;i&lt;/code&gt;進んだ数値を&lt;code&gt;char&lt;/code&gt;型に変換することで、&lt;code&gt;A&lt;/code&gt;から&lt;code&gt;i&lt;/code&gt;進んだ文字として得ることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var builder = new StringBuilder();
    for (var i = 0; i &amp;lt; K; i++)
    {
        builder.Append((char)('A' + i));
    }

    var answer = builder.ToString();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37326045"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&amp;lt;=i&amp;lt;j&amp;lt;=N&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;番と&lt;code&gt;j&lt;/code&gt;番のペアにおいて、&lt;code&gt;M&lt;/code&gt;問全ての問題で少なくともどちらか一方でも解くことができるペアの数を数え上げます。
これは、各ペアを列挙し、&amp;quot;&lt;code&gt;i&lt;/code&gt;番の&lt;code&gt;k&lt;/code&gt;問目と&lt;code&gt;j&lt;/code&gt;番の&lt;code&gt;k&lt;/code&gt;問目の少なくともどちらか一方が&lt;code&gt;o&lt;/code&gt;である&amp;quot;、という小問題を&lt;code&gt;1&amp;lt;=k&amp;lt;=M&lt;/code&gt;全てで満たしている場合の数となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        S[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var ok = true;
            for (var k = 0; k &amp;lt; M; k++)
            {
                ok &amp;amp;= S[i][k] == 'o' || S[j][k] == 'o';
            }

            if (ok) answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37329954"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在の文字が括られているかの判定は、それまでに出現した&lt;code&gt;&amp;quot;&lt;/code&gt;の数が奇数個であれば括られており、偶数個であれば括られていないことがわかります。
文字を順番に見ていき、現在の文字が括られていないときの&lt;code&gt;,&lt;/code&gt;であれば、&lt;code&gt;.&lt;/code&gt;に変換します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var level = 0;
    var T = new char[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = S[i];
        if (c == '&amp;quot;')
        {
            level ^= 1;
        }
        else
        {
            if (c == ',' &amp;amp;&amp;amp; level == 0)
            {
                c = '.';
            }
        }

        T[i] = c;
    }

    var answer = new string(T);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37360871"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;あるグラフが連結である場合、始点を白と決めて幅優先探索などを行い、連結している頂点の色を白黒反転したものを決めていくことで、そのグラフが二部グラフであるかどうかを判定することができます。&lt;/p&gt;
&lt;p&gt;二部グラフの性質として、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフが二部グラフではない場合、いずれの頂点どうしを新たに接続しても、二部グラフにすることはできません。&lt;/li&gt;
&lt;li&gt;グラフが二部グラフである場合、色が異なる頂点どうしを新たに接続しても、二部グラフを保つことができます。&lt;/li&gt;
&lt;li&gt;二部グラフ&lt;code&gt;A&lt;/code&gt;と二部グラフ&lt;code&gt;B&lt;/code&gt;があるとき、&lt;code&gt;A&lt;/code&gt;のいずれの頂点と&lt;code&gt;B&lt;/code&gt;のいずれの頂点を接続しても、接続後のグラフは二部グラフを保つことができます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらのことから、連結成分ごとに二部グラフかどうかを判定を行い、二部グラフではない連結成分が存在する場合、いずれの頂点どうしを新たに接続しても二部グラフにすることはできないので、答えは&lt;code&gt;0&lt;/code&gt;になります。
対して、全ての連結成分が二部グラフである場合、次の総和が答えとなります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各連結成分において&lt;code&gt;白の頂点の数*黒の頂点の数-既に接続している辺の数&lt;/code&gt;が新たに追加できる辺の数となります。&lt;/li&gt;
&lt;li&gt;連結成分の数が&lt;code&gt;K&lt;/code&gt;個であるとき、&lt;code&gt;1&amp;lt;=i&amp;lt;j&amp;lt;=K&lt;/code&gt;となる二部グラフ&lt;code&gt;i,j&lt;/code&gt;において、&lt;code&gt;iの頂点の数*jの頂点の数&lt;/code&gt;が新たに追加できる辺の数となります。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var E = new (int u, int v)[M];

    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--;
        v--;
        G[u].Add(v);
        G[v].Add(u);
        E[i] = (u, v);
    }

    var colors = new int[N];
    Array.Fill(colors, -1);
    var queue = new Queue&amp;lt;int&amp;gt;();
    var bipartiteSize = new List&amp;lt;long&amp;gt;();
    var isBipartiteNode = new bool[N];

    long answer = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (colors[i] != -1) continue;
        var isBipartite = true;
        queue.Enqueue(i);
        colors[i] = 0;
        long c0 = 0;
        long c1 = 0;
        var list = new List&amp;lt;int&amp;gt;();
        while (queue.Count &amp;gt; 0)
        {
            var u = queue.Dequeue();
            list.Add(u);
            if (colors[u] == 0) c0++;
            else c1++;

            foreach (var v in G[u])
            {
                if (colors[u] == colors[v]) isBipartite = false;
                if (colors[v] != -1) continue;
                colors[v] = colors[u] ^ 1;
                queue.Enqueue(v);
            }
        }

        if (!isBipartite)
        {
            Console.WriteLine(0);
            return;
        }

        bipartiteSize.Add(c0 + c1);
        answer += c0 * c1;
    }

    answer -= E.Count(x =&amp;gt; colors[x.u] != colors[x.v]);

    var cum = bipartiteSize.Sum();
    foreach (var size in bipartiteSize)
    {
        cum -= size;
        answer += size * cum;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc282/tasks/abc282_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc282/submissions/37361144"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;個の頂点と&lt;code&gt;1&amp;lt;=i&amp;lt;j&amp;lt;=N&lt;/code&gt;となる頂点&lt;code&gt;i,j&lt;/code&gt;間の辺の重さが&lt;code&gt;(A[i]^A[j]+A[j]^[i])%M&lt;/code&gt;としたときの最大全域木の重みが答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    mint.Modulo = M;
    var list = new List&amp;lt;(long V, int A, int B)&amp;gt;(N * (N - 1));

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var x = A[i];
            var y = A[j];
            var v = mint.Power(x, y) + mint.Power(y, x);
            list.Add((v, i, j));
        }
    }

    var dsu = new DisjointSetUnion(N);
    long answer = 0;
    foreach (var (v, a, b) in list.OrderByDescending(x =&amp;gt; x.V))
    {
        if (dsu.IsSame(a, b)) continue;

        dsu.Merge(a, b);
        answer += v;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC281</title>
			<link>https://blog.aconcavy.dev/posts/20221210abc281</link>
			<description>&lt;p&gt;AtCoder Grand Contest 281の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221210abc281</guid>
			<pubDate>Sun, 11 Dec 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Grand Contest 281の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc281"&gt;https://atcoder.jp/contests/abc281&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37136228"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;生成すべき非負整数は、&lt;code&gt;0,1,2,...,N&lt;/code&gt;の&lt;code&gt;N+1&lt;/code&gt;個の整数を逆順に表示したものとなります。
やりやすい方法で解きましょう。&lt;/p&gt;
&lt;h4 id="forn0"&gt;&lt;code&gt;for&lt;/code&gt;文で&lt;code&gt;N&lt;/code&gt;から&lt;code&gt;0&lt;/code&gt;まで逆順に表示する方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    for (var i = N; i &amp;gt;= 0; i--)
    {
        Console.WriteLine(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="enumerable.range"&gt;&lt;code&gt;Enumerable.Range&lt;/code&gt;で数列を生成して逆順に表示する方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = Enumerable.Range(0, N + 1).Reverse();
    Console.WriteLine(string.Join(Environment.NewLine, answer));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37144142"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;が条件を満たすかどうか、問題文に与えられた条件を詳細に分割して一つずつ判定していきます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の長さは&lt;code&gt;英大文字+6桁の整数+英大文字&lt;/code&gt;の&lt;code&gt;8&lt;/code&gt;であるか。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の先頭の文字は英文字であり、大文字であるか。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の末尾の文字は英文字であり、大文字であるか。&lt;/li&gt;
&lt;li&gt;英大文字に囲まれた文字列は数値に変換でき、&lt;code&gt;100000&lt;/code&gt;以上&lt;code&gt;999999&lt;/code&gt;以下であるか。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全ての条件を満たす場合、答えは&lt;code&gt;Yes&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.Length == 1 + 6 + 1;
    answer &amp;amp;= char.IsLetter(S[0]) &amp;amp;&amp;amp; char.IsUpper(S[0]);
    answer &amp;amp;= char.IsLetter(S[^1]) &amp;amp;&amp;amp; char.IsUpper(S[^1]);
    if (answer)
    {
        answer &amp;amp;= int.TryParse(S[1..7], out var val);
        answer &amp;amp;= 100000 &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= 999999;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37147756"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目の曲までの時間の累積和をとり、&lt;code&gt;i&lt;/code&gt;番目に&lt;code&gt;T&lt;/code&gt;秒を超えた曲が答えとなる曲であり、&lt;code&gt;T&lt;/code&gt;から&lt;code&gt;i-1&lt;/code&gt;番目の曲が終わった時間を引いた秒数が答えとなる時点となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, T) = Scanner.Scan&amp;lt;int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    T %= cum[N];
    var num = LowerBound(cum, T);
    var time = T - cum[Math.Max(0, num - 1)];
    Console.WriteLine($&amp;quot;{num} {time}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37157390"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][k][d]:=i番目の項までみたときにk項使い、和の余りがdのときの最大値&lt;/code&gt;とした動的計画法を解きます。
遷移として、&lt;code&gt;u&lt;/code&gt;を遷移前の和の余り、&lt;code&gt;v=(u+A[i])%D&lt;/code&gt;を遷移後の和の余りとしたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;番目の項を使わない場合: &lt;code&gt;dp[i+1][k][u] := Max(dp[i+1][k][u], dp[i][k][u])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;番目の項を使う場合 (&lt;code&gt;k&amp;lt;K&lt;/code&gt;): &lt;code&gt;dp[i+1][k][v] := Max(dp[i+1][k+1][v], dp[i][k][u]+A[i])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;番目の項まで見たときに&lt;code&gt;K&lt;/code&gt;項使い、和の余りが&lt;code&gt;0&lt;/code&gt;の時の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K, D) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var dp = new long[N + 1, K + 1, D];
    const long inf = (long)1e18;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var k = 0; k &amp;lt;= K; k++)
        {
            for (var d = 0; d &amp;lt; D; d++)
            {
                dp[i, k, d] = -inf;
            }
        }
    }

    dp[0, 0, 0] = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var k = 0; k &amp;lt;= K; k++)
        {
            for (var u = 0; u &amp;lt; D; u++)
            {
                var v = (u + A[i]) % D;
                dp[i + 1, k, u] = Math.Max(dp[i + 1, k, u], dp[i, k, u]);
                if (k + 1 &amp;lt;= K)
                {
                    dp[i + 1, k + 1, v] = Math.Max(dp[i + 1, k + 1, v], dp[i, k, u] + A[i]);
                }
            }
        }
    }

    var answer = dp[N, K, 0] &amp;lt; 0 ? -1 : dp[N, K, 0];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc281/tasks/abc281_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC281/submissions/37175993"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各&lt;code&gt;i&lt;/code&gt;について、毎回配列をソートしてしまうと、全体の時間計算量が&lt;code&gt;O((N-M+1)(NlogN+K))&lt;/code&gt;となり実行時間制限に間に合いません。
そこで、順序付けできる多重集合のデータ構造を使い、各&lt;code&gt;i&lt;/code&gt;における値の集合を管理しながら昇順&lt;code&gt;K&lt;/code&gt;個の総和を計算していきます。&lt;br /&gt;
&lt;code&gt;i==1&lt;/code&gt;について、集合には&lt;code&gt;M&lt;/code&gt;項目までの値があり、総和は&lt;code&gt;M&lt;/code&gt;項までの昇順&lt;code&gt;K&lt;/code&gt;個の総和となります。&lt;br /&gt;
&lt;code&gt;i==2&lt;/code&gt;について、&lt;code&gt;i==1&lt;/code&gt;の総和から&lt;code&gt;A[1]&lt;/code&gt;または集合のうち&lt;code&gt;K&lt;/code&gt;番目の値を引き、集合から&lt;code&gt;A[1]&lt;/code&gt;を削除します。
また、&lt;code&gt;A[2+M]&lt;/code&gt;を集合に追加し、&lt;code&gt;A[2+M]&lt;/code&gt;または集合のうち&lt;code&gt;K&lt;/code&gt;番目の値を総和に足します。&lt;br /&gt;
&lt;code&gt;i&amp;gt;2&lt;/code&gt;についても同様の操作を行うことで、各&lt;code&gt;i&lt;/code&gt;についての総和を時間計算量&lt;code&gt;O(logM)&lt;/code&gt;で求めることができ、全体の時間計算量&lt;code&gt;O((N-M+1)logM)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;p&gt;C#の標準ライブラリでは、多重集合を扱うクラスが存在しないため、多重集合のデータ構造は自前の実装が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var set = new Set&amp;lt;long&amp;gt;(true);
    for (var i = 0; i &amp;lt; M; i++)
    {
        set.Add(A[i]);
    }

    long sum = 0;
    for (var i = 0; i &amp;lt; K; i++)
    {
        sum += set.ElementAt(i);
    }

    var answer = new List&amp;lt;long&amp;gt;(N - M + 1) { sum };

    for (var i = M; i &amp;lt; N; i++)
    {
        var x = A[i - M];
        sum -= Math.Min(x, set.ElementAt(K - 1));
        set.Remove(x);

        set.Add(A[i]);
        sum += Math.Min(A[i], set.ElementAt(K - 1));

        answer.Add(sum);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC280</title>
			<link>https://blog.aconcavy.dev/posts/20221203abc280</link>
			<description>&lt;p&gt;AtCoder Grand Contest 280の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221203abc280</guid>
			<pubDate>Sat, 03 Dec 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Grand Contest 280の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280"&gt;https://atcoder.jp/contests/abc280&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/36947925"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列として入力をとり、全ての文字から&lt;code&gt;#&lt;/code&gt;の数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var answer = 0;
    for (var i = 0; i &amp;lt; H; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        foreach (var c in S)
        {
            if (c == '#') answer++;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/36952001"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S[k]=A[1]+A[2]+...A[k-1]+A[k]&lt;/code&gt;であることから、&lt;code&gt;S[k]=S[k-1]+A[k]&lt;/code&gt;であることがわかります。
そのため、&lt;code&gt;i==1&lt;/code&gt;のときは&lt;code&gt;A[1]=S[1]&lt;/code&gt;であり、&lt;code&gt;i&amp;gt;1&lt;/code&gt;の場合は&lt;code&gt;A[i]=S[i]-S[i-1]&lt;/code&gt;として、答えとなる数列&lt;code&gt;A&lt;/code&gt;を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var S = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var A = new long[N];
    A[0] = S[0];
    for (var i = 1; i &amp;lt; N; i++)
    {
        A[i] = S[i] - S[i - 1];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, A));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/36972273"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;の長さの範囲では&lt;code&gt;S[i]!=T[i]&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;が答えとなり、&lt;code&gt;T&lt;/code&gt;が&lt;code&gt;S&lt;/code&gt;の最後に文字が追加されている文字列である場合は、&lt;code&gt;T&lt;/code&gt;の最後が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (S[i] != T[i])
        {
            Console.WriteLine(i + 1);
            return;
        }
    }

    Console.WriteLine(T.Length);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/37000066"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt;について素因数分解を行い、&lt;code&gt;K&lt;/code&gt;の倍数であるために必要な素数とその個数を求めます。
そして、ある素数をその必要な個数以上使ったときの&lt;code&gt;n&lt;/code&gt;の値の最大が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;long&amp;gt;();
    long answer = 0;
    foreach (var (prime, required) in Prime.GetFactorDictionary(K))
    {
        long n = 0;
        var used = 0;
        while (used &amp;lt; required)
        {
            n += prime;
            var x = n;
            while (x % prime == 0)
            {
                x /= prime;
                used++;
            }
        }

        answer = Math.Max(answer, n);
    }

    Console.WriteLine(answer);
}

public static class Prime
{
    public static IDictionary&amp;lt;long, int&amp;gt; GetFactorDictionary(long value)
    {
        var factors = new Dictionary&amp;lt;long, int&amp;gt;();
        if (value &amp;lt; 2) return factors;

        void CountUp(long n)
        {
            if (value % n != 0) return;
            factors[n] = 0;
            while (value % n == 0)
            {
                value /= n;
                factors[n]++;
            }
        }

        CountUp(2);
        for (var i = 3L; i * i &amp;lt;= value; i += 2) CountUp(i);
        if (value &amp;gt; 1) factors[value] = 1;
        return factors;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc280/tasks/abc280_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc280/submissions/37000080"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i] := dp[i+2]*(i+2から遷移する確率) + dp[i+1]*(i+1から遷移する確率) + 1&lt;/code&gt;のような攻撃回数についての期待値dpを行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dp = new mint[N + 1];
    var p2 = P * mint.Inverse(100);
    var p1 = 1 - p2;
    for (var i = N - 1; i &amp;gt;= 0; i--)
    {
        dp[i] = dp[Math.Min(N, i + 1)] * p1 + dp[Math.Min(N, i + 2)] * p2 + 1;
    }

    var answer = dp[0];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC279</title>
			<link>https://blog.aconcavy.dev/posts/20221126abc279</link>
			<description>&lt;p&gt;AtCoder Grand Contest 279の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221126abc279</guid>
			<pubDate>Sat, 26 Nov 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Grand Contest 279の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc279"&gt;https://atcoder.jp/contests/abc279&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36792996"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;を順にみていき、文字&lt;code&gt;S[i]&lt;/code&gt;が&lt;code&gt;v&lt;/code&gt;なら&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;w&lt;/code&gt;なら&lt;code&gt;2&lt;/code&gt;を足した総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    int F(char c)
    {
        return c switch
        {
            'v' =&amp;gt; 1,
            'w' =&amp;gt; 2,
            _ =&amp;gt; 0,
        };
    }

    var answer = 0;
    foreach (var c in S)
    {
        answer += F(c);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36797148"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;に文字列&lt;code&gt;T&lt;/code&gt;が含まれているかを調べます。
方法としては以下のようなものがあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt;の&lt;code&gt;Contains&lt;/code&gt;メソッド(計算量&lt;code&gt;O(S)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;の始点を固定し&lt;code&gt;T&lt;/code&gt;と比較する(計算量&lt;code&gt;O(ST)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%9C%E3%82%A4%E3%83%A4%E3%83%BC-%E3%83%A0%E3%83%BC%E3%82%A2%E6%96%87%E5%AD%97%E5%88%97%E6%A4%9C%E7%B4%A2%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0"&gt;ボイヤームーア法&lt;/a&gt;で探索する(計算量&lt;code&gt;O(S)&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = S.Contains(T);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36802481"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;の列を並べ替えて&lt;code&gt;T&lt;/code&gt;と等しくできるかどうかは、&lt;code&gt;S&lt;/code&gt;の列の集合と&lt;code&gt;T&lt;/code&gt;の列の集合が一致しているか確認できればいいので、``S&lt;code&gt;の列と&lt;/code&gt;T`の列をそれぞれ文字列として辞書などのデータ構造などで個数を管理することで、集合が一致しているかを比較できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = new char[H][];
    var T = new char[H][];
    for (var k = 0; k &amp;lt; 2; k++)
    {
        for (var i = 0; i &amp;lt; H; i++)
        {
            (k == 0 ? S : T)[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        }
    }

    var dictS = new Dictionary&amp;lt;string, int&amp;gt;();
    var dictT = new Dictionary&amp;lt;string, int&amp;gt;();
    for (var j = 0; j &amp;lt; W; j++)
    {
        var builderS = new StringBuilder();
        var builderT = new StringBuilder();
        for (var i = 0; i &amp;lt; H; i++)
        {
            builderS.Append(S[i][j]);
            builderT.Append(T[i][j]);
        }

        var s = builderS.ToString();
        var t = builderT.ToString();
        if (!dictS.ContainsKey(s)) dictS[s] = 0;
        dictS[s]++;
        if (!dictT.ContainsKey(t)) dictT[t] = 0;
        dictT[t]++;
    }

    var answer = true;
    foreach (var (s, c) in dictS)
    {
        answer &amp;amp;= dictT.ContainsKey(s) &amp;amp;&amp;amp; dictT[s] == c;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36815340"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/editorial/5288"&gt;公式解説&lt;/a&gt;にもあるように、&lt;code&gt;F(g)=B(g-1)+A/Sqrt(g)&lt;/code&gt;は下に凸な関数であるため、&lt;code&gt;g&lt;/code&gt;に対する三部探索を行い、最小となる&lt;code&gt;g&lt;/code&gt;を求めます。
この&lt;code&gt;g&lt;/code&gt;は浮動小数点のため、その付近の整数値のうち、&lt;code&gt;F(g)&lt;/code&gt;が最小となる値が答えとなります。
また、三部探索を行う際の範囲として、&lt;code&gt;F(g)&amp;lt;F(1)=A&lt;/code&gt;以下であればいいので、&lt;code&gt;1&amp;lt;=g&amp;lt;=A/B&lt;/code&gt;であれば十分であることがわかります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;long, long&amp;gt;();

    double F(double g)
    {
        return B * (g - 1) + A / Math.Sqrt(g);
    }

    var r = (A + B - 1) / B;
    var g = (long)TernarySearch(0, r, F, 1e-2);
    var answer = new[] { Math.Max(g - 1, 1), g, g + 1 }.Select(x =&amp;gt; F(x)).Min();
    Console.WriteLine(answer);
}

public static double TernarySearch(double l, double r, Func&amp;lt;double, double&amp;gt; func, double eps = 1e-9)
{
    while (r - l &amp;gt; eps)
    {
        var d = (r - l) / 3;
        var (ml, mr) = (l + d, r - d);
        if (func(ml) &amp;lt; func(mr)) r = mr;
        else l = ml;
    }
    return (l + r) / 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc279/tasks/abc279_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC279/submissions/36822297"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直にシミュレーションしてしまうと、時間計算量が&lt;code&gt;O(M^2)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
求めるものは&lt;code&gt;B[j]==1&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;の位置&lt;code&gt;S&lt;/code&gt;であるため、位置&lt;code&gt;S&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;の集合を辞書などのデータ構造で管理します。
&lt;code&gt;x=A[k],y=A[k]+1&lt;/code&gt;としたとき、&lt;code&gt;B[x]&lt;/code&gt;と&lt;code&gt;B[y]&lt;/code&gt;を入れ替えるということは、位置&lt;code&gt;x&lt;/code&gt;と位置&lt;code&gt;y&lt;/code&gt;にあるそれぞれの&lt;code&gt;i&lt;/code&gt;の集合を入れ替えることになります。
また、&lt;code&gt;i==k&lt;/code&gt;のときは操作しないということは、入れ替えの操作時に&lt;code&gt;x&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;の集合に&lt;code&gt;k&lt;/code&gt;が含まれていれば、&lt;code&gt;i&lt;/code&gt;以外を&lt;code&gt;y&lt;/code&gt;に移動することになります。
このとき、一つずつ移動をしてしまうと時間計算量が&lt;code&gt;O(M)&lt;/code&gt;になってしまいますが、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;の集合の参照を入れ替えた後に、&lt;code&gt;y&lt;/code&gt;の集合から&lt;code&gt;k&lt;/code&gt;を削除し、&lt;code&gt;x&lt;/code&gt;の集合に&lt;code&gt;k&lt;/code&gt;を追加することで、時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で操作を行うことができます。
全体の時間計算量は&lt;code&gt;O(N+MlogN)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();

    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        dict[i] = new HashSet&amp;lt;int&amp;gt;();
    }

    for (var i = 0; i &amp;lt; M; i++)
    {
        dict[0].Add(i);
    }

    for (var k = 0; k &amp;lt; M; k++)
    {
        var i = k;
        var x = A[k];
        var y = A[k] + 1;
        (dict[x], dict[y]) = (dict[y], dict[x]);
        if (dict[x].Contains(i))
        {
            dict[x].Remove(i);
            dict[y].Add(i);
        }
        else if (dict[y].Contains(i))
        {
            dict[y].Remove(i);
            dict[x].Add(i);
        }
    }

    var answer = new int[M];
    foreach (var (s, set) in dict)
    {
        foreach (var i in set)
        {
            answer[i] = s + 1;
        }
    }

    Console.WriteLine(string.Join(Environment.NewLine, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC278</title>
			<link>https://blog.aconcavy.dev/posts/20221119abc278</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 278の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221119abc278</guid>
			<pubDate>Sat, 19 Nov 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 278の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc278"&gt;https://atcoder.jp/contests/abc278&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36599335"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;で初期化した長さ&lt;code&gt;N&lt;/code&gt;の配列に先頭から&lt;code&gt;A[i+K]&lt;/code&gt;の値を&lt;code&gt;N-K&lt;/code&gt;回代入することで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = new int[N];
    for (var i = 0; i &amp;lt; N - K; i++)
    {
        B[i] = A[i + K];
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, B));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36606958"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;見間違えやすい時刻は、元の時刻の&lt;code&gt;AB:CD&lt;/code&gt;となる時刻であり、&lt;code&gt;AB&lt;/code&gt;は時の&lt;code&gt;10&lt;/code&gt;の位と分の&lt;code&gt;10&lt;/code&gt;の位の値、&lt;code&gt;CD&lt;/code&gt;は時の&lt;code&gt;1&lt;/code&gt;の位と分の&lt;code&gt;1&lt;/code&gt;の位の値になり、&lt;code&gt;0&amp;lt;=AB&amp;lt;24&lt;/code&gt;かつ&lt;code&gt;0&amp;lt;=AB&amp;lt;60&lt;/code&gt;であることが必要です。
順に時刻をみていき、条件を満たす時刻が答えとなります。&lt;br /&gt;
&lt;code&gt;h=23, m=59&lt;/code&gt;のときなど、&lt;code&gt;00 00&lt;/code&gt;が答えとなることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    for (var h = H; h &amp;lt; 24; h++)
    {
        for (var m = 0; m &amp;lt; 60; m++)
        {
            if (h == H &amp;amp;&amp;amp; m &amp;lt; M) continue;
            var ab = h / 10 * 10 + m / 10;
            var cd = h % 10 * 10 + m % 10;
            if (ab &amp;lt; 24 &amp;amp;&amp;amp; cd &amp;lt; 60)
            {
                Console.WriteLine($&amp;quot;{h} {m}&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;0 0&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36610705"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ユーザがフォローしている人の集合を辞書で管理し、&lt;code&gt;t==1,2&lt;/code&gt;のときは集合を更新、&lt;code&gt;t==3&lt;/code&gt;のときはそれぞれのユーザがフォローしている人の集合に存在しているかを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, HashSet&amp;lt;int&amp;gt;&amp;gt;();
    while (Q-- &amp;gt; 0)
    {
        var (t, a, b) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        if (!dict.ContainsKey(a)) dict[a] = new HashSet&amp;lt;int&amp;gt;();
        if (!dict.ContainsKey(b)) dict[b] = new HashSet&amp;lt;int&amp;gt;();

        if (t == 1)
        {
            dict[a].Add(b);
        }
        else if (t == 2)
        {
            dict[a].Remove(b);
        }
        else
        {
            var answer = dict[a].Contains(b) &amp;amp;&amp;amp; dict[b].Contains(a);
            Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36621868"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36652094"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに配列のすべての値を更新してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;になり、実行時間制限に間に合いません。&lt;br /&gt;
クエリの形式が&lt;code&gt;1&lt;/code&gt;における最新の全体更新の時間と値、数列&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;i&lt;/code&gt;番目の値が最後に更新された時間を管理し、クエリの形式が&lt;code&gt;2&lt;/code&gt;か&lt;code&gt;3&lt;/code&gt;のときに&lt;code&gt;i&lt;/code&gt;番目の更新された時間が最新の全体更新の時間よりも前ならば、&lt;code&gt;i&lt;/code&gt;番目の値を最新の全体更新の値に変更してから処理を行うことで、時間計算量&lt;code&gt;O(N+Q)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
区間変更区間更新が可能な遅延セグメント木などのデータ構造を用いてクエリごとに値を更新することでも、時間計算量&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var latest = (T: -1, X: 0);
    var updated = new int[N];
    Array.Fill(updated, -1);

    void Update(int i, int x)
    {
        if (updated[i] &amp;lt; latest.T) A[i] = latest.X;
    }

    for (var t = 0; t &amp;lt; Q; t++)
    {
        var query = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
        var q = query[0];
        if (q == 1)
        {
            var x = query[1];
            latest = (t, x);
        }
        else if (q == 2)
        {
            var (i, x) = (query[1] - 1, query[2]);
            Update(i);
            A[i] += x;
            updated[i] = t;
        }
        else
        {
            var i = query[1] - 1;
            Update(i);
            Console.WriteLine(A[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc278/tasks/abc278_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC278/submissions/36626239"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直に範囲にある数を計算してしまうと、時間計算量が&lt;code&gt;O(H^2W^2)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
そこで、マスに書かれている値&lt;code&gt;c&lt;/code&gt;ごとの二次元累積和を求めておくと、マス目全体の&lt;code&gt;c&lt;/code&gt;の数と黒く塗りつぶした部分の&lt;code&gt;c&lt;/code&gt;の数を引くことで、塗りつぶされていないマスに書かれている&lt;code&gt;c&lt;/code&gt;の数を数え上げることができます。
これにより、二次元累積和の構築には時間計算量&lt;code&gt;O(HW)&lt;/code&gt;がかかり、&lt;code&gt;c&lt;/code&gt;の数え上げには時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。&lt;br /&gt;
そして、各&lt;code&gt;(k,l)&lt;/code&gt;ごとに&lt;code&gt;N&lt;/code&gt;種類の&lt;code&gt;c&lt;/code&gt;の数を求めることになるので、全体計算量&lt;code&gt;O(HW+HWN)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W, N, h, w) = Scanner.Scan&amp;lt;int, int, int, int, int&amp;gt;();
    var A = new int[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var cum = new CumulativeSum2D[N].Select(_ =&amp;gt; new CumulativeSum2D(H, W)).ToArray();
    for (var i = 0; i &amp;lt; H; i++)
    {
        for (var j = 0; j &amp;lt; W; j++)
        {
            var a = A[i][j] - 1;
            cum[a].Add(i, j, 1);
        }
    }

    var answer = new int[H - h + 1].Select(_ =&amp;gt; new int[W - w + 1]).ToArray();

    for (var i = 0; i &amp;lt; H - h + 1; i++)
    {
        for (var j = 0; j &amp;lt; W - w + 1; j++)
        {
            var sum = 0;
            for (var k = 0; k &amp;lt; N; k++)
            {
                var all = cum[k].Sum(H, W);
                var blak = cum[k].Sum(i, j, i + h, j + w);
                if (all - blak &amp;gt; 0) sum++;
            }

            answer[i][j] = sum;
        }
    }

    Printer.Print2D(answer, &amp;quot; &amp;quot;);
}

public class CumulativeSum2D
{
    public int Height { get; }
    public int Width { get; }
    private readonly long[] _data;
    private readonly long[] _sum;
    private bool _isUpdated;

    public CumulativeSum2D(int height, int width)
    {
        if (height &amp;lt;= 0) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt;= 0) throw new ArgumentOutOfRangeException(nameof(width));
        Height = height;
        Width = width;
        _data = new long[height * width];
        _sum = new long[(height + 1) * (width + 1)];
    }

    public void Add(int height, int width, long value)
    {
        if (height &amp;lt; 0 || Height &amp;lt;= height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt;= width) throw new ArgumentOutOfRangeException(nameof(width));
        _isUpdated = false;
        _data[height * Width + width] += value;
    }

    public void Set(int height, int width, long value)
    {
        if (height &amp;lt; 0 || Height &amp;lt;= height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt;= width) throw new ArgumentOutOfRangeException(nameof(width));
        _isUpdated = false;
        _data[height * Width + width] = value;
    }

    public long Get(int height, int width)
    {
        if (height &amp;lt; 0 || Height &amp;lt;= height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt;= width) throw new ArgumentOutOfRangeException(nameof(width));
        return _data[height * Width + width];
    }

    public long Sum(int height, int width)
    {
        if (height &amp;lt; 0 || Height &amp;lt; height) throw new ArgumentOutOfRangeException(nameof(height));
        if (width &amp;lt; 0 || Width &amp;lt; width) throw new ArgumentOutOfRangeException(nameof(width));
        if (!_isUpdated) Build();
        return _sum[height * (Width + 1) + width];
    }

    public long Sum(int height1, int width1, int height2, int width2)
    {
        if (height1 &amp;lt; 0 || Height &amp;lt; height1) throw new ArgumentOutOfRangeException(nameof(height1));
        if (width1 &amp;lt; 0 || Width &amp;lt; width1) throw new ArgumentOutOfRangeException(nameof(width1));
        if (height2 &amp;lt; 0 || Height &amp;lt; height2) throw new ArgumentOutOfRangeException(nameof(height2));
        if (width2 &amp;lt; 0 || Width &amp;lt; width2) throw new ArgumentOutOfRangeException(nameof(width2));
        if (!_isUpdated) Build();
        var w1 = Width + 1;
        return _sum[height1 * w1 + width1]
               + _sum[height2 * w1 + width2]
               - _sum[height2 * w1 + width1]
               - _sum[height1 * w1 + width2];
    }

    private void Build()
    {
        _isUpdated = true;
        var w1 = Width + 1;
        _sum[0] = _sum[w1] = _sum[1] = 0;
        for (var i = 1; i &amp;lt;= Height; i++)
        for (var j = 1; j &amp;lt;= Width; j++)
            _sum[i * w1 + j] =
                _sum[i * w1 + (j - 1)]
                + _sum[(i - 1) * w1 + j]
                - _sum[(i - 1) * w1 + (j - 1)]
                + _data[(i - 1) * Width + (j - 1)];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC277</title>
			<link>https://blog.aconcavy.dev/posts/20221112abc277</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 277の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221112abc277</guid>
			<pubDate>Sat, 12 Nov 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 277の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc277"&gt;https://atcoder.jp/contests/abc277&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36407369"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[i]&lt;/code&gt;を順にみていき、&lt;code&gt;A[i]==X&lt;/code&gt;となる位置が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A[i] == X) answer = i + 1;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36412022"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一つ一つの文字を条件式として判別しても答えを求めることが可能ですが、2文字目の判定の対象が多いので、配列や&lt;code&gt;HashSet&lt;/code&gt;等のデータ構造に集合として値を用意し、その集合に含まれているかどうかを判定することで、簡単に記述することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = true;
    var F = new HashSet&amp;lt;char&amp;gt; { 'H', 'D', 'C', 'S' };
    var G = new HashSet&amp;lt;char&amp;gt; { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
    var memo = new HashSet&amp;lt;string&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var s = Scanner.Scan&amp;lt;string&amp;gt;();
        answer &amp;amp;= F.Contains(s[0]);
        answer &amp;amp;= G.Contains(s[1]);
        answer &amp;amp;= !memo.Contains(s);
        memo.Add(s);
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36416984"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;階層を頂点としたグラフを構築し、深さ優先探索や幅優先探索を行うことで、行くことができる階層を探索して最高の階層を求めます。&lt;br /&gt;
階層をそのまま頂点としたグラフを配列で構築してしまうと、はしごがつながっていない階層含めて&lt;code&gt;1e9&lt;/code&gt;もの空間計算量が必要になってしまい、実行時間制限に間に合わなくなってしまいます。
そこで、頂点を圧縮したり、辞書などのデータ構造を用いることで、はしごがつながっていない階層を無視することができ、最大でも&lt;code&gt;4e5&lt;/code&gt;程度の空間計算量で収まり、実行時間制限内に処理することができるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var G = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (!G.ContainsKey(a)) G[a] = new List&amp;lt;int&amp;gt;();
        if (!G.ContainsKey(b)) G[b] = new List&amp;lt;int&amp;gt;();
        G[a].Add(b);
        G[b].Add(a);
    }

    var used = new HashSet&amp;lt;int&amp;gt; { 1 };
    var queue = new Queue&amp;lt;int&amp;gt;();
    queue.Enqueue(1);
    while (queue.Count &amp;gt; 0)
    {
        var u = queue.Dequeue();
        if (!G.ContainsKey(u)) continue;
        foreach (var v in G[u])
        {
            if (used.Contains(v)) continue;
            used.Add(v);
            queue.Enqueue(v);
        }
    }

    var answer = used.Max();
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36436734"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36455348"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作について、あるカードの整数&lt;code&gt;v&lt;/code&gt;をテーブルに置いたとき、次に出すことができるカードは&lt;code&gt;v&lt;/code&gt;または&lt;code&gt;(v+1)%M&lt;/code&gt;であることから、整数&lt;code&gt;v&lt;/code&gt;のカードを出した時は、整数&lt;code&gt;v&lt;/code&gt;のカードを全て出すことができます。
そのため、カードの整数ごとに出すことのできる枚数や総和を辞書などでまとめあげることができます。
整数&lt;code&gt;v&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を出した時の総和&lt;code&gt;s&lt;/code&gt;のペアを&lt;code&gt;P&lt;/code&gt;とし、&lt;code&gt;P&lt;/code&gt;を&lt;code&gt;v&lt;/code&gt;でソートすると、&lt;code&gt;P[i+1].v%M==(P[i].v+1)%M&lt;/code&gt;となる区間の総和が出すことができるカードの総和となります。
この区間の総和は尺取り法で求めることができ、その最大値を&lt;code&gt;A&lt;/code&gt;の総和から引いたものが答えとなります。
また、&lt;code&gt;v==M-1&lt;/code&gt;のとき&lt;code&gt;(v+1)%M&lt;/code&gt;は&lt;code&gt;0&lt;/code&gt;になり、円環になることがあるので注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    long sum = 0;
    var dict = new Dictionary&amp;lt;int, long&amp;gt;();
    foreach (var a in A)
    {
        if (!dict.ContainsKey(a)) dict[a] = 0;
        dict[a] += a;
        sum += a;
    }

    var K = dict.Count;
    var B = new List&amp;lt;(int V, long S)&amp;gt;(dict.Select(kv =&amp;gt; (kv.Key, kv.Value)));
    B.Sort();
    var l = 0;
    var r = 0;

    const long inf = (long)1e18;
    var answer = inf;
    while (l &amp;lt; K)
    {
        r = l;
        var s = B[r].S;
        while (r + 1 &amp;lt; l + K &amp;amp;&amp;amp; (B[(r + 1) % K].V % M) == (B[r % K].V + 1) % M)
        {
            s += B[(r + 1) % K].S;
            r++;
        }

        answer = Math.Min(answer, sum - s);
        l = r + 1;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc277/tasks/abc277_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC277/submissions/36429660"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;スイッチは2回押すと元の状態に戻るので、スイッチの状態2通りについての各頂点のコストを管理し、現在のスイッチの状態を持ちながら幅優先探索を行うことで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var G = new List&amp;lt;(int U, int A)&amp;gt;[N];
    G = new List&amp;lt;(int U, int A)&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;(int U, int A)&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v, a) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
        u--;
        v--;
        G[u].Add((v, a));
        G[v].Add((u, a));
    }

    var T = new HashSet&amp;lt;int&amp;gt;();
    if (K &amp;gt; 0)
    {
        var S = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
        T = new HashSet&amp;lt;int&amp;gt;(S);
    }

    const int inf = (int)1e9;
    var costs = new int[2][].Select(_ =&amp;gt; new int[N]).ToArray();
    Array.Fill(costs[0], inf);
    Array.Fill(costs[1], inf);
    costs[0][0] = 0;

    var queue = new Queue&amp;lt;(int T, int U, long Cost)&amp;gt;();
    queue.Enqueue((0, 0, 0));
    while (queue.Count &amp;gt; 0)
    {
        var (ut, u, uc) = queue.Dequeue();
        var vt = ut;

        for (var i = 0; i &amp;lt; 2; i++)
        {
            foreach (var (v, a) in G[u])
            {
                if (a == vt) continue;
                var c = costs[ut][u] + 1;
                if (costs[vt][v] &amp;lt;= c) continue;
                costs[vt][v] = c;
                queue.Enqueue((vt, v, c));
            }

            if (T.Contains(u)) vt = ut ^ 1;
            else break;
        }
    }

    var answer = Math.Min(costs[0][N - 1], costs[1][N - 1]);
    if (answer == inf) answer = -1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC276</title>
			<link>https://blog.aconcavy.dev/posts/20221105abc276</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 276の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221105abc276</guid>
			<pubDate>Sat, 05 Nov 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 276の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276"&gt;https://atcoder.jp/contests/abc276&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36221467"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;を左から順番に調べて、&lt;code&gt;a&lt;/code&gt;が出現した場所を更新し、最後に更新された場所が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = -1;
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        if (S[i] == 'a') answer = i + 1;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36225653"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G[u][v]&lt;/code&gt;のように二次元配列で頂点&lt;code&gt;u&lt;/code&gt;が頂点&lt;code&gt;v&lt;/code&gt;と接続しているかを持ってしまうと、空間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまいます。&lt;br /&gt;
&lt;code&gt;N&lt;/code&gt;が最大で&lt;code&gt;10^5&lt;/code&gt;なので、二乗の&lt;code&gt;10^10&lt;/code&gt;の空間計算量が必要となってしまい、実行時間制限に間に合いません。
そこで、頂点ごとにリストを持ち、接続されている頂点を追加していくことで、空間計算量が最大でも&lt;code&gt;10^5*2&lt;/code&gt;に収まり、ソートの計算量とあわせて全体で&lt;code&gt;O(logN+N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (a, b) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        a--;
        b--;
        G[a].Add(b);
        G[b].Add(a);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i].Sort();
        var c = G[i].Count;
        if (c == 0) Console.WriteLine(0);
        else Console.WriteLine($&amp;quot;{c} {string.Join(&amp;quot; &amp;quot;, G[i].Select(x =&amp;gt; x + 1))}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36257482"&gt;コンテスト提出&lt;/a&gt;
&lt;a href="https://atcoder.jp/contests/abc276/submissions/36264063"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例を見てみると、&lt;code&gt;P&lt;/code&gt;の末尾が単調増加している部分の一つ手前(位置&lt;code&gt;i&lt;/code&gt;)から右側が変化していることがわかります。&lt;br /&gt;
また、変化後の&lt;code&gt;P[i]&lt;/code&gt;は、もとの&lt;code&gt;P[i]&lt;/code&gt;より小さいものと入れ替わっており、&lt;code&gt;i&lt;/code&gt;より右側が逆順にソートされていることがわかります。&lt;br /&gt;
ここで、&lt;code&gt;P[i]&lt;/code&gt;と入れ替える値は、&lt;code&gt;P[i]&lt;/code&gt;より小さいもので最大の値であり、&lt;code&gt;P&lt;/code&gt;の末尾は単調増加していることから、末尾から見て&lt;code&gt;P[i]&lt;/code&gt;より小さくなった値と入れ替えることで、辞書順の直前にすることができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;/code&gt;などでは&lt;code&gt;prev_permutation()&lt;/code&gt;メソッドを使って求めることもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var j = N - 2;
    var k = N - 1;
    while (P[j] &amp;lt; P[j + 1]) j--;
    while (P[j] &amp;lt; P[k]) k--;
    (P[j], P[k]) = (P[k], P[j]);
    Array.Sort(P, j + 1, N - (j + 1));
    for (var (l, r) = (j + 1, N - 1); l &amp;lt; r; l++, r--)
    {
        (P[l], P[r]) = (P[r], P[l]);
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, P));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36253185"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;が操作後に全て一致するには、&lt;code&gt;A[i] = 2^x * 3^y * V[i]&lt;/code&gt;で表すことができ、かつ&lt;code&gt;V[i]==V[j]&lt;/code&gt;である必要があります。
そして、&lt;code&gt;A&lt;/code&gt;における最大公約数を&lt;code&gt;g&lt;/code&gt;とすると、&lt;code&gt;A[i] = 2^x * 3^y * g&lt;/code&gt;で表すことができます。
このことから、&lt;code&gt;A[i]/g == 2^x * 3^y&lt;/code&gt;が成り立つかどうかを判定しつつ、全ての&lt;code&gt;A&lt;/code&gt;における&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;の総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var g = A.Aggregate(0L, Gcd);
    var answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var k = A[i] / g;

        while (k % 2 == 0)
        {
            k /= 2;
            answer++;
        }

        while (k % 3 == 0)
        {
            k /= 3;
            answer++;
        }

        if (k != 1)
        {
            Console.WriteLine(-1);
            return;
        }
    }

    Console.WriteLine(answer);
}

public static long Gcd(long a, long b) =&amp;gt; b == 0 ? a : Gcd(b, a % b);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36250764"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4方向のみ移動可能であるため、直前にいたマスに戻らずに同じマスに訪れることができた場合は、&lt;code&gt;n&amp;gt;=4&lt;/code&gt;であることが確定します。
そのため、直前に訪れたマスをメモしながら深さ優先探索を行い、開始始点にたどり着くことができるかを判定することで答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    var (sh, sw) = (0, 0);
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
        for (var j = 0; j &amp;lt; W; j++)
        {
            if (G[i][j] == 'S') (sh, sw) = (i, j);
        }
    }

    var D4 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1) };

    var used = new bool[H * W];
    var prev = new int[H * W];
    var s = sh * W + sw;

    bool Dfs(int ch, int cw)
    {
        var u = ch * W + cw;
        used[u] = true;
        var result = false;

        foreach (var (dh, dw) in D4)
        {
            var (nh, nw) = (ch + dh, cw + dw);
            var v = nh * W + nw;
            if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw) continue;
            if (G[nh][nw] == '#') continue;
            if (v == s &amp;amp;&amp;amp; v != prev[u]) result |= true;
            if (used[v]) continue;
            prev[v] = u;

            result |= Dfs(nh, nw);
        }

        return result;
    }

    var answer = Dfs(sh, sw);

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="f"&gt;&lt;a href="https://atcoder.jp/contests/abc276/tasks/abc276_f"&gt;問題F&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc276/submissions/36263019"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G[i][j]:=Max(1回目のカードA[i], 2回目のカードA[j])&lt;/code&gt;とすると、&lt;code&gt;k&lt;/code&gt;番目の期待値は&lt;code&gt;G[i][j] {i,j=1..k}&lt;/code&gt;の和を&lt;code&gt;k*k&lt;/code&gt;で割ったものとなります。
&lt;code&gt;k&lt;/code&gt;番目の試行を考えたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1回目に&lt;code&gt;k-1&lt;/code&gt;番目までのカードがでて、2回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでるとすると、&lt;code&gt;G[i][k]=Max(A[i],A[k])&lt;/code&gt;になる。&lt;/li&gt;
&lt;li&gt;1回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでて、2回目に&lt;code&gt;k-1&lt;/code&gt;番目までのカードがでるとすると、&lt;code&gt;G[k][i]=Max(A[k],A[i])&lt;/code&gt;になる。&lt;/li&gt;
&lt;li&gt;1回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでて、2回目に&lt;code&gt;k&lt;/code&gt;番目のカードがでるとすると、&lt;code&gt;G[k][k]=A[k]&lt;/code&gt;になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;k-1&lt;/code&gt;番目の&lt;code&gt;G[i][j] {i,j=1..(k-1)}&lt;/code&gt;の総和を&lt;code&gt;prev&lt;/code&gt;とすると、&lt;code&gt;k&lt;/code&gt;番目の&lt;code&gt;G[i][j] {i,j=1..k}&lt;/code&gt;の総和は、&lt;code&gt;prev + G[i][k]{i..(k-1)} + G[k][i] {i..(k-1)} + G[k][k]&lt;/code&gt;となります。
このとき、&lt;code&gt;G[i][k]{i..(k-1)}&lt;/code&gt;は、&lt;code&gt;k-1番目までのA[k]より小さい数*A[k]&lt;/code&gt;を&lt;code&gt;sumS&lt;/code&gt;、&lt;code&gt;k-1番目までのA[k]より大きい数の和&lt;/code&gt;を&lt;code&gt;sumL&lt;/code&gt;とし、&lt;code&gt;G[i][k]{i..(k-1)}==G[k][i] {i..(k-1)}&lt;/code&gt;であることから、&lt;code&gt;k-1&lt;/code&gt;から&lt;code&gt;k&lt;/code&gt;の総和の増分は&lt;code&gt;(sumS + sumL)*2 + A[k]&lt;/code&gt;であることがわかります。&lt;br /&gt;
このことから、&lt;code&gt;FenwickTree&lt;/code&gt;等を使って&lt;code&gt;k&lt;/code&gt;番目までの&lt;code&gt;A[k]&lt;/code&gt;より小さい数の個数と&lt;code&gt;A[k]&lt;/code&gt;より大きな数の和を管理しながら&lt;code&gt;k&lt;/code&gt;番目における合計&lt;code&gt;S[k]=S[k-1]+(sumS+sumL)*2+A[k]&lt;/code&gt;を計算していくことで、&lt;code&gt;k&lt;/code&gt;番目における期待値&lt;code&gt;S[k]/(k*k)&lt;/code&gt;を求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var (map, _) = Compress(A);
    var ft1 = new FenwickTree(N);
    var ft2 = new FenwickTree(N);
    var dp = new mint[N];
    dp[0] = A[0];
    ft1.Add(map[A[0]], 1);
    ft2.Add(map[A[0]], A[0]);

    for (var i = 1; i &amp;lt; N; i++)
    {
        var sumS = ft1.Sum(map[A[i]] + 1) * A[i];
        var sumL = ft2.Sum(map[A[i]] + 1, N);
        dp[i] = dp[i - 1] + (sumS + sumL) * 2 + A[i];

        ft1.Add(map[A[i]], 1);
        ft2.Add(map[A[i]], A[i]);
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        var curr = (mint)(i + 1) * (i + 1);
        Console.WriteLine(dp[i] / curr);
    }
}

public static (Dictionary&amp;lt;T, int&amp;gt; Map, Dictionary&amp;lt;int, T&amp;gt; ReMap) Compress&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source)
{
    var distinct = source.Distinct().ToArray();
    Array.Sort(distinct);
    var map = new Dictionary&amp;lt;T, int&amp;gt;();
    var remap = new Dictionary&amp;lt;int, T&amp;gt;();
    foreach (var (x, i) in distinct.Select((x, i) =&amp;gt; (x, i)))
    {
        map[x] = i;
        remap[i] = x;
    }

    return (map, remap);
}

public class FenwickTree
{
    public int Length { get; }
    private readonly mint[] _data;

    public FenwickTree(int length)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _data = new mint[length];
    }

    public void Add(int index, long value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index++;
        while (index &amp;lt;= Length)
        {
            _data[index - 1] += value;
            index += index &amp;amp; -index;
        }
    }

    public mint Sum(int length)
    {
        if (length &amp;lt; 0 || Length &amp;lt; length) throw new ArgumentOutOfRangeException(nameof(length));
        mint s = 0;
        while (length &amp;gt; 0)
        {
            s += _data[length - 1];
            length -= length &amp;amp; -length;
        }

        return s;
    }

    public mint Sum(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        return Sum(right) - Sum(left);
    }

    public int LowerBound(long value) =&amp;gt; Bound(value, (x, y) =&amp;gt; x &amp;lt;= y);
    public int UpperBound(long value) =&amp;gt; Bound(value, (x, y) =&amp;gt; x &amp;lt; y);

    private int Bound(long value, Func&amp;lt;long, long, bool&amp;gt; compare)
    {
        if (Length == 0 || compare(value, _data[0])) return 0;
        var x = 0;
        var r = 1;
        while (r &amp;lt; Length) r &amp;lt;&amp;lt;= 1;
        for (var k = r; k &amp;gt; 0; k &amp;gt;&amp;gt;= 1)
        {
            if (x + k - 1 &amp;gt;= Length || compare(value, _data[x + k - 1])) continue;
            value -= _data[x + k - 1];
            x += k;
        }

        return x;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC275</title>
			<link>https://blog.aconcavy.dev/posts/20221029abc275</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 275の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221029abc275</guid>
			<pubDate>Sat, 29 Oct 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 275の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc275"&gt;https://atcoder.jp/contests/abc275&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36033017"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;順番に&lt;code&gt;A&lt;/code&gt;の値を見ていき、それまでの最大値より大きい場合、最大値と答えを更新し、最後まで見たときの最大値の順番が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var H = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = 0;
    var max = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (max &amp;lt; H[i])
        {
            max = H[i];
            answer = i + 1;
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36036335"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;64bit&lt;/code&gt;整数型を使っても、&lt;code&gt;10^18^6&lt;/code&gt;は整数型に収まりません。
&lt;code&gt;(X*Y)%M&lt;/code&gt;の値は&lt;code&gt;(X%M)*(Y%M)&lt;/code&gt;の値と等しくなるように、余りをとる&lt;code&gt;+,-,*&lt;/code&gt;の演算は計算の途中で余りをとっても最終的な余りと等しくなります。
そのため、各演算ごとに余りを取ることで、各項最大でも&lt;code&gt;10^9&lt;/code&gt;に収まり、掛け算でも&lt;code&gt;10^9 * 10^9&lt;/code&gt;で&lt;code&gt;10^18&lt;/code&gt;に収まります。
引き算を行うことで値が負の値になる可能性があるので、余りを足すことで正の値にすることに注意します。
余りをとる整数型の構造体をライブラリとして作っておくと便利です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, C, D, E, F) = Scanner.Scan&amp;lt;long, long, long, long, long, long&amp;gt;();
    var answer = ((mint)A * (mint)B * (mint)C) - ((mint)D * (mint)E * (mint)F);
    Console.WriteLine(answer);
}

public readonly struct ModuloInteger : IEquatable&amp;lt;ModuloInteger&amp;gt;
{
    public long Value { get; }

    // The modulo will be used as an editable property.
    // public static long Modulo { get; set; } = 998244353;
    // The constant modulo will be recommended to use for performances in use cases.
    public const long Modulo = 998244353;

    public ModuloInteger(int value)
    {
        Value = value % Modulo;
        if (Value &amp;lt; 0) Value += Modulo;
    }

    public ModuloInteger(long value)
    {
        Value = value % Modulo;
        if (Value &amp;lt; 0) Value += Modulo;
    }

    public static implicit operator int(ModuloInteger mint) =&amp;gt; (int)mint.Value;
    public static implicit operator long(ModuloInteger mint) =&amp;gt; mint.Value;
    public static implicit operator ModuloInteger(int value) =&amp;gt; new ModuloInteger(value);
    public static implicit operator ModuloInteger(long value) =&amp;gt; new ModuloInteger(value);
    public static ModuloInteger operator +(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Value + b.Value;
    public static ModuloInteger operator -(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Value - b.Value;
    public static ModuloInteger operator *(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Value * b.Value;
    public static ModuloInteger operator /(ModuloInteger a, ModuloInteger b) =&amp;gt; a * b.Inverse();
    public static bool operator ==(ModuloInteger a, ModuloInteger b) =&amp;gt; a.Equals(b);
    public static bool operator !=(ModuloInteger a, ModuloInteger b) =&amp;gt; !a.Equals(b);
    public bool Equals(ModuloInteger other) =&amp;gt; Value == other.Value;
    public override bool Equals(object obj) =&amp;gt; obj is ModuloInteger other &amp;amp;&amp;amp; Equals(other);
    public override int GetHashCode() =&amp;gt; Value.GetHashCode();
    public override string ToString() =&amp;gt; Value.ToString();
    public ModuloInteger Inverse() =&amp;gt; Inverse(Value);

    public static ModuloInteger Inverse(long value)
    {
        if (value == 0) return 0;
        var (s, t, m0, m1) = (Modulo, value, 0L, 1L);
        while (t &amp;gt; 0)
        {
            var u = s / t;
            s -= t * u;
            m0 -= m1 * u;
            (s, t) = (t, s);
            (m0, m1) = (m1, m0);
        }

        if (m0 &amp;lt; 0) m0 += Modulo / s;
        return m0;
    }

    public ModuloInteger Power(long n) =&amp;gt; Power(Value, n);

    public static ModuloInteger Power(long value, long n)
    {
        if (n &amp;lt; 0) throw new ArgumentException(nameof(n));
        var result = 1L;
        while (n &amp;gt; 0)
        {
            if ((n &amp;amp; 1) &amp;gt; 0) result = result * value % Modulo;
            value = value * value % Modulo;
            n &amp;gt;&amp;gt;= 1;
        }

        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36052389"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正方形となる4つの頂点を全探索し、正方形となる頂点の組み合わせを数え上げます。
正方形の左上の頂点を&lt;code&gt;p1&lt;/code&gt;、右上の頂点を&lt;code&gt;p2&lt;/code&gt;、左下の頂点を&lt;code&gt;p3&lt;/code&gt;、右下を&lt;code&gt;p4&lt;/code&gt;としたとき、&lt;code&gt;p1-p2&lt;/code&gt;のベクトルと、&lt;code&gt;p3-p4&lt;/code&gt;のベクトルは一致し、&lt;code&gt;p1-p3&lt;/code&gt;のベクトルは、&lt;code&gt;p1-p2&lt;/code&gt;を90度回転させたものと一致する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = 9;
    var G = new bool[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().Select(x =&amp;gt; x == '#').ToArray();
    }

    var answer = 0;

    IEnumerable&amp;lt;(int H, int W)&amp;gt; F()
    {
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                yield return (i, j);
            }
        }
    }

    foreach (var p1 in F())
    {
        foreach (var p2 in F())
        {
            foreach (var p3 in F())
            {
                foreach (var p4 in F())
                {
                    if (p1 == p2 || p1 == p3 || p1 == p4 || p2 == p3 || p2 == p4 || p3 == p4) continue;
                    var e1 = (p2.H - p1.H, p2.W - p1.W);
                    var e3 = (p4.H - p3.H, p4.W - p3.W);
                    var e2 = (p3.W - p1.W, -(p3.H - p1.H));
                    var ok = e1 == e3 &amp;amp;&amp;amp; e1 == e2;
                    ok &amp;amp;= G[p1.H][p1.W];
                    ok &amp;amp;= G[p2.H][p2.W];
                    ok &amp;amp;= G[p3.H][p3.W];
                    ok &amp;amp;= G[p4.H][p4.W];
                    if (ok) answer++;
                }
            }
        }
    }

    answer /= 4;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36053607"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての&lt;code&gt;F(x)&lt;/code&gt;を都度求めてしまうと、何度も同じ計算を行ってしまい、&lt;code&gt;N&lt;/code&gt;が大きい場合、実行時間制限に間に合いません。
そこで、一度計算した値を保持しておくことで(メモ化再帰)、同じ計算を省略することで、実行時間制限に間に合わせることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    var dp = new Dictionary&amp;lt;long, long&amp;gt;();
    dp[0] = 1;

    long F(long x)
    {
        if (dp.ContainsKey(x)) return dp[x];
        return dp[x] = F(x / 2) + F(x / 3);
    }

    var answer = F(N);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc275/tasks/abc275_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC275/submissions/36065330"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]:=ルーレットをi回まわした時にマスjにいる確率&lt;/code&gt;とした動的計画法を解きます。
遷移としては、&lt;code&gt;今いるマスの確率/M&lt;/code&gt;が次のいるマスの確率に寄与します。
&lt;code&gt;M&lt;/code&gt;の逆元を求めることに&lt;code&gt;O(logMod)&lt;/code&gt;かかるので、前計算しておくことで高速化できます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, K) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var dp = new mint[K + 1, N + 1];
    dp[0, 0] = 1;
    var im = mint.Inverse(M);

    for (var k = 0; k &amp;lt; K; k++)
    {
        for (var m = 1; m &amp;lt;= M; m++)
        {
            for (var n = 0; n &amp;lt; N; n++)
            {
                var x = n + m;
                if (x &amp;gt; N) x = Math.Max(0, N - (x - N));
                dp[k + 1, x] += dp[k, n] * im;
            }
        }
    }

    mint answer = 0;
    for (var k = 0; k &amp;lt;= K; k++)
    {
        answer += dp[k, N];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC274</title>
			<link>https://blog.aconcavy.dev/posts/20221022abc274</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 274の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20221022abc274</guid>
			<pubDate>Sat, 22 Oct 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 274の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc274"&gt;https://atcoder.jp/contests/abc274&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35862184"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt;型で&lt;code&gt;B/A&lt;/code&gt;をとり、カスタム数値形式文字列の&lt;a href="https://learn.microsoft.com/ja-jp/dotnet/standard/base-types/custom-numeric-format-strings#Specifier0"&gt;0カスタム指定子&lt;/a&gt;で桁数を指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B) = Scanner.Scan&amp;lt;double, double&amp;gt;();
    var answer = B / A;
    Console.WriteLine($&amp;quot;{answer:0.000}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35864895"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二次元配列の入力を受け取り、列ごとにその行にある&lt;code&gt;#&lt;/code&gt;の数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToArray();
    }

    var X = new int[W];
    for (var j = 0; j &amp;lt; W; j++)
    {
        for (var i = 0; i &amp;lt; H; i++)
        {
            X[j] += G[i][j] == '#' ? 1 : 0;
        }
    }

    Console.WriteLine(string.Join(&amp;quot; &amp;quot;, X));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35873509"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;辞書型などで番号&lt;code&gt;k&lt;/code&gt;の親の数を管理します。
初期値である番号&lt;code&gt;1&lt;/code&gt;のアメーバが&lt;code&gt;0&lt;/code&gt;であり、&lt;code&gt;1&lt;/code&gt;が分裂すると&lt;code&gt;1*2=2&lt;/code&gt;番目と&lt;code&gt;1*3&lt;/code&gt;番目のアメーバは&lt;code&gt;1&lt;/code&gt;番目のアメーバの数&lt;code&gt;+1&lt;/code&gt;されたものがたどることができる親の数となります。
そのため、&lt;code&gt;dict[i*2] = dict[i*2+1] = dict[A[i]]+1&lt;/code&gt;のように順番にそのアメーバのたどることができる親の数を数え上げることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dict = new Dictionary&amp;lt;int, int&amp;gt;();
    dict[1] = 0;
    for (var i = 1; i &amp;lt;= N; i++)
    {
        dict[i * 2] = dict[i * 2 + 1] = dict[A[i - 1]] + 1;
    }

    for (var i = 1; i &amp;lt;= N * 2 + 1; i++)
    {
        Console.WriteLine(dict[k]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35880846"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移動について、&lt;code&gt;i&lt;/code&gt;が奇数番目の時は&lt;code&gt;X&lt;/code&gt;の移動、偶数の時は&lt;code&gt;Y&lt;/code&gt;の移動であることに注目し、&lt;code&gt;X&lt;/code&gt;の移動と&lt;code&gt;Y&lt;/code&gt;の移動それぞれについて&lt;code&gt;i&lt;/code&gt;回目の移動で座標&lt;code&gt;P&lt;/code&gt;行くことができるか、という動的計画法をとき、最終的に&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;にたどり着くことができるかを判定します。
初期値&lt;code&gt;dpX{A[0]}, dpY{0}&lt;/code&gt;とし、&lt;code&gt;i&lt;/code&gt;が奇数番目の時は&lt;code&gt;dpX&lt;/code&gt;の集合であり、ある頂点&lt;code&gt;px&lt;/code&gt;が&lt;code&gt;px+A[i]&lt;/code&gt;と&lt;code&gt;px-A[i]&lt;/code&gt;に遷移します。
同様に&lt;code&gt;i&lt;/code&gt;が偶数番目の時は&lt;code&gt;dpY&lt;/code&gt;の集合である頂点&lt;code&gt;py&lt;/code&gt;が&lt;code&gt;py+A[i]&lt;/code&gt;と&lt;code&gt;py-A[i]&lt;/code&gt;に遷移します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, x, y) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dpX = new HashSet&amp;lt;int&amp;gt;();
    var dpY = new HashSet&amp;lt;int&amp;gt;();
    dpX.Add(A[0]);
    dpY.Add(0);
    for (var i = 1; i &amp;lt; N; i++)
    {
        var tmp = new HashSet&amp;lt;int&amp;gt;();
        var target = i % 2 == 0 ? dpX : dpY;
        foreach (var p in target)
        {
            tmp.Add(p + A[i]);
            tmp.Add(p - A[i]);
        }

        if (i % 2 == 0) dpX = tmp;
        else dpY = tmp;
    }

    var answer = dpX.Contains(x) &amp;amp;&amp;amp; dpY.Contains(y);
    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc274/tasks/abc274_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC274/submissions/35898361"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての組み合わせを愚直に探索してしまうと、時間計算量が&lt;code&gt;O((N+M)!)&lt;/code&gt;となり実行時間制限に間に合いません。&lt;br /&gt;
そこで、原点と町と宝箱を頂点とした集合について、&lt;code&gt;dp[s][u]:=既に訪れている頂点集合sで現在地がuのときの距離の最小値&lt;/code&gt;とした&lt;code&gt;bitDP&lt;/code&gt;を行うことで、時間計算量&lt;code&gt;O(2^(N+M)*(N+M)^2)&lt;/code&gt;で求めることができます。&lt;br /&gt;
&lt;code&gt;bitDP&lt;/code&gt;をおこない、すべての町を訪れている集合&lt;code&gt;s&lt;/code&gt;、現在地が&lt;code&gt;u&lt;/code&gt;、訪れた宝箱の数が&lt;code&gt;k&lt;/code&gt;、&lt;code&gt;Boost&lt;/code&gt;を単位時間に対する倍率としたとき、&lt;code&gt;Min(dp[s,u]+D[u,0]*Boost[k])&lt;/code&gt;が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = N + M + 1;
    var P = new (int X, int Y)[S];
    P[0] = (0, 0);
    for (var i = 1; i &amp;lt; S; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        P[i] = (x, y);
    }

    double Distance(double x1, double y1, double x2, double y2)
    {
        var dx = x1 - x2;
        var dy = y1 - y2;
        return Math.Sqrt(dx * dx + dy * dy);
    }

    var D = new double[S, S];
    for (var i = 0; i &amp;lt; S; i++)
    {
        for (var j = 0; j &amp;lt; S; j++)
        {
            D[i, j] = Distance(P[i].X, P[i].Y, P[j].X, P[j].Y);
        }
    }

    const double inf = 7e18;

    var p2 = new double[M + 1];
    p2[0] = 1;
    for (var i = 1; i &amp;lt;= M; i++)
    {
        p2[i] = p2[i - 1] / 2.0;
    }

    var dp = new double[1 &amp;lt;&amp;lt; S, S];
    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; S; s++)
    {
        for (var u = 0; u &amp;lt; S; u++)
        {
            dp[s, u] = inf;
        }
    }

    dp[1, 0] = 0;

    int CountM(int s)
    {
        var k = 0;
        for (var i = 0; i &amp;lt; M; i++)
        {
            k += (s &amp;gt;&amp;gt; (N + 1 + i)) &amp;amp; 1;
        }

        return k;
    }

    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; S; s++)
    {
        var k = CountM(s);
        for (var u = 0; u &amp;lt; S; u++)
        {
            for (var v = 0; v &amp;lt; S; v++)
            {
                var t = s | (1 &amp;lt;&amp;lt; v);
                dp[t, v] = Math.Min(dp[t, v], dp[s, u] + D[u, v] * p2[k]);
            }
        }
    }

    var answer = inf;
    var mask = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        mask |= 1 &amp;lt;&amp;lt; (1 + i);
    }

    for (var s = 0; s &amp;lt; 1 &amp;lt;&amp;lt; S; s++)
    {
        if ((s &amp;amp; mask) != mask) continue;
        var k = CountM(s);
        for (var u = 0; u &amp;lt; S; u++)
        {
            answer = Math.Min(answer, dp[s, u] + D[u, 0] * p2[k]);
        }
    }
    
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>