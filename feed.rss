<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://blog.aconcavy.dev/</link>
		<description />
		<copyright>Copyright © 2020-2022 AconCavy</copyright>
		<pubDate>Sat, 03 Sep 2022 14:53:44 GMT</pubDate>
		<lastBuildDate>Sat, 03 Sep 2022 14:53:44 GMT</lastBuildDate>
		<item>
			<title>ABC267</title>
			<link>https://blog.aconcavy.dev/posts/20220903abc267</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 267の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220903abc267</guid>
			<pubDate>Sat, 03 Sep 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 267の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267"&gt;https://atcoder.jp/contests/abc267&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34533809"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与えられる文字列は5通りしかないため、それぞれに対しての答えを求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var answer = 0;
    if (S == &amp;quot;Monday&amp;quot;) answer = 5;
    if (S == &amp;quot;Tuesday&amp;quot;) answer = 4;
    if (S == &amp;quot;Wednesday&amp;quot;) answer = 3;
    if (S == &amp;quot;Thursday&amp;quot;) answer = 2;
    if (S == &amp;quot;Friday&amp;quot;) answer = 1;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34560503"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;列ごとの処理を行うため、あらかじめ列ごとにピンが1本でも立っているかを&lt;code&gt;bool&lt;/code&gt;で管理できるようにします。
1番ピンが&lt;code&gt;false&lt;/code&gt;かつ、列&lt;code&gt;L&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;かつと列&lt;code&gt;R&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;かつ、列&lt;code&gt;L&lt;/code&gt;と列&lt;code&gt;R&lt;/code&gt;の間の列&lt;code&gt;M&lt;/code&gt;が&lt;code&gt;false&lt;/code&gt;であるときにスプリットになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = new bool[11];
    for (var i = 0; i &amp;lt; S.Length; i++)
    {
        T[i + 1] = S[i] == '1';
    }

    var col = new bool[7];
    col[0] |= T[7];
    col[1] |= T[4];
    col[2] |= T[8] || T[2];
    col[3] |= T[5] || T[1];
    col[4] |= T[9] || T[3];
    col[5] |= T[6];
    col[6] |= T[10];

    if (!T[1])
    {
        for (var l = 0; l &amp;lt; col.Length; l++)
        {
            for (var r = l + 2; r &amp;lt; col.Length; r++)
            {
                for (var m = l + 1; m &amp;lt; r; m++)
                {
                    if (col[l] &amp;amp;&amp;amp; col[r] &amp;amp;&amp;amp; !col[m])
                    {
                        Console.WriteLine(&amp;quot;Yes&amp;quot;);
                        return;
                    }
                }
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34548091"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長さ&lt;code&gt;M&lt;/code&gt;の連続部分列の右側の位置&lt;code&gt;R&lt;/code&gt;から位置&lt;code&gt;R+1&lt;/code&gt;にずれたとき、求める総和は&lt;code&gt;A[R-M+1..R]&lt;/code&gt;の区間和が引かれて&lt;code&gt;A[R]*M&lt;/code&gt;が足されます。
そのため、位置をずらして総和を更新していったときの最大値が答えとなります。
累積和を用いることで時間計算量&lt;code&gt;O(1)&lt;/code&gt;で区間和を求めることができ、全体の計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();

    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    var sum = 0L;
    for (var i = 0; i &amp;lt; M; i++)
    {
        sum += (i + 1) * A[i];
    }

    var answer = sum;
    for (var i = 1; i + M &amp;lt;= N; i++)
    {
        sum -= cum[i + M - 1] - cum[i - 1];
        sum += M * A[i + M - 1];
        answer = Math.Max(answer, sum);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34568995"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][j]:=i番目までみたときにBの要素をj個決めたときの求める和の最大値&lt;/code&gt;とした動的計画法を解きます。&lt;br /&gt;
これは、&lt;code&gt;i&lt;/code&gt;番目の要素を選ばなかったときは&lt;code&gt;Max(dp[i+1][j], dp[i][j])&lt;/code&gt;であり、選んだ時は&lt;code&gt;Max(dp[i+1][j+1], dp[i][j]+A[i]*(j+1))&lt;/code&gt;の遷移が成り立ちます。
総和が負になることもあるため、&lt;code&gt;dp&lt;/code&gt;テーブルを&lt;code&gt;-inf&lt;/code&gt;のような値で初期化する必要があることに注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    const long inf = (long)1e18;
    var dp = new long[N + 1, M + 1];
    for (var i = 0; i &amp;lt;= N; i++)
    {
        for (var j = 0; j &amp;lt;= M; j++)
        {
            dp[i, j] = -inf;
        }
    }

    dp[0, 0] = 0;

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= M; j++)
        {
            dp[i + 1, j] = Math.Max(dp[i + 1, j], dp[i, j]);
            if (j + 1 &amp;lt;= M) dp[i + 1, j + 1] = Math.Max(dp[i + 1, j + 1], dp[i, j] + A[i] * (j + 1));
        }
    }

    var answer = dp[N, M];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc267/tasks/abc267_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc267/submissions/34578204"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ある時点で頂点&lt;code&gt;u&lt;/code&gt;を消すと、頂点&lt;code&gt;u&lt;/code&gt;に接続している頂点&lt;code&gt;v&lt;/code&gt;のコストは&lt;code&gt;A[u]&lt;/code&gt;減ることになり、その時点での頂点&lt;code&gt;v&lt;/code&gt;とコストのペアを&lt;code&gt;PriorityQueue&lt;/code&gt;に追加していくことで、頂点&lt;code&gt;x&lt;/code&gt;を消すときに必要なコストの最小値を求めることができ、全ての頂点におけるコストの最小値の最大値が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var G = new List&amp;lt;int&amp;gt;[N].Select(x =&amp;gt; new List&amp;lt;int&amp;gt;()).ToArray();
    var costs = new long[N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--; v--;
        costs[u] += A[v];
        costs[v] += A[u];
        G[u].Add(v);
        G[v].Add(u);
    }

    var answer = 0L;
    var queue = new PriorityQueue&amp;lt;(int U, long C)&amp;gt;((x, y) =&amp;gt; x.C.CompareTo(y.C));
    for (var i = 0; i &amp;lt; N; i++)
    {
        queue.Enqueue((i, costs[i]));
    }

    var used = new bool[N];
    while (queue.Count &amp;gt; 0)
    {
        var (u, c) = queue.Dequeue();
        if (used[u]) continue;
        used[u] = true;
        answer = Math.Max(answer, c);
        foreach (var v in G[u])
        {
            if (used[v]) continue;
            costs[v] -= A[u];
            queue.Enqueue((v, costs[v]));
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC266</title>
			<link>https://blog.aconcavy.dev/posts/20220827abc266</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 266の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220827abc266</guid>
			<pubDate>Sat, 27 Aug 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 266の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc266"&gt;https://atcoder.jp/contests/abc266&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34367371"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列&lt;code&gt;S&lt;/code&gt;の長さが奇数なので、&lt;code&gt;S&lt;/code&gt;のインデックス&lt;code&gt;Floor(Sの長さ/2)&lt;/code&gt;の文字が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var N = S.Length;
    Console.WriteLine(S[N / 2]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34371987"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N-x&lt;/code&gt;が&lt;code&gt;998244353&lt;/code&gt;の倍数であるということは、&lt;code&gt;N&lt;/code&gt;を&lt;code&gt;998244353&lt;/code&gt;で割ったときの余りが&lt;code&gt;x&lt;/code&gt;になることがわかります。&lt;br /&gt;
また、言語によって負の数に対する余りの計算は異なり、余りが負の値になる場合があります。
&lt;code&gt;a&lt;/code&gt;を&lt;code&gt;b(!=0)&lt;/code&gt;で割ったときの余りが&lt;code&gt;c&lt;/code&gt;のとき、&lt;code&gt;a+b&lt;/code&gt;や&lt;code&gt;a-b&lt;/code&gt;を&lt;code&gt;b&lt;/code&gt;で割ったときの余りも&lt;code&gt;c&lt;/code&gt;になることから、&lt;code&gt;x&lt;/code&gt;が負の値のときは&lt;code&gt;998244353&lt;/code&gt;を足すことで、&lt;code&gt;0&amp;lt;=x&amp;lt;=998244353&lt;/code&gt;にすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;long&amp;gt;();
    const long M = 998244353;
    var x = N % M;
    if (x &amp;lt; 0) x += M;
    Console.WriteLine(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34400444"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34409358"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての角が180度未満であるかを外積を用いて判定します。
角&lt;code&gt;abc&lt;/code&gt;の外積は&lt;code&gt;cross=(c.X-b.X)*(a.Y-b.Y)-(a.X-b.X)*(c.Y-b.Y)&lt;/code&gt;で計算でき、&lt;code&gt;abc&lt;/code&gt;が反時計回りなら&lt;code&gt;cross&amp;gt;=0&lt;/code&gt;の場合角&lt;code&gt;abc&lt;/code&gt;の角は&lt;code&gt;180&lt;/code&gt;度未満になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = 4;
    var P = new Point[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        P[i] = new Point(x, y);
    }

    long Cross(Point a, Point b, Point c)
    {
        var (dx1, dy1) = (c.X - b.X, c.Y - b.Y);
        var (dx2, dy2) = (a.X - b.X, a.Y - b.Y);
        return dx1 * dy2 - dx2 * dy1;
    }

    var answer = true;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var a = P[i];
        var b = P[(i + 1) % N];
        var c = P[(i + 2) % N];
        answer &amp;amp;= Cross(a, b, c) &amp;gt;= 0;
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}

public readonly struct Point
{
    public readonly long X;
    public readonly long Y;
    public Point(long x, long y) =&amp;gt; (X, Y) = (x, y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34392662"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34408822"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[t][x]:=時刻tの座標xにおける既に捕まえた大きさの最大値&lt;/code&gt;とした動的計画法を解きます。
これは、時刻&lt;code&gt;t&lt;/code&gt;の座標&lt;code&gt;x&lt;/code&gt;における大きさを&lt;code&gt;A[t][x]&lt;/code&gt;としたとき、&lt;code&gt;dp[t][x] = Max(dp[t-1][x-1], dp[t-1][x], dp[t-1][x+1]) + A[t][x]&lt;/code&gt;の遷移で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new long[(int)1e5 + 1, 5];
    var T = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (t, x, a) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
        A[t, x] = a;
        T = t;
    }

    const long inf = (long)1e18;
    var dp = new long[T + 1, 5];
    for (var i = 0; i &amp;lt;= T; i++)
    {
        for (var j = 0; j &amp;lt; 5; j++)
        {
            dp[i, j] = -inf;
        }
    }

    dp[0, 0] = 0;

    for (var t = 1; t &amp;lt;= T; t++)
    {
        for (var x = 0; x &amp;lt; 5; x++)
        {
            for (var p = x - 1; p &amp;lt;= x + 1; p++)
            {
                if (0 &amp;lt;= p &amp;amp;&amp;amp; p &amp;lt; 5) dp[t, x] = Math.Max(dp[t, x], dp[t - 1, p] + A[t, x]);
            }
        }
    }

    var answer = 0L;
    for (var i = 0; i &amp;lt; 5; i++)
    {
        answer = Math.Max(answer, dp[T, i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc266/tasks/abc266_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC266/submissions/34405481"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt;回目の期待値は、&lt;code&gt;n-1&lt;/code&gt;回目の期待値と出目を比較して大きいほうを選んだときの&lt;code&gt;1-6&lt;/code&gt;の出目の総和になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = 0.0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var exp = 0.0;
        for (var x = 1; x &amp;lt;= 6; x++)
        {
            exp += Math.Max(x, answer) / 6.0;
        }

        answer = Math.Max(answer, exp);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC265</title>
			<link>https://blog.aconcavy.dev/posts/20220821abc265</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 265の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220821abc265</guid>
			<pubDate>Sun, 21 Aug 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 265の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265"&gt;https://atcoder.jp/contests/abc265&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34200512"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3個のりんごを&lt;code&gt;b&lt;/code&gt;セット買ったとき、1個のりんごを&lt;code&gt;a=N-b*3&lt;/code&gt;セット買うことができます。
この&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を全探索し、&lt;code&gt;a*X+b*Y&lt;/code&gt;の最小を求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    const int inf = (int)1e9;
    var answer = inf;
    for (var b = 0; b * 3 &amp;lt;= N; b++)
    {
        var a = (N - b * 3);
        var v = a * X + b * Y;
        answer = Math.Min(answer, v);
    }
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;X*3&amp;gt;Y&lt;/code&gt;で場合分けをして、時間計算量&lt;code&gt;O(1)&lt;/code&gt;で解くこともできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (X, Y, N) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var answer = X * 3 &amp;gt; Y ? (N / 3) * Y + N % 3 * X : X * N;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34206744"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;愚直にシミュレーションを行い、&lt;code&gt;現在の持ち時間-A[i]&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;以下になれば、答えは&lt;code&gt;No&lt;/code&gt;となります。
1回の移動あたりのボーナスを全て探索してしまうと、全体の時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;かかってしまうので、あらかじめ配列として&lt;code&gt;bonus[x]&lt;/code&gt;をもっておくことで、1回の移動あたりのボーナスの値を&lt;code&gt;O(1)&lt;/code&gt;で取得することができ、全体計算量&lt;code&gt;O(N)&lt;/code&gt;で解くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, T) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var bonus = new long[N + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        bonus[x] = y;
    }

    var curr = T;
    for (var i = 0; i &amp;lt; N - 1; i++)
    {
        curr += bonus[i + 1];
        if (curr &amp;gt; A[i])
        {
            curr -= A[i];
        }
        else
        {
            Console.WriteLine(&amp;quot;No&amp;quot;);
            return;
        }
    }

    Console.WriteLine(&amp;quot;Yes&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34212489"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在いるマスに書かれている文字にそって愚直にシミュレーションを行います。
あるマス&lt;code&gt;(i,j)&lt;/code&gt;からマスの外に出ようとした場合には、答えはマス&lt;code&gt;(i,j)&lt;/code&gt;となります。
無限に移動し続ける場合の判定として、既に訪れたマスをフラグ管理なのでメモしておき、移動先のマスが既に訪れているマスの場合には答えは&lt;code&gt;-1&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H, W) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new char[H][];
    for (var i = 0; i &amp;lt; H; i++)
    {
        G[i] = Scanner.Scan&amp;lt;string&amp;gt;().ToCharArray();
    }

    var used = new bool[H, W];
    used[0, 0] = true;
    var queue = new Queue&amp;lt;(int, int)&amp;gt;();
    queue.Enqueue((0, 0));
    while (queue.Count &amp;gt; 0)
    {
        var (ch, cw) = queue.Dequeue();
        var (nh, nw) = G[ch][cw] switch
        {
            'U' =&amp;gt; (ch - 1, cw),
            'D' =&amp;gt; (ch + 1, cw),
            'L' =&amp;gt; (ch, cw - 1),
            'R' =&amp;gt; (ch, cw + 1),
            _ =&amp;gt; (0, 0),
        };

        if (nh &amp;lt; 0 || H &amp;lt;= nh || nw &amp;lt; 0 || W &amp;lt;= nw)
        {
            Console.WriteLine($&amp;quot;{ch + 1} {cw + 1}&amp;quot;);
            return;
        }

        if (used[nh, nw])
        {
            Console.WriteLine(-1);
            return;
        }

        used[nh, nw] = true;
        queue.Enqueue((nh, nw));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34217740"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;累積和をあらかじめ求めておくことで、区間和を時間計算量&lt;code&gt;O(1)&lt;/code&gt;で求めることができます。
また、尺取り法で区間和&lt;code&gt;Cum[w]-Cum[x]==P+Q+R&lt;/code&gt;となる区間を求めることで、&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;が時間計算量&lt;code&gt;O(N)&lt;/code&gt;でわかります。
この&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;間で&lt;code&gt;Cum[y]-Cum[x]==P&lt;/code&gt;、&lt;code&gt;Cum[z]-Cum[y]==Q&lt;/code&gt;、&lt;code&gt;Cum[w]-Cum[z]==R&lt;/code&gt;となる&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;z&lt;/code&gt;が存在すれば、答えは&lt;code&gt;Yes&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, P, Q, R) = Scanner.Scan&amp;lt;int, long, long, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var cum = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cum[i + 1] = cum[i] + A[i];
    }

    var PQR = P + Q + R;
    var w = 0;
    for (var x = 0; x &amp;lt; N; x++)
    {
        while (x &amp;lt; N &amp;amp;&amp;amp; cum[w] - cum[x] &amp;lt; PQR) w++;
        if (cum[w] - cum[x] != PQR) continue;
        
        var y = l;
        while (y &amp;lt; w &amp;amp;&amp;amp; cum[y] - cum[x] &amp;lt; P) y++;
        if (cum[y] - cum[x] != P) continue;

        var z = y;
        while (z &amp;lt; w &amp;amp;&amp;amp; cum[z] - cum[y] &amp;lt; Q) z++;
        if (cum[z] - cum[y] != Q) continue;

        if (cum[w] - cum[z] != R) continue;

        Console.WriteLine(&amp;quot;Yes&amp;quot;);
        return;
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc265/tasks/abc265_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc265/submissions/34223689"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i][x][y] := i回目の移動で(x,y)に至る移動経路の個数&lt;/code&gt;とする動的計画法を解きます。
ここで、&lt;code&gt;(x,y)&lt;/code&gt;の取りうる値は疎であることから、全ての&lt;code&gt;(x,y)&lt;/code&gt;を管理せずに移動しうる&lt;code&gt;(x,y)&lt;/code&gt;をキーとした辞書などを使って管理することで、時間計算量&lt;code&gt;O(N^3logN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var (A, B, C, D, E, F) = Scanner.Scan&amp;lt;long, long, long, long, long, long&amp;gt;();
    var delta = new (long, long)[] { (A, B), (C, D), (E, F) };
    var obstacles = new HashSet&amp;lt;Point&amp;gt;();
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (x, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        obstacles.Add(new Point(x, y));
    }

    var dp0 = new Dictionary&amp;lt;Point, mint&amp;gt;();
    dp0[new Point(0, 0)] = 1;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var dp1 = new Dictionary&amp;lt;Point, mint&amp;gt;();
        foreach (var (p, v) in dp0)
        {
            foreach (var (dx, dy) in delta)
            {
                var np = new Point(p.X + dx, p.Y + dy);
                if (obstacles.Contains(np)) continue;
                if (!dp1.ContainsKey(np)) dp1[np] = 0;
                dp1[np] += v;
            }
        }

        dp0 = dp1;
    }

    mint answer = 0;
    foreach (var (_, v) in dp0)
    {
        answer += v;
    }

    Console.WriteLine(answer);
}

public readonly struct Point : IEquatable&amp;lt;Point&amp;gt;
{
    public readonly long X;
    public readonly long Y;
    public Point(long x, long y) =&amp;gt; (X, Y) = (x, y);
    public bool Equals(Point other) =&amp;gt; X == other.X &amp;amp;&amp;amp; Y == other.Y;
    public override int GetHashCode() =&amp;gt; HashCode.Combine(X, Y);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC264</title>
			<link>https://blog.aconcavy.dev/posts/20220813abc264</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 264の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220813abc264</guid>
			<pubDate>Sat, 13 Aug 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 264の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264"&gt;https://atcoder.jp/contests/abc264&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33984910"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#では、&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.string.substring?view=net-6.0"&gt;&lt;code&gt;SubString&lt;/code&gt;メソッド&lt;/a&gt;に始点と長さを指定することで、部分文字列を取得することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L, R) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    L--;
    const string atcoder = &amp;quot;atcoder&amp;quot;;
    var answer = atcoder.SubString(L, R - L);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、文字列スライスを使うことで&lt;code&gt;[L,R)&lt;/code&gt;区間の部分文字列を取得することもできます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L, R) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    L--;
    const string atcoder = &amp;quot;atcoder&amp;quot;;
    var answer = atcoder[L..R];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33988441"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中心(8行目8列目)からの行の距離と列の距離の最大値の偶奇によって色分けされているので、それを判定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (R, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var mid = 8;
    var r = Math.Abs(mid - R);
    var c = Math.Abs(mid - C);
    var answer = Math.Max(r, c) % 2 == 0 ? &amp;quot;white&amp;quot; : &amp;quot;black&amp;quot;;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33998636"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;行列&lt;code&gt;A&lt;/code&gt;のうち、どの行と列を使うかの組み合わせを全探索してます。
これは、bit全探索(2のn乗のビットが立っていれば、そのn行目またはn列目を使う)を行うことで簡潔に書くことができます。
時間計算量は、最大でも&lt;code&gt;(2^10)*(2^10)≒10^6&lt;/code&gt;なので、余裕で間に合います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (H1, W1) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var A = new int[H1][];
    for (var i = 0; i &amp;lt; H1; i++)
    {
        A[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    var (H2, W2) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var B = new int[H2][];
    for (var i = 0; i &amp;lt; H2; i++)
    {
        B[i] = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    }

    for (var H = 0; H &amp;lt; 1 &amp;lt;&amp;lt; H1; H++)
    {
        var hc = 0;
        for (var k = 0; k &amp;lt; H1; k++)
        {
            if ((H &amp;gt;&amp;gt; k &amp;amp; 1) == 1) hc++;
        }

        if (hc != H2) continue;

        for (var W = 0; W &amp;lt; 1 &amp;lt;&amp;lt; W1; W++)
        {
            var wc = 0;
            for (var k = 0; k &amp;lt; W1; k++)
            {
                if ((W &amp;gt;&amp;gt; k &amp;amp; 1) == 1) wc++;
            }

            if (wc != W2) continue;

            var G = new List&amp;lt;List&amp;lt;int&amp;gt;&amp;gt;();
            for (var i = 0; i &amp;lt; H1; i++)
            {
                if ((H &amp;gt;&amp;gt; i &amp;amp; 1) == 1) G.Add(new List&amp;lt;int&amp;gt;());
                else continue;

                for (var j = 0; j &amp;lt; W1; j++)
                {
                    if ((W &amp;gt;&amp;gt; j &amp;amp; 1) == 1) G[^1].Add(A[i][j]);
                }
            }

            var ok = true;
            for (var i = 0; i &amp;lt; H2; i++)
            {
                for (var j = 0; j &amp;lt; W2; j++)
                {
                    ok &amp;amp;= G[i][j] == B[i][j];
                }
            }

            if (ok)
            {
                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/33993322"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数列をソートするための最小の操作回数は転倒数と一致するため、文字が&lt;code&gt;atcoder&lt;/code&gt;の何番目に値するかに変換した数列の転倒数を求めることで、時間計算量&lt;code&gt;O(|S|log|S|)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    const int N = 7;
    var S = Scanner.Scan&amp;lt;string&amp;gt;();

    int F(char c)
    {
        return c switch
        {
            'a' =&amp;gt; 0,
            't' =&amp;gt; 1,
            'c' =&amp;gt; 2,
            'o' =&amp;gt; 3,
            'd' =&amp;gt; 4,
            'e' =&amp;gt; 5,
            'r' =&amp;gt; 6,
            _ =&amp;gt; 7,
        };
    }

    var T = S.Select(x =&amp;gt; F(x)).ToArray();
    var ft = new FenwickTree(10);
    var answer = 0L;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var c = T[i];
        answer += i - ft.Sum(c + 1);
        ft.Add(c, 1);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文字列を頂点として、隣接する文字を入れ替えていく幅優先探索でも、時間計算量&lt;code&gt;O(|S|!)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc264/tasks/abc264_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc264/submissions/34003277"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全ての発電所から電線がつながっている都市をクエリごとに計算してしまうと、連結成分の判定に&lt;code&gt;Disjoint Set Union (DSU)&lt;/code&gt;を使ったとしても、&lt;code&gt;DSU&lt;/code&gt;の構成に時間計算量&lt;code&gt;O(α(N+M)) (α:アッカーマンの逆関数、非常に小さな定数)&lt;/code&gt;、全ての発電所の連結成分の個数の数え上げに時間計算量&lt;code&gt;O(M)&lt;/code&gt;となってしまい、全体で&lt;code&gt;O(Q(α(N+M)+M))&lt;/code&gt;となり、実行時間制限に間に合いません。&lt;br /&gt;
そこで、使わない電線をあらかじめ繋いでおき、そこにクエリの逆順で電線を繋いでいくという問題に言い換えると、クエリごとに毎回&lt;code&gt;DSU&lt;/code&gt;を構築しなおす必要がなくなり、クエリ当たりの時間計算量が、全ての発電所の連結成分の個数の数え上げの&lt;code&gt;O(M)&lt;/code&gt;のみになります。&lt;br /&gt;
さらに、全ての発電所の連結成分の数え上げを、ある一つの発電所に連結成分をまとめ、その発電所のみ調べることで、時間計算量を&lt;code&gt;O(1)&lt;/code&gt;にすることができます。&lt;br /&gt;
このことから、クエリの先読み逆順処理と発電所のまとめあげをおこなうことで、全体の時間計算量を&lt;code&gt;O(α(N+M)+Q)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, E) = Scanner.Scan&amp;lt;int, int, int&amp;gt;();
    var Edges = new (int U, int V)[E];
    for (var i = 0; i &amp;lt; E; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        Edges[i] = (u, v);
    }

    var Q = Scanner.Scan&amp;lt;int&amp;gt;();
    var X = new int[Q];
    var removes = new bool[E];
    for (var i = 0; i &amp;lt; Q; i++)
    {
        var x = Scanner.Scan&amp;lt;int&amp;gt;() - 1;
        X[i] = x;
        removes[x] = true;
    }

    var s = 0;
    var dsu = new DisjointSetUnion(N + M + 1);
    for (var u = N + 1; u &amp;lt;= N + M; u++)
    {
        dsu.Merge(s, u);
    }

    for (var i = 0; i &amp;lt; E; i++)
    {
        if (!removes[i])
        {
            var (u, v) = Edges[i];
            dsu.Merge(u, v);
        }
    }

    var answer = new int[Q];
    for (var i = Q - 1; i &amp;gt;= 0; i--)
    {
        answer[i] = dsu.SizeOf(s) - (M + 1);
        var (u, v) = Edges[X[i]];
        dsu.Merge(u, v);
    }

    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC263</title>
			<link>https://blog.aconcavy.dev/posts/20220806abc263</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 263の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220806abc263</guid>
			<pubDate>Sat, 06 Aug 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 263の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc263"&gt;https://atcoder.jp/contests/abc263&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc263/tasks/abc263_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc263/submissions/33803567"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数字ごとの枚数を数え上げ、数値&lt;code&gt;i&lt;/code&gt;の枚数が&lt;code&gt;3&lt;/code&gt;と数値&lt;code&gt;j&lt;/code&gt;の枚数が&lt;code&gt;2&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;が存在するかを全探索します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var count = new int[14];
    foreach (var a in A) count[a]++;
    for (var i = 1; i &amp;lt;= 13; i++)
    {
        for (var j = 1; j &amp;lt;= 13; j++)
        {
            if (count[i] == 3 &amp;amp;&amp;amp; count[j] == 2)
            {
                Console.WriteLine(&amp;quot;Yes&amp;quot;);
                return;
            }
        }
    }

    Console.WriteLine(&amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数字をソートして、&lt;code&gt;A[0]==A[2] &amp;amp;&amp;amp; A[3]==A[4] || A[0]==A[1] &amp;amp;&amp;amp; A[2]==A[4]&lt;/code&gt;で求める方法もあります。&lt;/p&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc263/tasks/abc263_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc263/submissions/33807089"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在の値が&lt;code&gt;1&lt;/code&gt;になるまで、現在の値を更新しながら回数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var curr = N;
    var answer = 0;
    while (curr != 1)
    {
        curr = P[curr - 2];
        answer++;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc263/tasks/abc263_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc263/submissions/33809950"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現在の配列、深さ、ひとつ前の値を保持して深さ優先探索を行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();

    void Dfs(int[] buffer, int idx, int prev)
    {
        if (idx == N)
        {
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, buffer));
            return;
        }

        for (var i = prev + 1; i &amp;lt;= M; i++)
        {
            buffer[idx] = i;
            Dfs(buffer, idx + 1, i);
        }
    }

    var buffer = new int[N];
    Dfs(buffer, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc263/tasks/abc263_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc263/submissions/33822960"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;を全探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまい、実行時間制限内に答えを求めることができません。&lt;br /&gt;
数列を二つに分けたとき、数列の左側の合計と右側の合計は数列全体の合計になることに注目します。&lt;br /&gt;
そこで、左から&lt;code&gt;x&lt;/code&gt;番目までの累積和を考えたとき、&lt;code&gt;x&lt;/code&gt;番目の累積和になりえるものは&lt;code&gt;x-1番目までの累積和+A[x]&lt;/code&gt;または&lt;code&gt;L*x&lt;/code&gt;であり、それらの最小値を左から順に調べることで、&lt;code&gt;x&lt;/code&gt;番目までの累積和の最小値を求めることができます。&lt;br /&gt;
同様に、右から&lt;code&gt;y&lt;/code&gt;番目までの累積和の最小値を求め、左から&lt;code&gt;i&lt;/code&gt;番目までの累積和と右から&lt;code&gt;N-i&lt;/code&gt;番目の累積和の和の最小を求めることで、時間計算量&lt;code&gt;O(N)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, L, R) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    const long inf = (long)1e18;
    var cumL = new long[N + 1];
    var cumR = new long[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        cumL[i + 1] = Math.Min(cumL[i] + A[i], L * (i + 1));
        cumR[N - 1 - i] = Math.Min(cumR[N - i] + A[N - 1 - i], R * (i + 1));
    }

    var answer = inf;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        answer = Math.Min(answer, cumL[i] + cumR[i]);
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc263/tasks/abc263_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc263/submissions/33830652"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[i]&lt;/code&gt;:=マス&lt;code&gt;i&lt;/code&gt;からマス&lt;code&gt;N&lt;/code&gt;にたどり着くまでにサイコロを振る回数の期待値とした動的計画法を行います。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;dp[i] = (dp[i..i+A[i]] + 1) / (A[i] + 1) #(次の状態の期待値+1回)/種類数
=&amp;gt; dp[i] = dp[i] / (A[i] + 1) + (dp[(i+1)..(i+A[i])] + 1) / (A[i] + 1) #右辺に左辺が入っているので式変形
=&amp;gt; dp[i] * A[i] / (A[i] + 1) = (dp[(i+1)..(i+A[i])] + 1) / (A[i] + 1)
=&amp;gt; dp[i] = (dp[(i+1)..(i+A[i])] + A[i] + 1) / A[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i+1&lt;/code&gt;から&lt;code&gt;i+A[i]&lt;/code&gt;の累積和を&lt;code&gt;SegmentTree&lt;/code&gt;のようなデータ構造で管理し、クエリ当たり&lt;code&gt;O(logN)&lt;/code&gt;で累積和を求めることで、全体で&lt;code&gt;O(NlogN)&lt;/code&gt;で答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var dp = new SegmentTree&amp;lt;ModuloInteger&amp;gt;(N + 1, new Oracle());
    for (var i = N - 1; i &amp;gt; 0; i--)
    {
        var sum = dp.Query(i, i + A[i - 1] + 1);
        sum += A[i - 1] + 1;
        sum /= A[i - 1];
        dp.Set(i, sum);
    }

    var answer = dp.Get(1);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SegmentTree&lt;/code&gt;は以下のようなものを使いました。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public class Oracle : IOracle&amp;lt;ModuloInteger&amp;gt;
{
    public ModuloInteger MonoidIdentity =&amp;gt; (ModuloInteger)0;

    public ModuloInteger Operate(ModuloInteger a, ModuloInteger b)
    {
        return a + b;
    }
}

public interface IOracle&amp;lt;TMonoid&amp;gt;
{
    TMonoid MonoidIdentity { get; }
    TMonoid Operate(TMonoid a, TMonoid b);
}

public class SegmentTree&amp;lt;TMonoid&amp;gt;
{
    public int Length { get; }
    private readonly IOracle&amp;lt;TMonoid&amp;gt; _oracle;
    private readonly TMonoid[] _data;
    private readonly int _log;
    private readonly int _dataSize;

    public SegmentTree(IReadOnlyCollection&amp;lt;TMonoid&amp;gt; source, IOracle&amp;lt;TMonoid&amp;gt; oracle) : this(source.Count, oracle)
    {
        var idx = _dataSize;
        foreach (var value in source) _data[idx++] = value;
        for (var i = _dataSize - 1; i &amp;gt;= 1; i--) Update(i);
    }

    public SegmentTree(int length, IOracle&amp;lt;TMonoid&amp;gt; oracle)
    {
        if (length &amp;lt; 0) throw new ArgumentOutOfRangeException(nameof(length));
        Length = length;
        _oracle = oracle;
        while (1 &amp;lt;&amp;lt; _log &amp;lt; Length) _log++;
        _dataSize = 1 &amp;lt;&amp;lt; _log;
        _data = new TMonoid[_dataSize &amp;lt;&amp;lt; 1];
        Array.Fill(_data, oracle.MonoidIdentity);
    }

    public void Set(int index, TMonoid value)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        index += _dataSize;
        _data[index] = value;
        for (var i = 1; i &amp;lt;= _log; i++) Update(index &amp;gt;&amp;gt; i);
    }

    public TMonoid Get(int index)
    {
        if (index &amp;lt; 0 || Length &amp;lt;= index) throw new ArgumentOutOfRangeException(nameof(index));
        return _data[index + _dataSize];
    }

    public TMonoid Query(int left, int right)
    {
        if (left &amp;lt; 0 || right &amp;lt; left || Length &amp;lt; right) throw new ArgumentOutOfRangeException();
        var (sml, smr) = (_oracle.MonoidIdentity, _oracle.MonoidIdentity);
        left += _dataSize;
        right += _dataSize;
        while (left &amp;lt; right)
        {
            if ((left &amp;amp; 1) == 1) sml = _oracle.Operate(sml, _data[left++]);
            if ((right &amp;amp; 1) == 1) smr = _oracle.Operate(_data[--right], smr);
            left &amp;gt;&amp;gt;= 1;
            right &amp;gt;&amp;gt;= 1;
        }

        return _oracle.Operate(sml, smr);
    }

    public TMonoid QueryToAll() =&amp;gt; _data[1];

    public int MaxRight(int left, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (left &amp;lt; 0 || Length &amp;lt; left) throw new ArgumentOutOfRangeException(nameof(left));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.MonoidIdentity)) throw new ArgumentException(nameof(predicate));
        if (left == Length) return Length;
        left += _dataSize;
        var sm = _oracle.MonoidIdentity;
        do
        {
            while ((left &amp;amp; 1) == 0) left &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(sm, _data[left])))
            {
                while (left &amp;lt; _dataSize)
                {
                    left &amp;lt;&amp;lt;= 1;
                    var tmp = _oracle.Operate(sm, _data[left]);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    left++;
                }

                return left - _dataSize;
            }

            sm = _oracle.Operate(sm, _data[left]);
            left++;
        } while ((left &amp;amp; -left) != left);

        return Length;
    }

    public int MinLeft(int right, Func&amp;lt;TMonoid, bool&amp;gt; predicate)
    {
        if (right &amp;lt; 0 || Length &amp;lt; right) throw new ArgumentOutOfRangeException(nameof(right));
        if (predicate is null) throw new ArgumentNullException(nameof(predicate));
        if (!predicate(_oracle.MonoidIdentity)) throw new ArgumentException(nameof(predicate));
        if (right == 0) return 0;
        right += _dataSize;
        var sm = _oracle.MonoidIdentity;
        do
        {
            right--;
            while (right &amp;gt; 1 &amp;amp;&amp;amp; (right &amp;amp; 1) == 1) right &amp;gt;&amp;gt;= 1;
            if (!predicate(_oracle.Operate(_data[right], sm)))
            {
                while (right &amp;lt; _dataSize)
                {
                    right = (right &amp;lt;&amp;lt; 1) + 1;
                    var tmp = _oracle.Operate(_data[right], sm);
                    if (!predicate(tmp)) continue;
                    sm = tmp;
                    right--;
                }

                return right + 1 - _dataSize;
            }

            sm = _oracle.Operate(_data[right], sm);
        } while ((right &amp;amp; -right) != right);

        return 0;
    }

    private void Update(int k) =&amp;gt; _data[k] = _oracle.Operate(_data[k &amp;lt;&amp;lt; 1], _data[(k &amp;lt;&amp;lt; 1) + 1]);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC262</title>
			<link>https://blog.aconcavy.dev/posts/20220731abc262</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 262の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220731abc262</guid>
			<pubDate>Sun, 31 Jul 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 262の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc262"&gt;https://atcoder.jp/contests/abc262&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33660849"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数&lt;/code&gt;ならば2年後、&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数+1&lt;/code&gt;ならば1年後、&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数+2&lt;/code&gt;ならばその年、&lt;code&gt;Y&lt;/code&gt;が&lt;code&gt;4の倍数+3&lt;/code&gt;ならば3年後が答えとなります。
&lt;code&gt;Y&lt;/code&gt;を4で割った余りが&lt;code&gt;4の倍数+n&lt;/code&gt;の&lt;code&gt;n&lt;/code&gt;なので、その値によって答えを求めます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var Y = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = Y;
    if (Y % 4 == 0) answer += 2;
    if (Y % 4 == 1) answer += 1;
    if (Y % 4 == 3) answer += 3;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33662725"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;U&lt;/code&gt;と&lt;code&gt;V&lt;/code&gt;間に辺があるかどうかを二次元配列&lt;code&gt;G&lt;/code&gt;で表現し、&lt;code&gt;G[a,b]&lt;/code&gt;、&lt;code&gt;G[b,c]&lt;/code&gt;、&lt;code&gt;G[c,a]&lt;/code&gt;のすべてに辺が存在するときの総数を数え上げます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var G = new bool[N, N];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (u, v) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        u--;
        v--;
        G[u, v] = G[v, u] = true;
    }

    var answer = 0;
    for (var a = 0; a &amp;lt; N; a++)
    {
        for (var b = a + 1; b &amp;lt; N; b++)
        {
            for (var c = b + 1; c &amp;lt; N; c++)
            {
                if (G[a, b] &amp;amp;&amp;amp; G[b, c] &amp;amp;&amp;amp; G[c, a]) answer++;
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33669451"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;条件となる&lt;code&gt;i&lt;/code&gt;と&lt;code&gt;j&lt;/code&gt;を全探索してしまうと、時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となり、実行時間制限内に答えを求めることはできません。
条件を満たす要素を考えてみると、&lt;code&gt;(i==A[i], j==A[j])&lt;/code&gt;と&lt;code&gt;(i==A[j], j==A[i])&lt;/code&gt;となる組み合わせが対象となります。
前者の場合、&lt;code&gt;[1, x, x, 4, 5]&lt;/code&gt;のような&lt;code&gt;A&lt;/code&gt;があったとすると、&lt;code&gt;(1,4)&lt;/code&gt;、&lt;code&gt;(1,5)&lt;/code&gt;、&lt;code&gt;(4,5)&lt;/code&gt;が答えとなり、&lt;code&gt;i==A[i]&lt;/code&gt;となる要素から2つ選ぶ組み合わせとなるので、&lt;code&gt;i==A[i]&lt;/code&gt;の個数を&lt;code&gt;C&lt;/code&gt;とすると、&lt;code&gt;C*(C-1)/2&lt;/code&gt;が前者の組み合わせの数となります。
一方、後者の場合、&lt;code&gt;i&amp;lt;j&lt;/code&gt;より&lt;code&gt;A[i]&amp;gt;i&lt;/code&gt;かつ&lt;code&gt;A[A[i]]==i&lt;/code&gt;となるものがペアとして成り立ち、その総和が後者の組み合わせの数となります。
よって、これらの総和が答えとなります。
&lt;code&gt;N&lt;/code&gt;が最大&lt;code&gt;5*10^5&lt;/code&gt;なので、&lt;code&gt;int&lt;/code&gt;では収まらないので注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().Select(x =&amp;gt; x - 1).ToArray();
    var answer = 0L;
    var same = 0L;
    for (var i = 0; i &amp;lt; N; i++)
    {
        if (A[i] == i) same++;
        else if (A[i] &amp;gt; i &amp;amp;&amp;amp; A[A[i]] == i) answer++;
    }

    answer += same * (same - 1) / 2;
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc262/tasks/abc262_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/ABC262/submissions/33689722"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;の項を選ぶ個数を1つ決めたときの和の余りを動的計画法で求め、全て求めたときのあまりが&lt;code&gt;0&lt;/code&gt;の数の&lt;code&gt;1&lt;/code&gt;から&lt;code&gt;N&lt;/code&gt;までの総和が答えとなります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    mint answer = 0;

    for (var c = 1; c &amp;lt;= N; c++)
    {
        var dp = new mint[N + 1, N + 1, N];
        dp[0, 0, 0]++;
        for (var i = 0; i &amp;lt; N; i++)
        {
            for (var j = 0; j &amp;lt; N; j++)
            {
                for (var k = 0; k &amp;lt; N; k++)
                {
                    dp[i + 1, j + 1, (k + A[i]) % c] += dp[i, j, k];
                    dp[i + 1, j, k] += dp[i, j, k];
                }
            }
        }

        answer += dp[N, c, 0];
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC261</title>
			<link>https://blog.aconcavy.dev/posts/20220723abc261</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 261の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220723abc261</guid>
			<pubDate>Sat, 23 Jul 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 261の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261"&gt;https://atcoder.jp/contests/abc261&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33429389"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;から&lt;code&gt;100&lt;/code&gt;の範囲を全て見て、値&lt;code&gt;x&lt;/code&gt;のときにどちらの色も塗られている(&lt;code&gt;L1&amp;lt;=x&amp;lt;=R1 &amp;amp;&amp;amp; L2&amp;lt;=x&amp;lt;=R1&lt;/code&gt;)場合の数を数え上げることで答えを求めることができます。
また、共通する範囲のうち、&lt;code&gt;L&lt;/code&gt;は&lt;code&gt;Max(L1,L2)&lt;/code&gt;、&lt;code&gt;R&lt;/code&gt;は&lt;code&gt;Min(R1,R2)&lt;/code&gt;で求められるので、&lt;code&gt;Min(R1,R2)-Max(L1,L2)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
この場合、&lt;code&gt;L&amp;gt;R&lt;/code&gt;になる場合があるので、&lt;code&gt;0&lt;/code&gt;未満にならないように注意が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (L1, R1, L2, R2) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    var answer = Math.Max(0, Math.Min(R1, R2) - Math.Max(L1, L2));
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33435312"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i!=j&lt;/code&gt;において、表の&lt;code&gt;i&lt;/code&gt;行&lt;code&gt;j&lt;/code&gt;列を見たとき、表の&lt;code&gt;j&lt;/code&gt;行&lt;code&gt;i&lt;/code&gt;列の値が対応するものになっているかを判断します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A[i][j]==W&lt;/code&gt;のとき&lt;code&gt;A[j][i]==L&lt;/code&gt;である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A[i][j]==L&lt;/code&gt;のとき&lt;code&gt;A[j][i]==W&lt;/code&gt;である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A[i][j]==D&lt;/code&gt;のとき&lt;code&gt;A[j][i]==D&lt;/code&gt;である。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全ての値が対応するものになっていれば&lt;code&gt;correct&lt;/code&gt;、そうでなければ&lt;code&gt;incorrect&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var answer = true;
    var A = new string[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.Scan&amp;lt;string&amp;gt;();
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            answer &amp;amp;= A[i][j] == 'W' &amp;amp;&amp;amp; A[j][i] == 'L' ||
                      A[i][j] == 'L' &amp;amp;&amp;amp; A[j][i] == 'W' ||
                      A[i][j] == 'D' &amp;amp;&amp;amp; A[j][i] == 'D';
        }
    }

    Console.WriteLine(answer ? &amp;quot;correct&amp;quot; : &amp;quot;incorrect&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33437954"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列が既に何回出ているかを愚直に探索してしまうと、1回の探索の時間計算量が&lt;code&gt;O(N)&lt;/code&gt;、全体の時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまい、実行時間制限に間に合いません。
辞書のようなデータ構造を使って文字列が何回出ているかを管理することで、データ構造の構築に&lt;code&gt;O(logN)&lt;/code&gt;、値の取得に&lt;code&gt;O(1)&lt;/code&gt;、全体の時間計算量を&lt;code&gt;O(NlogN)&lt;/code&gt;に抑えることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;string, int&amp;gt;();
    for (var i = 0; i &amp;lt; N; i++)
    {
        var S = Scanner.Scan&amp;lt;string&amp;gt;();
        if (dict.ContainsKey(S))
        {
            Console.WriteLine($&amp;quot;{S}({dict[S]})&amp;quot;);
            dict[S] += 1;
        }
        else
        {
            Console.WriteLine(S);
            dict[S] = 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33446633"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コインの表裏の状態が&lt;code&gt;N&lt;/code&gt;回あるので、あり得る場合の数は&lt;code&gt;2^N&lt;/code&gt;通りとなり、全探索をしてしまうと時間計算量が&lt;code&gt;O(2^N)&lt;/code&gt;となり実行時間制限内に答えを求めることはできません。&lt;br /&gt;
そこで、&lt;code&gt;dp[i][j] := i回目のコイントスを終えてカウンタの数値がjのときのもらえる円の最大値&lt;/code&gt;とした動的計画法を解くことで時間計算量を抑えます。
&lt;code&gt;X[i]&lt;/code&gt;を&lt;code&gt;i&lt;/code&gt;回目のコイントスで表が出たときもらえる円、&lt;code&gt;C[j]&lt;/code&gt;をカウンタの数値が&lt;code&gt;j&lt;/code&gt;のときのボーナスでもらえる円としたとき、&lt;code&gt;i+1&lt;/code&gt;回目への遷移は次のようになります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;回目のコイントスで表の時: &lt;code&gt;Max(dp[i+1][j+1], dp[i][j]+X[i]+C[j+1])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;回目のコイントスで裏の時: &lt;code&gt;Max(dp[i+1][0], dp[i][j])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt;回遷移が終わった後のそれぞれのカウンタ状態の最大値が答えとなり、全体の時間計算量は&lt;code&gt;O(N^2)&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var X = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var C = new long[N + 1];
    for (var i = 0; i &amp;lt; M; i++)
    {
        var (c, y) = Scanner.Scan&amp;lt;long, long&amp;gt;();
        C[c] = y;
    }

    var dp = new long[N + 1, N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt;= i; j++)
        {
            dp[i + 1, j + 1] = Math.Max(dp[i + 1, j + 1], dp[i, j] + X[i] + C[j + 1]);
            dp[i + 1, 0] = Math.Max(dp[i + 1, 0], dp[i, j]);
        }
    }

    var answer = 0L;
    for (var i = 0; i &amp;lt;= N; i++)
    {
        answer = Math.Max(answer, dp[N, i]);
    }

    Console.WriteLine(answer);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc261/tasks/abc261_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc261/submissions/33477238"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作が全てビット演算なので、ビットごとに操作が独立していることがわかります。&lt;br /&gt;
&lt;code&gt;k&lt;/code&gt;番目のビットが&lt;code&gt;0&lt;/code&gt;と&lt;code&gt;1&lt;/code&gt;の二通りの状態に&lt;code&gt;i&lt;/code&gt;番目までの操作を累積したものを用意し、&lt;code&gt;C&lt;/code&gt;の&lt;code&gt;k&lt;/code&gt;番目のビットの値に&lt;code&gt;i&lt;/code&gt;番目まで累積した操作を適用したものが、&lt;code&gt;i&lt;/code&gt;行目の答えの&lt;code&gt;k&lt;/code&gt;番目ビット目になります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, C) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var Ops = new (int T, int A)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        Ops[i] = Scanner.Scan&amp;lt;int, int&amp;gt;();
    }

    var answer = new int[N];
    for (var k = 0; k &amp;lt; 30; k++)
    {
        var bit = C &amp;gt;&amp;gt; k &amp;amp; 1;
        var cum = new int[] { 0, 1 };
        for (var i = 0; i &amp;lt; N; i++)
        {
            var (t, a) = Ops[i];
            var b = a &amp;gt;&amp;gt; k &amp;amp; 1;
            var f = new int[] { 0, 1 };
            for (var j = 0; j &amp;lt; 2; j++)
            {
                if (t == 1) f[j] &amp;amp;= b;
                if (t == 2) f[j] |= b;
                if (t == 3) f[j] ^= b;
            }

            for (var j = 0; j &amp;lt; 2; j++)
            {
                cum[j] = f[cum[j]];
            }

            bit = cum[bit];
            answer[i] |= bit &amp;lt;&amp;lt; k;
        }
    }

    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC260</title>
			<link>https://blog.aconcavy.dev/posts/20220717abc260</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 260の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220717abc260</guid>
			<pubDate>Sun, 17 Jul 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 260の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260"&gt;https://atcoder.jp/contests/abc260&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33290941"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字ごとの出現数を数え上げ、出現数が1つのみ文字を出力します。&lt;br /&gt;
C#の場合、&lt;code&gt;char&lt;/code&gt;型を数値として扱い、小文字のアルファベットから&lt;code&gt;a&lt;/code&gt;を引くことで&lt;code&gt;a,b,c,...&lt;/code&gt;を&lt;code&gt;0,1,2,...&lt;/code&gt;として管理することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var count = new int[26];
    foreach (var c in S)
    {
        count[c - 'a']++;
    }

    for (var i = 0; i &amp;lt; 26; i++)
    {
        if (count[i] == 1)
        {
            Console.WriteLine((char)('a' + i));
            return;
        }
    }

    Console.WriteLine(-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33297423"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;受験生の番目、数学のスコア、英語のスコアを&lt;code&gt;Tuple&lt;/code&gt;などのデータクラスとして管理します。&lt;br /&gt;
&lt;code&gt;i&lt;/code&gt;番目の学生が合格したかをフラグとして管理し、それぞれの条件ごとにソートして合格となっていない受験生が対象となるかを判定することで、時間計算量&lt;code&gt;O(NlogN+N)&lt;/code&gt;で答えを求めることができます。&lt;br /&gt;
C#の場合、&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.array.sort?view=net-6.0#system-array-sort-1(-0()-system-comparison((-0)))"&gt;Array.Sort メソッド&lt;/a&gt;に&lt;code&gt;Comparison&amp;lt;T&amp;gt;&lt;/code&gt;を指定することで、比較関数を与えてソートすることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y, Z) = Scanner.Scan&amp;lt;int, int, int, int&amp;gt;();
    var A = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var B = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var accepts = new bool[N];
    var C = A.Zip(B).Select((x, i) =&amp;gt; (A: x.First, B: x.Second, ID: i)).ToArray();

    Array.Sort(C, (x, y) =&amp;gt;
    {
        var result = y.A.CompareTo(x.A);
        return result == 0 ? x.ID.CompareTo(y.ID) : result;
    });
    for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; X &amp;gt; 0; i++)
    {
        if (accepts[C[i].ID]) continue;
        accepts[C[i].ID] = true;
        X--;
    }

    Array.Sort(C, (x, y) =&amp;gt;
    {
        var result = y.B.CompareTo(x.B);
        return result == 0 ? x.ID.CompareTo(y.ID) : result;
    });
    for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; Y &amp;gt; 0; i++)
    {
        if (accepts[C[i].ID]) continue;
        accepts[C[i].ID] = true;
        Y--;
    }

    Array.Sort(C, (x, y) =&amp;gt;
    {
        var result = (y.A + y.B).CompareTo(x.A + x.B);
        return result == 0 ? x.ID.CompareTo(y.ID) : result;
    });
    for (var i = 0; i &amp;lt; N &amp;amp;&amp;amp; Z &amp;gt; 0; i++)
    {
        if (accepts[C[i].ID]) continue;
        accepts[C[i].ID] = true;
        Z--;
    }

    for (var i = 0; i &amp;lt; N; i++)
    {
        if (accepts[i])
        {
            Console.WriteLine(i + 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33301206"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;動的計画法で答えを求めます。
赤い宝石と青い宝石のレベルごとの個数をそれぞれ管理し、レベル&lt;code&gt;N&lt;/code&gt;からレベル&lt;code&gt;2&lt;/code&gt;まで計算します。
遷移としては、レベルごとに先に赤い宝石を変換し、次に青い宝石を変換します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X, Y) = Scanner.Scan&amp;lt;int, long, long&amp;gt;();
    var Red = new long[N + 1];
    var Blue = new long[N + 1];
    Red[N] = 1;
    for (var i = N; i &amp;gt;= 2; i--)
    {
        Red[i - 1] += Red[i];
        Blue[i] += Red[i] * X;
        Red[i - 1] += Blue[i];
        Blue[i - 1] += Blue[i] * Y;
    }

    var answer = Blue[1];
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc260/tasks/abc260_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc260/submissions/33307596"&gt;コンテスト提出&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://atcoder.jp/contests/abc260/submissions/33325990"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表になっているカードの集合のうち&lt;code&gt;X&lt;/code&gt;以上の値を高速に求められるようなデータ構造と、カードの山を管理するデータ構造を使って何ターン目に食べられるかを判定します。
前者のデータ構造では、&lt;code&gt;X&lt;/code&gt;以上の値を時間計算量&lt;code&gt;O(N)&lt;/code&gt;で探索してしまうと、全体の時間計算量が&lt;code&gt;O(N^2)&lt;/code&gt;となってしまい実行時間制限に間に合いません。&lt;br /&gt;
そのため、二部探索のような時間計算量&lt;code&gt;O(logN)&lt;/code&gt;で探索できるようなデータ構造(C++の場合は&lt;code&gt;set&lt;/code&gt;、C#の場合は&lt;code&gt;SortedSet&lt;/code&gt;)が必要です。&lt;br /&gt;
&lt;code&gt;SortedSet&lt;/code&gt;から&lt;code&gt;GetViewBetween&lt;/code&gt;したサブセットの&lt;code&gt;Count&lt;/code&gt;プロパティが、場合によっては時間計算量&lt;code&gt;O(1)&lt;/code&gt;ではなさそうなので、&lt;code&gt;LINQ&lt;/code&gt;の&lt;code&gt;Any&lt;/code&gt;で存在判定をしたほうが良さそうです。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, K) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var P = Scanner.ScanEnumerable&amp;lt;int&amp;gt;().ToArray();
    var answer = new int[N + 1];
    Array.Fill(answer, -1);
    var set = new SortedSet&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, List&amp;lt;int&amp;gt;&amp;gt;();
    var root = new int[N + 1];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var p = P[i];
        var r = root[p] = p;
        var subset = set.GetViewBetween(p, N);

        if (subset.Any())
        {
            var q = subset.Min;
            r = root[p] = root[q];
            set.Remove(q);
        }
        else
        {
            dict[r] = new List&amp;lt;int&amp;gt;();
        }
        
        set.Add(p);
        dict[r].Add(p);

        if (dict[r].Count &amp;gt;= K)
        {
            foreach (var v in dict[r])
            {
                answer[v] = i + 1;
            }

            set.Remove(p);
            dict.Remove(r);
        }
    }

    Console.WriteLine(string.Join(&amp;quot;\n&amp;quot;, answer.Skip(1)));
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC259</title>
			<link>https://blog.aconcavy.dev/posts/20220709abc259</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 259の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220709abc259</guid>
			<pubDate>Sat, 09 Jul 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 259の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259"&gt;https://atcoder.jp/contests/abc259&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33074995"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M&amp;lt;X&lt;/code&gt;のとき、&lt;code&gt;D&lt;/code&gt;ずつ&lt;code&gt;X-M&lt;/code&gt;年分変化したので、最終的な身長からその変化分を引いた数&lt;code&gt;T-D*(X-M)&lt;/code&gt;が答えとなります。&lt;br /&gt;
&lt;code&gt;X&amp;lt;=M&lt;/code&gt;のとき、&lt;code&gt;X&lt;/code&gt;歳にはすでに&lt;code&gt;T&lt;/code&gt;であるため、&lt;code&gt;M&lt;/code&gt;歳の時も&lt;code&gt;T&lt;/code&gt;です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, M, X, T, D) = Scanner.Scan&amp;lt;int, int, int, int, int&amp;gt;();
    var answer = T - D * Math.Max(X - M, 0);
    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33081607"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ベクトル&lt;code&gt;(a,b)&lt;/code&gt;に対して&lt;code&gt;d&lt;/code&gt;度の回転の操作を行います。
これは、&lt;code&gt;x' = x * cos(rad(d)) - y * sin(rad(d))&lt;/code&gt;, &lt;code&gt;y' = x * sin(rad(d)) + y * cos(rad(d))&lt;/code&gt;で表すことができます。
度から弧度法(ラジアン)を求めるには、&lt;code&gt;度 * PI / 180度&lt;/code&gt;で求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (A, B, D) = Scanner.Scan&amp;lt;double, double, double&amp;gt;();
    var rad = D * Math.PI / 180.0;
    var sin = Math.Sin(rad);
    var cos = Math.Cos(rad);
    var x = A * cos - B * sin;
    var y = A * sin + B * cos;
    Console.WriteLine($&amp;quot;{x} {y}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33110149"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列が一致するということは、同じ文字が連続した区間ごとに分割し、区間順にみたときに次の条件を全ての文字の区間が満たすときになります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の区間で出現する文字が一致する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;と&lt;code&gt;T&lt;/code&gt;の区間で文字が連続する長さが両方とも&lt;code&gt;1&lt;/code&gt;である。または、文字が連続する長さが両方とも&lt;code&gt;2&lt;/code&gt;以上かつ&lt;code&gt;T&lt;/code&gt;の文字が連続する長さが&lt;code&gt;S&lt;/code&gt;の文字が連続する長さ以上である。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var T = Scanner.Scan&amp;lt;string&amp;gt;();

    List&amp;lt;(char, int)&amp;gt; F(ReadOnlySpan&amp;lt;char&amp;gt; s)
    {
        var result = new List&amp;lt;(char, int)&amp;gt;();
        var r = 0;
        for (var l = 0; l &amp;lt; s.Length;)
        {
            r = l;
            while (r &amp;lt; s.Length &amp;amp;&amp;amp; s[r] == s[l]) r++;
            result.Add((s[l], r - l));
            l = r;
        }

        return result;
    }

    var ss = F(S);
    var tt = F(T);
    var answer = ss.Count == tt.Count;
    if (answer)
    {
        for (var i = 0; i &amp;lt; ss.Count; i++)
        {
            var (s, cs) = ss[i];
            var (t, ct) = tt[i];
            answer &amp;amp;= s == t;
            answer &amp;amp;= cs == ct || cs &amp;gt; 1 &amp;amp;&amp;amp; ct &amp;gt; 1 &amp;amp;&amp;amp; cs &amp;lt; ct;
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc259/tasks/abc259_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc259/submissions/33103648"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各円を頂点としたとき、円どうしで移動可能な場合に辺が存在すると考えると、グラフ問題として考えることができます。
ある二つの円が移動可能ということは、その二つの円が共有点を持つということになります。
共有点が存在するかどうかは、一つ目の円の半径を&lt;code&gt;r1&lt;/code&gt;、二つ目の円の半径を&lt;code&gt;r2&lt;/code&gt;、二つの円の中心間の距離を&lt;code&gt;d&lt;/code&gt;としたとき、&lt;code&gt;abs(r1-r2)&amp;lt;=d&amp;lt;=r1+r2&lt;/code&gt;が満たされれるかどうかで判断することができます。
&lt;code&gt;Disjoint Set Union&lt;/code&gt;などのデータ構造や深さ優先探索、幅優先探索などで、&lt;code&gt;(sx,sy)&lt;/code&gt;が含まれる円と&lt;code&gt;(tx,ty)&lt;/code&gt;が含まれる円が連結であるかの判定を行うことで、答えを求めることができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var (sx, sy, tx, ty) = Scanner.Scan&amp;lt;long, long, long, long&amp;gt;();
    var s = new Point(sx, sy);
    var t = new Point(tx, ty);

    var P = new (Point P, long R)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        var (x, y, r) = Scanner.Scan&amp;lt;long, long, long&amp;gt;();
        P[i] = (new Point(x, y), r);
    }

    long SqD(Point p1, Point p2)
    {
        var dx = p1.X - p2.X;
        var dy = p1.Y - p2.Y;
        return dx * dx + dy * dy;
    }

    var okS = new bool[N];
    var okT = new bool[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        okS[i] = SqD(s, P[i].P) == P[i].R * P[i].R;
        okT[i] = SqD(t, P[i].P) == P[i].R * P[i].R;
    }

    var dsu = new DisjointSetUnion(N);

    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = i + 1; j &amp;lt; N; j++)
        {
            var sqd = SqD(P[i].P, P[j].P);
            var rr1 = P[i].R + P[j].R;
            var rr2 = P[i].R - P[j].R;
            if (rr2 * rr2 &amp;lt;= sqd &amp;amp;&amp;amp; sqd &amp;lt;= rr1 * rr1)
            {
                dsu.Merge(i, j);
            }
        }
    }

    var answer = false;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {

            answer |= okS[i] &amp;amp;&amp;amp; okT[j] &amp;amp;&amp;amp; dsu.IsSame(i, j);
        }
    }

    Console.WriteLine(answer ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
}

public readonly struct Point
{
    public readonly long X;
    public readonly long Y;
    public Point(long x, long y) =&amp;gt; (X, Y) = (x, y);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>ABC258</title>
			<link>https://blog.aconcavy.dev/posts/20220702abc258</link>
			<description>&lt;p&gt;AtCoder Beginner Contest 258の復習記事です。&lt;/p&gt;</description>
			<guid>https://blog.aconcavy.dev/posts/20220702abc258</guid>
			<pubDate>Sat, 02 Jul 2022 00:00:00 GMT</pubDate>
			<content:encoded>&lt;h2 id="section"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;AtCoder Beginner Contest 258の復習記事です。&lt;/p&gt;
&lt;p&gt;記事における&lt;code&gt;Scanner&lt;/code&gt;クラスは、自作の入力クラスです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;コンテスト&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258"&gt;https://atcoder.jp/contests/abc258&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="a"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_a"&gt;問題A&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32886264"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1時間は60分なので、Kを60で割った商が経過時、Kを60で割った余りが経過分となるので、&lt;code&gt;21+K/60&lt;/code&gt;時&lt;code&gt;K%60&lt;/code&gt;分が答えとなります。&lt;br /&gt;
C#では文字列補間で&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/standard/base-types/custom-numeric-format-strings"&gt;カスタム数値形式文字列&lt;/a&gt;を使うことで、数値を&lt;code&gt;0&lt;/code&gt;埋めで表示することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var K = Scanner.Scan&amp;lt;int&amp;gt;();
    var x = K / 60;
    var y = K % 60;
    Console.WriteLine($&amp;quot;{21 + x}:{y:00}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="b"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_b"&gt;問題B&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32895144"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全てのマスから縦横斜めの8方向にずらした数値を全探索します。&lt;br /&gt;
8方向全てを書くのは大変なので、行と列のそれぞれの移動差分を用意することで、差分に移動量を掛けて範囲内に収まるように&lt;code&gt;N&lt;/code&gt;で割った余りを取ることで、簡単に記述することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var N = Scanner.Scan&amp;lt;int&amp;gt;();
    var A = new int[N][];
    for (var i = 0; i &amp;lt; N; i++)
    {
        A[i] = Scanner.ScanLine().Select(x =&amp;gt; x - '0').ToArray();
    }

    var D8 = new[] { (1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1) };

    long answer = 0;
    for (var i = 0; i &amp;lt; N; i++)
    {
        for (var j = 0; j &amp;lt; N; j++)
        {
            foreach (var (di, dj) in D8)
            {
                long v = 0;
                for (var k = 0; k &amp;lt; N; k++)
                {
                    var ii = (i + di * k + N) % N;
                    var jj = (j + dj * k + N) % N;
                    v = v * 10 + A[ii][jj];
                }

                answer = Math.Max(answer, v);
            }
        }
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="c"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_c"&gt;問題C&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32897344"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリごとに文字列を操作してしまうと、クエリごとの計算量が&lt;code&gt;O(N)&lt;/code&gt;、全体の計算量が&lt;code&gt;O(QN)&lt;/code&gt;になってしまい、実行時間制限に間に合わないため、計算量を改善する必要があります。&lt;/p&gt;
&lt;p&gt;クエリ1に注目すると、&lt;code&gt;N&lt;/code&gt;文字目の次を&lt;code&gt;1&lt;/code&gt;文字目としたとき、文字列を&lt;code&gt;x&lt;/code&gt;回右にシフトしてることがわかります。&lt;br /&gt;
そして、文字列を右にシフトすると、先頭の位置は&lt;code&gt;-x&lt;/code&gt;分移動し、移動先が負の場合は&lt;code&gt;N&lt;/code&gt;を足した位置が先頭になります。&lt;br /&gt;
このように、文字列の先頭の位置がどこであるかのみを管理することで、クエリごとの計算量を&lt;code&gt;O(1)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var S = Scanner.Scan&amp;lt;string&amp;gt;();
    var idx = 0;
    while (Q-- &amp;gt; 0)
    {
        var (t, x) = Scanner.Scan&amp;lt;int, int&amp;gt;();
        if (t == 1)
        {
            idx = (idx - x + N) % N;
        }
        else
        {
            var i = (idx + x - 1) % N;
            Console.WriteLine(S[i]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="d"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_d"&gt;問題D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32901859"&gt;コンテスト提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i番目のステージまでに必要な最小の時間 + 初回攻略時間 + (i番目のステージで必要な時間 * 残り回数全てを)&lt;/code&gt;が&lt;code&gt;i&lt;/code&gt;番目のステージおける時間の最小値となるとなるので、全てのステージにおける時間の最小値の最小値が答えとなります。
ステージごとに毎度&lt;code&gt;i&lt;/code&gt;番目のステージまでに必要な最小の時間を計算してしまうと時間計算量が&lt;code&gt;O(N)&lt;/code&gt;かかってしまうので、累積和を用いることで&lt;code&gt;O(1)&lt;/code&gt;に改善することができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, X) = Scanner.Scan&amp;lt;int, int&amp;gt;();
    var AB = new (long A, long B)[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        AB[i] = Scanner.Scan&amp;lt;long, long&amp;gt;();
    }

    var minStarts = new long[N];
    for (var i = 1; i &amp;lt; N; i++)
    {
        minStarts[i] = minStarts[i - 1] + AB[i - 1].A + AB[i - 1].B;
    }

    const long inf = (long)4e18;
    var answer = inf;
    for (var i = 0; i &amp;lt; N; i++)
    {
        var x = Math.Max(0, X - (i + 1));
        var time = sum + AB[i].A + AB[i].B + x * AB[i].B;
        answer = Math.Min(answer, time);
        sum += AB[i].A + AB[i].B;
    }

    Console.WriteLine(answer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="e"&gt;&lt;a href="https://atcoder.jp/contests/abc258/tasks/abc258_e"&gt;問題E&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://atcoder.jp/contests/abc258/submissions/32937679"&gt;復習提出&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;番目のじゃがいもを開始位置としたとき、1つの箱に必要なじゃがいもの個数を&lt;code&gt;C[i]&lt;/code&gt;とすると、次の箱に使うじゃがいもの開始位置は&lt;code&gt;(i+C[i])%N&lt;/code&gt;となり、開始位置の集合は最大でも&lt;code&gt;N&lt;/code&gt;の有向グラフとして表すことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text line-numbers"&gt;# 入力例1
# 3 2 5
# 3 4 1
# 1
# 2

0番目のじゃがいもから箱を作る: {0, 1}    =&amp;gt; 2個 =&amp;gt; 次は (0+2)%3 = 2番目のじゃがいも
2番目のじゃがいもから箱を作る: {2, 0, 1} =&amp;gt; 3個 =&amp;gt; 次は (2+3)%3 = 2番目のじゃがいも
2番目のじゃがいもから箱を作る: {2, 0, 1} =&amp;gt; 3個 =&amp;gt; 次は (2+3)%3 = 2番目のじゃがいも
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このことから、有効グラフのK番目の頂点に値する開始位置における必要なじゃがいもの個数が答えとなります。
時間計算量について、&lt;code&gt;C[i]&lt;/code&gt;は累積和と尺取り法を使うことで&lt;code&gt;O(N)&lt;/code&gt;、有効グラフも&lt;code&gt;O(N)&lt;/code&gt;で事前に計算でき、クエリに対して&lt;code&gt;O(1)&lt;/code&gt;で答えを求めることができるので、全体の時間計算量は&lt;code&gt;O(N+Q)&lt;/code&gt;となります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp line-numbers"&gt;public static void Solve()
{
    var (N, Q, X) = Scanner.Scan&amp;lt;int, int, long&amp;gt;();
    var W = Scanner.ScanEnumerable&amp;lt;long&amp;gt;().ToArray();
    var sum = W.Sum();

    var cumW = new long[N * 2 + 1];
    for (var i = 0; i &amp;lt; N * 2; i++)
    {
        cumW[i + 1] = cumW[i] + W[i % N];
    }

    var counts = new long[N];
    {
        var r = 0;
        var x = X % sum;
        for (var l = 0; l &amp;lt; N; l++)
        {
            counts[l] = X / sum * N;
            while (cumW[r] - cumW[l] &amp;lt; x) r++;
            counts[l] += r - l;
        }
    }

    var next = new int[N];
    for (var i = 0; i &amp;lt; N; i++)
    {
        next[i] = (int)((i + counts[i]) % N);
    }

    var steps = new List&amp;lt;int&amp;gt;();
    var dict = new Dictionary&amp;lt;int, int&amp;gt;();
    var noLoopLength = 0;
    var loopLength = 0;
    {
        var curr = 0;
        for (var i = 0;; i++)
        {
            if (dict.ContainsKey(curr))
            {
                noLoopLength = dict[curr];
                loopLength = i - dict[curr];
                break;
            }

            dict[curr] = i;
            steps.Add(curr);
            curr = next[curr];
        }
    }

    while (Q-- &amp;gt; 0)
    {
        var K = Scanner.Scan&amp;lt;long&amp;gt;() - 1;
        if (K &amp;lt;= noLoopLength)
        {
            var box = steps[(int)K];
            Console.WriteLine(counts[box]);
        }
        else
        {
            var mod = (K - noLoopLength) % loopLength;
            var box = steps[(int)(noLoopLength + mod)];
            Console.WriteLine(counts[box]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>